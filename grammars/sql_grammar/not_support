CREATE ROLE regress_publication_user LOGIN SUPERUSER;
CREATE ROLE regress_publication_user2;
CREATE ROLE regress_publication_user_dummy LOGIN NOSUPERUSER;
SET SESSION AUTHORIZATION 'regress_publication_user';
SET client_min_messages = 'ERROR';
CREATE PUBLICATION testpub_default;
RESET client_min_messages;
COMMENT ON PUBLICATION testpub_default IS 'test publication';
SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
SET client_min_messages = 'ERROR';
CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);
RESET client_min_messages;
ALTER PUBLICATION testpub_default SET (publish = update);
CREATE PUBLICATION testpub_xxx WITH (foo);
CREATE PUBLICATION testpub_xxx WITH (publish = 'cluster, vacuum');
ALTER PUBLICATION testpub_default SET (publish = 'insert, update, delete');
CREATE SCHEMA pub_test;
CREATE TABLE testpub_tbl1 (id serial primary key, data text);
CREATE TABLE pub_test.testpub_nopk (foo int, bar int);
CREATE TABLE testpub_parted (a int) PARTITION BY LIST (a);
SET client_min_messages = 'ERROR';
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES WITH (publish = 'insert');
RESET client_min_messages;
ALTER PUBLICATION testpub_foralltables SET (publish = 'insert, update');
CREATE TABLE testpub_tbl2 (id serial primary key, data text);
ALTER PUBLICATION testpub_foralltables ADD TABLE testpub_tbl2;
ALTER PUBLICATION testpub_foralltables DROP TABLE testpub_tbl2;
ALTER PUBLICATION testpub_foralltables SET TABLE pub_test.testpub_nopk;
DROP PUBLICATION testpub_foralltables;
CREATE TABLE testpub_tbl3a (b text) INHERITS (testpub_tbl3);
SET client_min_messages = 'ERROR';
CREATE PUBLICATION testpub3 FOR TABLE testpub_tbl3;
CREATE PUBLICATION testpub4 FOR TABLE ONLY testpub_tbl3;
RESET client_min_messages;
DROP TABLE testpub_tbl3, testpub_tbl3a;
DROP PUBLICATION testpub3, testpub4;
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_view;
SET client_min_messages = 'ERROR';
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1, pub_test.testpub_nopk;
RESET client_min_messages;
ALTER PUBLICATION testpub_fortbl ADD TABLE testpub_tbl1;
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default ADD TABLE testpub_view;
ALTER PUBLICATION testpub_fortbl ADD TABLE testpub_parted;
ALTER PUBLICATION testpub_default ADD TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default SET TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default ADD TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpib_ins_trunct ADD TABLE pub_test.testpub_nopk, testpub_tbl1;
ALTER PUBLICATION testpub_default DROP TABLE testpub_tbl1, pub_test.testpub_nopk;
ALTER PUBLICATION testpub_default DROP TABLE pub_test.testpub_nopk;
SET ROLE regress_publication_user2;
CREATE PUBLICATION testpub2;  -- failSET ROLE regress_publication_user;
GRANT CREATE ON DATABASE regression TO regress_publication_user2;
SET ROLE regress_publication_user2;
SET client_min_messages = 'ERROR';
CREATE PUBLICATION testpub2;  -- okRESET client_min_messages;
ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- failSET ROLE regress_publication_user;
GRANT regress_publication_user TO regress_publication_user2;
SET ROLE regress_publication_user2;
ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- okDROP PUBLICATION testpub2;
SET ROLE regress_publication_user;
REVOKE CREATE ON DATABASE regression FROM regress_publication_user2;
SET ROLE regress_publication_user_dummy;
ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
RESET ROLE;
ALTER PUBLICATION testpub_default RENAME TO testpub_foo;
ALTER PUBLICATION testpub_foo RENAME TO testpub_default;
ALTER PUBLICATION testpub_default OWNER TO regress_publication_user2;
DROP PUBLICATION testpub_default;
DROP PUBLICATION testpib_ins_trunct;
DROP PUBLICATION testpub_fortbl;
DROP SCHEMA pub_test CASCADE;
RESET SESSION AUTHORIZATION;
DROP ROLE regress_publication_user, regress_publication_user2;
DROP ROLE regress_publication_user_dummy;
SET extra_float_digits TO -3;
@@@@@@#SELECT '' AS two, p1.f1   FROM POINT_TBL p1   WHERE ishorizontal(p1.f1, point '(0,0)');
SELECT '' AS two, p1.f1   FROM POINT_TBL p1   WHERE p1.f1 ?- point '(0,0)';
SELECT '' AS one, p1.f1   FROM POINT_TBL p1   WHERE isvertical(p1.f1, point '(5.1,34.5)');
SELECT '' AS one, p1.f1   FROM POINT_TBL p1   WHERE p1.f1 ?| point '(5.1,34.5)';
SELECT p1.f1, p2.f1, slope(p1.f1, p2.f1) FROM POINT_TBL p1, POINT_TBL p2;
SELECT p1.f1, p2.f1, p1.f1 + p2.f1 FROM POINT_TBL p1, POINT_TBL p2;
SELECT p1.f1, p2.f1, p1.f1 - p2.f1 FROM POINT_TBL p1, POINT_TBL p2;
SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] BETWEEN 1 AND 1000;
SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] < 1;
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] BETWEEN 1 AND 1000;
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] > 1000;
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1 ~= '(0,0)'::point;
SELECT p.f1, l.s, p.f1 <-> l.s AS dist_pl, l.s <-> p.f1 AS dist_lp FROM POINT_TBL p, LINE_TBL l;
SELECT p.f1, l.s, p.f1 <-> l.s AS dist_ps, l.s <-> p.f1 AS dist_sp FROM POINT_TBL p, LSEG_TBL l;
SELECT p.f1, b.f1, p.f1 <-> b.f1 AS dist_pb, b.f1 <-> p.f1 AS dist_bp FROM POINT_TBL p, BOX_TBL b;
SELECT p.f1, p1.f1, p.f1 <-> p1.f1 AS dist_ppath, p1.f1 <-> p.f1 AS dist_pathp FROM POINT_TBL p, PATH_TBL p1;
SELECT p.f1, p1.f1, p.f1 <-> p1.f1 AS dist_ppoly, p1.f1 <-> p.f1 AS dist_polyp FROM POINT_TBL p, POLYGON_TBL p1;
SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LINE_TBL l;
SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LSEG_TBL l;
SELECT p.f1, b.f1, p.f1 ## b.f1 FROM POINT_TBL p, BOX_TBL b;
SELECT p.f1, l.s FROM POINT_TBL p, LINE_TBL l WHERE p.f1 <@ l.s;
SELECT p.f1, l.s FROM POINT_TBL p, LSEG_TBL l WHERE p.f1 <@ l.s;
SELECT p.f1, p1.f1 FROM POINT_TBL p, PATH_TBL p1 WHERE p.f1 <@ p1.f1;
?|?SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s = l2.s;
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?|| l2.s;
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?-| l2.s;
SELECT l1.s, l2.s, l1.s <-> l2.s FROM LINE_TBL l1, LINE_TBL l2;
SELECT l.s, b.f1, l.s <-> b.f1 FROM LINE_TBL l, BOX_TBL b;
SELECT l.s, b.f1, b.f1 <-> l.s FROM LINE_TBL l, BOX_TBL b;
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?# l2.s;
SELECT l.s, b.f1 FROM LINE_TBL l, BOX_TBL b WHERE l.s ?# b.f1;
SELECT l1.s, l2.s, l1.s # l2.s FROM LINE_TBL l1, LINE_TBL l2;
SELECT l.s, l1.s, l.s ## l1.s FROM LINE_TBL l, LSEG_TBL l1;
SELECT l.s, b.f1, l.s ## b.f1 FROM LINE_TBL l, BOX_TBL b;
SELECT '' AS count, p.f1, l.s, l.s # p.f1 AS intersection   FROM LSEG_TBL l, POINT_TBL p;
@@?|?@@::SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s < l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s <= l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s = l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s >= l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s > l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s != l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s ?|| l2.s;
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s ?-| l2.s;
SELECT l.s, l1.s, l.s <-> l1.s AS dist_sl, l1.s <-> l.s AS dist_ls FROM LSEG_TBL l, LINE_TBL l1;
SELECT l1.s, l2.s, l1.s <-> l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
SELECT l.s, b.f1, l.s <-> b.f1 AS dist_sb, b.f1 <-> l.s AS dist_bs FROM LSEG_TBL l, BOX_TBL b;
SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s ?# l1.s;
SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s ?# b.f1;
SELECT l1.s, l2.s, l1.s # l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
SELECT l.s, l1.s, l.s ## l1.s FROM LSEG_TBL l, LINE_TBL l1;
SELECT l1.s, l2.s, l1.s ## l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
SELECT l.s, b.f1, l.s ## b.f1 FROM LSEG_TBL l, BOX_TBL b;
SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s <@ l1.s;
SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s <@ b.f1;
SELECT '' AS twentyfour, b.f1 + p.f1 AS translation   FROM BOX_TBL b, POINT_TBL p;
SELECT '' AS twentyfour, b.f1 - p.f1 AS translation   FROM BOX_TBL b, POINT_TBL p;
SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] > 1000;
SELECT b.f1, p.f1, b.f1 / p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
::SELECT bound_box(a.f1, b.f1)	FROM BOX_TBL a, BOX_TBL b;
SELECT b1.f1, b2.f1, b1.f1 <^ b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
SELECT b1.f1, b2.f1, b1.f1 >^ b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
SELECT b1.f1, b2.f1, b1.f1 # b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
SELECT b1.f1, b2.f1, b1.f1 <-> b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
@@@@::::SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 < p2.f1;
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 <= p2.f1;
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 = p2.f1;
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 >= p2.f1;
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 > p2.f1;
SELECT p1.f1, p2.f1, p1.f1 + p2.f1 FROM PATH_TBL p1, PATH_TBL p2;
SELECT p.f1, p1.f1, p.f1 + p1.f1 FROM PATH_TBL p, POINT_TBL p1;
SELECT p.f1, p1.f1, p.f1 - p1.f1 FROM PATH_TBL p, POINT_TBL p1;
SELECT p.f1, p1.f1, p.f1 * p1.f1 FROM PATH_TBL p, POINT_TBL p1;
SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1[0] BETWEEN 1 AND 1000;
SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1 ~= '(0,0)'::point;
SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM PATH_TBL p1, PATH_TBL p2;
SELECT '' AS twentyfour, p.f1, poly.f1, poly.f1 @> p.f1 AS contains   FROM POLYGON_TBL poly, POINT_TBL p;
SELECT '' AS twentyfour, p.f1, poly.f1, p.f1 <@ poly.f1 AS contained   FROM POLYGON_TBL poly, POINT_TBL p;
::::SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 ~= p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 <@ p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 @> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 && p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 << p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &< p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 >> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 <<| p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &<| p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 |>> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 |&> p2.f1;
SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2;
#SELECT '' AS twentyfour, c1.f1 AS circle, p1.f1 AS point, (p1.f1 <-> c1.f1) AS distance   FROM CIRCLE_TBL c1, POINT_TBL p1   WHERE (p1.f1 <-> c1.f1) > 0   ORDER BY distance, area(c1.f1), p1.f1[0];
::SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 ~= c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 && c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &< c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 << c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 >> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <@ c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 @> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <<| c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 |>> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &<| c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 |&> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 = c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 != c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 < c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 > c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <= c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 >= c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 < c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 < c2.f1;
SELECT c.f1, p.f1, c.f1 + p.f1 FROM CIRCLE_TBL c, POINT_TBL p;
SELECT c.f1, p.f1, c.f1 - p.f1 FROM CIRCLE_TBL c, POINT_TBL p;
SELECT c.f1, p.f1, c.f1 * p.f1 FROM CIRCLE_TBL c, POINT_TBL p;
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] > 1000;
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1 ~= '(0,0)'::point;
SELECT c.f1, p.f1, c.f1 <-> p.f1 FROM CIRCLE_TBL c, POLYGON_TBL p;
create table spgist_point_tbl(id int4, p point);
create index spgist_point_idx on spgist_point_tbl using spgist(p) with (fillfactor = 75);
delete from spgist_point_tbl where id < 5;
vacuum spgist_point_tbl;
delete from spgist_point_tbl where id % 2 = 1;
delete from spgist_point_tbl where id < 10000;
vacuum spgist_point_tbl;
create table spgist_box_tbl(id serial, b box);
create index spgist_box_idx on spgist_box_tbl using spgist (b);
select count(*)  from (values (point(5,5)),(point(8,8)),(point(12,12))) v(p) where exists(select * from spgist_box_tbl b where b.b && box(v.p,v.p));
create table spgist_text_tbl(id int4, t text);
create index spgist_text_idx on spgist_text_tbl using spgist(t);
||insert into spgist_text_tbl (id, t)select g, 'f' || repeat('o', 100) || g from generate_series(1, 10000) gunion allselect g, 'baaaaaaaaaaaaaar' || g from generate_series(1, 1000) g;
||insert into spgist_text_tbl (id, t)select -g, 'f' || repeat('o', 100-g) || 'surprise' from generate_series(1, 100) g;
create index spgist_point_idx2 on spgist_point_tbl using spgist(p) with (fillfactor = 9);
create index spgist_point_idx2 on spgist_point_tbl using spgist(p) with (fillfactor = 101);
alter index spgist_point_idx set (fillfactor = 90);
BEGIN;
DECLARE foo13 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 50;
DECLARE foo14 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 51;
DECLARE foo15 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 52;
DECLARE foo16 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 53;
DECLARE foo17 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 54;
DECLARE foo18 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 55;
DECLARE foo19 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 56;
DECLARE foo20 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 57;
DECLARE foo21 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 58;
DECLARE foo22 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 59;
DECLARE foo23 CURSOR FOR   SELECT * FROM onek WHERE unique1 = 60;
DECLARE foo24 CURSOR FOR   SELECT * FROM onek2 WHERE unique1 = 50;
DECLARE foo25 CURSOR FOR   SELECT * FROM onek2 WHERE unique1 = 60;
FETCH all in foo13;
FETCH all in foo14;
FETCH all in foo15;
FETCH all in foo16;
FETCH all in foo17;
FETCH all in foo18;
FETCH all in foo19;
FETCH all in foo20;
FETCH all in foo21;
FETCH all in foo22;
FETCH all in foo23;
FETCH all in foo24;
FETCH all in foo25;
CLOSE foo13;
CLOSE foo14;
CLOSE foo15;
CLOSE foo16;
CLOSE foo17;
CLOSE foo18;
CLOSE foo19;
CLOSE foo20;
CLOSE foo21;
CLOSE foo22;
CLOSE foo23;
CLOSE foo24;
CLOSE foo25;
END;
::SELECT ''::text AS two, unique1, unique2, stringu1		FROM onek WHERE unique1 > 50		ORDER BY unique1 LIMIT 2;
::SELECT ''::text AS five, unique1, unique2, stringu1		FROM onek WHERE unique1 > 60		ORDER BY unique1 LIMIT 5;
::SELECT ''::text AS two, unique1, unique2, stringu1		FROM onek WHERE unique1 > 60 AND unique1 < 63		ORDER BY unique1 LIMIT 5;
::SELECT ''::text AS three, unique1, unique2, stringu1		FROM onek WHERE unique1 > 100		ORDER BY unique1 LIMIT 3 OFFSET 20;
::SELECT ''::text AS zero, unique1, unique2, stringu1		FROM onek WHERE unique1 < 50		ORDER BY unique1 DESC LIMIT 8 OFFSET 99;
::SELECT ''::text AS eleven, unique1, unique2, stringu1		FROM onek WHERE unique1 < 50		ORDER BY unique1 DESC LIMIT 20 OFFSET 39;
::SELECT ''::text AS ten, unique1, unique2, stringu1		FROM onek		ORDER BY unique1 OFFSET 990;
::SELECT ''::text AS five, unique1, unique2, stringu1		FROM onek		ORDER BY unique1 OFFSET 990 LIMIT 5;
::SELECT ''::text AS five, unique1, unique2, stringu1		FROM onek		ORDER BY unique1 LIMIT 5 OFFSET 900;
select * from int8_tbl limit (case when random() < 0.5 then null::bigint end);
select * from int8_tbl offset (case when random() < 0.5 then null::bigint end);
begin;
declare c1 cursor for select * from int8_tbl limit 10;
fetch all in c1;
fetch 1 in c1;
fetch backward 1 in c1;
fetch backward all in c1;
fetch backward 1 in c1;
fetch all in c1;
declare c2 cursor for select * from int8_tbl limit 3;
fetch all in c2;
fetch 1 in c2;
fetch backward 1 in c2;
fetch backward all in c2;
fetch backward 1 in c2;
fetch all in c2;
declare c3 cursor for select * from int8_tbl offset 3;
fetch all in c3;
fetch 1 in c3;
fetch backward 1 in c3;
fetch backward all in c3;
fetch backward 1 in c3;
fetch all in c3;
declare c4 cursor for select * from int8_tbl offset 10;
fetch all in c4;
fetch 1 in c4;
fetch backward 1 in c4;
fetch backward all in c4;
fetch backward 1 in c4;
fetch all in c4;
rollback;
SELECT  (SELECT n     FROM (VALUES (1)) AS x,          (SELECT n FROM generate_series(1,10) AS n             ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z  FROM generate_series(1,10) AS s;
create temp sequence testseq;
explain (verbose, costs off)select unique1, unique2, nextval('testseq')  from tenk1 order by unique2 limit 10;
explain (verbose, costs off)select unique1, unique2, nextval('testseq')  from tenk1 order by tenthous limit 10;
explain (verbose, costs off)select unique1, unique2, generate_series(1,10)  from tenk1 order by unique2 limit 7;
explain (verbose, costs off)select unique1, unique2, generate_series(1,10)  from tenk1 order by tenthous limit 7;
explain (verbose, costs off)select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
::select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
explain (verbose, costs off)select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2order by s2 desc;
::select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2order by s2 desc;
explain (verbose, costs off)select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2  from tenk1 group by thousand order by thousand limit 3;
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_addr_user;
RESET client_min_messages;
CREATE USER regress_addr_user;
CREATE SCHEMA addr_nsp;
SET search_path TO 'addr_nsp';
CREATE FOREIGN DATA WRAPPER addr_fdw;
CREATE SERVER addr_fserv FOREIGN DATA WRAPPER addr_fdw;
CREATE TEXT SEARCH DICTIONARY addr_ts_dict (template=simple);
CREATE TEXT SEARCH CONFIGURATION addr_ts_conf (copy=english);
CREATE TEXT SEARCH TEMPLATE addr_ts_temp (lexize=dsimple_lexize);
CREATE TEXT SEARCH PARSER addr_ts_prs    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
CREATE TABLE addr_nsp.gentable (	a serial primary key CONSTRAINT a_chk CHECK (a > 0),	b text DEFAULT 'hello');
CREATE TABLE addr_nsp.parttable (	a int PRIMARY KEY) PARTITION BY RANGE (a);
CREATE VIEW addr_nsp.genview AS SELECT * from addr_nsp.gentable;
CREATE MATERIALIZED VIEW addr_nsp.genmatview AS SELECT * FROM addr_nsp.gentable;
CREATE TYPE addr_nsp.gencomptype AS (a int);
CREATE TYPE addr_nsp.genenum AS ENUM ('one', 'two');
CREATE FOREIGN TABLE addr_nsp.genftable (a int) SERVER addr_fserv;
CREATE AGGREGATE addr_nsp.genaggr(int4) (sfunc = int4pl, stype = int4);
CREATE DOMAIN addr_nsp.gendomain AS int4 CONSTRAINT domconstr CHECK (value > 0);
CREATE FUNCTION addr_nsp.trig() RETURNS TRIGGER LANGUAGE plpgsql AS $$ BEGIN END; $$;
CREATE TRIGGER t BEFORE INSERT ON addr_nsp.gentable FOR EACH ROW EXECUTE PROCEDURE addr_nsp.trig();
CREATE POLICY genpol ON addr_nsp.gentable;
CREATE PROCEDURE addr_nsp.proc(int4) LANGUAGE SQL AS $$ $$;
CREATE SERVER "integer" FOREIGN DATA WRAPPER addr_fdw;
CREATE USER MAPPING FOR regress_addr_user SERVER "integer";
ALTER DEFAULT PRIVILEGES FOR ROLE regress_addr_user IN SCHEMA public GRANT ALL ON TABLES TO regress_addr_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_addr_user REVOKE DELETE ON TABLES FROM regress_addr_user;
CREATE TRANSFORM FOR int LANGUAGE SQL (	FROM SQL WITH FUNCTION prsd_lextype(internal),	TO SQL WITH FUNCTION int4recv(internal));
SET client_min_messages = 'ERROR';
CREATE PUBLICATION addr_pub FOR TABLE addr_nsp.gentable;
RESET client_min_messages;
CREATE SUBSCRIPTION regress_addr_sub CONNECTION '' PUBLICATION bar WITH (connect = false, slot_name = NONE);
CREATE STATISTICS addr_nsp.gentable_stat ON a, b FROM addr_nsp.gentable;
DO $$DECLARE	objtype text;
BEGIN	FOR objtype IN VALUES ('toast table'), ('index column'), ('sequence column'),		('toast table column'), ('view column'), ('materialized view column')	LOOP		BEGIN			PERFORM pg_get_object_address(objtype, '{one}', '{}');
		EXCEPTION WHEN invalid_parameter_value THEN			RAISE WARNING 'error for %: %', objtype, sqlerrm;
		END;
	END LOOP;
END;
$$;
DO $$DECLARE	objtype text;
	names	text[];
	args	text[];
BEGIN	FOR objtype IN VALUES		('table'), ('index'), ('sequence'), ('view'),		('materialized view'), ('foreign table'),		('table column'), ('foreign table column'),		('aggregate'), ('function'), ('procedure'), ('type'), ('cast'),		('table constraint'), ('domain constraint'), ('conversion'), ('default value'),		('operator'), ('operator class'), ('operator family'), ('rule'), ('trigger'),		('text search parser'), ('text search dictionary'),		('text search template'), ('text search configuration'),		('policy'), ('user mapping'), ('default acl'), ('transform'),		('operator of access method'), ('function of access method'),		('publication relation')	LOOP		FOR names IN VALUES ('{eins}'), ('{addr_nsp, zwei}'), ('{eins, zwei, drei}')		LOOP			FOR args IN VALUES ('{}'), ('{integer}')			LOOP				BEGIN					PERFORM pg_get_object_address(objtype, names, args);
				EXCEPTION WHEN OTHERS THEN						RAISE WARNING 'error for %,%,%: %', objtype, names, args, sqlerrm;
				END;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$;
WITH objects (type, name, args) AS (VALUES				('table', '{addr_nsp, gentable}'::text[], '{}'::text[]),				('table', '{addr_nsp, parttable}'::text[], '{}'::text[]),				('index', '{addr_nsp, gentable_pkey}', '{}'),				('index', '{addr_nsp, parttable_pkey}', '{}'),				('sequence', '{addr_nsp, gentable_a_seq}', '{}'),				-- toast table				('view', '{addr_nsp, genview}', '{}'),				('materialized view', '{addr_nsp, genmatview}', '{}'),				('foreign table', '{addr_nsp, genftable}', '{}'),				('table column', '{addr_nsp, gentable, b}', '{}'),				('foreign table column', '{addr_nsp, genftable, a}', '{}'),				('aggregate', '{addr_nsp, genaggr}', '{int4}'),				('function', '{pg_catalog, pg_identify_object}', '{pg_catalog.oid, pg_catalog.oid, int4}'),				('procedure', '{addr_nsp, proc}', '{int4}'),				('type', '{pg_catalog._int4}', '{}'),				('type', '{addr_nsp.gendomain}', '{}'),				('type', '{addr_nsp.gencomptype}', '{}'),				('type', '{addr_nsp.genenum}', '{}'),				('cast', '{int8}', '{int4}'),				('collation', '{default}', '{}'),				('table constraint', '{addr_nsp, gentable, a_chk}', '{}'),				('domain constraint', '{addr_nsp.gendomain}', '{domconstr}'),				('conversion', '{pg_catalog, koi8_r_to_mic}', '{}'),				('default value', '{addr_nsp, gentable, b}', '{}'),				('language', '{plpgsql}', '{}'),				-- large object				('operator', '{+}', '{int4, int4}'),				('operator class', '{btree, int4_ops}', '{}'),				('operator family', '{btree, integer_ops}', '{}'),				('operator of access method', '{btree,integer_ops,1}', '{integer,integer}'),				('function of access method', '{btree,integer_ops,2}', '{integer,integer}'),				('rule', '{addr_nsp, genview, _RETURN}', '{}'),				('trigger', '{addr_nsp, gentable, t}', '{}'),				('schema', '{addr_nsp}', '{}'),				('text search parser', '{addr_ts_prs}', '{}'),				('text search dictionary', '{addr_ts_dict}', '{}'),				('text search template', '{addr_ts_temp}', '{}'),				('text search configuration', '{addr_ts_conf}', '{}'),				('role', '{regress_addr_user}', '{}'),				-- database				-- tablespace				('foreign-data wrapper', '{addr_fdw}', '{}'),				('server', '{addr_fserv}', '{}'),				('user mapping', '{regress_addr_user}', '{integer}'),				('default acl', '{regress_addr_user,public}', '{r}'),				('default acl', '{regress_addr_user}', '{r}'),				-- extension				-- event trigger				('policy', '{addr_nsp, gentable, genpol}', '{}'),				('transform', '{int}', '{sql}'),				('access method', '{btree}', '{}'),				('publication', '{addr_pub}', '{}'),				('publication relation', '{addr_nsp, gentable}', '{addr_pub}'),				('subscription', '{regress_addr_sub}', '{}'),				('statistics object', '{addr_nsp, gentable_stat}', '{}')        )SELECT (pg_identify_object(addr1.classid, addr1.objid, addr1.objsubid)).*,	-- test roundtrip through pg_identify_object_as_address	ROW(pg_identify_object(addr1.classid, addr1.objid, addr1.objsubid)) =	ROW(pg_identify_object(addr2.classid, addr2.objid, addr2.objsubid))	  FROM objects, pg_get_object_address(type, name, args) addr1,			pg_identify_object_as_address(classid, objid, objsubid) ioa(typ,nms,args),			pg_get_object_address(typ, nms, ioa.args) as addr2	ORDER BY addr1.classid, addr1.objid, addr1.objsubid;
DROP FOREIGN DATA WRAPPER addr_fdw CASCADE;
DROP PUBLICATION addr_pub;
DROP SUBSCRIPTION regress_addr_sub;
DROP SCHEMA addr_nsp CASCADE;
DROP OWNED BY regress_addr_user;
DROP USER regress_addr_user;
DROP SEQUENCE test_sequence_exists;
DROP SEQUENCE IF EXISTS test_sequence_exists;
CREATE SEQUENCE test_sequence_exists;
DROP SEQUENCE IF EXISTS test_sequence_exists;
DROP SEQUENCE test_sequence_exists;
DROP SCHEMA test_schema_exists;
DROP SCHEMA IF EXISTS test_schema_exists;
CREATE SCHEMA test_schema_exists;
DROP SCHEMA IF EXISTS test_schema_exists;
DROP SCHEMA test_schema_exists;
DROP TYPE test_type_exists;
DROP TYPE IF EXISTS test_type_exists;
CREATE type test_type_exists as (a int, b text);
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE test_type_exists;
DROP DOMAIN test_domain_exists;
DROP DOMAIN IF EXISTS test_domain_exists;
CREATE domain test_domain_exists as int not null check (value > 0);
DROP DOMAIN IF EXISTS test_domain_exists;
DROP DOMAIN test_domain_exists;
CREATE USER regress_test_u1;
CREATE ROLE regress_test_r1;
CREATE GROUP regress_test_g1;
DROP USER regress_test_u2;
DROP USER IF EXISTS regress_test_u1, regress_test_u2;
DROP USER regress_test_u1;
DROP ROLE regress_test_r2;
DROP ROLE IF EXISTS regress_test_r1, regress_test_r2;
DROP ROLE regress_test_r1;
DROP GROUP regress_test_g2;
DROP GROUP IF EXISTS regress_test_g1, regress_test_g2;
DROP GROUP regress_test_g1;
DROP COLLATION IF EXISTS test_collation_exists;
DROP CONVERSION test_conversion_exists;
DROP CONVERSION IF EXISTS test_conversion_exists;
CREATE CONVERSION test_conversion_exists    FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
DROP CONVERSION test_conversion_exists;
DROP TEXT SEARCH PARSER test_tsparser_exists;
DROP TEXT SEARCH PARSER IF EXISTS test_tsparser_exists;
DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
DROP TEXT SEARCH DICTIONARY IF EXISTS test_tsdict_exists;
CREATE TEXT SEARCH DICTIONARY test_tsdict_exists (        Template=ispell,        DictFile=ispell_sample,        AffFile=ispell_sample);
DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
DROP TEXT SEARCH TEMPLATE IF EXISTS test_tstemplate_exists;
DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
DROP TEXT SEARCH CONFIGURATION IF EXISTS test_tsconfig_exists;
CREATE TEXT SEARCH CONFIGURATION test_tsconfig_exists (COPY=english);
DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
DROP EXTENSION test_extension_exists;
DROP EXTENSION IF EXISTS test_extension_exists;
DROP FUNCTION test_function_exists();
DROP FUNCTION IF EXISTS test_function_exists();
DROP FUNCTION test_function_exists(int, text, int[]);
DROP FUNCTION IF EXISTS test_function_exists(int, text, int[]);
DROP AGGREGATE test_aggregate_exists(*);
DROP AGGREGATE IF EXISTS test_aggregate_exists(*);
DROP AGGREGATE test_aggregate_exists(int);
DROP AGGREGATE IF EXISTS test_aggregate_exists(int);
DROP OPERATOR @#@ (int, int);
DROP OPERATOR IF EXISTS @#@ (int, int);
CREATE OPERATOR @#@        (leftarg = int8, rightarg = int8, procedure = int8xor);
DROP OPERATOR @#@ (int8, int8);
DROP LANGUAGE test_language_exists;
DROP LANGUAGE IF EXISTS test_language_exists;
DROP CAST (text AS text);
DROP CAST IF EXISTS (text AS text);
DROP TRIGGER test_trigger_exists ON test_exists;
DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists;
DROP TRIGGER test_trigger_exists ON no_such_table;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table;
DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema.no_such_table;
DROP TRIGGER test_trigger_exists ON test_exists;
DROP RULE test_rule_exists ON test_exists;
DROP RULE IF EXISTS test_rule_exists ON test_exists;
DROP RULE test_rule_exists ON no_such_table;
DROP RULE IF EXISTS test_rule_exists ON no_such_table;
DROP RULE test_rule_exists ON no_such_schema.no_such_table;
DROP RULE IF EXISTS test_rule_exists ON no_such_schema.no_such_table;
CREATE RULE test_rule_exists AS ON INSERT TO test_exists    DO INSTEAD    INSERT INTO test_exists VALUES (NEW.a, NEW.b || NEW.a::text);
DROP RULE test_rule_exists ON test_exists;
DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
DROP SERVER test_server_exists;
DROP SERVER IF EXISTS test_server_exists;
DROP OPERATOR CLASS test_operator_class USING btree;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree;
DROP OPERATOR CLASS test_operator_class USING no_such_am;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
DROP OPERATOR FAMILY test_operator_family USING btree;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree;
DROP OPERATOR FAMILY test_operator_family USING no_such_am;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
DROP ACCESS METHOD no_such_am;
DROP ACCESS METHOD IF EXISTS no_such_am;
DROP AGGREGATE IF EXISTS no_such_schema.foo(int);
DROP AGGREGATE IF EXISTS foo(no_such_type);
DROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);
DROP CAST IF EXISTS (INTEGER AS no_such_type2);
DROP CAST IF EXISTS (no_such_type1 AS INTEGER);
DROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);
DROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP CONVERSION IF EXISTS no_such_schema.foo;
DROP DOMAIN IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP FUNCTION IF EXISTS no_such_schema.foo();
DROP FUNCTION IF EXISTS foo(no_such_type);
DROP FUNCTION IF EXISTS foo(no_such_schema.no_such_type);
DROP INDEX IF EXISTS no_such_schema.foo;
DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;
DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);
DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);
DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);
DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);
DROP OPERATOR CLASS IF EXISTS no_such_schema.widget_ops USING btree;
DROP OPERATOR FAMILY IF EXISTS no_such_schema.float_ops USING btree;
DROP RULE IF EXISTS foo ON no_such_schema.bar;
DROP SEQUENCE IF EXISTS no_such_schema.foo;
DROP TABLE IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH CONFIGURATION IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH DICTIONARY IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH PARSER IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH TEMPLATE IF EXISTS no_such_schema.foo;
DROP TRIGGER IF EXISTS foo ON no_such_schema.bar;
DROP TYPE IF EXISTS no_such_schema.foo;
DROP VIEW IF EXISTS no_such_schema.foo;
CREATE FUNCTION test_ambiguous_funcname(int) returns int as $$ select $1; $$ language sql;
CREATE FUNCTION test_ambiguous_funcname(text) returns text as $$ select $1; $$ language sql;
DROP FUNCTION test_ambiguous_funcname;
DROP FUNCTION IF EXISTS test_ambiguous_funcname;
DROP FUNCTION test_ambiguous_funcname(int);
DROP FUNCTION test_ambiguous_funcname(text);
CREATE PROCEDURE test_ambiguous_procname(int) as $$ begin end; $$ language plpgsql;
CREATE PROCEDURE test_ambiguous_procname(text) as $$ begin end; $$ language plpgsql;
DROP PROCEDURE test_ambiguous_procname;
DROP PROCEDURE IF EXISTS test_ambiguous_procname;
DROP ROUTINE IF EXISTS test_ambiguous_procname;
DROP PROCEDURE test_ambiguous_procname(int);
DROP PROCEDURE test_ambiguous_procname(text);
drop database test_database_exists (force);
drop database test_database_exists with (force);
drop database if exists test_database_exists (force);
drop database if exists test_database_exists with (force);
::SELECT v as value, hashint2(v)::bit(32) as standard,       hashint2extended(v, 0)::bit(32) as extended0,       hashint2extended(v, 1)::bit(32) as extended1FROM   (VALUES (0::int2), (1::int2), (17::int2), (42::int2)) x(v)WHERE  hashint2(v)::bit(32) != hashint2extended(v, 0)::bit(32)       OR hashint2(v)::bit(32) = hashint2extended(v, 1)::bit(32);
::SELECT v as value, hashint4(v)::bit(32) as standard,	   hashint4extended(v, 0)::bit(32) as extended0,	   hashint4extended(v, 1)::bit(32) as extended1FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)WHERE  hashint4(v)::bit(32) != hashint4extended(v, 0)::bit(32)       OR hashint4(v)::bit(32) = hashint4extended(v, 1)::bit(32);
::SELECT v as value, hashint8(v)::bit(32) as standard,	   hashint8extended(v, 0)::bit(32) as extended0,	   hashint8extended(v, 1)::bit(32) as extended1FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)WHERE  hashint8(v)::bit(32) != hashint8extended(v, 0)::bit(32)       OR hashint8(v)::bit(32) = hashint8extended(v, 1)::bit(32);
::SELECT v as value, hashfloat4(v)::bit(32) as standard,	   hashfloat4extended(v, 0)::bit(32) as extended0,	   hashfloat4extended(v, 1)::bit(32) as extended1FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)WHERE  hashfloat4(v)::bit(32) != hashfloat4extended(v, 0)::bit(32)       OR hashfloat4(v)::bit(32) = hashfloat4extended(v, 1)::bit(32);
::SELECT v as value, hashfloat8(v)::bit(32) as standard,	   hashfloat8extended(v, 0)::bit(32) as extended0,	   hashfloat8extended(v, 1)::bit(32) as extended1FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)WHERE  hashfloat8(v)::bit(32) != hashfloat8extended(v, 0)::bit(32)       OR hashfloat8(v)::bit(32) = hashfloat8extended(v, 1)::bit(32);
::SELECT v as value, hashoid(v)::bit(32) as standard,	   hashoidextended(v, 0)::bit(32) as extended0,	   hashoidextended(v, 1)::bit(32) as extended1FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)WHERE  hashoid(v)::bit(32) != hashoidextended(v, 0)::bit(32)       OR hashoid(v)::bit(32) = hashoidextended(v, 1)::bit(32);
::SELECT v as value, hashchar(v)::bit(32) as standard,	   hashcharextended(v, 0)::bit(32) as extended0,	   hashcharextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::"char"), ('1'), ('x'), ('X'), ('p'), ('N')) x(v)WHERE  hashchar(v)::bit(32) != hashcharextended(v, 0)::bit(32)       OR hashchar(v)::bit(32) = hashcharextended(v, 1)::bit(32);
::SELECT v as value, hashname(v)::bit(32) as standard,	   hashnameextended(v, 0)::bit(32) as extended0,	   hashnameextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'),       ('muop28x03'), ('yi3nm0d73')) x(v)WHERE  hashname(v)::bit(32) != hashnameextended(v, 0)::bit(32)       OR hashname(v)::bit(32) = hashnameextended(v, 1)::bit(32);
::SELECT v as value, hashtext(v)::bit(32) as standard,	   hashtextextended(v, 0)::bit(32) as extended0,	   hashtextextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'),       ('muop28x03'), ('yi3nm0d73')) x(v)WHERE  hashtext(v)::bit(32) != hashtextextended(v, 0)::bit(32)       OR hashtext(v)::bit(32) = hashtextextended(v, 1)::bit(32);
::SELECT v as value, hashoidvector(v)::bit(32) as standard,	   hashoidvectorextended(v, 0)::bit(32) as extended0,	   hashoidvectorextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::oidvector), ('0 1 2 3 4'), ('17 18 19 20'),        ('42 43 42 45'), ('550273 550273 570274'),        ('207112489 207112499 21512 2155 372325 1363252')) x(v)WHERE  hashoidvector(v)::bit(32) != hashoidvectorextended(v, 0)::bit(32)       OR hashoidvector(v)::bit(32) = hashoidvectorextended(v, 1)::bit(32);
::SELECT v as value, hash_aclitem(v)::bit(32) as standard,	   hash_aclitem_extended(v, 0)::bit(32) as extended0,	   hash_aclitem_extended(v, 1)::bit(32) as extended1FROM   (SELECT DISTINCT(relacl[1]) FROM pg_class LIMIT 10) x(v)WHERE  hash_aclitem(v)::bit(32) != hash_aclitem_extended(v, 0)::bit(32)       OR hash_aclitem(v)::bit(32) = hash_aclitem_extended(v, 1)::bit(32);
::SELECT v as value, hashmacaddr(v)::bit(32) as standard,	   hashmacaddrextended(v, 0)::bit(32) as extended0,	   hashmacaddrextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::macaddr), ('08:00:2b:01:02:04'), ('08:00:2b:01:02:04'),		('e2:7f:51:3e:70:49'), ('d6:a9:4a:78:1c:d5'),        ('ea:29:b1:5e:1f:a5')) x(v)WHERE  hashmacaddr(v)::bit(32) != hashmacaddrextended(v, 0)::bit(32)       OR hashmacaddr(v)::bit(32) = hashmacaddrextended(v, 1)::bit(32);
::SELECT v as value, hashinet(v)::bit(32) as standard,	   hashinetextended(v, 0)::bit(32) as extended0,	   hashinetextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::inet), ('192.168.100.128/25'), ('192.168.100.0/8'),		('172.168.10.126/16'), ('172.18.103.126/24'), ('192.188.13.16/32')) x(v)WHERE  hashinet(v)::bit(32) != hashinetextended(v, 0)::bit(32)       OR hashinet(v)::bit(32) = hashinetextended(v, 1)::bit(32);
::SELECT v as value, hash_numeric(v)::bit(32) as standard,	   hash_numeric_extended(v, 0)::bit(32) as extended0,	   hash_numeric_extended(v, 1)::bit(32) as extended1FROM   (VALUES (0), (1.149484958), (17.149484958), (42.149484958),        (149484958.550273), (2071124898672)) x(v)WHERE  hash_numeric(v)::bit(32) != hash_numeric_extended(v, 0)::bit(32)       OR hash_numeric(v)::bit(32) = hash_numeric_extended(v, 1)::bit(32);
::SELECT v as value, hashmacaddr8(v)::bit(32) as standard,	   hashmacaddr8extended(v, 0)::bit(32) as extended0,	   hashmacaddr8extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::macaddr8), ('08:00:2b:01:02:04:36:49'),        ('08:00:2b:01:02:04:f0:e8'), ('e2:7f:51:3e:70:49:16:29'),        ('d6:a9:4a:78:1c:d5:47:32'), ('ea:29:b1:5e:1f:a5')) x(v)WHERE  hashmacaddr8(v)::bit(32) != hashmacaddr8extended(v, 0)::bit(32)       OR hashmacaddr8(v)::bit(32) = hashmacaddr8extended(v, 1)::bit(32);
::SELECT v as value, hash_array(v)::bit(32) as standard,	   hash_array_extended(v, 0)::bit(32) as extended0,	   hash_array_extended(v, 1)::bit(32) as extended1FROM   (VALUES ('{0}'::int4[]), ('{0,1,2,3,4}'), ('{17,18,19,20}'),        ('{42,34,65,98}'), ('{550273,590027, 870273}'),        ('{207112489, 807112489}')) x(v)WHERE  hash_array(v)::bit(32) != hash_array_extended(v, 0)::bit(32)       OR hash_array(v)::bit(32) = hash_array_extended(v, 1)::bit(32);
::SELECT v as value, hashbpchar(v)::bit(32) as standard,	   hashbpcharextended(v, 0)::bit(32) as extended0,	   hashbpcharextended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'),       ('muop28x03'), ('yi3nm0d73')) x(v)WHERE  hashbpchar(v)::bit(32) != hashbpcharextended(v, 0)::bit(32)       OR hashbpchar(v)::bit(32) = hashbpcharextended(v, 1)::bit(32);
::SELECT v as value, time_hash(v)::bit(32) as standard,	   time_hash_extended(v, 0)::bit(32) as extended0,	   time_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::time), ('11:09:59'), ('1:09:59'), ('11:59:59'),        ('7:9:59'), ('5:15:59')) x(v)WHERE  time_hash(v)::bit(32) != time_hash_extended(v, 0)::bit(32)       OR time_hash(v)::bit(32) = time_hash_extended(v, 1)::bit(32);
::SELECT v as value, timetz_hash(v)::bit(32) as standard,	   timetz_hash_extended(v, 0)::bit(32) as extended0,	   timetz_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::timetz), ('00:11:52.518762-07'), ('00:11:52.51762-08'),		('00:11:52.62-01'), ('00:11:52.62+01'), ('11:59:59+04')) x(v)WHERE  timetz_hash(v)::bit(32) != timetz_hash_extended(v, 0)::bit(32)       OR timetz_hash(v)::bit(32) = timetz_hash_extended(v, 1)::bit(32);
::SELECT v as value, interval_hash(v)::bit(32) as standard,	   interval_hash_extended(v, 0)::bit(32) as extended0,	   interval_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::interval),        ('5 month 7 day 46 minutes'), ('1 year 7 day 46 minutes'),		('1 year 7 month 20 day 46 minutes'), ('5 month'),		('17 year 11 month 7 day 9 hours 46 minutes 5 seconds')) x(v)WHERE  interval_hash(v)::bit(32) != interval_hash_extended(v, 0)::bit(32)       OR interval_hash(v)::bit(32) = interval_hash_extended(v, 1)::bit(32);
::SELECT v as value, timestamp_hash(v)::bit(32) as standard,	   timestamp_hash_extended(v, 0)::bit(32) as extended0,	   timestamp_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::timestamp), ('2017-08-22 00:09:59.518762'),        ('2015-08-20 00:11:52.51762-08'),		('2017-05-22 00:11:52.62-01'),        ('2013-08-22 00:11:52.62+01'), ('2013-08-22 11:59:59+04')) x(v)WHERE  timestamp_hash(v)::bit(32) != timestamp_hash_extended(v, 0)::bit(32)       OR timestamp_hash(v)::bit(32) = timestamp_hash_extended(v, 1)::bit(32);
::SELECT v as value, uuid_hash(v)::bit(32) as standard,	   uuid_hash_extended(v, 0)::bit(32) as extended0,	   uuid_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::uuid), ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'),		('5a9ba4ac-8d6f-11e7-bb31-be2e44b06b34'),        ('99c6705c-d939-461c-a3c9-1690ad64ed7b'),		('7deed3ca-8d6f-11e7-bb31-be2e44b06b34'),        ('9ad46d4f-6f2a-4edd-aadb-745993928e1e')) x(v)WHERE  uuid_hash(v)::bit(32) != uuid_hash_extended(v, 0)::bit(32)       OR uuid_hash(v)::bit(32) = uuid_hash_extended(v, 1)::bit(32);
::SELECT v as value, pg_lsn_hash(v)::bit(32) as standard,	   pg_lsn_hash_extended(v, 0)::bit(32) as extended0,	   pg_lsn_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::pg_lsn), ('16/B374D84'), ('30/B374D84'),		('255/B374D84'), ('25/B379D90'), ('900/F37FD90')) x(v)WHERE  pg_lsn_hash(v)::bit(32) != pg_lsn_hash_extended(v, 0)::bit(32)       OR pg_lsn_hash(v)::bit(32) = pg_lsn_hash_extended(v, 1)::bit(32);
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
::SELECT v as value, hashenum(v)::bit(32) as standard,	   hashenumextended(v, 0)::bit(32) as extended0,	   hashenumextended(v, 1)::bit(32) as extended1FROM   (VALUES ('sad'::mood), ('ok'), ('happy')) x(v)WHERE  hashenum(v)::bit(32) != hashenumextended(v, 0)::bit(32)       OR hashenum(v)::bit(32) = hashenumextended(v, 1)::bit(32);
DROP TYPE mood;
::SELECT v as value, jsonb_hash(v)::bit(32) as standard,	   jsonb_hash_extended(v, 0)::bit(32) as extended0,	   jsonb_hash_extended(v, 1)::bit(32) as extended1FROM   (VALUES (NULL::jsonb),    ('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}'),	('{"foo": [true, "bar"], "tags": {"e": 1, "f": null}}'),    ('{"g": {"h": "value"}}')) x(v)WHERE  jsonb_hash(v)::bit(32) != jsonb_hash_extended(v, 0)::bit(32)       OR jsonb_hash(v)::bit(32) = jsonb_hash_extended(v, 1)::bit(32);
::SELECT v as value, hash_range(v)::bit(32) as standard,	   hash_range_extended(v, 0)::bit(32) as extended0,	   hash_range_extended(v, 1)::bit(32) as extended1FROM   (VALUES (int4range(10, 20)), (int4range(23, 43)),         (int4range(5675, 550273)),		 (int4range(550274, 1550274)), (int4range(1550275, 208112489))) x(v)WHERE  hash_range(v)::bit(32) != hash_range_extended(v, 0)::bit(32)       OR hash_range(v)::bit(32) = hash_range_extended(v, 1)::bit(32);
CREATE TABLE INT8_TBL(q1 int8, q2 int8);
INSERT INTO INT8_TBL VALUES(+4567890123456789,'4567890123456789');
SELECT * FROM INT8_TBL WHERE q2 <> 4567890123456789;
SELECT * FROM INT8_TBL WHERE q2 <> 456;
SELECT * FROM INT8_TBL WHERE 123 <> q1;
::SELECT * FROM INT8_TBL WHERE q2 = '456'::int2;
SELECT * FROM INT8_TBL WHERE q2 <> '456'::int2;
::SELECT * FROM INT8_TBL WHERE q2 < '456'::int2;
::SELECT * FROM INT8_TBL WHERE q2 > '456'::int2;
::SELECT * FROM INT8_TBL WHERE q2 <= '456'::int2;
::SELECT * FROM INT8_TBL WHERE q2 >= '456'::int2;
::SELECT * FROM INT8_TBL WHERE '123'::int2 = q1;
::SELECT * FROM INT8_TBL WHERE '123'::int2 <> q1;
::SELECT * FROM INT8_TBL WHERE '123'::int2 < q1;
::SELECT * FROM INT8_TBL WHERE '123'::int2 > q1;
::SELECT * FROM INT8_TBL WHERE '123'::int2 <= q1;
::SELECT * FROM INT8_TBL WHERE '123'::int2 >= q1;
::SELECT q1 + 42::int4 AS "8plus4", q1 - 42::int4 AS "8minus4", q1 * 42::int4 AS "8mul4", q1 / 42::int4 AS "8div4" FROM INT8_TBL;
::SELECT 246::int4 + q1 AS "4plus8", 246::int4 - q1 AS "4minus8", 246::int4 * q1 AS "4mul8", 246::int4 / q1 AS "4div8" FROM INT8_TBL;
::SELECT q1 + 42::int2 AS "8plus2", q1 - 42::int2 AS "8minus2", q1 * 42::int2 AS "8mul2", q1 / 42::int2 AS "8div2" FROM INT8_TBL;
::SELECT 246::int2 + q1 AS "2plus8", 246::int2 - q1 AS "2minus8", 246::int2 * q1 AS "2mul8", 246::int2 / q1 AS "2div8" FROM INT8_TBL;
SELECT '' AS to_char_16, to_char(q2, E'99999 "text" 9999 "9999" 999 "\\"text between quote marks\\"" 9999') FROM INT8_TBL;
::::::::::::::select '9223372036854775800'::int8 + '9223372036854775800'::int8;
::select '-9223372036854775800'::int8 + '-9223372036854775800'::int8;
::select '9223372036854775800'::int8 - '-9223372036854775800'::int8;
::select '-9223372036854775800'::int8 - '9223372036854775800'::int8;
::select '9223372036854775800'::int8 * '9223372036854775800'::int8;
::select '9223372036854775800'::int8 / '0'::int8;
::select '9223372036854775800'::int8 % '0'::int8;
::::select '9223372036854775800'::int8 + '100'::int4;
::select '-9223372036854775800'::int8 - '100'::int4;
::select '9223372036854775800'::int8 * '100'::int4;
::select '100'::int4 + '9223372036854775800'::int8;
::select '-100'::int4 - '9223372036854775800'::int8;
::select '100'::int4 * '9223372036854775800'::int8;
::select '9223372036854775800'::int8 + '100'::int2;
::select '-9223372036854775800'::int8 - '100'::int2;
::select '9223372036854775800'::int8 * '100'::int2;
::select '-9223372036854775808'::int8 / '0'::int2;
::select '100'::int2 + '9223372036854775800'::int8;
::select '-100'::int2 - '9223372036854775800'::int8;
::select '100'::int2 * '9223372036854775800'::int8;
::select '100'::int2 / '0'::int8;
SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 = 456;
SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 <> 456;
SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 = 456;
SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456;
::SELECT CAST('42'::int2 AS int8), CAST('-37'::int2 AS int8);
SELECT CAST(q1 AS float4), CAST(q2 AS float8) FROM INT8_TBL;
::SELECT CAST('36854775807.0'::float4 AS int8);
::SELECT CAST('922337203685477580700.0'::float8 AS int8);
SELECT CAST(q1 AS oid) FROM INT8_TBL;
::&SELECT q1, q2, q1 & q2 AS "and", q1 | q2 AS "or", q1 # q2 AS "xor", ~q1 AS "not" FROM INT8_TBL;
SELECT q1, q1 << 2 AS "shl", q1 >> 3 AS "shr" FROM INT8_TBL;
::::::::::::::SELECT (-1::int8<<63)::text;
::SELECT ((-1::int8<<63)+1)::text;
::SELECT (-9223372036854775808)::int8 * (-1)::int8;
::SELECT (-9223372036854775808)::int8 / (-1)::int8;
::SELECT (-9223372036854775808)::int8 % (-1)::int8;
::SELECT (-9223372036854775808)::int8 * (-1)::int4;
::SELECT (-9223372036854775808)::int8 / (-1)::int4;
::SELECT (-9223372036854775808)::int8 % (-1)::int4;
::SELECT (-9223372036854775808)::int8 * (-1)::int2;
::SELECT (-9223372036854775808)::int8 / (-1)::int2;
::SELECT (-9223372036854775808)::int8 % (-1)::int2;
::SELECT x, x::int8 AS int8_valueFROM (VALUES (-2.5::float8),             (-1.5::float8),             (-0.5::float8),             (0.0::float8),             (0.5::float8),             (1.5::float8),             (2.5::float8)) t(x);
::SELECT x, x::int8 AS int8_valueFROM (VALUES (-2.5::numeric),             (-1.5::numeric),             (-0.5::numeric),             (0.0::numeric),             (0.5::numeric),             (1.5::numeric),             (2.5::numeric)) t(x);
CREATE TABLE ctv_data (v, h, c, i, d) ASVALUES   ('v1','h2','foo', 3, '2015-04-01'::date),   ('v2','h1','bar', 3, '2015-01-02'),   ('v1','h0','baz', NULL, '2015-07-12'),   ('v0','h4','qux', 4, '2015-07-15'),   ('v0','h4','dbl', -3, '2014-12-15'),   ('v0',NULL,'qux', 5, '2014-07-15'),   ('v1','h2','quux',7, '2015-04-04');
ANALYZE ctv_data;
SELECT v, EXTRACT(year FROM d), count(*) FROM ctv_data GROUP BY 1, 2 ORDER BY 1, 2;
\ \crosstabviewSELECT v, to_char(d, 'Mon') AS "month name", EXTRACT(month FROM d) AS num, count(*) FROM ctv_data  GROUP BY 1,2,3 ORDER BY 1 \crosstabview v "month name" 4 numSELECT EXTRACT(year FROM d) AS year, to_char(d,'Mon') AS """month"" name",  EXTRACT(month FROM d) AS month,  format('sum=%s avg=%s', sum(i), avg(i)::numeric(2,1))  FROM ctv_data  GROUP BY EXTRACT(year FROM d), to_char(d,'Mon'), EXTRACT(month FROM d)ORDER BY month\crosstabview """month"" name" year format yearSELECT v, h, string_agg(c, E'\n') FROM ctv_data GROUP BY v, h ORDER BY 1,2,3 \crosstabview 1 2 3SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h) AS rFROM ctv_data GROUP BY v, h ORDER BY 1,3,2 \crosstabview v h c rSELECT v, h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h DESC) AS rFROM ctv_data GROUP BY v, h ORDER BY 1,3,2 \crosstabview v h c rSELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h NULLS LAST) AS rFROM ctv_data GROUP BY v, h ORDER BY 1,3,2 \crosstabview v h c rSELECT null,null \crosstabviewSELECT null,null,null \crosstabview\pset null '#null#'SELECT v,h, string_agg(i::text, E'\n') AS i FROM ctv_dataGROUP BY v, h ORDER BY h,v \crosstabview v h i\pset null ''SELECT v,h,string_agg(i::text, E'\n'), string_agg(c, E'\n')FROM ctv_data GROUP BY v, h ORDER BY h,v \crosstabview 2 1 4SELECT v,h, string_agg(i::text, E'\n') AS i, string_agg(c, E'\n') AS cFROM ctv_data GROUP BY v, h ORDER BY h,v \crosstabview 1 "h" 4SELECT 1 as "22", 2 as b, 3 as "Foo" \crosstabview "22" B "Foo"SELECT v,h,c,i FROM ctv_data \crosstabview v h jSELECT 1 as "22", 2 as b, 3 as "Foo" \crosstabview 1 2 FooSELECT 1 as "22", 2 as b, 3 as "Foo" \crosstabview 1 "B" "Foo"SELECT v,h,i,c FROM ctv_data \crosstabview 2 1 5SELECT v,h,i,c FROM ctv_data \crosstabview 2 h 4SELECT a,a,1 FROM generate_series(1,3000) AS a \crosstabviewSELECT 1 \crosstabviewDROP TABLE ctv_data;
||\SELECT * FROM ctv_data \crosstabviewINSERT INTO ctv_data VALUES (1, 10, '*'); -- duplicate data to cause errorSELECT * FROM ctv_data \crosstabviewDROP TABLE ctv_data;
create type complex as (r float8, i float8);
create temp table fullname (first text, last text);
create type quad as (c1 complex, c2 complex);
::select (1.1,2.2)::complex, row((3.3,4.4),(5.5,null))::quad;
select row('Joe', 'Blow')::fullname, '(Joe,Blow)'::fullname;
::::::select '(Joe,"von""Blow")'::fullname, E'(Joe,d\\\\Blow)'::fullname;
::::select '(Joe,)'::fullname;	-- ok, null 2nd columnselect '(Joe)'::fullname;	-- badselect '(Joe,,)'::fullname;	-- badselect '[]'::fullname;          -- badselect ' (Joe,Blow)  '::fullname;  -- ok, extra whitespaceselect '(Joe,Blow) /'::fullname;  -- badcreate temp table quadtable(f1 int, q quad);
insert into quadtable values (2, ((null,4.4),(5.5,6.6)));
select f1, q.c1 from quadtable;		-- fails, q is a table referenceselect f1, (q).c1, (qq.q).c1.i from quadtable qq;
create temp table people (fn fullname, bd date);
alter table fullname add column suffix text default '';
alter table fullname add column suffix text default null;
update people set fn.suffix = 'Jr';
insert into quadtable (f1, q.c1.r, q.c2.i) values(44,55,66);
insert into people select ('Jim', f1, null)::fullname, current_date from pp;
select (fn).first, substr((fn).last, 1, 20), length((fn).last) from people;
select ROW(1,2) < ROW(1,3) as true;
select ROW(1,2) < ROW(1,1) as false;
select ROW(1,2) < ROW(1,NULL) as null;
select ROW(1,2,3) < ROW(1,3,NULL) as true; -- the NULL is not examinedselect ROW(11,'ABC') < ROW(11,'DEF') as true;
select ROW(11,'ABC') > ROW(11,'DEF') as false;
select ROW(12,'ABC') > ROW(11,'DEF') as true;
select ROW(1,2,3) < ROW(1,NULL,4) as null;
select ROW(1,2,3) = ROW(1,NULL,4) as false;
select ROW(1,2,3) <> ROW(1,NULL,4) as true;
select ROW('ABC','DEF') ~<=~ ROW('DEF','ABC') as true;
select ROW('ABC','DEF') ~>=~ ROW('DEF','ABC') as false;
select ROW('ABC','DEF') ~~ ROW('DEF','ABC') as fail;
select ROW(1,2) = ROW(1,2::int8);
select ROW(1,2) in (ROW(3,4), ROW(1,2));
select ROW(1,2) in (ROW(3,4), ROW(1,2::int8));
select unique1, unique2 from tenk1where (unique1, unique2) < any (select ten, ten from tenk1 where hundred < 3)      and unique1 <= 20order by 1;
explain (costs off)select thousand, tenthous from tenk1where (thousand, tenthous) >= (997, 5000)order by thousand, tenthous;
select thousand, tenthous from tenk1where (thousand, tenthous) >= (997, 5000)order by thousand, tenthous;
explain (costs off)select thousand, tenthous, four from tenk1where (thousand, tenthous, four) > (998, 5000, 3)order by thousand, tenthous;
select thousand, tenthous, four from tenk1where (thousand, tenthous, four) > (998, 5000, 3)order by thousand, tenthous;
explain (costs off)select thousand, tenthous from tenk1where (998, 5000) < (thousand, tenthous)order by thousand, tenthous;
select thousand, tenthous from tenk1where (998, 5000) < (thousand, tenthous)order by thousand, tenthous;
explain (costs off)select thousand, hundred from tenk1where (998, 5000) < (thousand, hundred)order by thousand, hundred;
select thousand, hundred from tenk1where (998, 5000) < (thousand, hundred)order by thousand, hundred;
insert into test_table select 'a', null from generate_series(1,1000);
create index on test_table (a,b);
set enable_sort = off;
explain (costs off)select a,b from test_table where (a,b) > ('a','a') order by a,b;
select a,b from test_table where (a,b) > ('a','a') order by a,b;
reset enable_sort;
select * from int8_tbl i8 where i8 in (row(123,456));  -- fail, type mismatchexplain (costs off)select * from int8_tbl i8where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
select * from int8_tbl i8where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
select (row(1, 2.0)).f1;
select (row(1, 2.0)).f2;
select (row(1, 2.0)).nosuch;  -- failselect (row(1, 2.0)).*;
select (r).f1 from (select row(1, 2.0) as r) ss;
select (r).f3 from (select row(1, 2.0) as r) ss;  -- failselect (r).* from (select row(1, 2.0) as r) ss;
select ROW();
select ROW() IS NULL;
select ROW() = ROW();
select array[ row(1,2), row(3,4), row(5,6) ];
select row(1,1.1) = any (array[ row(7,7.7), row(1,1.1), row(0,0.0) ]);
select row(1,1.1) = any (array[ row(7,7.7), row(1,1.0), row(0,0.0) ]);
create type cantcompare as (p point, r float8);
create temp table cc (f1 cantcompare);
select * from cc order by f1; -- fail, but should complain about cantcomparecreate type testtype1 as (a int, b int);
select row(1, 2)::testtype1 < row(1, 3)::testtype1;
select row(1, 2)::testtype1 <= row(1, 3)::testtype1;
select row(1, 2)::testtype1 = row(1, 2)::testtype1;
select row(1, 2)::testtype1 <> row(1, 3)::testtype1;
select row(1, 3)::testtype1 >= row(1, 2)::testtype1;
select row(1, 3)::testtype1 > row(1, 2)::testtype1;
select row(1, -2)::testtype1 < row(1, -3)::testtype1;
select row(1, -2)::testtype1 <= row(1, -3)::testtype1;
select row(1, -2)::testtype1 = row(1, -3)::testtype1;
select row(1, -2)::testtype1 <> row(1, -2)::testtype1;
select row(1, -3)::testtype1 >= row(1, -2)::testtype1;
select row(1, -3)::testtype1 > row(1, -2)::testtype1;
select row(1, -2)::testtype1 < row(1, 3)::testtype1;
create type testtype3 as (a int, b text);
select row(1, 2)::testtype1 < row(1, 'abc')::testtype3;
select row(1, 2)::testtype1 <> row(1, 'abc')::testtype3;
create type testtype5 as (a int);
select row(1, 2)::testtype1 < row(1)::testtype5;
select row(1, 2)::testtype1 <> row(1)::testtype5;
create type testtype6 as (a int, b point);
select row(1, '(1,2)')::testtype6 < row(1, '(1,3)')::testtype6;
select row(1, '(1,2)')::testtype6 <> row(1, '(1,3)')::testtype6;
drop type testtype1, testtype3, testtype5, testtype6;
create type testtype1 as (a int, b int);
select row(1, 2)::testtype1 *< row(1, 3)::testtype1;
select row(1, 2)::testtype1 *<= row(1, 3)::testtype1;
select row(1, 2)::testtype1 *= row(1, 2)::testtype1;
select row(1, 2)::testtype1 *<> row(1, 3)::testtype1;
select row(1, 3)::testtype1 *>= row(1, 2)::testtype1;
select row(1, 3)::testtype1 *> row(1, 2)::testtype1;
select row(1, -2)::testtype1 *< row(1, -3)::testtype1;
select row(1, -2)::testtype1 *<= row(1, -3)::testtype1;
select row(1, -2)::testtype1 *= row(1, -3)::testtype1;
select row(1, -2)::testtype1 *<> row(1, -2)::testtype1;
select row(1, -3)::testtype1 *>= row(1, -2)::testtype1;
select row(1, -3)::testtype1 *> row(1, -2)::testtype1;
select row(1, -2)::testtype1 *< row(1, 3)::testtype1;
create type testtype2 as (a smallint, b bool);  -- byval different sizesselect row(1, true)::testtype2 *< row(2, true)::testtype2;
select row(-2, true)::testtype2 *< row(-1, true)::testtype2;
select row(0, false)::testtype2 *< row(0, true)::testtype2;
select row(0, false)::testtype2 *<> row(0, true)::testtype2;
create type testtype3 as (a int, b text);  -- variable lengthselect row(1, 'abc')::testtype3 *< row(1, 'abd')::testtype3;
select row(1, 'abc')::testtype3 *< row(1, 'abcd')::testtype3;
select row(1, 'abc')::testtype3 *> row(1, 'abd')::testtype3;
select row(1, 'abc')::testtype3 *<> row(1, 'abd')::testtype3;
create type testtype4 as (a int, b point);  -- by ref, fixed lengthselect row(1, '(1,2)')::testtype4 *< row(1, '(1,3)')::testtype4;
select row(1, '(1,2)')::testtype4 *<> row(1, '(1,3)')::testtype4;
select row(1, 2)::testtype1 *< row(1, 'abc')::testtype3;
select row(1, 2)::testtype1 *<> row(1, 'abc')::testtype3;
create type testtype5 as (a int);
select row(1, 2)::testtype1 *< row(1)::testtype5;
select row(1, 2)::testtype1 *<> row(1)::testtype5;
create type testtype6 as (a int, b point);
select row(1, '(1,2)')::testtype6 *< row(1, '(1,3)')::testtype6;
select row(1, '(1,2)')::testtype6 *>= row(1, '(1,3)')::testtype6;
select row(1, '(1,2)')::testtype6 *<> row(1, '(1,3)')::testtype6;
select q.a, q.b = row(2), q.c = array[row(3)], q.d = row(row(4)) from    unnest(array[row(1, row(2), array[row(3)], row(row(4))),                 row(2, row(3), array[row(4)], row(row(5)))])      as q(a int, b record, c record[], d record);
drop type testtype1, testtype2, testtype3, testtype4, testtype5, testtype6;
BEGIN;
CREATE TABLE price (    id SERIAL PRIMARY KEY,    active BOOLEAN NOT NULL,    price NUMERIC);
CREATE TYPE price_input AS (    id INTEGER,    price NUMERIC);
CREATE TYPE price_key AS (    id INTEGER);
CREATE FUNCTION price_key_from_table(price) RETURNS price_key AS $$    SELECT $1.id$$ LANGUAGE SQL;
CREATE FUNCTION price_key_from_input(price_input) RETURNS price_key AS $$    SELECT $1.id$$ LANGUAGE SQL;
UPDATE price    SET active = true, price = input_prices.price    FROM unnest(ARRAY[(10, 123.00), (11, 99.99)]::price_input[]) input_prices    WHERE price_key_from_table(price.*) = price_key_from_input(input_prices.*);
rollback;
create function fcompos1(v compos) returns void as $$insert into compos values (v);  -- fail$$ language sql;
create function fcompos1(v compos) returns void as $$insert into compos values (v.*);
$$ language sql;
create function fcompos2(v compos) returns void as $$select fcompos1(v);
$$ language sql;
create function fcompos3(v compos) returns void as $$select fcompos1(fcompos3.v.*);
$$ language sql;
select fcompos1(row(1,'one'));
select fcompos2(row(2,'two'));
select fcompos3(row(3,'three'));
::select fullname::text from fullname;
select text(fullname) from fullname;  -- errorselect fullname.text from fullname;  -- errorselect cast (row('Jim', 'Beam') as text);
select (row('Jim', 'Beam'))::text;
select text(row('Jim', 'Beam'));  -- errorselect (row('Jim', 'Beam')).text;  -- errorinsert into fullname values ('Joe', 'Blow');
select f.last from fullname f;
select last(f) from fullname f;
create function longname(fullname) returns text language sqlas $$select $1.first || ' ' || $1.last$$;
select f.longname from fullname f;
select f.longname from fullname f;
select row_to_json(i) from int8_tbl i(x,y);
select row_to_json(i) from vv1 i(x,y);
select row_to_json(ss) from  (select q1, q2 from int8_tbl offset 0) as ss;
select row_to_json(ss) from  (select q1 as a, q2 as b from int8_tbl offset 0) as ss;
select row_to_json(ss) from  (select q1 as a, q2 as b from int8_tbl) as ss(x,y);
select row_to_json(ss) from  (select q1 as a, q2 as b from int8_tbl offset 0) as ss(x,y);
explain (costs off)select row_to_json(q) from  (select thousand, tenthous from tenk1   where thousand = 42 and tenthous < 2000 offset 0) q;
select row_to_json(q) from  (select thousand, tenthous from tenk1   where thousand = 42 and tenthous < 2000 offset 0) q;
select row_to_json(q) from  (select thousand as x, tenthous as y from tenk1   where thousand = 42 and tenthous < 2000 offset 0) q;
select row_to_json(q) from  (select thousand as x, tenthous as y from tenk1   where thousand = 42 and tenthous < 2000 offset 0) q(a,b);
create temp table tt2 () inherits(tt1);
select row_to_json(r) from (select q2,q1 from tt1 offset 0) r;
create temp table tt3 () inherits(tt2);
::::select row_to_json(tt3::tt2::tt1) from tt3;
explain (verbose, costs off)select r, r is null as isnull, r is not null as isnotnullfrom (values (1,row(1,2)), (1,row(null,null)), (1,null),             (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
select r, r is null as isnull, r is not null as isnotnullfrom (values (1,row(1,2)), (1,row(null,null)), (1,null),             (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
explain (verbose, costs off)with r(a,b) as materialized  (values (1,row(1,2)), (1,row(null,null)), (1,null),          (null,row(1,2)), (null,row(null,null)), (null,null) )select r, r is null as isnull, r is not null as isnotnull from r;
with r(a,b) as materialized  (values (1,row(1,2)), (1,row(null,null)), (1,null),          (null,row(1,2)), (null,row(null,null)), (null,null) )select r, r is null as isnull, r is not null as isnotnull from r;
SELECT d.a FROM (SELECT compositetable AS d FROM compositetable) s;
SELECT (d).a, (d).b FROM (SELECT compositetable AS d FROM compositetable) s;
SELECT (d).ctid FROM (SELECT compositetable AS d FROM compositetable) s;
SELECT (NULL::compositetable).nonexistent;
SELECT (NULL::compositetable).a;
SELECT (NULL::compositetable).oid;
COPY hs1 TO '/tmp/copy_test';
\!\! cat /tmp/copy_testselect is_called from hsseq;
begin;
end;
begin transaction read only;
end;
begin transaction isolation level repeatable read;
commit;
begin;
commit;
begin;
abort;
start transaction;
commit;
begin;
rollback;
begin;
savepoint s;
commit;
begin;
savepoint s;
release savepoint s;
savepoint s;
rollback to savepoint s;
commit;
set synchronous_commit = on;
show synchronous_commit;
reset synchronous_commit;
discard temp;
discard all;
BEGIN;
DECLARE hsc CURSOR FOR select * from hs3;
FETCH next from hsc;
fetch first from hsc;
fetch last from hsc;
fetch 1 from hsc;
CLOSE hsc;
COMMIT;
PREPARE hsp AS select count(*) from hs1;
PREPARE hsp_noexec (integer) AS insert into hs1 values ($1);
EXECUTE hsp;
DEALLOCATE hsp;
BEGIN;
LOCK hs1 IN ACCESS SHARE MODE;
LOCK hs1 IN ROW SHARE MODE;
LOCK hs1 IN ROW EXCLUSIVE MODE;
COMMIT;
UNLISTEN a;
UNLISTEN *;
CHECKPOINT;
discard all;
::select length(txid_current_snapshot()::text) >= 4;
CREATE AGGREGATE newavg (   sfunc = int4_avg_accum, basetype = int4, stype = _int8,   finalfunc = int8_avg,   initcond1 = '{0,0}');
COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS NULL;
CREATE AGGREGATE newsum (   sfunc1 = int4pl, basetype = int4, stype1 = int4,   initcond1 = '0');
CREATE AGGREGATE newcnt (*) (   sfunc = int8inc, stype = int8,   initcond = '0', parallel = safe);
CREATE AGGREGATE oldcnt (   sfunc = int8inc, basetype = 'ANY', stype = int8,   initcond = '0');
CREATE AGGREGATE newcnt ("any") (   sfunc = int8inc_any, stype = int8,   initcond = '0');
COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
create function sum3(int8,int8,int8) returns int8 as'select $1 + $2 + $3' language sql strict immutable;
create aggregate sum2(int8,int8) (   sfunc = sum3, stype = int8,   initcond = '0');
create type aggtype as (a integer, b integer, c text);
create function aggf_trans(aggtype[],integer,integer,text) returns aggtype[]as 'select array_append($1,ROW($2,$3,$4)::aggtype)'language sql strict immutable;
create function aggfns_trans(aggtype[],integer,integer,text) returns aggtype[]as 'select array_append($1,ROW($2,$3,$4)::aggtype)'language sql immutable;
create aggregate aggfstr(integer,integer,text) (   sfunc = aggf_trans, stype = aggtype[],   initcond = '{}');
create aggregate aggfns(integer,integer,text) (   sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,   initcond = '{}');
create function least_accum(anyelement, variadic anyarray)returns anyelement language sql as  'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
create aggregate least_agg(variadic items anyarray) (  stype = anyelement, sfunc = least_accum);
create aggregate my_percentile_disc(float8 ORDER BY anyelement) (  stype = internal,  sfunc = ordered_set_transition,  finalfunc = percentile_disc_final,  finalfunc_extra = true,  finalfunc_modify = read_write);
create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (  stype = internal,  sfunc = ordered_set_transition_multi,  finalfunc = rank_final,  finalfunc_extra = true,  hypothetical);
alter aggregate my_percentile_disc(float8 ORDER BY anyelement)  rename to test_percentile_disc;
alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")  rename to test_rank;
CREATE AGGREGATE sumdouble (float8)    stype = float8,    sfunc = float8pl,    mstype = float8,    msfunc = float8pl,    minvfunc = float8mi);
CREATE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	serialfunc = numeric_avg_serialize);
CREATE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	serialfunc = numeric_avg_deserialize,	deserialfunc = numeric_avg_deserialize);
CREATE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	serialfunc = numeric_avg_serialize,	deserialfunc = numeric_avg_serialize);
CREATE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	serialfunc = numeric_avg_serialize,	deserialfunc = numeric_avg_deserialize,	combinefunc = int4larger);
CREATE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	finalfunc = numeric_avg,	serialfunc = numeric_avg_serialize,	deserialfunc = numeric_avg_deserialize,	combinefunc = numeric_avg_combine,	finalfunc_modify = shareable  -- just to test a non-default setting);
::SELECT aggfnoid, aggtransfn, aggcombinefn, aggtranstype::regtype,       aggserialfn, aggdeserialfn, aggfinalmodifyFROM pg_aggregateWHERE aggfnoid = 'myavg'::REGPROC;
DROP AGGREGATE myavg (numeric);
CREATE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	finalfunc = numeric_avg);
CREATE OR REPLACE AGGREGATE myavg (numeric)	stype = internal,	sfunc = numeric_avg_accum,	finalfunc = numeric_avg,	serialfunc = numeric_avg_serialize,	deserialfunc = numeric_avg_deserialize,	combinefunc = numeric_avg_combine,	finalfunc_modify = shareable  -- just to test a non-default setting);
::SELECT aggfnoid, aggtransfn, aggcombinefn, aggtranstype::regtype,       aggserialfn, aggdeserialfn, aggfinalmodifyFROM pg_aggregateWHERE aggfnoid = 'myavg'::REGPROC;
CREATE OR REPLACE AGGREGATE myavg (numeric)	stype = numeric,	sfunc = numeric_add);
::SELECT aggfnoid, aggtransfn, aggcombinefn, aggtranstype::regtype,       aggserialfn, aggdeserialfn, aggfinalmodifyFROM pg_aggregateWHERE aggfnoid = 'myavg'::REGPROC;
CREATE OR REPLACE AGGREGATE myavg (numeric)	stype = numeric,	sfunc = numeric_add,	finalfunc = numeric_out);
CREATE OR REPLACE AGGREGATE myavg (order by numeric)	stype = numeric,	sfunc = numeric_add);
create function sum4(int8,int8,int8,int8) returns int8 as'select $1 + $2 + $3 + $4' language sql strict immutable;
CREATE OR REPLACE AGGREGATE sum3 (int8,int8,int8)	stype = int8,	sfunc = sum4);
drop function sum4(int8,int8,int8,int8);
DROP AGGREGATE myavg (numeric);
CREATE AGGREGATE mysum (int)	stype = int,	sfunc = int4pl,	parallel = pear);
CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS$$ SELECT $1 - $2; $$LANGUAGE SQL;
CREATE AGGREGATE invalidsumdouble (float8)    stype = float8,    sfunc = float8pl,    mstype = float8,    msfunc = float8pl,    minvfunc = float8mi_n);
CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS$$ SELECT CAST($1 - $2 AS INT); $$LANGUAGE SQL;
CREATE AGGREGATE wrongreturntype (float8)    stype = float8,    sfunc = float8pl,    mstype = float8,    msfunc = float8pl,    minvfunc = float8mi_int);
CREATE AGGREGATE case_agg ( -- old syntax	"Sfunc1" = int4pl,	"Basetype" = int4,	"Stype1" = int4,	"Initcond1" = '0',	"Parallel" = safe);
CREATE AGGREGATE case_agg(float8)	"Stype" = internal,	"Sfunc" = ordered_set_transition,	"Finalfunc" = percentile_disc_final,	"Finalfunc_extra" = true,	"Finalfunc_modify" = read_write,	"Parallel" = safe);
DROP sequence if exists hsseq;
create sequence hsseq;
select jsonb '{"a": 12}' @? '$';
select jsonb '{"a": 12}' @? '1';
select jsonb '{"a": 12}' @? '$.a.b';
select jsonb '{"a": 12}' @? '$.b';
select jsonb '{"a": 12}' @? '$.a + 2';
select jsonb '{"a": 12}' @? '$.b + 2';
select jsonb '{"a": {"a": 12}}' @? '$.a.a';
select jsonb '{"a": {"a": 12}}' @? '$.*.a';
select jsonb '{"b": {"a": 12}}' @? '$.*.a';
select jsonb '{"b": {"a": 12}}' @? '$.*.b';
select jsonb '{"b": {"a": 12}}' @? 'strict $.*.b';
select jsonb '{}' @? '$.*';
select jsonb '{"a": 1}' @? '$.*';
select jsonb '{"a": {"b": 1}}' @? 'lax $.**{1}';
select jsonb '{"a": {"b": 1}}' @? 'lax $.**{2}';
select jsonb '{"a": {"b": 1}}' @? 'lax $.**{3}';
select jsonb '[]' @? '$[*]';
select jsonb '[1]' @? '$[*]';
select jsonb '[1]' @? '$[1]';
select jsonb '[1]' @? 'strict $[1]';
select jsonb_path_query('[1]', 'strict $[1]', silent => true);
select jsonb '[1]' @? 'lax $[10000000000000000]';
select jsonb '[1]' @? 'strict $[10000000000000000]';
select jsonb '[1]' @? '$[0]';
select jsonb '[1]' @? '$[0.3]';
select jsonb '[1]' @? '$[0.5]';
select jsonb '[1]' @? '$[0.9]';
select jsonb '[1]' @? '$[1.2]';
select jsonb '[1]' @? 'strict $[1.2]';
select jsonb '{"a": [1,2,3], "b": [3,4,5]}' @? '$ ? (@.a[*] >  @.b[*])';
select jsonb '{"a": [1,2,3], "b": [3,4,5]}' @? '$ ? (@.a[*] >= @.b[*])';
select jsonb '{"a": [1,2,3], "b": [3,4,"5"]}' @? '$ ? (@.a[*] >= @.b[*])';
select jsonb '{"a": [1,2,3], "b": [3,4,"5"]}' @? 'strict $ ? (@.a[*] >= @.b[*])';
select jsonb '{"a": [1,2,3], "b": [3,4,null]}' @? '$ ? (@.a[*] >= @.b[*])';
select jsonb '1' @? '$ ? ((@ == "1") is unknown)';
select jsonb '1' @? '$ ? ((@ == 1) is unknown)';
select jsonb '[{"a": 1}, {"a": 2}]' @? '$[0 to 1] ? (@.a > 1)';
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'lax $[*].a', silent => false);
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'lax $[*].a', silent => true);
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => false);
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => true);
select jsonb_path_query('1', 'strict $.a', silent => true);
select jsonb_path_query('1', 'strict $.*', silent => true);
select jsonb_path_query('[]', 'strict $.a', silent => true);
select jsonb_path_query('{}', 'strict $.a', silent => true);
select jsonb_path_query('1', 'strict $[1]', silent => true);
select jsonb_path_query('1', 'strict $[*]', silent => true);
select jsonb_path_query('[]', 'strict $[1]', silent => true);
select jsonb_path_query('[]', 'strict $["a"]', silent => true);
select jsonb_path_query('[1,2,3]', 'strict $[*].a', silent => true);
select jsonb_path_query('[]', 'strict $[last]', silent => true);
select jsonb_path_query('[1,2,3]', '$[last ? (@.type() == "string")]', silent => true);
select jsonb '{"a": {"b": 1}}' @? '$.**.b ? ( @ > 0)';
select jsonb '{"a": {"b": 1}}' @? '$.**{0}.b ? ( @ > 0)';
select jsonb '{"a": {"b": 1}}' @? '$.**{1}.b ? ( @ > 0)';
select jsonb '{"a": {"b": 1}}' @? '$.**{0 to last}.b ? ( @ > 0)';
select jsonb '{"a": {"b": 1}}' @? '$.**{1 to last}.b ? ( @ > 0)';
select jsonb '{"a": {"b": 1}}' @? '$.**{1 to 2}.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**{0}.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**{1}.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**{0 to last}.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**{1 to last}.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**{1 to 2}.b ? ( @ > 0)';
select jsonb '{"a": {"c": {"b": 1}}}' @? '$.**{2 to 3}.b ? ( @ > 0)';
select	x, y,	jsonb_path_query(		'[true, false, null]',		'$[*] ? (@ == true  &&  ($x == true && $y == true) ||				 @ == false && !($x == true && $y == true) ||				 @ == null  &&  ($x == true && $y == true) is unknown)',		jsonb_build_object('x', x, 'y', y)	) as "x && y"from	(values (jsonb 'true'), ('false'), ('"null"')) x(x),	(values (jsonb 'true'), ('false'), ('"null"')) y(y);
select	x, y,	jsonb_path_query(		'[true, false, null]',		'$[*] ? (@ == true  &&  ($x == true || $y == true) ||				 @ == false && !($x == true || $y == true) ||				 @ == null  &&  ($x == true || $y == true) is unknown)',		jsonb_build_object('x', x, 'y', y)	) as "x || y"from	(values (jsonb 'true'), ('false'), ('"null"')) x(x),	(values (jsonb 'true'), ('false'), ('"null"')) y(y);
select jsonb '{"a": 1, "b":1}' @? '$ ? (@.a == @.b)';
select jsonb '{"c": {"a": 1, "b":1}}' @? '$ ? (@.a == @.b)';
select jsonb '{"c": {"a": 1, "b":1}}' @? '$.c ? (@.a == @.b)';
select jsonb '{"c": {"a": 1, "b":1}}' @? '$.c ? ($.c.a == @.b)';
select jsonb '{"c": {"a": 1, "b":1}}' @? '$.* ? (@.a == @.b)';
select jsonb '{"a": 1, "b":1}' @? '$.** ? (@.a == @.b)';
select jsonb '{"c": {"a": 1, "b":1}}' @? '$.** ? (@.a == @.b)';
select jsonb '{"c": {"a": -1, "b":1}}' @? '$.** ? (@.a == - 1)';
select jsonb '{"c": {"a": -1, "b":1}}' @? '$.** ? (@.a == -1)';
select jsonb '{"c": {"a": -1, "b":1}}' @? '$.** ? (@.a == -@.b)';
select jsonb '{"c": {"a": -1, "b":1}}' @? '$.** ? (@.a == - @.b)';
select jsonb '{"c": {"a": 0, "b":1}}' @? '$.** ? (@.a == 1 - @.b)';
select jsonb '{"c": {"a": 2, "b":1}}' @? '$.** ? (@.a == 1 - - @.b)';
select jsonb '{"c": {"a": 0, "b":1}}' @? '$.** ? (@.a == 1 - +@.b)';
select jsonb '[1,2,3]' @? '$ ? (+@[*] > +2)';
select jsonb '[1,2,3]' @? '$ ? (+@[*] > +3)';
select jsonb '[1,2,3]' @? '$ ? (-@[*] < -2)';
select jsonb '[1,2,3]' @? '$ ? (-@[*] < -3)';
select jsonb '1' @? '$ ? ($ > 0)';
select jsonb_path_query('1', '$ + "2"', silent => true);
select jsonb_path_query('[1, 2]', '3 * $', silent => true);
select jsonb_path_query('"a"', '-$', silent => true);
select jsonb_path_query('[1,"2",3]', '+$', silent => true);
select jsonb '["1",2,0,3]' @? '-$[*]';
select jsonb '[1,"2",0,3]' @? '-$[*]';
select jsonb '["1",2,0,3]' @? 'strict -$[*]';
select jsonb '[1,"2",0,3]' @? 'strict -$[*]';
select jsonb_path_query('{"a": [1, 2]}', 'lax $.a * 3', silent => true);
select jsonb '2' @? '$ == "2"';
select jsonb '2' @@ '$ > 1';
select jsonb '2' @@ '$ <= 1';
select jsonb '2' @@ '$ == "2"';
select jsonb '2' @@ '1';
select jsonb '{}' @@ '$';
select jsonb '[]' @@ '$';
select jsonb '[1,2,3]' @@ '$[*]';
select jsonb '[]' @@ '$[*]';
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'lax exists($[*].a)', silent => false);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'lax exists($[*].a)', silent => true);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'strict exists($[*].a)', silent => false);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'strict exists($[*].a)', silent => true);
select jsonb_path_query('[1,null,true,"11",[],[1],[1,2,3],{},{"a":1,"b":2}]', 'strict $[*].size()', silent => true);
select jsonb_path_query('[{},1]', '$[*].keyvalue()', silent => true);
select jsonb '{"a": 1, "b": [1, 2]}' @? 'lax $.keyvalue()';
select jsonb '{"a": 1, "b": [1, 2]}' @? 'lax $.keyvalue().key';
select jsonb_path_query('null', '$.double()', silent => true);
select jsonb_path_query('true', '$.double()', silent => true);
select jsonb_path_query('[]', 'strict $.double()', silent => true);
select jsonb_path_query('{}', '$.double()', silent => true);
select jsonb_path_query('"inf"', '$.double()', silent => true);
select jsonb_path_query('"-inf"', '$.double()', silent => true);
select jsonb_path_query('{}', '$.abs()', silent => true);
select jsonb_path_query('true', '$.floor()', silent => true);
select jsonb_path_query('"1.2"', '$.ceiling()', silent => true);
select jsonb '"10-03-2017"' @? '$.datetime("dd-mm-yyyy")';
set time zone '+00';
set time zone '+10';
set time zone default;
set time zone '+00';
::set time zone default;
SELECT jsonb_path_query_array('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 1, "max": 4}');
SELECT jsonb_path_query_array('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 3, "max": 4}');
SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a', silent => true);
SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 1, "max": 4}');
SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 3, "max": 4}');
SELECT jsonb '[{"a": 1}, {"a": 2}]' @? '$[*].a ? (@ > 1)';
SELECT jsonb '[{"a": 1}, {"a": 2}]' @? '$[*] ? (@.a > 2)';
SELECT jsonb_path_exists('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*] ? (@.a > $min && @.a < $max)', vars => '{"min": 1, "max": 4}');
SELECT jsonb_path_exists('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*] ? (@.a > $min && @.a < $max)', vars => '{"min": 3, "max": 4}');
SELECT jsonb_path_match('true', '$', silent => false);
SELECT jsonb_path_match('false', '$', silent => false);
SELECT jsonb_path_match('null', '$', silent => false);
SELECT jsonb_path_match('1', '$', silent => true);
SELECT jsonb_path_match('1', '$', silent => false);
SELECT jsonb_path_match('"a"', '$', silent => false);
SELECT jsonb_path_match('{}', '$', silent => false);
SELECT jsonb_path_match('[true]', '$', silent => false);
SELECT jsonb_path_match('{}', 'lax $.a', silent => false);
SELECT jsonb_path_match('{}', 'strict $.a', silent => false);
SELECT jsonb_path_match('{}', 'strict $.a', silent => true);
SELECT jsonb_path_match('[true, true]', '$[*]', silent => false);
SELECT jsonb '[{"a": 1}, {"a": 2}]' @@ '$[*].a > 1';
SELECT jsonb '[{"a": 1}, {"a": 2}]' @@ '$[*].a > 2';
WITH str(j, num) AS	SELECT jsonb_build_object('s', s), num	FROM unnest('{"", "a", "ab", "abc", "abcd", "b", "A", "AB", "ABC", "ABc", "ABcD", "B"}'::text[]) WITH ORDINALITY AS a(s, num)SELECT	s1.j, s2.j,	jsonb_path_query_first(s1.j, '$.s < $s', vars => s2.j) lt,	jsonb_path_query_first(s1.j, '$.s <= $s', vars => s2.j) le,	jsonb_path_query_first(s1.j, '$.s == $s', vars => s2.j) eq,	jsonb_path_query_first(s1.j, '$.s >= $s', vars => s2.j) ge,	jsonb_path_query_first(s1.j, '$.s > $s', vars => s2.j) gtFROM str s1, str s2ORDER BY s1.num, s2.num;
SELECT text 'this is a text string' = text 'this is a text string' AS true;
SELECT text 'this is a text string' = text 'this is a text strin' AS false;
::select 'four: '::text || 2+2;
||select 'four: ' || 2+2;
||select 3 || 4.0;
/* * various string functions */select concat('one');
select concat_ws(',',10,20,null,30);
select concat_ws('',10,20,null,30);
select concat_ws(NULL,10,20,null,30) is null;
select i, left('ahoj', i), right('ahoj', i) from generate_series(-5, 5) t(i) order by i;
select quote_literal(e'\\');
select concat(variadic array[1,2,3]);
select concat_ws(',', variadic array[1,2,3]);
select concat_ws(',', variadic NULL::int[]);
select concat(variadic NULL::int[]) is NULL;
select concat(variadic '{}'::int[]) = '';
select concat_ws(',', variadic 10);
/* * format */select format(NULL);
select format('%s%s%s','Hello', NULL,'World');
select format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, NULL);
select format('INSERT INTO %I VALUES(%L,%L)', 'mytab', NULL, 'Hello');
select format('INSERT INTO %I VALUES(%L,%L)', NULL, 10, 'Hello');
select format('%s, %s', variadic array['Hello','World']);
select format('%s, %s', variadic array[1, 2]);
select format('%s, %s', variadic array[true, false]);
select format('%s, %s', variadic array[true, false]::text[]);
select format('%2$s, %1$s', variadic array['first', 'second']);
select format('%2$s, %1$s', variadic array[1, 2]);
select format('Hello', variadic NULL::int[]);
select format(string_agg('%s',','), variadic array_agg(i))from generate_series(1,200) g(i);
select format('>>%10s<<', NULL);
select format('>>%-10s<<', NULL);
select format('>>%2$*1$L<<', 10, NULL);
select format('>>%2$*1$L<<', -10, NULL);
select format('>>%10L<<', NULL);
select format('>>%2$*1$L<<', NULL, 'Hello');
CREATE TYPE widget (   internallength = 24,   input = widget_in,   output = widget_out,   typmod_in = numerictypmodin,   typmod_out = numerictypmodout,   alignment = double);
CREATE TYPE city_budget (   internallength = 16,   input = int44in,   output = int44out,   element = int4,   category = 'x',   -- just to verify the system will take it   preferred = true  -- ditto);
CREATE TYPE shell;
CREATE TYPE shell;   -- fail, type already presentDROP TYPE shell;
DROP TYPE shell;     -- fail, type not existCREATE TYPE myshell;
CREATE TYPE int42;
CREATE TYPE text_w_default;
CREATE FUNCTION int42_in(cstring)   RETURNS int42   AS 'int4in'   LANGUAGE internal STRICT IMMUTABLE;
CREATE FUNCTION int42_out(int42)   RETURNS cstring   AS 'int4out'   LANGUAGE internal STRICT IMMUTABLE;
CREATE FUNCTION text_w_default_in(cstring)   RETURNS text_w_default   AS 'textin'   LANGUAGE internal STRICT IMMUTABLE;
CREATE FUNCTION text_w_default_out(text_w_default)   RETURNS cstring   AS 'textout'   LANGUAGE internal STRICT IMMUTABLE;
CREATE TYPE int42 (   internallength = 4,   input = int42_in,   output = int42_out,   alignment = int4,   default = 42,   passedbyvalue);
CREATE TYPE text_w_default (   internallength = variable,   input = text_w_default_in,   output = text_w_default_out,   alignment = int4,   default = 'zippo');
CREATE TABLE default_test (f1 text_w_default, f2 int42);
CREATE TYPE case_int42 (	"Internallength" = 4,	"Input" = int42_in,	"Output" = int42_out,	"Alignment" = int4,	"Default" = 42,	"Passedbyvalue");
CREATE TYPE default_test_row AS (f1 text_w_default, f2 int42);
CREATE FUNCTION get_default_test() RETURNS SETOF default_test_row AS '  SELECT * FROM default_test;
' LANGUAGE SQL;
SELECT * FROM get_default_test();
COMMENT ON TYPE bad IS 'bad comment';
COMMENT ON TYPE default_test_row IS 'good comment';
COMMENT ON TYPE default_test_row IS NULL;
COMMENT ON COLUMN default_test_row.nope IS 'bad comment';
COMMENT ON COLUMN default_test_row.f1 IS 'good comment';
COMMENT ON COLUMN default_test_row.f1 IS NULL;
CREATE TYPE text_w_default;		-- should failDROP TYPE default_test_row CASCADE;
CREATE TYPE not_existing_type (INPUT = array_in,    OUTPUT = array_out,    ELEMENT = int,    INTERNALLENGTH = 32);
CREATE FUNCTION base_fn_in(cstring) RETURNS opaque AS 'boolin'    LANGUAGE internal IMMUTABLE STRICT;
CREATE FUNCTION base_fn_out(opaque) RETURNS opaque AS 'boolout'    LANGUAGE internal IMMUTABLE STRICT;
CREATE TYPE base_type(INPUT = base_fn_in, OUTPUT = base_fn_out);
DROP FUNCTION base_fn_in(cstring); -- errorDROP FUNCTION base_fn_out(opaque); -- errorDROP TYPE base_type; -- errorDROP TYPE base_type CASCADE;
CREATE TEMP TABLE mytab (foo widget(42,13,7));     -- should failCREATE TEMP TABLE mytab (foo widget(42,13));
SELECT format_type(atttypid,atttypmod) FROM pg_attributeWHERE attrelid = 'mytab'::regclass AND attnum > 0;
TABLE mytab;
::::select format_type('bpchar'::regtype, null);
::create domain domaindroptest int4;
comment on domain domaindroptest is 'About to drop this..';
create domain dependenttypetest domaindroptest;
drop domain domaindroptest;
drop domain domaindroptest cascade;
drop domain domaindroptest cascade;
create domain domainvarchar varchar(5);
create domain domainnumeric numeric(8,2);
create domain domainint4 int4;
create domain domaintext text;
SELECT cast('123456' as domainvarchar);
SELECT cast('12345' as domainvarchar);
create table basictest           ( testint4 domainint4           , testtext domaintext           , testvarchar domainvarchar           , testnumeric domainnumeric           );
INSERT INTO basictest values ('88', 'haha', 'short', '123.12');      -- GoodINSERT INTO basictest values ('88', 'haha', 'short text', '123.12'); -- Bad varcharINSERT INTO basictest values ('88', 'haha', 'short', '123.1212');    -- Truncate numericCOPY basictest (testvarchar) FROM stdin; -- failnotsoshorttext\.COPY basictest (testvarchar) FROM stdin;
short\.select * from basictest;
||select testtext || testvarchar as concat, testnumeric + 42 as sumfrom basictest;
::select coalesce(4::domainint4, 7) is of (int4) as t;
::select coalesce(4::domainint4, 7) is of (domainint4) as f;
::::select coalesce(4::domainint4, 7::domainint4) is of (domainint4) as t;
drop domain domainvarchar restrict;
drop domain domainnumeric restrict;
drop domain domainint4 restrict;
drop domain domaintext;
create domain domainint4arr int4[1];
create domain domainchar4arr varchar(4)[2][3];
create table domarrtest           ( testint4arr domainint4arr           , testchar4arr domainchar4arr            );
INSERT INTO domarrtest values (NULL, '{{"a","b","c"},{"d","e","f"}}');
INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}');
INSERT INTO domarrtest (testint4arr[1], testint4arr[3]) values (11,22);
:select testint4arr[1], testchar4arr[2:2] from domarrtest;
COPY domarrtest FROM stdin;
{{3,4}	{q,w,e}\N	\N\.COPY domarrtest FROM stdin;	-- fail{3,4}	{qwerty,w,e}\.select * from domarrtest;
update domarrtest set  testint4arr[1] = testint4arr[1] + 1,  testint4arr[3] = testint4arr[3] - 1where testchar4arr is null;
drop domain domainint4arr restrict;
drop domain domainchar4arr restrict;
create domain dia as int[];
::::::::||select pg_typeof('{1,2,3}'::dia || 42); -- should be int[] not diadrop domain dia;
create type comptype as (r float8, i float8);
create domain dcomptype as comptype;
create table dcomptable (d1 dcomptype unique);
insert into dcomptable values (row(1,2)::dcomptype);
insert into dcomptable values (row(3,4)::comptype);
insert into dcomptable values (row(1,2)::dcomptype);  -- fail on uniquenessinsert into dcomptable (d1.r) values(11);
select (d1).r, (d1).i, (d1).* from dcomptable;
update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0;
alter domain dcomptype add constraint c1 check ((value).r <= (value).i);
alter domain dcomptype add constraint c2 check ((value).r > (value).i);  -- failselect row(2,1)::dcomptype;  -- failinsert into dcomptable values (row(1,2)::comptype);
insert into dcomptable values (row(2,1)::comptype);  -- failinsert into dcomptable (d1.r) values(99);
insert into dcomptable (d1.r, d1.i) values(99, 100);
insert into dcomptable (d1.r, d1.i) values(100, 99);  -- failupdate dcomptable set d1.r = (d1).r + 1 where (d1).i > 0;  -- failupdate dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
explain (verbose, costs off)  update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
create rule silly as on delete to dcomptable do instead  update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
drop type comptype cascade;
create type comptype as (r float8, i float8);
create domain dcomptype as comptype;
alter domain dcomptype add constraint c1 check ((value).r > 0);
comment on constraint c1 on domain dcomptype is 'random commentary';
select row(0,1)::dcomptype;  -- failalter type comptype alter attribute r type varchar;  -- failalter type comptype alter attribute r type bigint;
alter type comptype drop attribute r;  -- failalter type comptype drop attribute i;
::select conname, obj_description(oid, 'pg_constraint') from pg_constraint  where contypid = 'dcomptype'::regtype;  -- check comment is still theredrop type comptype cascade;
create type comptype as (r float8, i float8);
create domain dcomptypea as comptype[];
create table dcomptable (d1 dcomptypea unique);
insert into dcomptable values (array[row(1,2)]::dcomptypea);
insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniquenessinsert into dcomptable (d1[1]) values(row(9,10));
insert into dcomptable (d1[1].r) values(11);
select d1[2], d1[1].r, d1[1].i from dcomptable;
update dcomptable set d1[2] = row(d1[2].i, d1[2].r);
update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;
alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- failselect array[row(2,1)]::dcomptypea;  -- failinsert into dcomptable values (array[row(1,2)]::comptype[]);
insert into dcomptable values (array[row(2,1)]::comptype[]);  -- failinsert into dcomptable (d1[1].r) values(99);
insert into dcomptable (d1[1].r, d1[1].i) values(99, 100);
insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);  -- failupdate dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;  -- failupdate dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1  where d1[1].i > 0;
explain (verbose, costs off)  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1    where d1[1].i > 0;
create rule silly as on delete to dcomptable do instead  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1    where d1[1].i > 0;
drop type comptype cascade;
create domain posint as int check (value > 0);
create table pitable (f1 posint[]);
insert into pitable values(array[-1]);  -- failinsert into pitable values('{0}');  -- failupdate pitable set f1[1] = f1[1] + 1;
update pitable set f1[1] = 0;  -- failselect * from pitable;
create domain vc4 as varchar(4);
create table vc4table (f1 vc4[]);
insert into vc4table values(array['too long']);  -- failinsert into vc4table values(array['too long']::vc4[]);  -- cast truncatesselect * from vc4table;
drop type vc4;
create domain dposinta as posint[];
create table dposintatable (f1 dposinta[]);
insert into dposintatable values(array[array[42]]);  -- failinsert into dposintatable values(array[array[42]::posint[]]); -- still failinsert into dposintatable values(array[array[42]::dposinta]); -- but this worksselect f1, f1[1], (f1[1])[1] from dposintatable;
update dposintatable set f1[2] = array[99];
update dposintatable set f1[2][1] = array[97];
update dposintatable set (f1[2])[1] = array[98];
drop domain posint cascade;
create domain dnotnull varchar(15) NOT NULL;
create domain dnull    varchar(15);
create domain dcheck   varchar(15) NOT NULL CHECK (VALUE = 'a' OR VALUE = 'c' OR VALUE = 'd');
create table nulltest           ( col1 dnotnull           , col2 dnotnull NULL  -- NOT NULL in the domain cannot be overridden           , col3 dnull    NOT NULL           , col4 dnull           , col5 dcheck CHECK (col5 IN ('c', 'd'))           );
INSERT INTO nulltest values ('a', 'b', 'c', 'd', 'c');  -- Goodinsert into nulltest values ('a', 'b', 'c', 'd', NULL);
INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd');
INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c');
INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c');
INSERT INTO nulltest values ('a', 'b', 'c', NULL, 'd'); -- GoodCOPY nulltest FROM stdin; --faila	b	\N	d	d\.COPY nulltest FROM stdin; --faila	b	c	d	\N\.COPY nulltest FROM stdin;
a	b	c	\N	ca	b	c	\N	da	b	c	\N	a\.select * from nulltest;
SELECT cast('1' as dnotnull);
SELECT cast(NULL as dnotnull); -- failSELECT cast(cast(NULL as dnull) as dnotnull); -- failSELECT cast(col4 as dnotnull) from nulltest; -- faildrop table nulltest;
drop domain dnotnull restrict;
drop domain dnull restrict;
drop domain dcheck restrict;
create domain ddef1 int4 DEFAULT 3;
create domain ddef2 oid DEFAULT '12';
create domain ddef3 text DEFAULT 5;
create sequence ddef4_seq;
create domain ddef4 int4 DEFAULT nextval('ddef4_seq');
create domain ddef5 numeric(8,2) NOT NULL DEFAULT '12.12';
create table defaulttest            ( col1 ddef1            , col2 ddef2            , col3 ddef3            , col4 ddef4 PRIMARY KEY            , col5 ddef1 NOT NULL DEFAULT NULL            , col6 ddef2 DEFAULT '88'            , col7 ddef4 DEFAULT 8000            , col8 ddef5            );
insert into defaulttest(col4) values(0); -- fails, col5 defaults to nullalter table defaulttest alter column col5 drop default;
insert into defaulttest default values; -- succeeds, inserts domain defaultalter table defaulttest alter column col5 set default null;
insert into defaulttest(col4) values(0); -- failsalter table defaulttest alter column col5 drop default;
COPY defaulttest(col5) FROM stdin;
42\.select * from defaulttest;
drop table defaulttest cascade;
create domain dnotnulltest integer;
create table domnotnull( col1 dnotnulltest, col2 dnotnulltest);
alter domain dnotnulltest set not null; -- failsupdate domnotnull set col1 = 5;
alter domain dnotnulltest set not null; -- failsupdate domnotnull set col2 = 6;
alter domain dnotnulltest set not null;
update domnotnull set col1 = null; -- failsalter domain dnotnulltest drop not null;
update domnotnull set col1 = null;
drop domain dnotnulltest cascade;
create table domdeftest (col1 ddef1);
alter domain ddef1 set default '42';
alter domain ddef1 drop default;
create domain con as integer;
create table domcontest (col1 con);
alter domain con add constraint t check (VALUE < 1); -- failsalter domain con add constraint t check (VALUE < 34);
alter domain con add check (VALUE > 0);
insert into domcontest values (-5); -- failsinsert into domcontest values (42); -- failsinsert into domcontest values (5);
alter domain con drop constraint t;
insert into domcontest values (-5); --failsinsert into domcontest values (42);
alter domain con drop constraint nonexistent;
alter domain con drop constraint if exists nonexistent;
create domain things AS INT;
CREATE TABLE thethings (stuff things);
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
create domain dom as integer;
create view domview as select cast(col1 as dom) from domtab;
insert into domtab (col1) values (null);
alter domain dom set not null;
select * from domview; -- failalter domain dom drop not null;
alter domain dom add constraint domchkgt6 check(value > 6);
select * from domview; --failalter domain dom drop constraint domchkgt6 restrict;
drop domain ddef1 restrict;
drop domain ddef2 restrict;
drop domain ddef3 restrict;
drop domain ddef4 restrict;
drop domain ddef5 restrict;
drop sequence ddef4_seq;
create domain vchar4 varchar(4);
create domain dinter vchar4 check (substring(VALUE, 1, 1) = 'x');
create domain dtop dinter check (substring(VALUE, 2, 1) = '1');
::::select 'x1234'::dtop; -- explicit coercion should truncateselect 'y1234'::dtop; -- failselect 'y123'::dtop; -- failselect 'yz23'::dtop; -- failselect 'xz23'::dtop; -- failcreate temp table dtest(f1 dtop);
insert into dtest values('x1234'); -- fail, implicit coercioninsert into dtest values('y1234'); -- fail, implicit coercioninsert into dtest values('y123'); -- failinsert into dtest values('yz23'); -- failinsert into dtest values('xz23'); -- faildrop table dtest;
drop domain vchar4 cascade;
create domain str_domain as text not null;
alter table domain_test add column c str_domain;
create domain str_domain2 as text check (value <> 'foo') default 'foo';
alter table domain_test add column d str_domain2;
create domain pos_int as int4 check (value > 0) not null;
prepare s1 as select $1::pos_int = 10 as "is_ten";
execute s1(10);
execute s1(0); -- should failexecute s1(NULL); -- should failcreate function doubledecrement(p1 pos_int) returns pos_int as $$declare v pos_int;
begin    return p1;
end$$ language plpgsql;
select doubledecrement(3); -- fail because of implicit null assignmentcreate or replace function doubledecrement(p1 pos_int) returns pos_int as $$declare v pos_int := 0;
begin    return p1;
end$$ language plpgsql;
select doubledecrement(3); -- fail at initialization assignmentcreate or replace function doubledecrement(p1 pos_int) returns pos_int as $$declare v pos_int := 1;
begin    v := p1 - 1;
    return v - 1;
end$$ language plpgsql;
select doubledecrement(null); -- fail before callselect doubledecrement(0); -- fail before callselect doubledecrement(1); -- fail at assignment to vselect doubledecrement(2); -- fail at returnselect doubledecrement(3); -- goodcreate domain posint as int4;
create type ddtest1 as (f1 posint);
create table ddtest2(f1 ddtest1);
insert into ddtest2 values(row(-1));
alter domain posint add constraint c1 check(value >= 0);
create table ddtest2(f1 ddtest1[]);
alter domain posint add constraint c1 check(value >= 0);
create domain ddtest1d as ddtest1;
create table ddtest2(f1 ddtest1d);
alter domain posint add constraint c1 check(value >= 0);
drop domain ddtest1d;
create domain ddtest1d as ddtest1[];
create table ddtest2(f1 ddtest1d);
alter domain posint add constraint c1 check(value >= 0);
drop domain ddtest1d;
create type rposint as range (subtype = posint);
create table ddtest2(f1 rposint);
alter domain posint add constraint c1 check(value >= 0);
drop type rposint;
alter domain posint add constraint c1 check(value >= 0);
create domain posint2 as posint check (value % 2 = 0);
create table ddtest2(f1 posint2);
insert into ddtest2 values(11); -- failinsert into ddtest2 values(-2); -- failinsert into ddtest2 values(2);
alter domain posint add constraint c2 check(value >= 10); -- failalter domain posint add constraint c2 check(value > 0); -- OKdrop table ddtest2;
drop type ddtest1;
drop domain posint cascade;
create or replace function array_elem_check(numeric) returns numeric as $$declare  x numeric(4,2)[1];
begin  x[1] := $1;
  return x[1];
end$$ language plpgsql;
create domain mynums as numeric(4,2)[1];
create or replace function array_elem_check(numeric) returns numeric as $$declare  x mynums;
begin  x[1] := $1;
  return x[1];
end$$ language plpgsql;
create domain mynums2 as mynums;
create or replace function array_elem_check(numeric) returns numeric as $$declare  x mynums2;
begin  x[1] := $1;
  return x[1];
end$$ language plpgsql;
drop function array_elem_check(numeric);
create domain orderedpair as int[2] check (value[1] < value[2]);
::::select array[2,1]::orderedpair;  -- failcreate temp table op (f1 orderedpair);
insert into p1 values (array[2,1]);  -- failupdate op set f1[2] = 3;
create or replace function array_elem_check(int) returns int as $$declare  x orderedpair := '{1,2}';
begin  x[2] := $1;
  return x[2];
end$$ language plpgsql;
drop function array_elem_check(int);
create domain di as int;
create function dom_check(int) returns di as $$declare d di;
begin  d := $1::di;
  return d;
end$$ language plpgsql immutable;
alter domain di add constraint pos check (value > 0);
select dom_check(0); -- failalter domain di drop constraint pos;
create or replace function dom_check(int) returns di as $$declare d di;
begin  d := $1;
  return d;
end$$ language plpgsql immutable;
alter domain di add constraint pos check (value > 0);
select dom_check(0); -- failalter domain di drop constraint pos;
drop function dom_check(int);
drop domain di;
create function sql_is_distinct_from(anyelement, anyelement)returns boolean language sqlas 'select $1 is distinct from $2 limit 1';
create domain inotnull int  check (sql_is_distinct_from(value, null));
::select null::inotnull;
create table dom_table (x inotnull);
insert into dom_table values (null);
drop domain inotnull;
drop function sql_is_distinct_from(anyelement, anyelement);
create domain testdomain1 as int;
alter domain testdomain1 rename to testdomain2;
alter type testdomain2 rename to testdomain3;  -- alter type also worksdrop domain testdomain3;
create domain testdomain1 as int constraint unsigned check (value > 0);
alter domain testdomain1 rename constraint unsigned to unsigned_foo;
alter domain testdomain1 drop constraint unsigned_foo;
drop domain testdomain1;
CREATE OR REPLACE FUNCTION hs_subxids (n integer)RETURNS voidLANGUAGE plpgsqlAS $$    BEGIN      IF n <= 0 THEN RETURN; END IF;
      PERFORM hs_subxids(n - 1);
      RETURN;
    EXCEPTION WHEN raise_exception THEN NULL; END;
$$;
BEGIN;
ROLLBACK;
BEGIN;
COMMIT;
set client_min_messages = 'warning';
CREATE OR REPLACE FUNCTION hs_locks_create (n integer)RETURNS voidLANGUAGE plpgsqlAS $$    BEGIN      IF n <= 0 THEN		CHECKPOINT;
		RETURN;
	  END IF;
      EXECUTE 'CREATE TABLE hs_locks_' || n::text || ' ()';
      PERFORM hs_locks_create(n - 1);
      RETURN;
    EXCEPTION WHEN raise_exception THEN NULL; END;
$$;
CREATE OR REPLACE FUNCTION hs_locks_drop (n integer)RETURNS voidLANGUAGE plpgsqlAS $$    BEGIN      IF n <= 0 THEN		CHECKPOINT;
		RETURN;
	  END IF;
	  EXECUTE 'DROP TABLE IF EXISTS hs_locks_' || n::text;
      PERFORM hs_locks_drop(n - 1);
      RETURN;
    EXCEPTION WHEN raise_exception THEN NULL; END;
$$;
BEGIN;
ROLLBACK;
BEGIN;
COMMIT;
CREATE TABLE FLOAT8_TBL(f1 float8);
::::::::::::::::::::::::::::SELECT 'Infinity'::float8 + 100.0;
::SELECT 'Infinity'::float8 / 'Infinity'::float8;
::SELECT 'nan'::float8 / 'nan'::float8;
::SELECT 'nan'::numeric::float8;
SELECT '' AS four, f.* FROM FLOAT8_TBL f WHERE f.f1 <> '1004.3';
SELECT '' AS one, f.* FROM FLOAT8_TBL f WHERE f.f1 = '1004.3';
SELECT '' AS three, f.* FROM FLOAT8_TBL f WHERE '1004.3' > f.f1;
SELECT '' AS three, f.* FROM FLOAT8_TBL f WHERE  f.f1 < '1004.3';
SELECT '' AS four, f.* FROM FLOAT8_TBL f WHERE '1004.3' >= f.f1;
SELECT '' AS four, f.* FROM FLOAT8_TBL f WHERE  f.f1 <= '1004.3';
SELECT '' AS three, f.f1, f.f1 * '-10' AS x   FROM FLOAT8_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS three, f.f1, f.f1 + '-10' AS x   FROM FLOAT8_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS three, f.f1, f.f1 / '-10' AS x   FROM FLOAT8_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS three, f.f1, f.f1 - '-10' AS x   FROM FLOAT8_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS one, f.f1 ^ '2.0' AS square_f1   FROM FLOAT8_TBL f where f.f1 = '1004.3';
SELECT '' AS five, f.f1, @f.f1 AS abs_f1   FROM FLOAT8_TBL f;
SELECT '' AS five, f.f1, trunc(f.f1) AS trunc_f1   FROM FLOAT8_TBL f;
SELECT '' AS five, f.f1, round(f.f1) AS round_f1   FROM FLOAT8_TBL f;
SET extra_float_digits = 0;
SELECT sqrt(float8 '64') AS eight;
|SELECT |/ float8 '64' AS eight;
SELECT '' AS three, f.f1, |/f.f1 AS sqrt_f1   FROM FLOAT8_TBL f   WHERE f.f1 > '0.0';
SELECT power(float8 '144', float8 '0.5');
SELECT power(float8 'NaN', float8 '0.5');
SELECT power(float8 '144', float8 'NaN');
SELECT power(float8 'NaN', float8 'NaN');
SELECT power(float8 '-1', float8 'NaN');
SELECT power(float8 '1', float8 'NaN');
SELECT power(float8 'NaN', float8 '0');
SELECT '' AS three, f.f1, exp(ln(f.f1)) AS exp_ln_f1   FROM FLOAT8_TBL f   WHERE f.f1 > '0.0';
||SELECT ||/ float8 '27' AS three;
SELECT '' AS five, f.f1, ||/f.f1 AS cbrt_f1 FROM FLOAT8_TBL f;
UPDATE FLOAT8_TBL   SET f1 = FLOAT8_TBL.f1 * '-1'   WHERE FLOAT8_TBL.f1 > '0.0';
SELECT '' AS bad, f.f1 * '1e200' from FLOAT8_TBL f;
SELECT '' AS bad, f.f1 ^ '1e200' from FLOAT8_TBL f;
SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0' ;
SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0' ;
SELECT '' AS bad, exp(f.f1) from FLOAT8_TBL f;
SELECT '' AS bad, f.f1 / '0.0' from FLOAT8_TBL f;
SELECT sinh(float8 '1');
SELECT cosh(float8 '1');
SELECT tanh(float8 '1');
SELECT asinh(float8 '1');
SELECT acosh(float8 '2');
SELECT atanh(float8 '0.5');
SELECT sinh(float8 'infinity');
SELECT sinh(float8 '-infinity');
SELECT sinh(float8 'nan');
SELECT cosh(float8 'infinity');
SELECT cosh(float8 '-infinity');
SELECT cosh(float8 'nan');
SELECT tanh(float8 'infinity');
SELECT tanh(float8 '-infinity');
SELECT tanh(float8 'nan');
SELECT asinh(float8 'infinity');
SELECT asinh(float8 '-infinity');
SELECT asinh(float8 'nan');
SELECT acosh(float8 '-infinity');
SELECT acosh(float8 'nan');
SELECT atanh(float8 'infinity');
SELECT atanh(float8 '-infinity');
SELECT atanh(float8 'nan');
RESET extra_float_digits;
DELETE FROM FLOAT8_TBL;
::::SELECT '32767.4'::float8::int2;
::::SELECT '32767.6'::float8::int2;
::::SELECT '-32768.4'::float8::int2;
::::SELECT '-32768.6'::float8::int2;
::::SELECT '2147483647.4'::float8::int4;
::::SELECT '2147483647.6'::float8::int4;
::::SELECT '-2147483648.4'::float8::int4;
::::SELECT '-2147483648.6'::float8::int4;
::::SELECT '9223372036854773760'::float8::int8;
::::SELECT '9223372036854775807'::float8::int8;
::::SELECT '-9223372036854775808.5'::float8::int8;
::::SELECT '-9223372036854780000'::float8::int8;
SELECT x,       sind(x),       sind(x) IN (-1,-0.5,0,0.5,1) AS sind_exactFROM (VALUES (0), (30), (90), (150), (180),      (210), (270), (330), (360)) AS t(x);
SELECT x,       cosd(x),       cosd(x) IN (-1,-0.5,0,0.5,1) AS cosd_exactFROM (VALUES (0), (60), (90), (120), (180),      (240), (270), (300), (360)) AS t(x);
::::::::SELECT x,       tand(x),       tand(x) IN ('-Infinity'::float8,-1,0,                   1,'Infinity'::float8) AS tand_exact,       cotd(x),       cotd(x) IN ('-Infinity'::float8,-1,0,                   1,'Infinity'::float8) AS cotd_exactFROM (VALUES (0), (45), (90), (135), (180),      (225), (270), (315), (360)) AS t(x);
SELECT x,       asind(x),       asind(x) IN (-90,-30,0,30,90) AS asind_exact,       acosd(x),       acosd(x) IN (0,60,90,120,180) AS acosd_exactFROM (VALUES (-1), (-0.5), (0), (0.5), (1)) AS t(x);
SELECT x,       atand(x),       atand(x) IN (-90,-45,0,45,90) AS atand_exactFROM (VALUES ('-Infinity'::float8), (-1), (0), (1),      ('Infinity'::float8)) AS t(x);
SELECT x, y,       atan2d(y, x),       atan2d(y, x) IN (-90,0,90,180) AS atan2d_exactFROM (SELECT 10*cosd(a), 10*sind(a)      FROM generate_series(0, 360, 90) AS t(a)) AS t(x,y);
create type xfloat8;
create function xfloat8in(cstring) returns xfloat8 immutable strict  language internal as 'int8in';
create function xfloat8out(xfloat8) returns cstring immutable strict  language internal as 'int8out';
create type xfloat8 (input = xfloat8in, output = xfloat8out, like = float8);
create cast (xfloat8 as float8) without function;
create cast (float8 as xfloat8) without function;
create cast (xfloat8 as bigint) without function;
create cast (bigint as xfloat8) without function;
with testdata(bits) as (values  -- small subnormals  (x'0000000000000001'),  (x'0000000000000002'), (x'0000000000000003'),  (x'0000000000001000'), (x'0000000100000000'),  (x'0000010000000000'), (x'0000010100000000'),  (x'0000400000000000'), (x'0000400100000000'),  (x'0000800000000000'), (x'0000800000000001'),  -- these values taken from upstream testsuite  (x'00000000000f4240'),  (x'00000000016e3600'),  (x'0000008cdcdea440'),  -- borderline between subnormal and normal  (x'000ffffffffffff0'), (x'000ffffffffffff1'),  (x'000ffffffffffffe'), (x'000fffffffffffff'))select float8send(flt) as ibits,       flt  from (select bits::bigint::xfloat8::float8 as flt          from testdata	offset 0) s;
with testdata(bits) as (values  (x'0000000000000000'),  -- smallest normal values  (x'0010000000000000'), (x'0010000000000001'),  (x'0010000000000002'), (x'0018000000000000'),  --  (x'3ddb7cdfd9d7bdba'), (x'3ddb7cdfd9d7bdbb'), (x'3ddb7cdfd9d7bdbc'),  (x'3e112e0be826d694'), (x'3e112e0be826d695'), (x'3e112e0be826d696'),  (x'3e45798ee2308c39'), (x'3e45798ee2308c3a'), (x'3e45798ee2308c3b'),  (x'3e7ad7f29abcaf47'), (x'3e7ad7f29abcaf48'), (x'3e7ad7f29abcaf49'),  (x'3eb0c6f7a0b5ed8c'), (x'3eb0c6f7a0b5ed8d'), (x'3eb0c6f7a0b5ed8e'),  (x'3ee4f8b588e368ef'), (x'3ee4f8b588e368f0'), (x'3ee4f8b588e368f1'),  (x'3f1a36e2eb1c432c'), (x'3f1a36e2eb1c432d'), (x'3f1a36e2eb1c432e'),  (x'3f50624dd2f1a9fb'), (x'3f50624dd2f1a9fc'), (x'3f50624dd2f1a9fd'),  (x'3f847ae147ae147a'), (x'3f847ae147ae147b'), (x'3f847ae147ae147c'),  (x'3fb9999999999999'), (x'3fb999999999999a'), (x'3fb999999999999b'),  -- values very close to 1  (x'3feffffffffffff0'), (x'3feffffffffffff1'), (x'3feffffffffffff2'),  (x'3feffffffffffff3'), (x'3feffffffffffff4'), (x'3feffffffffffff5'),  (x'3feffffffffffff6'), (x'3feffffffffffff7'), (x'3feffffffffffff8'),  (x'3feffffffffffff9'), (x'3feffffffffffffa'), (x'3feffffffffffffb'),  (x'3feffffffffffffc'), (x'3feffffffffffffd'), (x'3feffffffffffffe'),  (x'3fefffffffffffff'),  (x'3ff0000000000000'),  (x'3ff0000000000001'), (x'3ff0000000000002'), (x'3ff0000000000003'),  (x'3ff0000000000004'), (x'3ff0000000000005'), (x'3ff0000000000006'),  (x'3ff0000000000007'), (x'3ff0000000000008'), (x'3ff0000000000009'),  --  (x'3ff921fb54442d18'),  (x'4005bf0a8b14576a'),  (x'400921fb54442d18'),  --  (x'4023ffffffffffff'), (x'4024000000000000'), (x'4024000000000001'),  (x'4058ffffffffffff'), (x'4059000000000000'), (x'4059000000000001'),  (x'408f3fffffffffff'), (x'408f400000000000'), (x'408f400000000001'),  (x'40c387ffffffffff'), (x'40c3880000000000'), (x'40c3880000000001'),  (x'40f869ffffffffff'), (x'40f86a0000000000'), (x'40f86a0000000001'),  (x'412e847fffffffff'), (x'412e848000000000'), (x'412e848000000001'),  (x'416312cfffffffff'), (x'416312d000000000'), (x'416312d000000001'),  (x'4197d783ffffffff'), (x'4197d78400000000'), (x'4197d78400000001'),  (x'41cdcd64ffffffff'), (x'41cdcd6500000000'), (x'41cdcd6500000001'),  (x'4202a05f1fffffff'), (x'4202a05f20000000'), (x'4202a05f20000001'),  (x'42374876e7ffffff'), (x'42374876e8000000'), (x'42374876e8000001'),  (x'426d1a94a1ffffff'), (x'426d1a94a2000000'), (x'426d1a94a2000001'),  (x'42a2309ce53fffff'), (x'42a2309ce5400000'), (x'42a2309ce5400001'),  (x'42d6bcc41e8fffff'), (x'42d6bcc41e900000'), (x'42d6bcc41e900001'),  (x'430c6bf52633ffff'), (x'430c6bf526340000'), (x'430c6bf526340001'),  (x'4341c37937e07fff'), (x'4341c37937e08000'), (x'4341c37937e08001'),  (x'4376345785d89fff'), (x'4376345785d8a000'), (x'4376345785d8a001'),  (x'43abc16d674ec7ff'), (x'43abc16d674ec800'), (x'43abc16d674ec801'),  (x'43e158e460913cff'), (x'43e158e460913d00'), (x'43e158e460913d01'),  (x'4415af1d78b58c3f'), (x'4415af1d78b58c40'), (x'4415af1d78b58c41'),  (x'444b1ae4d6e2ef4f'), (x'444b1ae4d6e2ef50'), (x'444b1ae4d6e2ef51'),  (x'4480f0cf064dd591'), (x'4480f0cf064dd592'), (x'4480f0cf064dd593'),  (x'44b52d02c7e14af5'), (x'44b52d02c7e14af6'), (x'44b52d02c7e14af7'),  (x'44ea784379d99db3'), (x'44ea784379d99db4'), (x'44ea784379d99db5'),  (x'45208b2a2c280290'), (x'45208b2a2c280291'), (x'45208b2a2c280292'),  --  (x'7feffffffffffffe'), (x'7fefffffffffffff'),  -- round to even tests (+ve)  (x'4350000000000002'),  (x'4350000000002e06'),  (x'4352000000000003'),  (x'4352000000000004'),  (x'4358000000000003'),  (x'4358000000000004'),  (x'435f000000000020'),  -- round to even tests (-ve)  (x'c350000000000002'),  (x'c350000000002e06'),  (x'c352000000000003'),  (x'c352000000000004'),  (x'c358000000000003'),  (x'c358000000000004'),  (x'c35f000000000020'),  -- exercise fixed-point memmoves  (x'42dc12218377de66'),  (x'42a674e79c5fe51f'),  (x'4271f71fb04cb74c'),  (x'423cbe991a145879'),  (x'4206fee0e1a9e061'),  (x'41d26580b487e6b4'),  (x'419d6f34540ca453'),  (x'41678c29dcd6e9dc'),  (x'4132d687e3df217d'),  (x'40fe240c9fcb68c8'),  (x'40c81cd6e63c53d3'),  (x'40934a4584fd0fdc'),  (x'405edd3c07fb4c93'),  (x'4028b0fcd32f7076'),  (x'3ff3c0ca428c59f8'),  -- these cases come from the upstream's testsuite  -- LotsOfTrailingZeros)  (x'3e60000000000000'),  -- Regression  (x'c352bd2668e077c4'),  (x'434018601510c000'),  (x'43d055dc36f24000'),  (x'43e052961c6f8000'),  (x'3ff3c0ca2a5b1d5d'),  -- LooksLikePow5  (x'4830f0cf064dd592'),  (x'4840f0cf064dd592'),  (x'4850f0cf064dd592'),  -- OutputLength  (x'3ff3333333333333'),  (x'3ff3ae147ae147ae'),  (x'3ff3be76c8b43958'),  (x'3ff3c083126e978d'),  (x'3ff3c0c1fc8f3238'),  (x'3ff3c0c9539b8887'),  (x'3ff3c0ca2a5b1d5d'),  (x'3ff3c0ca4283de1b'),  (x'3ff3c0ca43db770a'),  (x'3ff3c0ca428abd53'),  (x'3ff3c0ca428c1d2b'),  (x'3ff3c0ca428c51f2'),  (x'3ff3c0ca428c58fc'),  (x'3ff3c0ca428c59dd'),  (x'3ff3c0ca428c59f8'),  (x'3ff3c0ca428c59fb'),  -- 32-bit chunking  (x'40112e0be8047a7d'),  (x'40112e0be815a889'),  (x'40112e0be826d695'),  (x'40112e0be83804a1'),  (x'40112e0be84932ad'),  -- MinMaxShift  (x'0040000000000000'),  (x'007fffffffffffff'),  (x'0290000000000000'),  (x'029fffffffffffff'),  (x'4350000000000000'),  (x'435fffffffffffff'),  (x'1330000000000000'),  (x'133fffffffffffff'),  (x'3a6fa7161a4d6e0c')select float8send(flt) as ibits,       flt,       flt::text::float8 as r_flt,       float8send(flt::text::float8) as obits,       float8send(flt::text::float8) = float8send(flt) as correct  from (select bits::bigint::xfloat8::float8 as flt          from testdata	offset 0) s;
drop type xfloat8 cascade;
EXPLAIN (costs off)  CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
::SELECT relispopulated FROM pg_class WHERE oid = 'mvtest_tm'::regclass;
REFRESH MATERIALIZED VIEW mvtest_tm;
::SELECT relispopulated FROM pg_class WHERE oid = 'mvtest_tm'::regclass;
EXPLAIN (costs off)  CREATE MATERIALIZED VIEW mvtest_tvm AS SELECT * FROM mvtest_tv ORDER BY type;
CREATE MATERIALIZED VIEW mvtest_tvm AS SELECT * FROM mvtest_tv ORDER BY type;
CREATE MATERIALIZED VIEW mvtest_tmm AS SELECT sum(totamt) AS grandtot FROM mvtest_tm;
CREATE MATERIALIZED VIEW mvtest_tvmm AS SELECT sum(totamt) AS grandtot FROM mvtest_tvm;
EXPLAIN (costs off)  CREATE MATERIALIZED VIEW mvtest_tvvm AS SELECT * FROM mvtest_tvv;
CREATE MATERIALIZED VIEW mvtest_tvvm AS SELECT * FROM mvtest_tvv;
CREATE MATERIALIZED VIEW mvtest_bb AS SELECT * FROM mvtest_tvvmv;
CREATE SCHEMA mvtest_mvschema;
ALTER MATERIALIZED VIEW mvtest_tvm SET SCHEMA mvtest_mvschema;
SET search_path = mvtest_mvschema, public;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tm;
REFRESH MATERIALIZED VIEW mvtest_tvm;
RESET search_path;
EXPLAIN (costs off)  SELECT * FROM mvtest_tmm;
EXPLAIN (costs off)  SELECT * FROM mvtest_tvmm;
EXPLAIN (costs off)  SELECT * FROM mvtest_tvvm;
REFRESH MATERIALIZED VIEW mvtest_tmm;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
REFRESH MATERIALIZED VIEW mvtest_tvmm;
REFRESH MATERIALIZED VIEW mvtest_tvvm;
EXPLAIN (costs off)  SELECT * FROM mvtest_tmm;
EXPLAIN (costs off)  SELECT * FROM mvtest_tvmm;
EXPLAIN (costs off)  SELECT * FROM mvtest_tvvm;
DROP MATERIALIZED VIEW IF EXISTS no_such_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
SELECT * FROM mvtest_tvvm FOR SHARE;
SELECT type, m.totamt AS mtot, v.totamt AS vtot FROM mvtest_tm m LEFT JOIN mvtest_tv v USING (type) ORDER BY type;
BEGIN;
DROP TABLE mvtest_t CASCADE;
ROLLBACK;
CREATE VIEW mvtest_vt2 AS SELECT moo, 2*moo FROM mvtest_vt1 UNION ALL SELECT moo, 3*moo FROM mvtest_vt1;
CREATE MATERIALIZED VIEW mv_test2 AS SELECT moo, 2*moo FROM mvtest_vt2 UNION ALL SELECT moo, 3*moo FROM mvtest_vt2;
CREATE MATERIALIZED VIEW mv_test3 AS SELECT * FROM mv_test2 WHERE moo = 12345;
::SELECT relispopulated FROM pg_class WHERE oid = 'mv_test3'::regclass;
DROP VIEW mvtest_vt1 CASCADE;
CREATE TABLE mvtest_foo(a, b) AS VALUES(1, 10);
CREATE MATERIALIZED VIEW mvtest_mv AS SELECT * FROM mvtest_foo;
CREATE UNIQUE INDEX ON mvtest_mv(a);
REFRESH MATERIALIZED VIEW mvtest_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
DROP TABLE mvtest_foo CASCADE;
CREATE TABLE mvtest_foo(a, b, c) AS VALUES(1, 2, 3);
CREATE MATERIALIZED VIEW mvtest_mv AS SELECT * FROM mvtest_foo;
CREATE UNIQUE INDEX ON mvtest_mv (a);
CREATE UNIQUE INDEX ON mvtest_mv (b);
CREATE UNIQUE INDEX on mvtest_mv (c);
REFRESH MATERIALIZED VIEW mvtest_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
DROP TABLE mvtest_foo CASCADE;
CREATE MATERIALIZED VIEW mvtest_mv1 AS SELECT 1 AS col1 WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_mv2 AS SELECT * FROM mvtest_mv1  WHERE col1 = (SELECT LEAST(col1) FROM mvtest_mv1) WITH NO DATA;
DROP MATERIALIZED VIEW mvtest_mv1 CASCADE;
CREATE TABLE mvtest_boxes (id serial primary key, b box);
CREATE MATERIALIZED VIEW mvtest_boxmv AS SELECT * FROM mvtest_boxes;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_boxmv;
DROP TABLE mvtest_boxes CASCADE;
CREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj, kk) AS SELECT i, j FROM mvtest_v; -- errorCREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj) AS SELECT i, j FROM mvtest_v; -- okCREATE MATERIALIZED VIEW mvtest_mv_v_2 (ii) AS SELECT i, j FROM mvtest_v; -- okCREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj, kk) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- errorCREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- okCREATE MATERIALIZED VIEW mvtest_mv_v_4 (ii) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- okALTER TABLE mvtest_v RENAME COLUMN i TO x;
REFRESH MATERIALIZED VIEW mvtest_mv_v;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_v;
REFRESH MATERIALIZED VIEW mvtest_mv_v_2;
REFRESH MATERIALIZED VIEW mvtest_mv_v_3;
REFRESH MATERIALIZED VIEW mvtest_mv_v_4;
DROP TABLE mvtest_v CASCADE;
CREATE MATERIALIZED VIEW mv_unspecified_types AS  SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
DROP MATERIALIZED VIEW mv_unspecified_types;
create materialized view mvtest_error as select 1/0 as x;  -- failcreate materialized view mvtest_error as select 1/0 as x with no data;
refresh materialized view mvtest_error;  -- fail heredrop materialized view mvtest_error;
CREATE MATERIALIZED VIEW mvtest_mv_v AS SELECT a FROM mvtest_v WHERE a <= 5;
DELETE FROM mvtest_v WHERE EXISTS ( SELECT * FROM mvtest_mv_v WHERE mvtest_mv_v.a = mvtest_v.a );
DROP TABLE mvtest_v CASCADE;
CREATE ROLE regress_user_mvtest;
SET ROLE regress_user_mvtest;
::CREATE TABLE mvtest_foo_data AS SELECT i, md5(random()::text)  FROM generate_series(1, 10) i;
CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
CREATE MATERIALIZED VIEW IF NOT EXISTS mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
CREATE UNIQUE INDEX ON mvtest_mv_foo (i);
RESET ROLE;
REFRESH MATERIALIZED VIEW mvtest_mv_foo;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_foo;
DROP OWNED BY regress_user_mvtest CASCADE;
DROP ROLE regress_user_mvtest;
BEGIN;
CREATE FUNCTION mvtest_func()  RETURNS void AS $$BEGIN  CREATE MATERIALIZED VIEW mvtest1 AS SELECT 1 AS x;
  CREATE MATERIALIZED VIEW mvtest2 AS SELECT 1 AS x WITH NO DATA;
END;
$$ LANGUAGE plpgsql;
ROLLBACK;
CREATE TABLE test_tablesample (id int, name text) WITH (fillfactor=10);
::INSERT INTO test_tablesample  SELECT i, repeat(i::text, 200) FROM generate_series(0, 9) s(i);
SELECT t.id FROM test_tablesample AS t TABLESAMPLE SYSTEM (50) REPEATABLE (0);
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (100.0/11) REPEATABLE (0);
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (50) REPEATABLE (0);
SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (5.5) REPEATABLE (0);
SELECT count(*) FROM test_tablesample TABLESAMPLE SYSTEM (100);
SELECT count(*) FROM test_tablesample TABLESAMPLE SYSTEM (100) REPEATABLE (1+2);
SELECT count(*) FROM test_tablesample TABLESAMPLE SYSTEM (100) REPEATABLE (0.4);
CREATE VIEW test_tablesample_v1 AS  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (10*2) REPEATABLE (2);
CREATE VIEW test_tablesample_v2 AS  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (99);
BEGIN;
DECLARE tablesample_cur CURSOR FOR  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
FETCH FIRST FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH FIRST FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
CLOSE tablesample_cur;
END;
EXPLAIN (COSTS OFF)  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (2);
EXPLAIN (COSTS OFF)  SELECT * FROM test_tablesample_v1;
explain (costs off)  select count(*) from person tablesample bernoulli (100);
select count(*) from person tablesample bernoulli (100);
SELECT count(*) FROM test_tablesample TABLESAMPLE bernoulli (('1'::text < '0'::text)::int);
select * from  (values (0),(100)) v(pct),  lateral (select count(*) from tenk1 tablesample bernoulli (pct)) ss;
select * from  (values (0),(100)) v(pct),  lateral (select count(*) from tenk1 tablesample system (pct)) ss;
explain (costs off)select pct, count(unique1) from  (values (0),(100)) v(pct),  lateral (select * from tenk1 tablesample bernoulli (pct)) ss  group by pct;
select pct, count(unique1) from  (values (0),(100)) v(pct),  lateral (select * from tenk1 tablesample bernoulli (pct)) ss  group by pct;
select pct, count(unique1) from  (values (0),(100)) v(pct),  lateral (select * from tenk1 tablesample system (pct)) ss  group by pct;
SELECT id FROM test_tablesample TABLESAMPLE FOOBAR (1);
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (NULL);
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (NULL);
SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (-1);
SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (200);
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (-1);
SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (200);
SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1);
WITH query_select AS (SELECT * FROM test_tablesample)SELECT * FROM query_select TABLESAMPLE BERNOULLI (5.5) REPEATABLE (1);
SELECT q.* FROM (SELECT * FROM test_tablesample) as q TABLESAMPLE BERNOULLI (5);
create table parted_sample (a int) partition by list (a);
create table parted_sample_1 partition of parted_sample for values in (1);
create table parted_sample_2 partition of parted_sample for values in (2);
explain (costs off)  select * from parted_sample tablesample bernoulli (100);
drop table parted_sample, parted_sample_1, parted_sample_2;
SELECT *FROM pg_depend as d1WHERE refclassid = 0 OR refobjid = 0 OR      deptype NOT IN ('a', 'e', 'i', 'n', 'p') OR      (deptype != 'p' AND (classid = 0 OR objid = 0)) OR      (deptype = 'p' AND (classid != 0 OR objid != 0 OR objsubid != 0));
SELECT *FROM pg_shdepend as d1WHERE refclassid = 0 OR refobjid = 0 OR      deptype NOT IN ('a', 'o', 'p', 'r') OR      (deptype != 'p' AND (classid = 0 OR objid = 0)) OR      (deptype = 'p' AND (dbid != 0 OR classid != 0 OR objid != 0 OR objsubid != 0));
do $$declare relnm text;
  reloid oid;
  shared bool;
  lowoid oid;
  pinned bool;
beginfor relnm, reloid, shared in  select relname, oid, relisshared from pg_class  where EXISTS(      SELECT * FROM pg_attribute      WHERE attrelid = pg_class.oid AND attname = 'oid')    and relkind = 'r' and oid < 16384 order by 1loop  execute 'select min(oid) from ' || relnm into lowoid;
  continue when lowoid is null or lowoid >= 16384;
  if shared then    pinned := exists(select 1 from pg_shdepend                     where refclassid = reloid and refobjid = lowoid                     and deptype = 'p');
  else    pinned := exists(select 1 from pg_depend                     where refclassid = reloid and refobjid = lowoid                     and deptype = 'p');
  end if;
  if not pinned then    raise notice '% contains unpinned initdb-created object(s)', relnm;
  end if;
end loop;
end$$;
::SELECT relname, attname, atttypid::regtypeFROM pg_class c JOIN pg_attribute a ON c.oid = attrelidWHERE c.oid < 16384 AND      reltoastrelid = 0 AND      relkind = 'r' AND      attstorage != 'p'ORDER BY 1, 2;
SELECT * INTO TABLE onek2 FROM onek;
SELECT *   INTO TABLE Bprime   FROM tenk1   WHERE unique2 < 1000;
INSERT INTO hobbies_r (name, person)   SELECT 'posthacking', p.name   FROM person* p   WHERE p.name = 'mike' or p.name = 'jeff';
INSERT INTO hobbies_r (name, person)   SELECT 'basketball', p.name   FROM person p   WHERE p.name = 'joe' or p.name = 'sally';
TABLE city;
SELECT *   INTO TABLE ramp   FROM road   WHERE name ~ '.*Ramp';
~INSERT INTO ihighway   SELECT *   FROM road   WHERE name ~ 'I- .*';
~INSERT INTO shighway   SELECT *   FROM road   WHERE name ~ 'State Hwy.*';
::INSERT INTO b_star (class, a, b) VALUES ('b', 3, 'mumble'::text);
::INSERT INTO b_star (class, b) VALUES ('b', 'bumble'::text);
::::::INSERT INTO d_star (class, a, b, c, d)   VALUES ('d', 7, 'grumble'::text, 'hi sunita'::name, '0.0'::float8);
::INSERT INTO d_star (class, a, b, c)   VALUES ('d', 8, 'stumble'::text, 'hi koko'::name);
::INSERT INTO d_star (class, a, b, d)   VALUES ('d', 9, 'rumble'::text, '1.1'::float8);
::::::INSERT INTO d_star (class, b, c, d)   VALUES ('d', 'crumble'::text, 'hi boris'::name, '100.001'::float8);
::INSERT INTO d_star (class, a, b)   VALUES ('d', 11, 'fumble'::text);
::::::INSERT INTO d_star (class, b, c)   VALUES ('d', 'tumble'::text, 'hi andrew'::name);
::INSERT INTO d_star (class, b, d)   VALUES ('d', 'humble'::text, '10000.00001'::float8);
::::::INSERT INTO d_star (class, b) VALUES ('d', 'jumble'::text);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::ANALYZE a_star;
ANALYZE b_star;
ANALYZE c_star;
ANALYZE d_star;
ANALYZE e_star;
ANALYZE f_star;
CREATE TABLE iportaltest (	i		int4,	d		float4,	p		polygon);
::::SET DateStyle = 'Postgres, MDY';
SELECT timestamp with time zone '20011227 040506+08';
SELECT timestamp with time zone '20011227 040506-08';
SELECT timestamp with time zone '20011227 040506.789+08';
SELECT timestamp with time zone '20011227 040506.789-08';
SELECT timestamp with time zone '20011227T040506+08';
SELECT timestamp with time zone '20011227T040506-08';
SELECT timestamp with time zone '20011227T040506.789+08';
SELECT timestamp with time zone '20011227T040506.789-08';
SELECT timestamp with time zone '2001-12-27 04:05:06.789-08';
SELECT timestamp with time zone '2001.12.27 04:05:06.789-08';
SELECT timestamp with time zone '2001/12/27 04:05:06.789-08';
SELECT timestamp with time zone '12/27/2001 04:05:06.789-08';
SELECT timestamp with time zone '27/12/2001 04:05:06.789-08';
set datestyle to dmy;
SELECT timestamp with time zone '27/12/2001 04:05:06.789-08';
reset datestyle;
SELECT timestamp with time zone 'Y2001M12D27H04M05S06.789+08';
SELECT timestamp with time zone 'Y2001M12D27H04M05S06.789-08';
SELECT timestamp with time zone 'Y2001M12D27H04MM05S06.789+08';
SELECT timestamp with time zone 'Y2001M12D27H04MM05S06.789-08';
SELECT timestamp with time zone 'J2452271+08';
SELECT timestamp with time zone 'J2452271-08';
SELECT timestamp with time zone 'J2452271.5+08';
SELECT timestamp with time zone 'J2452271.5-08';
SELECT timestamp with time zone 'J2452271 04:05:06+08';
SELECT timestamp with time zone 'J2452271 04:05:06-08';
SELECT timestamp with time zone 'J2452271T040506+08';
SELECT timestamp with time zone 'J2452271T040506-08';
SELECT timestamp with time zone 'J2452271T040506.789+08';
SELECT timestamp with time zone 'J2452271T040506.789-08';
SELECT timestamp with time zone '12.27.2001 04:05:06.789+08';
SELECT timestamp with time zone '12.27.2001 04:05:06.789-08';
SET DateStyle = 'German';
SELECT timestamp with time zone '27.12.2001 04:05:06.789+08';
SELECT timestamp with time zone '27.12.2001 04:05:06.789-08';
SET DateStyle = 'ISO';
SELECT time without time zone '040506.789+08';
SELECT time without time zone '040506.789-08';
SELECT time without time zone 'T040506.789+08';
SELECT time without time zone 'T040506.789-08';
SELECT time with time zone '040506.789+08';
SELECT time with time zone '040506.789-08';
SELECT time with time zone 'T040506.789+08';
SELECT time with time zone 'T040506.789-08';
SELECT time with time zone 'T040506.789 +08';
SELECT time with time zone 'T040506.789 -08';
SET DateStyle = 'Postgres, MDY';
SELECT date 'J1520447' AS "Confucius' Birthday";
SELECT date 'J0' AS "Julian Epoch";
SELECT date '1981-02-03' + time '04:05:06' AS "Date + Time";
SELECT date '1991-02-03' + time with time zone '04:05:06 PST' AS "Date + Time PST";
SELECT date '2001-02-03' + time with time zone '04:05:06 UTC' AS "Date + Time UTC";
SELECT date '1991-02-03' + interval '2 years' AS "Add Two Years";
SELECT date '2001-12-13' - interval '2 years' AS "Subtract Two Years";
SELECT date '1991-02-03' - time '04:05:06' AS "Subtract Time";
SELECT date '1991-02-03' - time with time zone '04:05:06 UTC' AS "Subtract Time UTC";
SELECT timestamp without time zone '1996-03-01' - interval '1 second' AS "Feb 29";
SELECT timestamp without time zone '1999-03-01' - interval '1 second' AS "Feb 28";
SELECT timestamp without time zone '2000-03-01' - interval '1 second' AS "Feb 29";
SELECT timestamp without time zone '1999-12-01' + interval '1 month - 1 second' AS "Dec 31";
SELECT timestamp without time zone 'Jan 1, 4713 BC' + interval '106000000 days' AS "Feb 23, 285506";
SELECT timestamp without time zone 'Jan 1, 4713 BC' + interval '107000000 days' AS "Jan 20, 288244";
SELECT timestamp without time zone 'Jan 1, 4713 BC' + interval '109203489 days' AS "Dec 31, 294276";
SELECT timestamp without time zone '12/31/294276' - timestamp without time zone '12/23/1999' AS "106751991 Days";
SELECT (timestamp without time zone 'today' = (timestamp without time zone 'yesterday' + interval '1 day')) as "True";
SELECT (timestamp without time zone 'today' = (timestamp without time zone 'tomorrow' - interval '1 day')) as "True";
SELECT (timestamp without time zone 'today 10:30' = (timestamp without time zone 'yesterday' + interval '1 day 10 hr 30 min')) as "True";
SELECT (timestamp without time zone '10:30 today' = (timestamp without time zone 'yesterday' + interval '1 day 10 hr 30 min')) as "True";
SELECT (timestamp without time zone 'tomorrow' = (timestamp without time zone 'yesterday' + interval '2 days')) as "True";
SELECT (timestamp without time zone 'tomorrow 16:00:00' = (timestamp without time zone 'today' + interval '1 day 16 hours')) as "True";
SELECT (timestamp without time zone '16:00:00 tomorrow' = (timestamp without time zone 'today' + interval '1 day 16 hours')) as "True";
SELECT (timestamp without time zone 'yesterday 12:34:56' = (timestamp without time zone 'tomorrow' - interval '2 days - 12:34:56')) as "True";
SELECT (timestamp without time zone '12:34:56 yesterday' = (timestamp without time zone 'tomorrow' - interval '2 days - 12:34:56')) as "True";
SELECT (timestamp without time zone 'tomorrow' > 'now') as "True";
SELECT date '1994-01-01' + time '11:00' AS "Jan_01_1994_11am";
SELECT date '1994-01-01' + time '10:00' AS "Jan_01_1994_10am";
SELECT date '1994-01-01' + timetz '11:00-5' AS "Jan_01_1994_8am";
SELECT timestamptz(date '1994-01-01', time with time zone '11:00-5') AS "Jan_01_1994_8am";
SELECT '' AS "64", d1 + interval '1 year' AS one_year FROM TIMESTAMP_TBL;
SELECT '' AS "64", d1 - interval '1 year' AS one_year FROM TIMESTAMP_TBL;
SELECT timestamp with time zone '1996-03-01' - interval '1 second' AS "Feb 29";
SELECT timestamp with time zone '1999-03-01' - interval '1 second' AS "Feb 28";
SELECT timestamp with time zone '2000-03-01' - interval '1 second' AS "Feb 29";
SELECT timestamp with time zone '1999-12-01' + interval '1 month - 1 second' AS "Dec 31";
SELECT (timestamp with time zone 'today' = (timestamp with time zone 'yesterday' + interval '1 day')) as "True";
SELECT (timestamp with time zone 'today' = (timestamp with time zone 'tomorrow' - interval '1 day')) as "True";
SELECT (timestamp with time zone 'tomorrow' = (timestamp with time zone 'yesterday' + interval '2 days')) as "True";
SELECT (timestamp with time zone 'tomorrow' > 'now') as "True";
SET TIME ZONE 'CST7CDT';
SELECT timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' as "Apr 3, 12:00";
SELECT timestamp with time zone '2005-04-02 12:00-07' + interval '24 hours' as "Apr 3, 13:00";
SELECT timestamp with time zone '2005-04-03 12:00-06' - interval '1 day' as "Apr 2, 12:00";
SELECT timestamp with time zone '2005-04-03 12:00-06' - interval '24 hours' as "Apr 2, 11:00";
RESET TIME ZONE;
SELECT timestamptz(date '1994-01-01', time '11:00') AS "Jan_01_1994_10am";
SELECT timestamptz(date '1994-01-01', time '10:00') AS "Jan_01_1994_9am";
SELECT timestamptz(date '1994-01-01', time with time zone '11:00-8') AS "Jan_01_1994_11am";
SELECT timestamptz(date '1994-01-01', time with time zone '10:00-8') AS "Jan_01_1994_10am";
SELECT timestamptz(date '1994-01-01', time with time zone '11:00-5') AS "Jan_01_1994_8am";
SELECT '' AS "64", d1 + interval '1 year' AS one_year FROM TIMESTAMPTZ_TBL;
SELECT '' AS "64", d1 - interval '1 year' AS one_year FROM TIMESTAMPTZ_TBL;
SELECT CAST(time '01:02' AS interval) AS "+01:02";
SELECT CAST(interval '02:03' AS time) AS "02:03:00";
SELECT time '01:30' + interval '02:01' AS "03:31:00";
SELECT time '01:30' - interval '02:01' AS "23:29:00";
SELECT time '02:30' + interval '36:01' AS "14:31:00";
SELECT time '03:30' + interval '1 month 04:01' AS "07:31:00";
SELECT CAST(time with time zone '01:02-08' AS interval) AS "+00:01";
SELECT CAST(interval '02:03' AS time with time zone) AS "02:03:00-08";
SELECT time with time zone '01:30-08' - interval '02:01' AS "23:29:00-08";
SELECT time with time zone '02:30-08' + interval '36:01' AS "14:31:00-08";
SELECT CAST(CAST(date 'today' + time with time zone '05:30'            + interval '02:01' AS time with time zone) AS time) AS "07:31:00";
SELECT CAST(cast(date 'today' + time with time zone '03:30'  + interval '1 month 04:01' as timestamp without time zone) AS time) AS "07:31:00";
SELECT t.d1 AS t, i.f1 AS i, t.d1 + i.f1 AS "add", t.d1 - i.f1 AS "subtract"  FROM TIMESTAMP_TBL t, INTERVAL_TBL i  WHERE t.d1 BETWEEN '1990-01-01' AND '2001-01-01'    AND i.f1 BETWEEN '00:00' AND '23:00'  ORDER BY 1,2;
SELECT t.f1 AS t, i.f1 AS i, t.f1 + i.f1 AS "add", t.f1 - i.f1 AS "subtract"  FROM TIME_TBL t, INTERVAL_TBL i  ORDER BY 1,2;
SELECT t.f1 AS t, i.f1 AS i, t.f1 + i.f1 AS "add", t.f1 - i.f1 AS "subtract"  FROM TIMETZ_TBL t, INTERVAL_TBL i  ORDER BY 1,2;
SELECT (timestamp with time zone '2000-11-27', timestamp with time zone '2000-11-28')  OVERLAPS (timestamp with time zone '2000-11-27 12:00', timestamp with time zone '2000-11-30') AS "True";
SELECT (timestamp with time zone '2000-11-26', timestamp with time zone '2000-11-27')  OVERLAPS (timestamp with time zone '2000-11-27 12:00', timestamp with time zone '2000-11-30') AS "False";
SELECT (timestamp with time zone '2000-11-27', timestamp with time zone '2000-11-28')  OVERLAPS (timestamp with time zone '2000-11-27 12:00', interval '1 day') AS "True";
SELECT (timestamp with time zone '2000-11-27', interval '12 hours')  OVERLAPS (timestamp with time zone '2000-11-27 12:00', timestamp with time zone '2000-11-30') AS "False";
SELECT (timestamp with time zone '2000-11-27', interval '12 hours')  OVERLAPS (timestamp with time zone '2000-11-27', interval '12 hours') AS "True";
SELECT (timestamp with time zone '2000-11-27', interval '12 hours')  OVERLAPS (timestamp with time zone '2000-11-27 12:00', interval '12 hours') AS "False";
SELECT (timestamp without time zone '2000-11-27', timestamp without time zone '2000-11-28')  OVERLAPS (timestamp without time zone '2000-11-27 12:00', timestamp without time zone '2000-11-30') AS "True";
SELECT (timestamp without time zone '2000-11-26', timestamp without time zone '2000-11-27')  OVERLAPS (timestamp without time zone '2000-11-27 12:00', timestamp without time zone '2000-11-30') AS "False";
SELECT (timestamp without time zone '2000-11-27', timestamp without time zone '2000-11-28')  OVERLAPS (timestamp without time zone '2000-11-27 12:00', interval '1 day') AS "True";
SELECT (timestamp without time zone '2000-11-27', interval '12 hours')  OVERLAPS (timestamp without time zone '2000-11-27 12:00', timestamp without time zone '2000-11-30') AS "False";
SELECT (timestamp without time zone '2000-11-27', interval '12 hours')  OVERLAPS (timestamp without time zone '2000-11-27', interval '12 hours') AS "True";
SELECT (timestamp without time zone '2000-11-27', interval '12 hours')  OVERLAPS (timestamp without time zone '2000-11-27 12:00', interval '12 hours') AS "False";
SELECT (time '00:00', time '01:00')  OVERLAPS (time '00:30', time '01:30') AS "True";
SELECT (time '00:00', interval '1 hour')  OVERLAPS (time '00:30', interval '1 hour') AS "True";
SELECT (time '00:00', interval '1 hour')  OVERLAPS (time '01:30', interval '1 hour') AS "False";
SELECT (time '00:00', interval '1 hour')  OVERLAPS (time '01:30', interval '1 day') AS "False";
CREATE TABLE TEMP_TIMESTAMP (f1 timestamp with time zone);
INSERT INTO TEMP_TIMESTAMP (f1)  SELECT d1 FROM TIMESTAMP_TBL  WHERE d1 BETWEEN '13-jun-1957' AND '1-jan-1997'   OR d1 BETWEEN '1-jan-1999' AND '1-jan-2010';
SELECT '' AS "160", d.f1 AS "timestamp", t.f1 AS "interval", d.f1 + t.f1 AS plus  FROM TEMP_TIMESTAMP d, INTERVAL_TBL t  ORDER BY plus, "timestamp", "interval";
SELECT '' AS "160", d.f1 AS "timestamp", t.f1 AS "interval", d.f1 - t.f1 AS minus  FROM TEMP_TIMESTAMP d, INTERVAL_TBL t  WHERE isfinite(d.f1)  ORDER BY minus, "timestamp", "interval";
SELECT '' AS "16", d.f1 AS "timestamp",   timestamp with time zone '1980-01-06 00:00 GMT' AS gpstime_zero,   d.f1 - timestamp with time zone '1980-01-06 00:00 GMT' AS difference  FROM TEMP_TIMESTAMP d  ORDER BY difference;
SELECT '' AS "226", d1.f1 AS timestamp1, d2.f1 AS timestamp2, d1.f1 - d2.f1 AS difference  FROM TEMP_TIMESTAMP d1, TEMP_TIMESTAMP d2  ORDER BY timestamp1, timestamp2, difference;
SELECT '' AS "16", f1 AS "timestamp", date(f1) AS date  FROM TEMP_TIMESTAMP  WHERE f1 <> timestamp 'now'  ORDER BY date, "timestamp";
SET DateStyle TO 'US,Postgres';
SHOW DateStyle;
SET DateStyle TO 'US,ISO';
SET DateStyle TO 'US,SQL';
SHOW DateStyle;
SET DateStyle TO 'European,Postgres';
SHOW DateStyle;
SET DateStyle TO 'European,ISO';
SHOW DateStyle;
SET DateStyle TO 'European,SQL';
SHOW DateStyle;
RESET DateStyle;
SELECT to_timestamp('15 "text between quote marks" 98 54 45',                    E'HH24 "\\"text between quote marks\\"" YY MI SS');
||||||||||||||||SELECT to_timestamp('2016-06-13 15:50:55', 'YYYY-MM-DD HH24:MI:SS');  -- okSELECT to_timestamp('2016-06-13 15:50:55', 'YYYY-MM-DD HH:MI:SS');
SELECT to_timestamp('2016-02-29 15:50:55', 'YYYY-MM-DD HH24:MI:SS');  -- okSELECT to_timestamp('2015-02-29 15:50:55', 'YYYY-MM-DD HH24:MI:SS');
SELECT to_timestamp('2015-02-11 86000', 'YYYY-MM-DD SSSS');  -- okSELECT to_timestamp('2015-02-11 86400', 'YYYY-MM-DD SSSS');
SELECT to_timestamp('2015-02-11 86000', 'YYYY-MM-DD SSSSS');  -- okSELECT to_timestamp('2015-02-11 86400', 'YYYY-MM-DD SSSSS');
SELECT to_date('2016-02-29', 'YYYY-MM-DD');  -- okSELECT to_date('2015-02-29', 'YYYY-MM-DD');
SELECT to_date('2015 365', 'YYYY DDD');  -- okSELECT to_date('2015 366', 'YYYY DDD');
SELECT to_date('2016 365', 'YYYY DDD');  -- okSELECT to_date('2016 366', 'YYYY DDD');  -- okSELECT to_date('2016 367', 'YYYY DDD');
SET TIME ZONE 'America/New_York';
SET TIME ZONE '-1.5';
SHOW TIME ZONE;
::::::::::RESET TIME ZONE;
\\cSELECT * FROM temptest;
CREATE TEMP TABLE temptest(col int) ON COMMIT DELETE ROWS;
CREATE INDEX ON temptest(bit_length(''));
BEGIN;
COMMIT;
BEGIN;
CREATE TEMP TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
COMMIT;
BEGIN;
CREATE TEMP TABLE temptest(col int) ON COMMIT DROP;
COMMIT;
BEGIN;
CREATE TEMP TABLE temptest(col) ON COMMIT DROP AS SELECT 1;
COMMIT;
CREATE TABLE temptest(col int) ON COMMIT DELETE ROWS;
CREATE TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
BEGIN;
CREATE TEMP TABLE temptest2(col int REFERENCES temptest1)  ON COMMIT DELETE ROWS;
COMMIT;
BEGIN;
CREATE TEMP TABLE temptest3(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
COMMIT;
create table public.whereami (f1 text);
insert into public.whereami values ('public');
create function public.whoami() returns text  as $$select 'public'::text$$ language sql;
create function pg_temp.whoami() returns text  as $$select 'temp'::text$$ language sql;
set search_path = pg_temp, public;
set search_path = public, pg_temp;
select pg_temp.whoami();
drop table public.whereami;
set search_path = pg_temp, public;
create domain pg_temp.nonempty as text check (value <> '');
select pg_temp.nonempty('');
::reset search_path;
begin;
create temp table temp_parted_oncommit (a int)  partition by list (a) on commit delete rows;
create temp table temp_parted_oncommit_1  partition of temp_parted_oncommit  for values in (1) on commit delete rows;
commit;
begin;
create temp table temp_parted_oncommit_test (a int)  partition by list (a) on commit drop;
create temp table temp_parted_oncommit_test1  partition of temp_parted_oncommit_test  for values in (1) on commit delete rows;
create temp table temp_parted_oncommit_test2  partition of temp_parted_oncommit_test  for values in (2) on commit drop;
commit;
~select relname from pg_class where relname ~ '^temp_parted_oncommit_test';
begin;
create temp table temp_parted_oncommit_test (a int)  partition by list (a) on commit delete rows;
create temp table temp_parted_oncommit_test1  partition of temp_parted_oncommit_test  for values in (1) on commit preserve rows;
create temp table temp_parted_oncommit_test2  partition of temp_parted_oncommit_test  for values in (2) on commit drop;
commit;
~select relname from pg_class where relname ~ '^temp_parted_oncommit_test'  order by relname;
begin;
create temp table temp_inh_oncommit_test (a int) on commit drop;
create temp table temp_inh_oncommit_test1 ()  inherits(temp_inh_oncommit_test) on commit delete rows;
commit;
~select relname from pg_class where relname ~ '^temp_inh_oncommit_test';
begin;
create temp table temp_inh_oncommit_test (a int) on commit delete rows;
create temp table temp_inh_oncommit_test1 ()  inherits(temp_inh_oncommit_test) on commit drop;
commit;
~select relname from pg_class where relname ~ '^temp_inh_oncommit_test';
begin;
create function pg_temp.twophase_func() returns void as  $$ select '2pc_func'::text $$ language sql;
prepare transaction 'twophase_func';
create function pg_temp.twophase_func() returns void as  $$ select '2pc_func'::text $$ language sql;
begin;
drop function pg_temp.twophase_func();
prepare transaction 'twophase_func';
begin;
create operator pg_temp.@@ (leftarg = int4, rightarg = int4, procedure = int4mi);
prepare transaction 'twophase_operator';
begin;
create type pg_temp.twophase_type as (a int);
prepare transaction 'twophase_type';
begin;
create view pg_temp.twophase_view as select 1;
prepare transaction 'twophase_view';
begin;
create sequence pg_temp.twophase_seq;
prepare transaction 'twophase_sequence';
begin;
prepare transaction 'twophase_tab';
begin;
prepare transaction 'twophase_tab';
begin;
lock twophase_tab in access exclusive mode;
prepare transaction 'twophase_tab';
begin;
prepare transaction 'twophase_tab';
\\c -SET search_path TO 'pg_temp';
BEGIN;
~SELECT current_schema() ~ 'pg_temp' AS is_temp_schema;
PREPARE TRANSACTION 'twophase_search';
CREATE TABLE update_test (    a   INT DEFAULT 10,    b   INT,    c   TEXT);
UPDATE update_test SET a = DEFAULT, b = DEFAULT;
UPDATE update_test AS t SET b = 10 WHERE t.a = 10;
UPDATE update_test t SET b = t.b + 10 WHERE t.a = 10;
UPDATE update_test SET a=v.i FROM (VALUES(100, 20)) AS v(i, j)  WHERE update_test.b = v.j;
UPDATE update_test SET a = v.* FROM (VALUES(100, 20)) AS v(i, j)  WHERE update_test.b = v.j;
UPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';
UPDATE update_test o  SET (b,a) = (select a+1,b from update_test i               where i.a=o.a and i.b=o.b and i.c is not distinct from o.c);
UPDATE update_test SET (a,b) = ROW(v.*) FROM (VALUES(21, 100)) AS v(i, j)  WHERE update_test.a = v.i;
UPDATE update_test SET (a,b) = (v.*) FROM (VALUES(21, 101)) AS v(i, j)  WHERE update_test.a = v.i;
UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a = 10;
EXPLAIN (VERBOSE, COSTS OFF)UPDATE update_test t  SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)  WHERE CURRENT_USER = SESSION_USER;
UPDATE update_test t  SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)  WHERE CURRENT_USER = SESSION_USER;
WITH aaa AS (SELECT 1 AS a, 'Foo' AS b) INSERT INTO upsert_test  VALUES (1, 'Bar') ON CONFLICT(a)  DO UPDATE SET (b, a) = (SELECT b, a FROM aaa) RETURNING *;
INSERT INTO upsert_test VALUES (1, 'Baz') ON CONFLICT(a)  DO UPDATE SET (b, a) = (SELECT b || ', Correlated', a from upsert_test i WHERE i.a = upsert_test.a)  RETURNING *;
INSERT INTO upsert_test VALUES (1, 'Bat') ON CONFLICT(a)  DO UPDATE SET (b, a) = (SELECT b || ', Excluded', a from upsert_test i WHERE i.a = excluded.a)  RETURNING *;
CREATE FUNCTION xid_current() RETURNS xid LANGUAGE SQL AS $$SELECT (txid_current() % ((1::int8<<32)))::text::xid;$$;
INSERT INTO upsert_test VALUES (2, 'Beeble') ON CONFLICT(a)  DO UPDATE SET (b, a) = (SELECT b || ', Excluded', a from upsert_test i WHERE i.a = excluded.a)  RETURNING tableoid::regclass, xmin = xid_current() AS xmin_correct, xmax = 0 AS xmax_correct;
INSERT INTO upsert_test VALUES (2, 'Brox') ON CONFLICT(a)  DO UPDATE SET (b, a) = (SELECT b || ', Excluded', a from upsert_test i WHERE i.a = excluded.a)  RETURNING tableoid::regclass, xmin = xid_current() AS xmin_correct, xmax = xid_current() AS xmax_correct;
DROP FUNCTION xid_current();
CREATE TABLE range_parted (	a text,	b bigint,	c numeric,	d int,	e varchar) PARTITION BY RANGE (a, b);
ALTER TABLE range_parted ATTACH PARTITION part_b_20_b_30 FOR VALUES FROM ('b', 20) TO ('b', 30);
CREATE TABLE part_b_10_b_20 (e varchar, c numeric, a text, b bigint, d int) PARTITION BY RANGE (c);
CREATE TABLE part_b_1_b_10 PARTITION OF range_parted FOR VALUES FROM ('b', 1) TO ('b', 10);
ALTER TABLE range_parted ATTACH PARTITION part_b_10_b_20 FOR VALUES FROM ('b', 10) TO ('b', 20);
CREATE TABLE part_a_10_a_20 PARTITION OF range_parted FOR VALUES FROM ('a', 10) TO ('a', 20);
CREATE TABLE part_a_1_a_10 PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('a', 10);
CREATE TABLE part_c_100_200 (e varchar, c numeric, a text, b bigint, d int) PARTITION BY range (abs(d));
ALTER TABLE part_c_100_200 DROP COLUMN e, DROP COLUMN c, DROP COLUMN a;
ALTER TABLE part_c_100_200 ADD COLUMN c numeric, ADD COLUMN e varchar, ADD COLUMN a text;
ALTER TABLE part_c_100_200 DROP COLUMN b;
CREATE TABLE part_d_1_15 PARTITION OF part_c_100_200 FOR VALUES FROM (1) TO (15);
CREATE TABLE part_d_15_20 PARTITION OF part_c_100_200 FOR VALUES FROM (15) TO (20);
ALTER TABLE part_b_10_b_20 ATTACH PARTITION part_c_100_200 FOR VALUES FROM (100) TO (200);
ALTER TABLE part_b_10_b_20 ATTACH PARTITION part_c_1_100 FOR VALUES FROM (1) TO (100);
\\set init_range_parted 'truncate range_parted; insert into range_parted VALUES (''a'', 1, 1, 1), (''a'', 10, 200, 1), (''b'', 12, 96, 1), (''b'', 13, 97, 2), (''b'', 15, 105, 16), (''b'', 17, 105, 19)'\set show_data 'select tableoid::regclass::text COLLATE "C" partname, * from range_parted ORDER BY 1, 2, 3, 4, 5, 6':init_range_parted;
::show_data;
EXPLAIN (costs off) UPDATE range_parted set c = c - 50 WHERE c > 97;
UPDATE part_b_10_b_20 set c = c + 20 returning c, b, a;
::show_data;
UPDATE part_b_10_b_20 set b = b - 6 WHERE c > 116 returning *;
UPDATE range_parted set b = b - 6 WHERE c > 116 returning a, b + c;
::show_data;
::show_data;
::init_range_parted;
UPDATE range_parted set c = 95 WHERE a = 'b' and b > 10 and c > 100 returning (range_parted), *;
::show_data;
::init_range_parted;
CREATE FUNCTION trans_updatetrigfunc() RETURNS trigger LANGUAGE plpgsql AS$$  begin    raise notice 'trigger = %, old table = %, new table = %',                 TG_NAME,                 (select string_agg(old_table::text, ', ' ORDER BY a) FROM old_table),                 (select string_agg(new_table::text, ', ' ORDER BY a) FROM new_table);
    return null;
  end;
$$;
CREATE TRIGGER trans_updatetrig  AFTER UPDATE ON range_parted REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table  FOR EACH STATEMENT EXECUTE PROCEDURE trans_updatetrigfunc();
UPDATE range_parted set c = (case when c = 96 then 110 else c + 1 end ) WHERE a = 'b' and b > 10 and c >= 96;
::show_data;
::init_range_parted;
CREATE TRIGGER trans_deletetrig  AFTER DELETE ON range_parted REFERENCING OLD TABLE AS old_table  FOR EACH STATEMENT EXECUTE PROCEDURE trans_updatetrigfunc();
CREATE TRIGGER trans_inserttrig  AFTER INSERT ON range_parted REFERENCING NEW TABLE AS new_table  FOR EACH STATEMENT EXECUTE PROCEDURE trans_updatetrigfunc();
UPDATE range_parted set c = c + 50 WHERE a = 'b' and b > 10 and c >= 96;
::show_data;
DROP TRIGGER trans_deletetrig ON range_parted;
DROP TRIGGER trans_inserttrig ON range_parted;
CREATE FUNCTION func_parted_mod_b() RETURNS trigger AS $$BEGIN   NEW.b = NEW.b + 1;
   return NEW;
END $$ language plpgsql;
CREATE TRIGGER trig_c1_100 BEFORE UPDATE OR INSERT ON part_c_1_100   FOR EACH ROW EXECUTE PROCEDURE func_parted_mod_b();
CREATE TRIGGER trig_d1_15 BEFORE UPDATE OR INSERT ON part_d_1_15   FOR EACH ROW EXECUTE PROCEDURE func_parted_mod_b();
CREATE TRIGGER trig_d15_20 BEFORE UPDATE OR INSERT ON part_d_15_20   FOR EACH ROW EXECUTE PROCEDURE func_parted_mod_b();
::init_range_parted;
UPDATE range_parted set c = (case when c = 96 then 110 else c + 1 end) WHERE a = 'b' and b > 10 and c >= 96;
::show_data;
::init_range_parted;
UPDATE range_parted set c = c + 50 WHERE a = 'b' and b > 10 and c >= 96;
::show_data;
::init_range_parted;
::show_data;
DROP TRIGGER trans_updatetrig ON range_parted;
DROP TRIGGER trig_c1_100 ON part_c_1_100;
DROP TRIGGER trig_d1_15 ON part_d_1_15;
DROP TRIGGER trig_d15_20 ON part_d_15_20;
DROP FUNCTION func_parted_mod_b();
ALTER TABLE range_parted ENABLE ROW LEVEL SECURITY;
CREATE USER regress_range_parted_user;
GRANT ALL ON range_parted, mintab TO regress_range_parted_user;
CREATE POLICY seeall ON range_parted AS PERMISSIVE FOR SELECT USING (true);
CREATE POLICY policy_range_parted ON range_parted for UPDATE USING (true) WITH CHECK (c % 2 = 0);
::init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
RESET SESSION AUTHORIZATION;
CREATE FUNCTION func_d_1_15() RETURNS trigger AS $$BEGIN   NEW.c = NEW.c + 1; -- Make even numbers odd, or vice versa   return NEW;
END $$ LANGUAGE plpgsql;
::init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
RESET SESSION AUTHORIZATION;
::init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
RESET SESSION AUTHORIZATION;
DROP TRIGGER trig_d_1_15 ON part_d_1_15;
DROP FUNCTION func_d_1_15();
RESET SESSION AUTHORIZATION;
::init_range_parted;
CREATE POLICY policy_range_parted_subplan on range_parted    AS RESTRICTIVE for UPDATE USING (true)    WITH CHECK ((SELECT range_parted.c <= c1 FROM mintab));
SET SESSION AUTHORIZATION regress_range_parted_user;
RESET SESSION AUTHORIZATION;
::init_range_parted;
CREATE POLICY policy_range_parted_wholerow on range_parted AS RESTRICTIVE for UPDATE USING (true)   WITH CHECK (range_parted = row('b', 10, 112, 1, NULL)::range_parted);
SET SESSION AUTHORIZATION regress_range_parted_user;
RESET SESSION AUTHORIZATION;
::init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
RESET SESSION AUTHORIZATION;
DROP POLICY policy_range_parted ON range_parted;
DROP POLICY policy_range_parted_subplan ON range_parted;
DROP POLICY policy_range_parted_wholerow ON range_parted;
REVOKE ALL ON range_parted, mintab FROM regress_range_parted_user;
DROP USER regress_range_parted_user;
::init_range_parted;
CREATE FUNCTION trigfunc() returns trigger language plpgsql as$$  begin    raise notice 'trigger = % fired on table % during %',                 TG_NAME, TG_TABLE_NAME, TG_OP;
    return null;
  end;
$$;
CREATE TRIGGER parent_delete_trig  AFTER DELETE ON range_parted for each statement execute procedure trigfunc();
CREATE TRIGGER parent_update_trig  AFTER UPDATE ON range_parted for each statement execute procedure trigfunc();
CREATE TRIGGER parent_insert_trig  AFTER INSERT ON range_parted for each statement execute procedure trigfunc();
CREATE TRIGGER c1_delete_trig  AFTER DELETE ON part_c_1_100 for each statement execute procedure trigfunc();
CREATE TRIGGER c1_update_trig  AFTER UPDATE ON part_c_1_100 for each statement execute procedure trigfunc();
CREATE TRIGGER c1_insert_trig  AFTER INSERT ON part_c_1_100 for each statement execute procedure trigfunc();
CREATE TRIGGER d1_delete_trig  AFTER DELETE ON part_d_1_15 for each statement execute procedure trigfunc();
CREATE TRIGGER d1_update_trig  AFTER UPDATE ON part_d_1_15 for each statement execute procedure trigfunc();
CREATE TRIGGER d1_insert_trig  AFTER INSERT ON part_d_1_15 for each statement execute procedure trigfunc();
CREATE TRIGGER d15_delete_trig  AFTER DELETE ON part_d_15_20 for each statement execute procedure trigfunc();
CREATE TRIGGER d15_update_trig  AFTER UPDATE ON part_d_15_20 for each statement execute procedure trigfunc();
CREATE TRIGGER d15_insert_trig  AFTER INSERT ON part_d_15_20 for each statement execute procedure trigfunc();
::show_data;
DROP TRIGGER parent_delete_trig ON range_parted;
DROP TRIGGER parent_update_trig ON range_parted;
DROP TRIGGER parent_insert_trig ON range_parted;
DROP TRIGGER c1_delete_trig ON part_c_1_100;
DROP TRIGGER c1_update_trig ON part_c_1_100;
DROP TRIGGER c1_insert_trig ON part_c_1_100;
DROP TRIGGER d1_delete_trig ON part_d_1_15;
DROP TRIGGER d1_update_trig ON part_d_1_15;
DROP TRIGGER d1_insert_trig ON part_d_1_15;
DROP TRIGGER d15_delete_trig ON part_d_15_20;
DROP TRIGGER d15_update_trig ON part_d_15_20;
DROP TRIGGER d15_insert_trig ON part_d_15_20;
::init_range_parted;
create table part_def partition of range_parted default;
::show_data;
::show_data;
::show_data;
CREATE TABLE list_parted (	a text,	b int) PARTITION BY list (a);
CREATE TABLE list_part1  PARTITION OF list_parted for VALUES in ('a', 'b');
CREATE TABLE list_default PARTITION OF list_parted default;
CREATE TABLE list_parted (a numeric, b int, c int8) PARTITION BY list (a);
CREATE TABLE sub_parted PARTITION OF list_parted for VALUES in (1) PARTITION BY list (b);
CREATE TABLE sub_part1(b int, c int8, a numeric);
ALTER TABLE sub_parted ATTACH PARTITION sub_part1 for VALUES in (1);
CREATE TABLE sub_part2(b int, c int8, a numeric);
ALTER TABLE sub_parted ATTACH PARTITION sub_part2 for VALUES in (2);
CREATE TABLE list_part1(a numeric, b int, c int8);
ALTER TABLE list_parted ATTACH PARTITION list_part1 for VALUES in (2,3);
::::SELECT tableoid::regclass::text, * FROM list_parted WHERE a = 2 ORDER BY 1;
::::SELECT tableoid::regclass::text, * FROM list_parted WHERE a = 2 ORDER BY 1;
CREATE FUNCTION func_parted_mod_b() returns trigger as $$BEGIN   NEW.b = 2; -- This is changing partition key column.   return NEW;
END $$ LANGUAGE plpgsql;
::::SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
::::SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
DROP TRIGGER parted_mod_b ON sub_part1;
CREATE OR REPLACE FUNCTION func_parted_mod_b() returns trigger as $$BEGIN   raise notice 'Trigger: Got OLD row %, but returning NULL', OLD;
   return NULL;
END $$ LANGUAGE plpgsql;
::::SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
DROP TRIGGER trig_skip_delete ON sub_part2;
::::SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
DROP FUNCTION func_parted_mod_b();
UPDATE list_parted t1 set a = 2 FROM non_parted t2 WHERE t1.a = t2.id and a = 1;
::::SELECT tableoid::regclass::text, * FROM list_parted ORDER BY 1, 2, 3, 4;
create or replace function dummy_hashint4(a int4, seed int8) returns int8 as$$ begin return (a + seed); end; $$ language 'plpgsql' immutable;
create operator class custom_opclass for type int4 using hash asoperator 1 = , function 2 dummy_hashint4(int4, int8);
create table hash_parted (	a int,	b int) partition by hash (a custom_opclass, b custom_opclass);
create table hpart1 partition of hash_parted for values with (modulus 2, remainder 1);
create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
create table hpart3 partition of hash_parted for values with (modulus 8, remainder 0);
create table hpart4 partition of hash_parted for values with (modulus 8, remainder 4);
drop operator class custom_opclass using hash;
drop function dummy_hashint4(a int4, seed int8);
create table insertconflicttest(key int4, fruit text);
create unique index op_index_key on insertconflicttest(key, fruit text_pattern_ops);
create unique index collation_index_key on insertconflicttest(key, fruit collate "C");
create unique index both_index_key on insertconflicttest(key, fruit collate "C" text_pattern_ops);
create unique index both_index_expr_key on insertconflicttest(key, lower(fruit) collate "C" text_pattern_ops);
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit, key) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit), key, lower(fruit), key) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do update set fruit = excluded.fruit  where exists (select 1 from insertconflicttest ii where ii.key = excluded.key);
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit text_pattern_ops) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit collate "C") do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit collate "C" text_pattern_ops, key) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", key, key) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit text_pattern_ops, key) do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C" text_pattern_ops, key, key) do nothing;
create unique index cross_match on insertconflicttest(lower(fruit) collate "C", upper(fruit) text_pattern_ops);
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", upper(fruit) text_pattern_ops) do nothing;
create unique index key_index on insertconflicttest(key);
explain (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit;
explain (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Cawesh';
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do update set fruit = excluded.fruit where excluded.fruit != 'Elderberry';
explain (costs off, format json) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Lime' returning *;
insert into insertconflicttest values (1, 'Apple') on conflict do update set fruit = excluded.fruit;
insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (2, 'Orange') on conflict (key, key, key) do update set fruit = excluded.fruit;
insert into insertconflicttestvalues (1, 'Apple'), (2, 'Orange')on conflict (key) do update set (fruit, key) = (excluded.fruit, excluded.key);
insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit RETURNING excluded.fruit;
insert into insertconflicttest values (1, 'Apple') on conflict (keyy) do update set fruit = excluded.fruit;
insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruitt;
insert into insertconflicttest values (3, 'Kiwi') on conflict (key, fruit) do update set fruit = excluded.fruit;
insert into insertconflicttest values (4, 'Mango') on conflict (fruit, key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (5, 'Lemon') on conflict (fruit) do update set fruit = excluded.fruit;
insert into insertconflicttest values (6, 'Passionfruit') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = excluded.fruit; -- ok, no reference to target tableinsert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = ict.fruit; -- ok, aliasinsert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = insertconflicttest.fruit; -- error, references aliased away namedrop index key_index;
create unique index comp_key_index on insertconflicttest(key, fruit);
insert into insertconflicttest values (7, 'Raspberry') on conflict (key, fruit) do update set fruit = excluded.fruit;
insert into insertconflicttest values (8, 'Lime') on conflict (fruit, key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (9, 'Banana') on conflict (key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (10, 'Blueberry') on conflict (key, key, key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (11, 'Cherry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (12, 'Date') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
create unique index part_comp_key_index on insertconflicttest(key, fruit) where key < 5;
create unique index expr_part_comp_key_index on insertconflicttest(key, lower(fruit)) where key < 5;
insert into insertconflicttest values (13, 'Grape') on conflict (key, fruit) do update set fruit = excluded.fruit;
insert into insertconflicttest values (14, 'Raisin') on conflict (fruit, key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (15, 'Cranberry') on conflict (key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (16, 'Melon') on conflict (key, key, key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (17, 'Mulberry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (18, 'Pineapple') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (20, 'Quince') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (21, 'Pomegranate') on conflict (lower(fruit), lower(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (22, 'Apricot') on conflict (upper(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) do update set fruit = excluded.fruit;
create unique index expr_comp_key_index on insertconflicttest(key, lower(fruit));
create unique index tricky_expr_comp_key_index on insertconflicttest(key, lower(fruit), upper(fruit));
insert into insertconflicttest values (24, 'Plum') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (25, 'Peach') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
explain (costs off) insert into insertconflicttest values (26, 'Fig') on conflict (lower(fruit), key, lower(fruit), key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (27, 'Prune') on conflict (key, upper(fruit)) do update set fruit = excluded.fruit;
insert into insertconflicttest values (28, 'Redcurrant') on conflict (fruit, key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (29, 'Nectarine') on conflict (key) do update set fruit = excluded.fruit;
create unique index key_index on insertconflicttest(key);
insert into insertconflicttest values (26, 'Fig') on conflict (key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (26, 'Peach') on conflict (key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (25, 'Fig') on conflict (fruit) do update set fruit = excluded.fruit;
create unique index partial_key_index on insertconflicttest(key) where fruit like '%berry';
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' do update set fruit = excluded.fruit;
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' and fruit = 'inconsequential' do nothing;
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) do update set fruit = excluded.fruit;
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' or fruit = 'consequential' do nothing;
insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) where fruit like '%berry' do update set fruit = excluded.fruit;
create unique index plain on insertconflicttest(key);
insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit  where i.* != excluded.* returning *;
insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit  where i.* != excluded.* returning *;
insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit  where i.* = excluded.* returning *;
insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text  returning *;
explain (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.fruit where excluded.* is null;
explain (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text;
create table syscolconflicttest(key int4, data text);
insert into syscolconflicttest values (1) on conflict (key) do update set data = excluded.ctid::text;
insert into insertconflict values (1, 2)on conflict (coalesce(a, 0)) do nothing;
insert into insertconflictv values (1,'foo')  on conflict (f1) do update set f2 = excluded.f2;
insert into insertconflictv values (1,'bar')  on conflict (f1) do update set f2 = excluded.f2;
create table cities (	name		text,	population	float8,	altitude	int		-- (in ft));
create table capitals (	state		char(2)) inherits (cities);
insert into cities values ('San Francisco', 7.24E+5, 63);
insert into cities values ('Las Vegas', 2.583E+5, 2174);
insert into capitals values ('Sacramento', 3.694E+5, 30, 'CA');
insert into capitals values ('Madison', 1.913E+5, 845, 'WI');
insert into cities values ('Las Vegas', 2.583E+5, 2174) on conflict do nothing;
insert into capitals values ('Sacramento', 4664.E+5, 30, 'CA') on conflict (name) do update set population = excluded.population;
insert into capitals values ('Sacramento', 50, 2267, 'NE') on conflict (name) do nothing;
insert into cities values ('Las Vegas', 5.83E+5, 2001) on conflict (name) do update set population = excluded.population, altitude = excluded.altitude;
::insert into capitals values ('Las Vegas', 5.83E+5, 2222, 'NV') on conflict (name) do update set population = excluded.population;
::insert into cities values ('Las Vegas', 5.86E+5, 2223) on conflict (name) do update set population = excluded.population, altitude = excluded.altitude;
::create table excluded(key int primary key, data text);
insert into excluded values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
insert into excluded AS target values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
insert into excluded AS target values(1, '2') on conflict (key) do update set data = target.data RETURNING *;
insert into excluded values(1, '2') on conflict (key) do update set data = 3 RETURNING excluded.*;
create table dropcol(key int primary key, drop1 int, keep1 text, drop2 numeric, keep2 float);
insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 1, '1', '1', 1);
insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 2, '2', '2', 2) on conflict(key)    do update set drop1 = excluded.drop1, keep1 = excluded.keep1, drop2 = excluded.drop2, keep2 = excluded.keep2    where excluded.drop1 is not null and excluded.keep1 is not null and excluded.drop2 is not null and excluded.keep2 is not null          and dropcol.drop1 is not null and dropcol.keep1 is not null and dropcol.drop2 is not null and dropcol.keep2 is not null    returning *;
insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 3, '3', '3', 3) on conflict(key)    do update set drop1 = dropcol.drop1, keep1 = dropcol.keep1, drop2 = dropcol.drop2, keep2 = dropcol.keep2    returning *;
alter table dropcol drop column drop1, drop column drop2;
insert into dropcol(key, keep1, keep2) values(1, '4', 4) on conflict(key)    do update set keep1 = excluded.keep1, keep2 = excluded.keep2    where excluded.keep1 is not null and excluded.keep2 is not null          and dropcol.keep1 is not null and dropcol.keep2 is not null    returning *;
insert into dropcol(key, keep1, keep2) values(1, '5', 5) on conflict(key)    do update set keep1 = dropcol.keep1, keep2 = dropcol.keep2    returning *;
create table twoconstraints (f1 int unique, f2 box,                             exclude using gist(f2 with &&));
insert into twoconstraints values(1, '((2,2),(3,3))');  -- fail on f1insert into twoconstraints values(2, '((0,0),(1,2))');  -- fail on f2insert into twoconstraints values(2, '((0,0),(1,2))')  on conflict on constraint twoconstraints_f1_key do nothing;  -- fail on f2insert into twoconstraints values(2, '((0,0),(1,2))')  on conflict on constraint twoconstraints_f2_excl do nothing;  -- do nothingselect * from twoconstraints;
begin transaction isolation level read committed;
commit;
begin transaction isolation level repeatable read;
commit;
begin transaction isolation level serializable;
commit;
begin transaction isolation level read committed;
insert into selfconflict values (4,1), (4,2) on conflict(f1) do update set f2 = 0;
commit;
begin transaction isolation level repeatable read;
insert into selfconflict values (5,1), (5,2) on conflict(f1) do update set f2 = 0;
commit;
begin transaction isolation level serializable;
insert into selfconflict values (6,1), (6,2) on conflict(f1) do update set f2 = 0;
commit;
create table parted_conflict_test (a int unique, b char) partition by list (a);
create table parted_conflict_test_1 partition of parted_conflict_test (b unique) for values in (1, 2);
insert into parted_conflict_test values (1, 'a') on conflict (a) do nothing;
insert into parted_conflict_test values (1, 'a') on conflict (a) do update set b = excluded.b;
insert into parted_conflict_test_1 values (1, 'a') on conflict (a) do nothing;
insert into parted_conflict_test_1 values (1, 'b') on conflict (a) do update set b = excluded.b;
insert into parted_conflict_test values (2, 'b') on conflict (b) do update set a = excluded.a;
insert into parted_conflict_test_1 values (2, 'b') on conflict (b) do update set a = excluded.a;
alter table parted_conflict_test attach partition parted_conflict_test_2 for values in (3);
truncate parted_conflict_test;
insert into parted_conflict_test values (3, 'a') on conflict (a) do update set b = excluded.b;
insert into parted_conflict_test values (3, 'b') on conflict (a) do update set b = excluded.b;
alter table parted_conflict_test drop b, add b char;
create table parted_conflict_test_3 partition of parted_conflict_test for values in (4);
truncate parted_conflict_test;
insert into parted_conflict_test (a, b) values (4, 'a') on conflict (a) do update set b = excluded.b;
insert into parted_conflict_test (a, b) values (4, 'b') on conflict (a) do update set b = excluded.b where parted_conflict_test.b = 'a';
create table parted_conflict_test_4 partition of parted_conflict_test for values in (5) partition by list (a);
create table parted_conflict_test_4_1 partition of parted_conflict_test_4 for values in (5);
truncate parted_conflict_test;
insert into parted_conflict_test (a, b) values (5, 'a') on conflict (a) do update set b = excluded.b;
insert into parted_conflict_test (a, b) values (5, 'b') on conflict (a) do update set b = excluded.b where parted_conflict_test.b = 'a';
truncate parted_conflict_test;
insert into parted_conflict_test (a, b) values (1, 'a'), (2, 'a'), (4, 'a') on conflict (a) do update set b = excluded.b where excluded.b = 'b';
insert into parted_conflict_test (a, b) values (1, 'b'), (2, 'c'), (4, 'b') on conflict (a) do update set b = excluded.b where excluded.b = 'b';
create table parted_conflict (a int primary key, b text) partition by range (a);
create table parted_conflict_1 partition of parted_conflict for values from (0) to (1000) partition by range (a);
create table parted_conflict_1_1 partition of parted_conflict_1 for values from (0) to (500);
insert into parted_conflict_1 values (40, 'cuarenta')  on conflict (a) do update set b = excluded.b;
create table parted_conflict (a int, b text) partition by range (a);
create table parted_conflict_1 partition of parted_conflict for values from (0) to (1000) partition by range (a);
create table parted_conflict_1_1 partition of parted_conflict_1 for values from (0) to (500);
create unique index on only parted_conflict_1 (a);
create unique index on only parted_conflict (a);
alter index parted_conflict_a_idx attach partition parted_conflict_1_a_idx;
insert into parted_conflict_1 values (40, 'cuarenta')  on conflict (a) do update set b = excluded.b;
create table parted_conflict (a int, b text, c int) partition by range (a);
alter table parted_conflict_1 drop column drp;
create unique index on parted_conflict (a, b);
alter table parted_conflict attach partition parted_conflict_1 for values from (0) to (1000);
truncate parted_conflict;
insert into parted_conflict values (50, 'cincuenta', 2)  on conflict (a, b) do update set (a, b, c) = row(excluded.*)  where parted_conflict = (50, text 'cincuenta', 1) and        excluded = (50, text 'cincuenta', 2);
create or replace function parted_conflict_update_func() returns trigger as $$declare    r record;
begin for r in select * from inserted loop	raise notice 'a = %, b = %, c = %', r.a, r.b, r.c;
 end loop;
 return new;
end;
$$ language plpgsql;
create trigger parted_conflict_update    after update on parted_conflict    referencing new table as inserted    for each statement    execute procedure parted_conflict_update_func();
truncate parted_conflict;
insert into parted_conflict values(0, 'cero', 1)  on conflict (a,b) do update set c = parted_conflict.c + 1;
drop function parted_conflict_update_func();
CREATE OPERATOR ## (   leftarg = path,   rightarg = path,   function = path_inter,   commutator = ##);
CREATE OPERATOR <% (   leftarg = point,   rightarg = widget,   procedure = pt_in_widget,   commutator = >% ,   negator = >=%);
CREATE OPERATOR @#@ (   rightarg = int8,		-- left unary   procedure = numeric_fac);
CREATE OPERATOR #@# (   leftarg = int8,		-- right unary   procedure = numeric_fac);
CREATE OPERATOR #%# (   leftarg = int8,		-- right unary   procedure = numeric_fac);
SELECT point '(1,2)' <% widget '(0,0,3)' AS t,       point '(1,2)' <% widget '(0,0,1)' AS f;
COMMENT ON OPERATOR ###### (int4, NONE) IS 'bad right unary';
CREATE OPERATOR => (   leftarg = int8,		-- right unary   procedure = numeric_fac);
CREATE OPERATOR !=- (   leftarg = int8,		-- right unary   procedure = numeric_fac);
SELECT 2 !=-;
SELECT 2 !=/**/ 1, 2 !=/**/ 2;
SELECT 2 !=-- comment to be removed by psql  1;
DO $$ -- use DO to protect -- from psql  declare r boolean;
  begin    execute $e$ select 2 !=-- comment      1 $e$ into r;
    raise info 'r = %', r;
  end;
$$;
SELECT true<>-1 BETWEEN 1 AND 1;  -- BETWEEN has prec. above <> but below OpSELECT false<>/**/1 BETWEEN 1 AND 1;
SELECT 2<=/**/3, 3>=/**/2, 2<>/**/3;
SELECT 3<=/**/2, 2>=/**/3, 2<>/**/2;
BEGIN TRANSACTION;
CREATE ROLE regress_rol_op1;
CREATE SCHEMA schema_op1;
GRANT USAGE ON SCHEMA schema_op1 TO PUBLIC;
REVOKE USAGE ON SCHEMA schema_op1 FROM regress_rol_op1;
SET ROLE regress_rol_op1;
CREATE OPERATOR schema_op1.#*# (   leftarg = int8,		-- right unary   procedure = numeric_fac);
ROLLBACK;
BEGIN TRANSACTION;
CREATE OPERATOR #*# (   leftarg = SETOF int8,   procedure = numeric_fac);
ROLLBACK;
BEGIN TRANSACTION;
CREATE OPERATOR #*# (   rightarg = SETOF int8,   procedure = numeric_fac);
ROLLBACK;
BEGIN TRANSACTION;
CREATE OR REPLACE FUNCTION fn_op2(boolean, boolean)RETURNS boolean AS $$    SELECT NULL::BOOLEAN;
$$ LANGUAGE sql IMMUTABLE;
CREATE OPERATOR === (    LEFTARG = boolean,    RIGHTARG = boolean,    PROCEDURE = fn_op2,    COMMUTATOR = ===,    NEGATOR = !==,    RESTRICT = contsel,    JOIN = contjoinsel,    SORT1, SORT2, LTCMP, GTCMP, HASHES, MERGES);
ROLLBACK;
CREATE OPERATOR #@%# (   leftarg = int8,		-- right unary   procedure = numeric_fac,   invalid_att = int8);
CREATE OPERATOR #@%# (   procedure = numeric_fac);
CREATE OPERATOR #@%# (   leftarg = int8);
BEGIN TRANSACTION;
CREATE ROLE regress_rol_op3;
CREATE TYPE type_op3 AS ENUM ('new', 'open', 'closed');
CREATE FUNCTION fn_op3(type_op3, int8)RETURNS int8 AS $$    SELECT NULL::int8;
$$ LANGUAGE sql IMMUTABLE;
REVOKE USAGE ON TYPE type_op3 FROM regress_rol_op3;
REVOKE USAGE ON TYPE type_op3 FROM PUBLIC;  -- Need to do this so that regress_rol_op3 is not allowed USAGE via PUBLICSET ROLE regress_rol_op3;
CREATE OPERATOR #*# (   leftarg = type_op3,   rightarg = int8,   procedure = fn_op3);
ROLLBACK;
BEGIN TRANSACTION;
CREATE ROLE regress_rol_op4;
CREATE TYPE type_op4 AS ENUM ('new', 'open', 'closed');
CREATE FUNCTION fn_op4(int8, type_op4)RETURNS int8 AS $$    SELECT NULL::int8;
$$ LANGUAGE sql IMMUTABLE;
REVOKE USAGE ON TYPE type_op4 FROM regress_rol_op4;
REVOKE USAGE ON TYPE type_op4 FROM PUBLIC;  -- Need to do this so that regress_rol_op3 is not allowed USAGE via PUBLICSET ROLE regress_rol_op4;
CREATE OPERATOR #*# (   leftarg = int8,   rightarg = type_op4,   procedure = fn_op4);
ROLLBACK;
BEGIN TRANSACTION;
CREATE ROLE regress_rol_op5;
CREATE TYPE type_op5 AS ENUM ('new', 'open', 'closed');
CREATE FUNCTION fn_op5(int8, int8)RETURNS int8 AS $$    SELECT NULL::int8;
$$ LANGUAGE sql IMMUTABLE;
REVOKE EXECUTE ON FUNCTION fn_op5(int8, int8) FROM regress_rol_op5;
REVOKE EXECUTE ON FUNCTION fn_op5(int8, int8) FROM PUBLIC;-- Need to do this so that regress_rol_op3 is not allowed EXECUTE via PUBLICSET ROLE regress_rol_op5;
CREATE OPERATOR #*# (   leftarg = int8,   rightarg = int8,   procedure = fn_op5);
ROLLBACK;
BEGIN TRANSACTION;
CREATE ROLE regress_rol_op6;
CREATE TYPE type_op6 AS ENUM ('new', 'open', 'closed');
CREATE FUNCTION fn_op6(int8, int8)RETURNS type_op6 AS $$    SELECT NULL::type_op6;
$$ LANGUAGE sql IMMUTABLE;
REVOKE USAGE ON TYPE type_op6 FROM regress_rol_op6;
REVOKE USAGE ON TYPE type_op6 FROM PUBLIC;  -- Need to do this so that regress_rol_op3 is not allowed USAGE via PUBLICSET ROLE regress_rol_op6;
CREATE OPERATOR #*# (   leftarg = int8,   rightarg = int8,   procedure = fn_op6);
ROLLBACK;
CREATE OPERATOR ===	"Leftarg" = box,	"Rightarg" = box,	"Procedure" = area_equal_function,	"Commutator" = ===,	"Negator" = !==,	"Restrict" = area_restriction_function,	"Join" = area_join_function,	"Hashes",	"Merges");
CREATE SCHEMA test_ns_schema_1       CREATE UNIQUE INDEX abc_a_idx ON abc (a)       CREATE VIEW abc_view AS              SELECT a+1 AS a, b+1 AS b FROM abc       CREATE TABLE abc (              a serial,              b int UNIQUE       );
INSERT INTO test_ns_schema_1.abc DEFAULT VALUES;
INSERT INTO test_ns_schema_1.abc DEFAULT VALUES;
INSERT INTO test_ns_schema_1.abc DEFAULT VALUES;
SELECT * FROM test_ns_schema_1.abc;
SELECT * FROM test_ns_schema_1.abc_view;
ALTER SCHEMA test_ns_schema_1 RENAME TO test_ns_schema_renamed;
CREATE SCHEMA test_ns_schema_renamed; -- fail, already existsCREATE SCHEMA IF NOT EXISTS test_ns_schema_renamed; -- ok with noticeCREATE SCHEMA IF NOT EXISTS test_ns_schema_renamed -- fail, disallowed       CREATE TABLE abc (              a serial,              b int UNIQUE       );
DROP SCHEMA test_ns_schema_renamed CASCADE;
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_alter_table_user1;
RESET client_min_messages;
CREATE USER regress_alter_table_user1;
CREATE TABLE attmp (initial int4);
COMMENT ON TABLE attmp_wrong IS 'table comment';
COMMENT ON TABLE attmp IS 'table comment';
COMMENT ON TABLE attmp IS NULL;
ALTER TABLE attmp ADD COLUMN xmin integer; -- failsALTER TABLE attmp ADD COLUMN a int4 default 3;
ALTER TABLE attmp ADD COLUMN b name;
ALTER TABLE attmp ADD COLUMN d float8;
ALTER TABLE attmp ADD COLUMN e float4;
ALTER TABLE attmp ADD COLUMN f int2;
ALTER TABLE attmp ADD COLUMN g polygon;
ALTER TABLE attmp ADD COLUMN k int4;
ALTER TABLE attmp ADD COLUMN l tid;
ALTER TABLE attmp ADD COLUMN m xid;
ALTER TABLE attmp ADD COLUMN n oidvector;
ALTER TABLE attmp ADD COLUMN q point;
ALTER TABLE attmp ADD COLUMN r lseg;
ALTER TABLE attmp ADD COLUMN s path;
ALTER TABLE attmp ADD COLUMN t box;
ALTER TABLE attmp ADD COLUMN v timestamp;
ALTER TABLE attmp ADD COLUMN w interval;
ALTER TABLE attmp ADD COLUMN x float8[];
ALTER TABLE attmp ADD COLUMN y float4[];
ALTER TABLE attmp ADD COLUMN z int2[];
CREATE TABLE attmp (	initial 	int4);
ALTER TABLE attmp ADD COLUMN a int4;
ALTER TABLE attmp ADD COLUMN b name;
ALTER TABLE attmp ADD COLUMN d float8;
ALTER TABLE attmp ADD COLUMN e float4;
ALTER TABLE attmp ADD COLUMN f int2;
ALTER TABLE attmp ADD COLUMN g polygon;
ALTER TABLE attmp ADD COLUMN k int4;
ALTER TABLE attmp ADD COLUMN l tid;
ALTER TABLE attmp ADD COLUMN m xid;
ALTER TABLE attmp ADD COLUMN n oidvector;
ALTER TABLE attmp ADD COLUMN q point;
ALTER TABLE attmp ADD COLUMN r lseg;
ALTER TABLE attmp ADD COLUMN s path;
ALTER TABLE attmp ADD COLUMN t box;
ALTER TABLE attmp ADD COLUMN v timestamp;
ALTER TABLE attmp ADD COLUMN w interval;
ALTER TABLE attmp ADD COLUMN x float8[];
ALTER TABLE attmp ADD COLUMN y float4[];
ALTER TABLE attmp ADD COLUMN z int2[];
ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000;
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000;
ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000;
ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000;
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1;
SELECT * FROM attmp;		-- should failSELECT * FROM attmp_new;
CREATE TABLE part_attmp (a int primary key) partition by range (a);
CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100);
ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index;
ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index;
SET ROLE regress_alter_table_user1;
ALTER INDEX part_attmp_index RENAME TO fail;
ALTER INDEX part_attmp1_index RENAME TO fail;
RESET ROLE;
::SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
::SELECT typname FROM pg_type WHERE oid = 'attmp_array2[]'::regtype;
_::SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
::SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
_::SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
_::SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
_ALTER INDEX IF EXISTS __onek_unique1 RENAME TO attmp_onek_unique1;
ALTER INDEX IF EXISTS __attmp_onek_unique1 RENAME TO onek_unique1;
ALTER INDEX onek_unique1 RENAME TO attmp_onek_unique1;
ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
SET ROLE regress_alter_table_user1;
ALTER INDEX onek_unique1 RENAME TO fail;  -- permission deniedRESET ROLE;
SET ROLE regress_alter_table_user1;
ALTER VIEW attmp_view_new RENAME TO fail;  -- permission deniedRESET ROLE;
set enable_seqscan to off;
set enable_bitmapscan to off;
reset enable_seqscan;
reset enable_bitmapscan;
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
DROP INDEX onek_unique1_constraint;  -- to see whether it's thereALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's thereALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- failALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- failALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- okALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- okALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- okALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- okDROP TABLE constraint_rename_test2;
ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo; -- okALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
CREATE TABLE constraint_rename_cache (a int,  CONSTRAINT chk_a CHECK (a > 0),  PRIMARY KEY (a));
ALTER TABLE constraint_rename_cache  RENAME CONSTRAINT chk_a TO chk_a_new;
ALTER TABLE constraint_rename_cache  RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new;
CREATE TABLE like_constraint_rename_cache  (LIKE constraint_rename_cache INCLUDING ALL);
CREATE TABLE attmp4 (a int, b int, unique(a,b));
ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full;
ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full;
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
DELETE FROM attmp3 where a=5;
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
ALTER TABLE attmp3 drop constraint attmpconstr;
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full NOT VALID;
ALTER TABLE attmp3 validate constraint attmpconstr;
DELETE FROM attmp3 where a=5;
ALTER TABLE attmp3 validate constraint attmpconstr;
ALTER TABLE attmp3 validate constraint attmpconstr;
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- failALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeedsALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- failsDELETE FROM attmp3 WHERE NOT b > 10;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeedsALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeedsselect * from attmp3;
CREATE TABLE attmp6 () INHERITS (attmp3);
CREATE TABLE attmp7 () INHERITS (attmp3);
ALTER TABLE attmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- failsDELETE FROM attmp6 WHERE b > 20;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- succeedsCREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
ALTER TABLE attmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
ALTER TABLE attmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
ALTER TABLE attmp3 VALIDATE CONSTRAINT identity;
create table child_noinh_convalid () inherits (parent_noinh_convalid);
alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
alter table parent_noinh_convalid validate constraint check_a_is_2;
delete from only parent_noinh_convalid;
alter table parent_noinh_convalid validate constraint check_a_is_2;
::select convalidated from pg_constraint where conrelid = 'parent_noinh_convalid'::regclass and conname = 'check_a_is_2';
drop table parent_noinh_convalid, child_noinh_convalid;
ALTER TABLE attmp5 add constraint attmpconstr foreign key(a) references attmp4(a) match full;
set constraint_exclusion TO 'partition';
create table nv_parent (d date, check (false) no inherit not valid);
create table nv_child_2010 () inherits (nv_parent);
create table nv_child_2011 () inherits (nv_parent);
alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
alter table nv_parent add check (d between '2001-01-01'::date and '2099-12-31'::date) not valid;
CREATE TEMP TABLE FKTABLE (ftest1 inet);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
CREATE TEMP TABLE FKTABLE (ftest1 int8);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
INSERT INTO FKTABLE VALUES(42);		-- should succeedINSERT INTO FKTABLE VALUES(43);		-- should failDROP TABLE FKTABLE;
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
INSERT INTO FKTABLE VALUES(42);		-- should succeedINSERT INTO FKTABLE VALUES(43);		-- should failDROP TABLE FKTABLE;
CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,                           PRIMARY KEY(ptest1, ptest2));
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)     references pktable(ptest1, ptest2);
CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)     references pktable(ptest2, ptest1);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)     references pktable(ptest1, ptest2);
ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE;
::SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferredFROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraintWHERE tgrelid = 'pktable'::regclassORDER BY 1,2,3;
::SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferredFROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraintWHERE tgrelid = 'fktable'::regclassORDER BY 1,2,3;
alter table atacc1 add constraint atacc_test1 check (test>3);
alter table atacc1 add constraint atacc_test1 check (test>3);
alter table atacc1 add constraint atacc_test1 check (test1>3);
alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
alter table atacc1 add check (test2>test);
create table atacc3 (test3 int) inherits (atacc1, atacc2);
alter table atacc2 add constraint foo check (test2>0);
create table atacc3 (test3 int) inherits (atacc1, atacc2);
alter table atacc3 no inherit atacc2;
alter table atacc3 no inherit atacc2;
alter table atacc2 add constraint foo check (test2>0);
alter table atacc3 inherit atacc2;
alter table atacc3 inherit atacc2;
alter table atacc3 add test2 bool;
alter table atacc3 inherit atacc2;
alter table atacc3 drop test2;
alter table atacc3 add constraint foo check (test2>0);
alter table atacc3 inherit atacc2;
alter table atacc3 inherit atacc2;
alter table atacc2 inherit atacc3;
alter table atacc2 inherit atacc2;
drop table atacc2 cascade;
create table atacc2 (test2 int) inherits (atacc1);
alter table atacc1 add constraint foo check (test>0) no inherit;
alter table atacc2 add constraint foo check (test>0) no inherit;
alter table atacc1 add constraint atacc_test1 unique (test);
alter table atacc1 alter column test type integer using 0;
alter table atacc1 add constraint atacc_test1 unique (test);
alter table atacc1 add constraint atacc_test1 unique (test1);
alter table atacc1 add constraint atacc_test1 unique (test, test2);
create table atacc1 (test int, test2 int, unique(test));
alter table atacc1 add unique (test2);
create table atacc1 ( id serial, test int) ;
alter table atacc1 add constraint atacc_test1 primary key (test);
insert into atacc1 (test) values(NULL);
alter table atacc1 add constraint atacc_oid1 primary key(id);
alter table atacc1 drop constraint atacc_test1 restrict;
alter table atacc1 add constraint atacc_oid1 primary key(id);
alter table atacc1 add constraint atacc_test1 primary key (test);
insert into atacc1 (test) values (NULL);
alter table atacc1 add constraint atacc_test1 primary key (test);
alter table atacc1 add constraint atacc_test1 primary key (test1);
alter table atacc1 add column test2 int default 0 primary key;
alter table atacc1  add column b float8 not null default random(),  add primary key(a);
alter table atacc1 add constraint atacc_test1 primary key (test, test2);
alter table atacc1 add constraint atacc_test2 primary key (test);
insert into atacc1 (test,test2) values (NULL,3);
insert into atacc1 (test,test2) values (3, NULL);
insert into atacc1 (test,test2) values (NULL,NULL);
create table atacc1 (test int, test2 int, primary key(test));
insert into atacc1 (test2, test) values (1, NULL);
alter table pg_class alter column relname drop not null;
alter table pg_class alter relname set not null;
alter table non_existent alter column bar set not null;
alter table non_existent alter column bar drop not null;
alter table atacc1 add constraint "atacc1_pkey" primary key (test);
alter table atacc1 alter column test drop not null;
alter table atacc1 drop constraint "atacc1_pkey";
alter table atacc1 alter column test drop not null;
insert into atacc1 values (null);
alter table atacc1 alter test set not null;
delete from atacc1;
alter table atacc1 alter test set not null;
alter table atacc1 alter bar set not null;
alter table atacc1 alter bar drop not null;
alter table myview alter column test drop not null;
alter table myview alter column test set not null;
insert into atacc1 values (null, 1);
alter table atacc1 add constraint atacc1_constr_or check(test_a is not null or test_b < 10);
alter table atacc1 alter test_a set not null;
alter table atacc1 drop constraint atacc1_constr_or;
alter table atacc1 add constraint atacc1_constr_invalid check(test_a is not null) not valid;
alter table atacc1 alter test_a set not null;
alter table atacc1 drop constraint atacc1_constr_invalid;
alter table atacc1 add constraint atacc1_constr_a_valid check(test_a is not null);
alter table atacc1 alter test_a set not null;
delete from atacc1;
insert into atacc1 values (2, null);
alter table atacc1 alter test_a drop not null;
alter table atacc1 alter test_a set not null, alter test_b set not null;
alter table atacc1 alter test_b set not null, alter test_a set not null;
alter table atacc1 alter test_b set not null, alter test_a set not null;
alter table atacc1 alter test_a drop not null, alter test_b drop not null;
alter table atacc1 add constraint atacc1_constr_b_valid check(test_b is not null);
alter table atacc1 alter test_b set not null, alter test_a set not null;
create table child (b varchar(255)) inherits (parent);
alter table parent alter a set not null;
insert into parent values (NULL);
insert into child (a, b) values (NULL, 'foo');
alter table parent alter a drop not null;
insert into parent values (NULL);
insert into child (a, b) values (NULL, 'foo');
alter table only parent alter a set not null;
alter table child alter a set not null;
delete from parent;
alter table only parent alter a set not null;
insert into parent values (NULL);
alter table child alter a set not null;
insert into child (a, b) values (NULL, 'foo');
delete from child;
alter table child alter a set not null;
insert into child (a, b) values (NULL, 'foo');
create table def_test (	c1	int4 default 5,	c2	text default 'initial_default');
alter table def_test alter column c1 drop default;
alter table def_test alter column c2 drop default;
alter table def_test alter column c1 set default 10;
alter table def_test alter column c2 set default 'new_default';
alter table def_test alter column c1 set default 'wrong_datatype';
alter table def_test alter column c2 set default 20;
alter table def_test alter column c3 set default 30;
create rule def_view_test_ins as	on insert to def_view_test	do instead insert into def_test select new.*;
alter table def_view_test alter column c1 set default 45;
alter table def_view_test alter column c2 set default 'view_default';
drop rule def_view_test_ins on def_view_test;
alter table pg_class drop column relname;
alter table nosuchtable drop column bar;
create table atacc1 (a int4 not null, b int4, c int4 not null, d int4);
alter table atacc1 drop a;
alter table atacc1 drop a;
select atacc1.* from atacc1;
select atacc1.a from atacc1;
select atacc1."........pg.dropped.1........" from atacc1;
insert into atacc1 values (default, 11, 12, 13);
insert into atacc1 (a) values (default);
insert into atacc1 (a,b,c,d) values (default,11,12,13);
insert into atacc1 ("........pg.dropped.1........") values (default);
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
delete from atacc1 where a = 3;
delete from atacc1 where "........pg.dropped.1........" = 3;
delete from atacc1;
alter table atacc1 drop bar;
alter table atacc1 SET WITHOUT OIDS;
alter table atacc1 SET WITH OIDS;
alter table atacc1 drop xmin;
alter table myview drop d;
analyze atacc1(a);
analyze atacc1("........pg.dropped.1........");
vacuum analyze atacc1(a);
vacuum analyze atacc1("........pg.dropped.1........");
comment on column atacc1.a is 'testing';
comment on column atacc1."........pg.dropped.1........" is 'testing';
alter table atacc1 alter a set storage plain;
alter table atacc1 alter "........pg.dropped.1........" set storage plain;
alter table atacc1 alter a set statistics 0;
alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
alter table atacc1 alter a set default 3;
alter table atacc1 alter "........pg.dropped.1........" set default 3;
alter table atacc1 alter a drop default;
alter table atacc1 alter "........pg.dropped.1........" drop default;
alter table atacc1 alter a set not null;
alter table atacc1 alter "........pg.dropped.1........" set not null;
alter table atacc1 alter a drop not null;
alter table atacc1 alter "........pg.dropped.1........" drop not null;
alter table atacc1 add primary key(a);
alter table atacc1 add primary key("........pg.dropped.1........");
alter table atacc1 add unique(a);
alter table atacc1 add unique("........pg.dropped.1........");
alter table atacc1 add check (a > 3);
alter table atacc1 add check ("........pg.dropped.1........" > 3);
create table atacc2 (id int4 unique);
alter table atacc1 add foreign key (a) references atacc2(id);
alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
alter table atacc2 add foreign key (id) references atacc1(a);
alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
select * into attest2 from atacc1;
alter table atacc1 drop c;
alter table atacc1 drop d;
alter table atacc1 drop b;
create table atacc1 (id serial primary key, value int check (value < 10));
alter table atacc1 drop column value;
insert into atacc1(id, value) values (null, 0);
alter table parent drop a;
create table child (d varchar(255)) inherits (parent);
alter table parent drop c;
create table parent (a float8, b numeric(10,4), c text collate "C");
create table child (a float4) inherits (parent); -- failcreate table child (b decimal(10,7)) inherits (parent); -- failcreate table child (c text collate "POSIX") inherits (parent); -- failcreate table child (a double precision, b decimal(10,4)) inherits (parent);
create table attest (a int4, b int4, c int4);
alter table attest drop a;
copy attest to stdout;
copy attest(a) to stdout;
copy attest("........pg.dropped.1........") to stdout;
copy attest from stdin;
10	11	12\.select * from attest;
copy attest from stdin;
21	22\.select * from attest;
copy attest(a) from stdin;
copy attest("........pg.dropped.1........") from stdin;
copy attest(b,c) from stdin;
31	32\.select * from attest;
create table dropColumnChild (c int) inherits (dropColumn);
create table dropColumnAnother (d int) inherits (dropColumnChild);
alter table dropColumnchild drop column a;
alter table only dropColumnChild drop column b;
alter table only dropColumn drop column e;
alter table dropColumnChild drop column c;
alter table dropColumn drop column a;
create table renameColumnChild (b int) inherits (renameColumn);
create table renameColumnAnother (c int) inherits (renameColumnChild);
alter table only renameColumnChild rename column a to d;
alter table only renameColumn rename column a to d;
alter table if exists doesnt_exist_tab rename column a to d;
alter table if exists doesnt_exist_tab rename column b to a;
alter table only renameColumn add column x int;
create table c1 (f1 int not null) inherits(p1);
alter table c1 drop column f1;
alter table p1 drop column f1;
alter table c1 drop column f1;
drop table p1 cascade;
create table c1 () inherits(p1);
alter table c1 drop column f1;
alter table p1 drop column f1;
drop table p1 cascade;
create table c1 () inherits(p1);
alter table c1 drop column f1;
alter table only p1 drop column f1;
alter table c1 drop column f1;
drop table p1 cascade;
create table c1 (f1 int not null) inherits(p1);
alter table c1 drop column f1;
alter table only p1 drop column f1;
alter table c1 drop column f1;
drop table p1 cascade;
create table c1(age int) inherits(p1,p2);
create table gc1() inherits (c1);
select relname, attname, attinhcount, attislocalfrom pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdroppedorder by relname, attnum;
alter table only p1 drop column name;
alter table p2 drop column name;
alter table gc1 drop column name;
alter table c1 drop column name;
alter table gc1 drop column name;
alter table p2 drop column height;
create table dropColumnExists ();
alter table dropColumnExists drop column non_existing; --failalter table dropColumnExists drop column if exists non_existing; --succeedselect relname, attname, attinhcount, attislocalfrom pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdroppedorder by relname, attnum;
drop table p1, p2 cascade;
create table depth0();
create table depth1(c text) inherits (depth0);
create table depth2() inherits (depth1);
::select attrelid::regclass, attname, attinhcount, attislocalfrom pg_attributewhere attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')order by attrelid::regclass::text, attnum;
create table c1 (f2 text, f3 int) inherits (p1);
insert into c1 values(11,'xyz',33,0); -- should failinsert into c1 values(11,'xyz',33,22);
drop table p1 cascade;
create domain mytype as text;
create temp table foo (f1 text, f2 mytype, f3 text);
drop domain mytype cascade;
alter table foo alter f1 TYPE integer; -- failsalter table foo alter f1 TYPE varchar(10);
create table anothertab (atcol1 serial8, atcol2 boolean,	constraint anothertab_chk check (atcol1 <= 3));
insert into anothertab (atcol1, atcol2) values (default, true);
insert into anothertab (atcol1, atcol2) values (default, false);
alter table anothertab alter column atcol1 type boolean; -- failsalter table anothertab alter column atcol1 type boolean using atcol1::int; -- failsalter table anothertab alter column atcol1 type integer;
insert into anothertab (atcol1, atcol2) values (45, null); -- failsinsert into anothertab (atcol1, atcol2) values (default, null);
alter table anothertab alter column atcol2 type text      using case when atcol2 is true then 'IT WAS TRUE'                 when atcol2 is false then 'IT WAS FALSE'                 else 'IT WAS NULL!' end;
alter table anothertab alter column atcol1 type boolean        using case when atcol1 % 2 = 0 then true else false end; -- failsalter table anothertab alter column atcol1 drop default;
alter table anothertab alter column atcol1 type boolean        using case when atcol1 % 2 = 0 then true else false end; -- failsalter table anothertab drop constraint anothertab_chk;
alter table anothertab drop constraint anothertab_chk; -- failsalter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeedsalter table anothertab alter column atcol1 type boolean        using case when atcol1 % 2 = 0 then true else false end;
alter table anothertab  add exclude using btree (f3 with =);
alter table anothertab  add exclude using btree (f4 with =) where (f4 is not null);
alter table anothertab  add exclude using btree (f4 with =) where (f5 > 0);
alter table anothertab  add unique(f1,f4);
create index on anothertab(f2,f3);
create unique index on anothertab(f4);
alter table anothertab alter column f1 type bigint;
alter table anothertab  alter column f2 type bigint,  alter column f3 type bigint,  alter column f4 type bigint;
alter table anothertab alter column f5 type bigint;
alter table another  alter f1 type text using f2 || ' more',  alter f2 type bigint using f1 * 10;
create table tab2 (x int, y tab1);
alter table tab1 alter column b type varchar; -- failscreate table at_partitioned (a int, b text) partition by range (a);
create table at_part_1 partition of at_partitioned for values from (0) to (1000);
create index on at_partitioned (b);
create index on at_partitioned (a);
alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
alter table at_partitioned alter column b type numeric using b::numeric;
create table at_partitioned(id int, name varchar(64), unique (id, name))  partition by hash(id);
comment on constraint at_partitioned_id_name_key on at_partitioned is 'parent constraint';
comment on index at_partitioned_id_name_key is 'parent index';
create table at_partitioned_0 partition of at_partitioned  for values with (modulus 2, remainder 0);
comment on constraint at_partitioned_0_id_name_key on at_partitioned_0 is 'child 0 constraint';
comment on index at_partitioned_0_id_name_key is 'child 0 index';
create table at_partitioned_1 partition of at_partitioned  for values with (modulus 2, remainder 1);
comment on constraint at_partitioned_1_id_name_key on at_partitioned_1 is 'child 1 constraint';
comment on index at_partitioned_1_id_name_key is 'child 1 index';
select relname,  c.oid = oldoid as orig_oid,  case relfilenode    when 0 then 'none'    when c.oid then 'own'    when oldfilenode then 'orig'    else 'OTHER'    end as storage,  obj_description(c.oid, 'pg_class') as desc  from pg_class c left join old_oids using (relname)  where relname like 'at_partitioned%'  order by relname;
select conname, obj_description(oid, 'pg_constraint') as desc  from pg_constraint where conname like 'at_partitioned%'  order by conname;
alter table at_partitioned alter column name type varchar(127);
select relname,  c.oid = oldoid as orig_oid,  case relfilenode    when 0 then 'none'    when c.oid then 'own'    when oldfilenode then 'orig'    else 'OTHER'    end as storage,  obj_description(c.oid, 'pg_class') as desc  from pg_class c left join old_oids using (relname)  where relname like 'at_partitioned%'  order by relname;
select conname, obj_description(oid, 'pg_constraint') as desc  from pg_constraint where conname like 'at_partitioned%'  order by conname;
alter table recur1 add column f2 recur1; -- failsalter table recur1 add column f2 recur1[]; -- failscreate domain array_of_recur1 as recur1[];
alter table recur1 add column f2 array_of_recur1; -- failscreate temp table recur2 (f1 int, f2 recur1);
alter table recur1 add column f2 recur2; -- failsalter table recur1 add column f2 int;
alter table recur1 alter column f2 type recur2; -- failscreate table test_storage (a text);
alter table test_storage alter a set storage plain;
alter table test_storage add b int default 0; -- rewrite table to remove its TOAST tablealter table test_storage alter a set storage extended; -- re-add TOAST tableselect reltoastrelid <> 0 as has_toast_tablefrom pg_classwhere oid = 'test_storage'::regclass;
CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
select relname, conname, coninhcount, conislocal, connoinherit  from pg_constraint c, pg_class r  where relname like 'test_inh_check%' and c.conrelid = r.oid  order by 1, 2;
ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
select relname, conname, coninhcount, conislocal, connoinherit  from pg_constraint c, pg_class r  where relname like 'test_inh_check%' and c.conrelid = r.oid  order by 1, 2;
ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
ALTER TABLE test_inh_check_child ADD CONSTRAINT bmerged CHECK (b > 1);
ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
select relname, conname, coninhcount, conislocal, connoinherit  from pg_constraint c, pg_class r  where relname like 'test_inh_check%' and c.conrelid = r.oid  order by 1, 2;
ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
select relname, conname, coninhcount, conislocal, connoinherit  from pg_constraint c, pg_class r  where relname like 'test_inh_check%' and c.conrelid = r.oid  order by 1, 2;
CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff);
ALTER TABLE test_type_diff ALTER COLUMN f2 TYPE bigint USING f2::bigint;
CREATE TABLE test_type_diff2 (int_two int2, int_four int4, int_eight int8);
CREATE TABLE test_type_diff2_c1 (int_four int4, int_eight int8, int_two int2);
CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int8 USING int_four::int8;
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2));
BEGIN;
ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
ANALYZE check_fk_presence_2;
ROLLBACK;
DROP TABLE check_fk_presence_1, check_fk_presence_2;
explain (verbose, costs off) select * from at_view_2;
explain (verbose, costs off) select * from at_view_2;
CREATE FUNCTION check_ddl_rewrite(p_tablename regclass, p_ddl text)RETURNS booleanLANGUAGE plpgsql AS $$DECLARE    v_relfilenode oid;
BEGIN    v_relfilenode := relfilenode FROM pg_class WHERE oid = p_tablename;
    EXECUTE p_ddl;
    RETURN v_relfilenode <> (SELECT relfilenode FROM pg_class WHERE oid = p_tablename);
END;
$$;
INSERT INTO rewrite_test VALUES (NULL);
SELECT check_ddl_rewrite('rewrite_test', $$  ALTER TABLE rewrite_test      ADD COLUMN empty1 text,      ADD COLUMN notempty1_rewrite serial;
$$);
SELECT check_ddl_rewrite('rewrite_test', $$    ALTER TABLE rewrite_test        ADD COLUMN notempty2_rewrite serial,        ADD COLUMN empty2 text;
$$);
SELECT check_ddl_rewrite('rewrite_test', $$    ALTER TABLE rewrite_test        ADD COLUMN empty3 text,        ADD COLUMN notempty3_norewrite int default 42;
$$);
SELECT check_ddl_rewrite('rewrite_test', $$    ALTER TABLE rewrite_test        ADD COLUMN notempty4_norewrite int default 42,        ADD COLUMN empty4 text;
$$);
SELECT check_ddl_rewrite('rewrite_test', $$    ALTER TABLE rewrite_test        ADD COLUMN empty5 text,        ADD COLUMN notempty5_norewrite int default 42,        ADD COLUMN notempty5_rewrite serial;
$$);
SELECT check_ddl_rewrite('rewrite_test', $$    ALTER TABLE rewrite_test        ADD COLUMN notempty6_rewrite serial,        ADD COLUMN empty6 text,        ADD COLUMN notempty6_norewrite int default 42;
$$);
DROP FUNCTION check_ddl_rewrite(regclass, text);
drop type lockmodes;
create type lockmodes as enum ( 'SIReadLock','AccessShareLock','RowShareLock','RowExclusiveLock','ShareUpdateExclusiveLock','ShareLock','ShareRowExclusiveLock','ExclusiveLock','AccessExclusiveLock');
create or replace view my_locks asselect case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmodefrom pg_locks l join pg_class c on l.relation = c.oidwhere virtualtransaction = (        select virtualtransaction        from pg_locks        where transactionid = txid_current()::integer)and locktype = 'relation'and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')and c.relname != 'my_locks'group by c.relname;
begin; alter table alterlock alter column f2 set statistics 150;
rollback;
begin; alter table alterlock cluster on alterlock_pkey;
commit;
begin; alter table alterlock set without cluster;
commit;
begin; alter table alterlock set (fillfactor = 100);
commit;
begin; alter table alterlock reset (fillfactor);
commit;
begin; alter table alterlock set (toast.autovacuum_enabled = off);
commit;
begin; alter table alterlock set (autovacuum_enabled = off);
commit;
begin; alter table alterlock alter column f2 set (n_distinct = 1);
rollback;
begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
commit;
begin; alter table alterlock alter column f2 set storage extended;
rollback;
begin; alter table alterlock alter column f2 set default 'x';
rollback;
begin;
create trigger ttdummy	before delete or update on alterlock	for each row	execute procedure	ttdummy (1, 1);
rollback;
begin;
alter table alterlock2 add foreign key (f1) references alterlock (f1);
rollback;
begin;
alter table alterlock2add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
commit;
begin;
alter table alterlock2 validate constraint alterlock2nv;
rollback;
create or replace view my_locks asselect case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmodefrom pg_locks l join pg_class c on l.relation = c.oidwhere virtualtransaction = (        select virtualtransaction        from pg_locks        where transactionid = txid_current()::integer)and locktype = 'relation'and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')and c.relname = 'my_locks'group by c.relname;
alter table my_locks set (autovacuum_enabled = false);
alter view my_locks set (autovacuum_enabled = false);
alter table my_locks reset (autovacuum_enabled);
alter view my_locks reset (autovacuum_enabled);
begin;
alter view my_locks set (security_barrier=off);
alter view my_locks reset (security_barrier);
rollback;
begin;
alter table my_locks set (security_barrier=off);
alter table my_locks reset (security_barrier);
rollback;
drop type lockmodes;
create function test_strict(text) returns text as    'select coalesce($1, ''got passed a null'');'    language sql returns null on null input;
select test_strict(NULL);
alter function test_strict(text) called on null input;
select test_strict(NULL);
create function non_strict(text) returns text as    'select coalesce($1, ''got passed a null'');'    language sql called on null input;
select non_strict(NULL);
alter function non_strict(text) returns null on null input;
select non_strict(NULL);
create schema alter1;
create schema alter2;
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
create view alter1.v1 as select * from alter1.t1;
create function alter1.plus1(int) returns int as 'select $1+1' language sql;
create domain alter1.posint integer check (value > 0);
create type alter1.ctype as (f1 int, f2 text);
create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sqlas 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as  operator 1 alter1.=(alter1.ctype, alter1.ctype);
create conversion alter1.latin1_to_utf8 for 'latin1' to 'utf8' from iso8859_1_to_utf8;
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
create text search configuration alter1.cfg(parser = alter1.prs);
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
create text search dictionary alter1.dict(template = alter1.tmpl);
insert into alter1.t1(f2) values(11);
insert into alter1.t1(f2) values(12);
alter table alter1.t1 set schema alter1; -- no-op, same schemaalter table alter1.t1 set schema alter2;
alter table alter1.v1 set schema alter2;
alter function alter1.plus1(int) set schema alter2;
alter domain alter1.posint set schema alter2;
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
alter type alter1.ctype set schema alter1; -- no-op, same schemaalter type alter1.ctype set schema alter2;
alter conversion alter1.latin1_to_utf8 set schema alter2;
alter text search parser alter1.prs set schema alter2;
alter text search configuration alter1.cfg set schema alter2;
alter text search template alter1.tmpl set schema alter2;
alter text search dictionary alter1.dict set schema alter2;
drop schema alter1;
insert into alter2.t1(f2) values(13);
insert into alter2.t1(f2) values(14);
select * from alter2.t1;
select * from alter2.v1;
select alter2.plus1(41);
drop schema alter2 cascade;
CREATE TYPE test_type AS (a int);
ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- failsALTER TYPE test_type ADD ATTRIBUTE b text;
ALTER TYPE test_type ADD ATTRIBUTE b text; -- failsALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
ALTER TYPE test_type DROP ATTRIBUTE b;
ALTER TYPE test_type DROP ATTRIBUTE c; -- failsALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
DROP TYPE test_type;
CREATE TYPE test_type1 AS (a int, b text);
CREATE TABLE test_tbl1 (x int, y test_type1);
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- failsCREATE TYPE test_type2 AS (a int, b text);
CREATE TABLE test_tbl2 OF test_type2;
CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- failsALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- failsALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ALTER TYPE test_type2 DROP ATTRIBUTE b; -- failsALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- failsALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
CREATE TYPE test_typex AS (a int, b text);
CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
ALTER TYPE test_typex DROP ATTRIBUTE a; -- failsALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
DROP TYPE test_typex;
CREATE TYPE test_type3 AS (a int);
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
CREATE TYPE test_type_empty AS ();
DROP TYPE test_type_empty;
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OKCREATE TABLE tt1 (x int, y bigint);					-- wrong base typeCREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmodCREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column orderCREATE TABLE tt4 (x int);							-- too few columnsCREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columnsCREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parentCREATE TABLE tt7 (x int, q text, y numeric(8,2));
ALTER TABLE tt7 DROP q;								-- OKALTER TABLE tt0 OF tt_t0;
ALTER TABLE tt1 OF tt_t0;
ALTER TABLE tt2 OF tt_t0;
ALTER TABLE tt3 OF tt_t0;
ALTER TABLE tt4 OF tt_t0;
ALTER TABLE tt5 OF tt_t0;
ALTER TABLE tt6 OF tt_t0;
ALTER TABLE tt7 OF tt_t0;
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed tableALTER TABLE tt7 NOT OF;
CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
INSERT INTO test_drop_constr_child (c) VALUES (NULL);
DROP TABLE test_drop_constr_parent CASCADE;
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
CREATE SCHEMA alter2;
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
DROP TABLE alter2.tt8;
DROP SCHEMA alter2;
ALTER TABLE tt9 ADD CHECK(c > 1);
ALTER TABLE tt9 ADD CHECK(c > 2);  -- picks nonconflicting nameALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 3);
ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 4);  -- fail, dup nameALTER TABLE tt9 ADD UNIQUE(c);
ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting nameALTER TABLE tt9 ADD CONSTRAINT tt9_c_key UNIQUE(c);  -- fail, dup nameALTER TABLE tt9 ADD CONSTRAINT foo UNIQUE(c);  -- fail, dup nameALTER TABLE tt9 ADD CONSTRAINT tt9_c_key CHECK(c > 5);  -- fail, dup nameALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6);
ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting nameDROP TABLE tt9;
CREATE TABLE comment_test (  id int,  positive_col int CHECK (positive_col > 0),  indexed_col int,  CONSTRAINT comment_test_pk PRIMARY KEY (id));
COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test';
COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test';
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col';
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test';
COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test';
::::::SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int;
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int;
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint;
::::::SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
CREATE TABLE comment_test_child (  id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
::::::SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
CREATE TEMP TABLE filenode_mapping ASSELECT    oid, mapped_oid, reltablespace, relfilenode, relnameFROM pg_class,    pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oidWHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oidWHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
SHOW allow_system_table_mods;
CREATE TABLE pg_catalog.new_system_table();
CREATE TABLE new_system_table(id serial primary key, othercol text);
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ALTER TABLE new_system_table SET SCHEMA public;
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
DELETE FROM old_system_table WHERE othercol = 'somedata';
TRUNCATE old_system_table;
ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
ALTER TABLE old_system_table DROP COLUMN othercol;
CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
~SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'UNION ALLSELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'UNION ALLSELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'ORDER BY relname;
CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign keyCREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign keyALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign keyALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table existsALTER TABLE unlogged1 SET LOGGED;
~SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'UNION ALLSELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'UNION ALLSELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'ORDER BY relname;
ALTER TABLE unlogged1 SET LOGGED; -- silently do nothingDROP TABLE unlogged3;
CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
~SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'UNION ALLSELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'UNION ALLSELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'ORDER BY relname;
CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign keyCREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign keyALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table existsALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign keyALTER TABLE logged2 SET UNLOGGED;
ALTER TABLE logged1 SET UNLOGGED;
~SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'UNION ALLSELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'UNION ALLSELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'ORDER BY relname;
ALTER TABLE logged1 SET UNLOGGED; -- silently do nothingDROP TABLE logged3;
ALTER TABLE test_add_column	ADD COLUMN c2 integer; -- fail because c2 already existsALTER TABLE ONLY test_add_column	ADD COLUMN c2 integer; -- fail because c2 already existsALTER TABLE test_add_column	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already existsALTER TABLE ONLY test_add_column	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already existsALTER TABLE test_add_column	ADD COLUMN c2 integer, -- fail because c2 already exists	ADD COLUMN c3 integer;
ALTER TABLE test_add_column	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists	ADD COLUMN c3 integer; -- fail because c3 already existsALTER TABLE test_add_column	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists	ADD COLUMN IF NOT EXISTS c3 integer; -- skipping because c3 already existsALTER TABLE test_add_column	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists	ADD COLUMN c4 integer;
CREATE TABLE partitioned (	a int,	b int) PARTITION BY RANGE (a, (a+b+1));
ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
ALTER TABLE partitioned DROP COLUMN a;
ALTER TABLE partitioned ALTER COLUMN a TYPE char(5);
ALTER TABLE partitioned DROP COLUMN b;
ALTER TABLE partitioned ALTER COLUMN b TYPE char(5);
ALTER TABLE partitioned INHERIT nonpartitioned;
ALTER TABLE nonpartitioned INHERIT partitioned;
ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT;
DROP TABLE partitioned, nonpartitioned;
CREATE TABLE fail_part (like unparted);
ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
DROP TABLE unparted, fail_part;
CREATE TABLE list_parted (	a int NOT NULL,	b char(2) COLLATE "C",	CONSTRAINT check_a CHECK (a > 0)) PARTITION BY LIST (a);
CREATE TABLE fail_part (LIKE list_parted);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1);
CREATE ROLE regress_test_me;
CREATE ROLE regress_test_not_me;
CREATE TABLE not_owned_by_me (LIKE list_parted);
ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me;
SET SESSION AUTHORIZATION regress_test_me;
CREATE TABLE owned_by_me (	a int) PARTITION BY LIST (a);
ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
RESET SESSION AUTHORIZATION;
DROP TABLE owned_by_me, not_owned_by_me;
DROP ROLE regress_test_not_me;
DROP ROLE regress_test_me;
CREATE TABLE parent (LIKE list_parted);
CREATE TABLE child () INHERITS (parent);
ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
DROP TABLE parent CASCADE;
CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
DROP TABLE temp_parted, perm_part;
CREATE TYPE mytype AS (a int);
CREATE TABLE fail_part OF mytype;
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TYPE mytype CASCADE;
CREATE TABLE fail_part (like list_parted, c int);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX";
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
CREATE TABLE fail_part (	b char(2) COLLATE "C",	a int NOT NULL);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ALTER TABLE fail_part ADD CONSTRAINT check_a CHECK (a >= 0);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
CREATE TABLE part_1 (	a int NOT NULL,	b char(2) COLLATE "C",	CONSTRAINT check_a CHECK (a > 0));
ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1);
::SELECT attislocal, attinhcount FROM pg_attribute WHERE attrelid = 'part_1'::regclass AND attnum > 0;
::SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_1'::regclass AND conname = 'check_a';
CREATE TABLE fail_part (LIKE part_1 INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
CREATE TABLE def_part (LIKE list_parted INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT;
CREATE TABLE fail_def_part (LIKE part_1 INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
CREATE TABLE list_parted2 (	a int,	b char) PARTITION BY LIST (a);
CREATE TABLE part_2 (LIKE list_parted2);
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
DELETE FROM part_2;
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
CREATE TABLE part_3 (LIKE list_parted2);
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
DELETE FROM list_parted2_def WHERE a = 11;
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
CREATE TABLE part_3_4 (	LIKE list_parted2,	CONSTRAINT check_a CHECK (a IN (3)));
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
ALTER TABLE part_3_4 ALTER a SET NOT NULL;
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
ALTER TABLE list_parted2_def ADD CONSTRAINT check_a CHECK (a IN (5, 6));
CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66);
CREATE TABLE range_parted (	a int,	b int) PARTITION BY RANGE (a, b);
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
DELETE FROM part1;
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20);
CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT;
CREATE TABLE partr_def2 (LIKE part1 INCLUDING CONSTRAINTS);
ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
CREATE TABLE part3 (LIKE range_parted);
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
CREATE TABLE part_5 (	LIKE list_parted2) PARTITION BY LIST (b);
CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
DELETE FROM part_5_a WHERE a NOT IN (3);
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ALTER TABLE list_parted2 DETACH PARTITION part_5;
ALTER TABLE part_5 DROP CONSTRAINT check_a;
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL;
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
CREATE TABLE part_6 (	c int,	LIKE list_parted2,	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 6));
ALTER TABLE part_6 DROP c;
ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6);
CREATE TABLE part_7 (	LIKE list_parted2,	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)) PARTITION BY LIST (b);
CREATE TABLE part_7_a_null (	c int,	d int,	e int,	LIKE list_parted2,  -- 'a' will have attnum = 4	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'),	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7));
ALTER TABLE part_7_a_null DROP c, DROP d, DROP e;
ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null);
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
ALTER TABLE list_parted2 DETACH PARTITION part_7;
ALTER TABLE part_7 DROP CONSTRAINT check_a; -- thusly, scan won't be skippedINSERT INTO part_7 (a, b) VALUES (8, null), (9, 'a');
::ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
ALTER TABLE part_5 DROP CONSTRAINT check_a;
CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a);
CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5);
CREATE TABLE part5_p1 (LIKE part_5);
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
DELETE FROM part5_def_p1 WHERE b = 'y';
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a);
CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b);
CREATE TABLE quuux_default1 PARTITION OF quuux_default (	CONSTRAINT check_1 CHECK (a IS NOT NULL AND a = 1)) FOR VALUES IN ('b');
ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1); -- validate!CREATE TABLE quuux2 (a int, b text);
ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2); -- skip validationDROP TABLE quuux1, quuux2;
CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1);
CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2);
CREATE TABLE hash_parted (	a int,	b int) PARTITION BY HASH (a part_test_int4_ops);
CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE fail_part (LIKE hpart_1);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
CREATE TABLE hpart_2 (LIKE hash_parted);
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
DELETE FROM hpart_2;
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE hpart_5 (	LIKE hash_parted) PARTITION BY LIST (b);
CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
DELETE FROM hpart_5_a;
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE fail_part(LIKE hash_parted);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
ALTER TABLE regular_table DETACH PARTITION any_name;
ALTER TABLE list_parted2 DETACH PARTITION part_4;
ALTER TABLE hash_parted DETACH PARTITION hpart_4;
ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
ALTER TABLE list_parted2 DETACH PARTITION part_1;
ALTER TABLE hash_parted DETACH PARTITION not_a_part;
ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
::SELECT attinhcount, attislocal FROM pg_attribute WHERE attrelid = 'part_3_4'::regclass AND attnum > 0;
::SELECT coninhcount, conislocal FROM pg_constraint WHERE conrelid = 'part_3_4'::regclass AND conname = 'check_a';
CREATE TABLE range_parted2 (    a int) PARTITION BY RANGE(a);
CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
ALTER TABLE range_parted2 DETACH PARTITION part_rp;
ALTER TABLE ONLY list_parted2 ADD COLUMN c int;
ALTER TABLE ONLY list_parted2 DROP COLUMN b;
ALTER TABLE part_2 DROP COLUMN b;
ALTER TABLE part_2 ALTER COLUMN b TYPE text;
ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL;
ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
ALTER TABLE list_parted2 ALTER b SET NOT NULL;
ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL;
ALTER TABLE list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b;
CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a);
ALTER TABLE ONLY parted_no_parts ALTER a SET NOT NULL;
ALTER TABLE ONLY parted_no_parts ADD CONSTRAINT check_a CHECK (a > 0);
ALTER TABLE ONLY parted_no_parts ALTER a DROP NOT NULL;
ALTER TABLE ONLY parted_no_parts DROP CONSTRAINT check_a;
ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0);
ALTER TABLE part_2 ALTER b DROP NOT NULL;
ALTER TABLE part_2 DROP CONSTRAINT check_a2;
ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
CREATE TABLE inh_test () INHERITS (part_2);
CREATE TABLE inh_test (LIKE part_2);
ALTER TABLE inh_test INHERIT part_2;
ALTER TABLE part_2 INHERIT inh_test;
ALTER TABLE list_parted2 DROP COLUMN b;
ALTER TABLE list_parted2 ALTER COLUMN b TYPE text;
ALTER TABLE list_parted DROP COLUMN b;
DROP TABLE list_parted, list_parted2, range_parted;
create table p (a int, b int) partition by range (a, b);
create table p1 (b int, a int not null) partition by range (b);
create table p11 (like p1);
alter table p11 drop a;
alter table p11 drop a;
::select attrelid::regclass, attname, attnumfrom pg_attributewhere attname = 'a' and (attrelid = 'p'::regclass   or attrelid = 'p1'::regclass   or attrelid = 'p11'::regclass)order by attrelid::regclass::text;
alter table p1 attach partition p11 for values from (2) to (5);
alter table p attach partition p1 for values from (1, 2) to (1, 10);
create table parted_validate_test (a int) partition by list (a);
create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1);
alter table parted_validate_test add constraint parted_validate_test_chka check (a > 0) not valid;
alter table parted_validate_test validate constraint parted_validate_test_chka;
ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2);
ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
ANALYZE attmp;
DROP USER regress_alter_table_user1;
create table defpart_attach_test (a int) partition by list (a);
create table defpart_attach_test1 partition of defpart_attach_test for values in (1);
alter table defpart_attach_test_d drop b;
alter table defpart_attach_test attach partition defpart_attach_test_d default;
delete from defpart_attach_test_d where a = 1;
alter table defpart_attach_test_d add check (a > 1);
alter table defpart_attach_test attach partition defpart_attach_test_d default;
create table defpart_attach_test_2 (like defpart_attach_test_d);
alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2);
create table perm_part_parent (a int) partition by list (a);
create temp table temp_part_parent (a int) partition by list (a);
alter table temp_part_parent attach partition perm_part_child default; -- erroralter table perm_part_parent attach partition temp_part_child default; -- erroralter table temp_part_parent attach partition temp_part_child default; -- okdrop table perm_part_parent cascade;
drop table temp_part_parent cascade;
create table tab_part_attach (a int) partition by list (a);
create or replace function func_part_attach() returns trigger  language plpgsql as $$  begin    execute 'create table tab_part_attach_1 (a int)';
    execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
    return null;
  end $$;
create trigger trig_part_attach before insert on tab_part_attach  for each statement execute procedure func_part_attach();
drop function func_part_attach();
create function at_test_sql_partop (int4, int4) returns int language sqlas $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create operator class at_test_sql_partop for type int4 using btree as    operator 1 < (int4, int4), operator 2 <= (int4, int4),    operator 3 = (int4, int4), operator 4 >= (int4, int4),    operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop);
alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10);
drop operator class at_test_sql_partop using btree;
drop function at_test_sql_partop;
::SELECT '""'::json;				-- OK.SELECT $$''$$::json;			-- ERROR, single quotes are not allowedSELECT '"abc"'::json;			-- OKSELECT '"abc'::json;			-- ERROR, quotes not closedSELECT '"abcdef"'::json;					-- ERROR, unescaped newline in string constantSELECT '"\n\"\\"'::json;		-- OK, legal escapesSELECT '"\v"'::json;			-- ERROR, not a valid JSON escapeSELECT '1'::json;				-- OKSELECT '0'::json;				-- OKSELECT '01'::json;				-- ERROR, not valid according to JSON specSELECT '0.1'::json;				-- OKSELECT '9223372036854775808'::json;	-- OK, even though it's too large for int8SELECT '1e100'::json;			-- OKSELECT '1.3e100'::json;			-- OKSELECT '1f2'::json;				-- ERRORSELECT '0.x1'::json;			-- ERRORSELECT '1.3ex100'::json;		-- ERRORSELECT '[]'::json;				-- OKSELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::json;  -- OKSELECT '[1,2]'::json;			-- OKSELECT '[1,2,]'::json;			-- ERROR, trailing commaSELECT '[1,2'::json;			-- ERROR, no closing bracketSELECT '[1,[2]'::json;			-- ERROR, no closing bracketSELECT '{}'::json;				-- OKSELECT '{"abc"}'::json;			-- ERROR, no valueSELECT '{"abc":1}'::json;		-- OKSELECT '{1:"abc"}'::json;		-- ERROR, keys must be stringsSELECT '{"abc",1}'::json;		-- ERROR, wrong separatorSELECT '{"abc"=1}'::json;		-- ERROR, totally wrong separatorSELECT '{"abc"::1}'::json;		-- ERROR, another wrong separatorSELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::json; -- OKSELECT '{"abc":1:2}'::json;		-- ERROR, colon in wrong spotSELECT '{"abc":1,3}'::json;		-- ERROR, no valueSET max_stack_depth = '100kB';
::::RESET max_stack_depth;
::SELECT 'true'::json;			-- OKSELECT 'false'::json;			-- OKSELECT 'null'::json;			-- OKSELECT ' true '::json;			-- OK, even with extra whitespaceSELECT 'true false'::json;		-- ERROR, too many valuesSELECT 'true, false'::json;		-- ERROR, too many valuesSELECT 'truf'::json;			-- ERROR, not a keywordSELECT 'trues'::json;			-- ERROR, not a keywordSELECT ''::json;				-- ERROR, no valueSELECT '    '::json;			-- ERROR, no valueSELECT array_to_json(array(select 1 as a));
SELECT array_to_json(array_agg(q),false)  FROM ( SELECT $$a$$ || x AS b, y AS c,               ARRAY[ROW(x.*,ARRAY[1,2,3]),               ROW(y.*,ARRAY[4,5,6])] AS z         FROM generate_series(1,2) x,              generate_series(4,5) y) q;
::SELECT array_to_json('{{1,5},{99,100}}'::int[]);
SELECT row_to_json(row(1,'foo'));
SELECT row_to_json(q)FROM (SELECT $$a$$ || x AS b,         y AS c,         ARRAY[ROW(x.*,ARRAY[1,2,3]),               ROW(y.*,ARRAY[4,5,6])] AS z      FROM generate_series(1,2) x,           generate_series(4,5) y) q;
SELECT row_to_json(q,true)FROM (SELECT $$a$$ || x AS b,         y AS c,         ARRAY[ROW(x.*,ARRAY[1,2,3]),               ROW(y.*,ARRAY[4,5,6])] AS z      FROM generate_series(1,2) x,           generate_series(4,5) y) q;
CREATE TEMP TABLE rows ASSELECT x, 'txt' || x as yFROM generate_series(1,3) AS x;
SELECT row_to_json(q,true)FROM rows q;
SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
analyze rows;
select attname, to_json(histogram_bounds) histogram_boundsfrom pg_statswhere tablename = 'rows' and      schemaname = pg_my_temp_schema()::regnamespace::textorder by 1;
select to_json(timestamp '2014-05-28 12:22:35.614298');
BEGIN;
SET LOCAL TIME ZONE 10.5;
select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
SET LOCAL TIME ZONE -8;
select to_json(timestamptz '2014-05-28 12:22:35.614298-04');
COMMIT;
select to_json(date '2014-05-28');
select to_json(date 'Infinity');
select to_json(date '-Infinity');
select to_json(timestamp 'Infinity');
select to_json(timestamp '-Infinity');
select to_json(timestamptz 'Infinity');
select to_json(timestamptz '-Infinity');
SELECT json_agg(q)  FROM ( SELECT $$a$$ || x AS b, y AS c,               ARRAY[ROW(x.*,ARRAY[1,2,3]),               ROW(y.*,ARRAY[4,5,6])] AS z         FROM generate_series(1,2) x,              generate_series(4,5) y) q;
SELECT json_agg(q ORDER BY x, y)  FROM rows q;
UPDATE rows SET x = NULL WHERE x = 1;
SELECT json_agg(q ORDER BY x NULLS FIRST, y)  FROM rows q;
::SELECT row_to_json(q)FROM (SELECT 'NaN'::float8 AS "float8field") q;
::SELECT row_to_json(q)FROM (SELECT 'Infinity'::float8 AS "float8field") q;
::SELECT row_to_json(q)FROM (SELECT '-Infinity'::float8 AS "float8field") q;
::SELECT row_to_json(q)FROM (SELECT '{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}'::json AS "jsonfield") q;
CREATE TEMP TABLE test_json (       json_type text,       test_json json);
SELECT test_json -> 'x'FROM test_jsonWHERE json_type = 'scalar';
SELECT test_json -> 'x'FROM test_jsonWHERE json_type = 'array';
SELECT test_json -> 'x'FROM test_jsonWHERE json_type = 'object';
SELECT test_json->'field2'FROM test_jsonWHERE json_type = 'object';
SELECT test_json->>'field2'FROM test_jsonWHERE json_type = 'object';
SELECT test_json -> 2FROM test_jsonWHERE json_type = 'scalar';
SELECT test_json -> 2FROM test_jsonWHERE json_type = 'array';
SELECT test_json -> -1FROM test_jsonWHERE json_type = 'array';
SELECT test_json -> 2FROM test_jsonWHERE json_type = 'object';
SELECT test_json->>2FROM test_jsonWHERE json_type = 'array';
SELECT test_json ->> 6 FROM test_json WHERE json_type = 'array';
SELECT test_json ->> 7 FROM test_json WHERE json_type = 'array';
SELECT test_json ->> 'field4' FROM test_json WHERE json_type = 'object';
SELECT test_json ->> 'field5' FROM test_json WHERE json_type = 'object';
SELECT test_json ->> 'field6' FROM test_json WHERE json_type = 'object';
SELECT json_object_keys(test_json)FROM test_jsonWHERE json_type = 'scalar';
SELECT json_object_keys(test_json)FROM test_jsonWHERE json_type = 'array';
SELECT json_object_keys(test_json)FROM test_jsonWHERE json_type = 'object';
||::select count(*) from    (select json_object_keys(json_object(array_agg(g)))     from (select unnest(array['f'||n,n::text])as g           from generate_series(1,300) as n) x ) y;
select (test_json->'field3') is null as expect_falsefrom test_jsonwhere json_type = 'object';
select (test_json->>'field3') is null as expect_truefrom test_jsonwhere json_type = 'object';
select (test_json->3) is null as expect_falsefrom test_jsonwhere json_type = 'array';
select (test_json->>3) is null as expect_truefrom test_jsonwhere json_type = 'array';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::text;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> null::int;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> 1;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> -1;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> 'z';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json -> '';
::select '[{"b": "c"}, {"b": "cc"}]'::json -> 1;
::select '[{"b": "c"}, {"b": "cc"}]'::json -> 3;
::select '[{"b": "c"}, {"b": "cc"}]'::json -> 'z';
::select '{"a": "c", "b": null}'::json -> 'b';
::select '"foo"'::json -> 1;
::select '"foo"'::json -> 'z';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> null::text;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> null::int;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> 1;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> 'z';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json ->> '';
::select '[{"b": "c"}, {"b": "cc"}]'::json ->> 1;
::select '[{"b": "c"}, {"b": "cc"}]'::json ->> 3;
::select '[{"b": "c"}, {"b": "cc"}]'::json ->> 'z';
::select '{"a": "c", "b": null}'::json ->> 'b';
::select '"foo"'::json ->> 1;
::select '"foo"'::json ->> 'z';
::select json_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
::select json_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
::select json_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
::select json_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
::#select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f4','f6'];
::#select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2'];
::#select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','0'];
::#select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','1'];
::#select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f4','f6'];
::#select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2'];
::#select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','0'];
::#select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','1'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> '{}';
::#select '[1,2,3]'::json #> '{}';
::#select '"foo"'::json #> '{}';
::#select '42'::json #> '{}';
::#select 'null'::json #> '{}';
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', null];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', ''];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c','d'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','z','c'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','1','b'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','z','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::json #> array['1','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::json #> array['z','b'];
::#select '[{"b": "c"}, {"b": null}]'::json #> array['1','b'];
::#select '"foo"'::json #> array['z'];
::#select '42'::json #> array['f2'];
::#select '42'::json #> array['0'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> '{}';
::#select '[1,2,3]'::json #>> '{}';
::#select '"foo"'::json #>> '{}';
::#select '42'::json #>> '{}';
::#select 'null'::json #>> '{}';
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', null];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', ''];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c','d'];
::#select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','z','c'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','1','b'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','z','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['1','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['z','b'];
::#select '[{"b": "c"}, {"b": null}]'::json #>> array['1','b'];
::#select '"foo"'::json #>> array['z'];
::#select '42'::json #>> array['f2'];
::#select '42'::json #>> array['0'];
create type jpop as (a text, b int, c timestamp);
CREATE DOMAIN js_int_not_null  AS int     NOT NULL;
CREATE DOMAIN js_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
CREATE DOMAIN js_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
create type j_unordered_pair as (x int, y int);
create domain j_ordered_pair as j_unordered_pair check((value).x <= (value).y);
CREATE TYPE jsrec AS (	i	int,	ia	_int4,	ia1	int[],	ia2	int[][],	ia3	int[][][],	ia1d	js_int_array_1d,	ia2d	js_int_array_2d,	t	text,	ta	text[],	c	char(10),	ca	char(10)[],	ts	timestamp,	js	json,	jsb	jsonb,	jsa	json[],	rec	jpop,	reca	jpop[]);
CREATE TYPE jsrec_i_not_null AS (	i	js_int_not_null);
select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}') q;
select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":"blurfl","x":43.2}') q;
select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}') q;
select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":"blurfl","x":43.2}') q;
select * from json_populate_record(null::jpop,'{"a":[100,200,false],"x":43.2}') q;
select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"a":[100,200,false],"x":43.2}') q;
select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"c":[100,200,false],"x":43.2}') q;
select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{}') q;
SELECT i FROM json_populate_record(NULL::jsrec_i_not_null, '{"x": 43.2}') q;
SELECT i FROM json_populate_record(NULL::jsrec_i_not_null, '{"i": null}') q;
SELECT i FROM json_populate_record(NULL::jsrec_i_not_null, '{"i": 12345}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": null}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": 123}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": [1, "2", null, 4]}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": [[1, 2], [3, 4]]}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": [[1], 2]}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": [[1], [2, 3]]}') q;
SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": "{1,2,3}"}') q;
SELECT ia1 FROM json_populate_record(NULL::jsrec, '{"ia1": null}') q;
SELECT ia1 FROM json_populate_record(NULL::jsrec, '{"ia1": 123}') q;
SELECT ia1 FROM json_populate_record(NULL::jsrec, '{"ia1": [1, "2", null, 4]}') q;
SELECT ia1 FROM json_populate_record(NULL::jsrec, '{"ia1": [[1, 2, 3]]}') q;
SELECT ia1d FROM json_populate_record(NULL::jsrec, '{"ia1d": null}') q;
SELECT ia1d FROM json_populate_record(NULL::jsrec, '{"ia1d": 123}') q;
SELECT ia1d FROM json_populate_record(NULL::jsrec, '{"ia1d": [1, "2", null, 4]}') q;
SELECT ia1d FROM json_populate_record(NULL::jsrec, '{"ia1d": [1, "2", null]}') q;
SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [1, "2", null, 4]}') q;
SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [[1, 2], [null, 4]]}') q;
SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [[], []]}') q;
SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [[1, 2], [3]]}') q;
SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [[1, 2], 3, 4]}') q;
SELECT ia2d FROM json_populate_record(NULL::jsrec, '{"ia2d": [[1, "2"], [null, 4]]}') q;
SELECT ia2d FROM json_populate_record(NULL::jsrec, '{"ia2d": [[1, "2", 3], [null, 5, 6]]}') q;
SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [1, "2", null, 4]}') q;
SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [[1, 2], [null, 4]]}') q;
SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [ [[], []], [[], []], [[], []] ]}') q;
SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [ [[1, 2]], [[3, 4]] ]}') q;
SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]}') q;
SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]] ]}') q;
SELECT ta FROM json_populate_record(NULL::jsrec, '{"ta": null}') q;
SELECT ta FROM json_populate_record(NULL::jsrec, '{"ta": 123}') q;
SELECT ta FROM json_populate_record(NULL::jsrec, '{"ta": [1, "2", null, 4]}') q;
SELECT ta FROM json_populate_record(NULL::jsrec, '{"ta": [[1, 2, 3], {"k": "v"}]}') q;
SELECT c FROM json_populate_record(NULL::jsrec, '{"c": null}') q;
SELECT c FROM json_populate_record(NULL::jsrec, '{"c": "aaa"}') q;
SELECT c FROM json_populate_record(NULL::jsrec, '{"c": "aaaaaaaaaa"}') q;
SELECT c FROM json_populate_record(NULL::jsrec, '{"c": "aaaaaaaaaaaaa"}') q;
SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": null}') q;
SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": 123}') q;
SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": [1, "2", null, 4]}') q;
SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": ["aaaaaaaaaaaaaaaa"]}') q;
SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": [[1, 2, 3], {"k": "v"}]}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": null}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": true}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": 123.45}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": "123.45"}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": "abc"}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": [123, "123", null, {"key": "value"}]}') q;
SELECT js FROM json_populate_record(NULL::jsrec, '{"js": {"a": "bbb", "b": null, "c": 123.45}}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": null}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": true}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": 123.45}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": "123.45"}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": "abc"}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": [123, "123", null, {"key": "value"}]}') q;
SELECT jsb FROM json_populate_record(NULL::jsrec, '{"jsb": {"a": "bbb", "b": null, "c": 123.45}}') q;
SELECT jsa FROM json_populate_record(NULL::jsrec, '{"jsa": null}') q;
SELECT jsa FROM json_populate_record(NULL::jsrec, '{"jsa": 123}') q;
SELECT jsa FROM json_populate_record(NULL::jsrec, '{"jsa": [1, "2", null, 4]}') q;
SELECT jsa FROM json_populate_record(NULL::jsrec, '{"jsa": ["aaa", null, [1, 2, "3", {}], { "k" : "v" }]}') q;
SELECT rec FROM json_populate_record(NULL::jsrec, '{"rec": 123}') q;
SELECT rec FROM json_populate_record(NULL::jsrec, '{"rec": [1, 2]}') q;
SELECT rec FROM json_populate_record(NULL::jsrec, '{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}') q;
SELECT rec FROM json_populate_record(NULL::jsrec, '{"rec": "(abc,42,01.02.2003)"}') q;
SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": 123}') q;
SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": [1, 2]}') q;
SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]}') q;
SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": ["(abc,42,01.02.2003)"]}') q;
SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": "{\"(abc,42,01.02.2003)\"}"}') q;
SELECT rec FROM json_populate_record(	row(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,		row('x',3,'2012-12-31 15:30:56')::jpop,NULL)::jsrec,	'{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}') q;
SELECT json_populate_record(null::record, '{"x": 0, "y": 1}');
SELECT json_populate_record(row(1,2), '{"f1": 0, "f2": 1}');
SELECT * FROM  json_populate_record(null::record, '{"x": 776}') AS (x int, y int);
SELECT json_populate_record(null::j_ordered_pair, '{"x": 0, "y": 1}');
SELECT json_populate_record(row(1,2)::j_ordered_pair, '{"x": 0}');
SELECT json_populate_record(row(1,2)::j_ordered_pair, '{"x": 1, "y": 0}');
select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(row('def',99,null)::jpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
create type jpop2 as (a int, b json, c int, d int);
select * from json_populate_recordset(null::jpop2, '[{"a":2,"c":3,"b":{"z":4},"d":6}]') q;
select * from json_populate_recordset(null::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
select * from json_populate_recordset(row('def',99,null)::jpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT json_populate_recordset(null::record, '[{"x": 0, "y": 1}]');
SELECT json_populate_recordset(row(1,2), '[{"f1": 0, "f2": 1}]');
SELECT i, json_populate_recordset(row(i,50), '[{"f1":"42"},{"f2":"43"}]')FROM (VALUES (1),(2)) v(i);
SELECT * FROM  json_populate_recordset(null::record, '[{"x": 776}]') AS (x int, y int);
SELECT json_populate_recordset(null::record, '[]');
SELECT json_populate_recordset(row(1,2), '[]');
SELECT * FROM json_populate_recordset(NULL::jpop,'[]') q;
SELECT * FROM  json_populate_recordset(null::record, '[]') AS (x int, y int);
SELECT json_populate_recordset(null::j_ordered_pair, '[{"x": 0, "y": 1}]');
SELECT json_populate_recordset(row(1,2)::j_ordered_pair, '[{"x": 0}, {"y": 3}]');
SELECT json_populate_recordset(row(1,2)::j_ordered_pair, '[{"x": 1, "y": 0}]');
select * from json_populate_recordset(row(0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
select * from json_populate_recordset(row(0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
select * from json_populate_recordset(row(0::int,0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
select * from json_populate_recordset(row(1000000000::int,50::int),'[{"b":"2"},{"a":"3"}]') q (a text, b text);
CREATE TEMP TABLE jspoptest (js json);
INSERT INTO jspoptestSELECT '{	"jsa": [1, "2", null, 4],	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2},	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]}'::jsonFROM generate_series(1, 3);
SELECT (json_populate_record(NULL::jsrec, js)).* FROM jspoptest;
DROP TYPE jsrec;
DROP TYPE jsrec_i_not_null;
DROP DOMAIN js_int_not_null;
DROP DOMAIN js_int_array_1d;
DROP DOMAIN js_int_array_2d;
DROP DOMAIN j_ordered_pair;
DROP TYPE j_unordered_pair;
select value, json_typeof(value)  from (values (json '123.4'),               (json '-1'),               (json '"foo"'),               (json 'true'),               (json 'false'),               (json 'null'),               (json '[1, 2, 3]'),               (json '[]'),               (json '{"x":"foo", "y":123}'),               (json '{}'),               (NULL::json))      as data(value);
SELECT json_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
SELECT json_build_array('a', NULL); -- okSELECT json_build_array(VARIADIC NULL::text[]); -- okSELECT json_build_array(VARIADIC '{}'::text[]); -- okSELECT json_build_array(VARIADIC '{a,b,c}'::text[]); -- okSELECT json_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- okSELECT json_build_array(VARIADIC '{1,2,3,4}'::text[]); -- okSELECT json_build_array(VARIADIC '{1,2,3,4}'::int[]); -- okSELECT json_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- okSELECT json_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
::SELECT json_build_object(       'a', json_build_object('b',false,'c',99),       'd', json_build_object('e',array[9,8,7]::int[],           'f', (select row_to_json(r) from ( select relkind, oid::regclass as name from pg_class where relname = 'pg_class') r)));
::SELECT json_build_object('{a,b,c}'::text[]); -- errorSELECT json_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be arraySELECT json_build_object('a', 'b', 'c'); -- errorSELECT json_build_object(NULL, 'a'); -- error, key cannot be NULLSELECT json_build_object('a', NULL); -- okSELECT json_build_object(VARIADIC NULL::text[]); -- okSELECT json_build_object(VARIADIC '{}'::text[]); -- okSELECT json_build_object(VARIADIC '{a,b,c}'::text[]); -- errorSELECT json_build_object(VARIADIC ARRAY['a', NULL]::text[]); -- okSELECT json_build_object(VARIADIC ARRAY[NULL, 'a']::text[]); -- error, key cannot be NULLSELECT json_build_object(VARIADIC '{1,2,3,4}'::text[]); -- okSELECT json_build_object(VARIADIC '{1,2,3,4}'::int[]); -- okSELECT json_build_object(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- okSELECT json_build_array();
SELECT json_build_object(null,2);
SELECT json_build_object(json '{"a":1,"b":2}', 3);
::SELECT json_build_object('{1,2,3}'::int[], 3);
INSERT INTO foo VALUES (999999, NULL, 'bar');
select * from json_to_record('{"a":1,"b":"foo","c":"bar"}')    as x(a int, b text, d text);
select * from json_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')    as x(a int, b text, c boolean);
select * from json_to_recordset('[{"a":1,"b":{"d":"foo"},"c":true},{"a":2,"c":false,"b":{"d":"bar"}}]')    as x(a int, b json, c boolean);
select *, c is null as c_is_nullfrom json_to_record('{"a":1, "b":{"c":16, "d":2}, "x":8, "ca": ["1 2", 3], "ia": [[1,2],[3,4]], "r": {"a": "aaa", "b": 123}}'::json)    as t(a int, b json, c text, x int, ca char(5)[], ia int[][], r jpop);
select *, c is null as c_is_nullfrom json_to_recordset('[{"a":1, "b":{"c":16, "d":2}, "x":8}]'::json)    as t(a int, b json, c text, x int);
select * from json_to_record('{"ia": null}') as x(ia _int4);
select * from json_to_record('{"ia": 123}') as x(ia _int4);
select * from json_to_record('{"ia": [1, "2", null, 4]}') as x(ia _int4);
select * from json_to_record('{"ia": [[1, 2], [3, 4]]}') as x(ia _int4);
select * from json_to_record('{"ia": [[1], 2]}') as x(ia _int4);
select * from json_to_record('{"ia": [[1], [2, 3]]}') as x(ia _int4);
select * from json_to_record('{"ia2": [1, 2, 3]}') as x(ia2 int[][]);
select * from json_to_record('{"ia2": [[1, 2], [3, 4]]}') as x(ia2 int4[][]);
select * from json_to_record('{"ia2": [[[1], [2], [3]]]}') as x(ia2 int4[][]);
select * from json_to_record('{"out": {"key": 1}}') as x(out json);
select * from json_to_record('{"out": [{"key": 1}]}') as x(out json);
select * from json_to_record('{"out": "{\"key\": 1}"}') as x(out json);
select * from json_to_record('{"out": {"key": 1}}') as x(out jsonb);
select * from json_to_record('{"out": [{"key": 1}]}') as x(out jsonb);
select * from json_to_record('{"out": "{\"key\": 1}"}') as x(out jsonb);
select json_strip_nulls(null);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::SELECT '123    08:00:2b:01:02:03'::macaddr8; -- invalidSELECT '08:00:2b:01:02:03  123'::macaddr8; -- invalidSELECT '123    08:00:2b:01:02:03:04:05'::macaddr8; -- invalidSELECT '08:00:2b:01:02:03:04:05  123'::macaddr8; -- invalidSELECT '08:00:2b:01:02:03:04:05:06:07'::macaddr8; -- invalidSELECT '08-00-2b-01-02-03-04-05-06-07'::macaddr8; -- invalidSELECT '08002b:01020304050607'::macaddr8; -- invalidSELECT '08002b01020304050607'::macaddr8; -- invalidSELECT '0z002b0102030405'::macaddr8; -- invalidSELECT '08002b010203xyza'::macaddr8; -- invalidSELECT '08:00-2b:01:02:03:04:05'::macaddr8; -- invalidSELECT '08:00-2b:01:02:03:04:05'::macaddr8; -- invalidSELECT '08:00:2b:01.02:03:04:05'::macaddr8; -- invalidSELECT '08:00:2b:01.02:03:04:05'::macaddr8; -- invalidSELECT macaddr8_set7bit('00:08:2b:01:02:03'::macaddr8);
CREATE TABLE macaddr8_data (a int, b macaddr8);
INSERT INTO macaddr8_data VALUES (9, 'not even close'); -- invalidINSERT INTO macaddr8_data VALUES (10, '08:00:2b:01:02:04');
CREATE INDEX macaddr8_data_btree ON macaddr8_data USING btree (b);
CREATE INDEX macaddr8_data_hash ON macaddr8_data USING hash (b);
SELECT a, b, trunc(b) FROM macaddr8_data ORDER BY 2, 1;
SELECT b <  '08:00:2b:01:02:04' FROM macaddr8_data WHERE a = 1; -- trueSELECT b >  '08:00:2b:ff:fe:01:02:04' FROM macaddr8_data WHERE a = 1; -- falseSELECT b >  '08:00:2b:ff:fe:01:02:03' FROM macaddr8_data WHERE a = 1; -- falseSELECT b::macaddr <= '08:00:2b:01:02:04' FROM macaddr8_data WHERE a = 1; -- trueSELECT b::macaddr >= '08:00:2b:01:02:04' FROM macaddr8_data WHERE a = 1; -- falseSELECT b =  '08:00:2b:ff:fe:01:02:03' FROM macaddr8_data WHERE a = 1; -- trueSELECT b::macaddr <> '08:00:2b:01:02:04'::macaddr FROM macaddr8_data WHERE a = 1; -- trueSELECT b::macaddr <> '08:00:2b:01:02:03'::macaddr FROM macaddr8_data WHERE a = 1; -- falseSELECT b <  '08:00:2b:01:02:03:04:06' FROM macaddr8_data WHERE a = 15; -- trueSELECT b >  '08:00:2b:01:02:03:04:06' FROM macaddr8_data WHERE a = 15; -- falseSELECT b >  '08:00:2b:01:02:03:04:05' FROM macaddr8_data WHERE a = 15; -- falseSELECT b <= '08:00:2b:01:02:03:04:06' FROM macaddr8_data WHERE a = 15; -- trueSELECT b >= '08:00:2b:01:02:03:04:06' FROM macaddr8_data WHERE a = 15; -- falseSELECT b =  '08:00:2b:01:02:03:04:05' FROM macaddr8_data WHERE a = 15; -- trueSELECT b <> '08:00:2b:01:02:03:04:06' FROM macaddr8_data WHERE a = 15; -- trueSELECT b <> '08:00:2b:01:02:03:04:05' FROM macaddr8_data WHERE a = 15; -- falseSELECT ~b                       FROM macaddr8_data;
&SELECT  b & '00:00:00:ff:ff:ff' FROM macaddr8_data;
|SELECT  b | '01:02:03:04:05:06' FROM macaddr8_data;
CREATE USER regress_unpriv_user;
CREATE SCHEMA temp_func_test;
GRANT ALL ON SCHEMA temp_func_test TO public;
SET search_path TO temp_func_test, public;
CREATE FUNCTION functest_A_1(text, date) RETURNS bool LANGUAGE 'sql'       AS 'SELECT $1 = ''abcd'' AND $2 > ''2001-01-01''';
CREATE FUNCTION functest_A_2(text[]) RETURNS int LANGUAGE 'sql'       AS 'SELECT $1[0]::int';
CREATE FUNCTION functest_A_3() RETURNS bool LANGUAGE 'sql'       AS 'SELECT false';
::::SELECT proname, prorettype::regtype, proargtypes::regtype[] FROM pg_proc       WHERE oid in ('functest_A_1'::regproc,                     'functest_A_2'::regproc,                     'functest_A_3'::regproc) ORDER BY proname;
CREATE FUNCTION functest_B_1(int) RETURNS bool LANGUAGE 'sql'       AS 'SELECT $1 > 0';
CREATE FUNCTION functest_B_2(int) RETURNS bool LANGUAGE 'sql'       IMMUTABLE AS 'SELECT $1 > 0';
CREATE FUNCTION functest_B_3(int) RETURNS bool LANGUAGE 'sql'       STABLE AS 'SELECT $1 = 0';
CREATE FUNCTION functest_B_4(int) RETURNS bool LANGUAGE 'sql'       VOLATILE AS 'SELECT $1 < 0';
::::::::ALTER FUNCTION functest_B_2(int) VOLATILE;
ALTER FUNCTION functest_B_3(int) COST 100;	-- unrelated change, no effectSELECT proname, provolatile FROM pg_proc       WHERE oid in ('functest_B_1'::regproc,                     'functest_B_2'::regproc,                     'functest_B_3'::regproc,		     'functest_B_4'::regproc) ORDER BY proname;
CREATE FUNCTION functest_C_1(int) RETURNS bool LANGUAGE 'sql'       AS 'SELECT $1 > 0';
CREATE FUNCTION functest_C_2(int) RETURNS bool LANGUAGE 'sql'       SECURITY DEFINER AS 'SELECT $1 = 0';
CREATE FUNCTION functest_C_3(int) RETURNS bool LANGUAGE 'sql'       SECURITY INVOKER AS 'SELECT $1 < 0';
::::::ALTER FUNCTION functest_C_1(int) IMMUTABLE;	-- unrelated change, no effectALTER FUNCTION functest_C_2(int) SECURITY INVOKER;
ALTER FUNCTION functest_C_3(int) SECURITY DEFINER;
::::::CREATE FUNCTION functest_E_1(int) RETURNS bool LANGUAGE 'sql'       AS 'SELECT $1 > 100';
CREATE FUNCTION functest_E_2(int) RETURNS bool LANGUAGE 'sql'       LEAKPROOF AS 'SELECT $1 > 100';
::::ALTER FUNCTION functest_E_1(int) LEAKPROOF;
ALTER FUNCTION functest_E_2(int) STABLE;	-- unrelated change, no effectSELECT proname, proleakproof FROM pg_proc       WHERE oid in ('functest_E_1'::regproc,                     'functest_E_2'::regproc) ORDER BY proname;
ALTER FUNCTION functest_E_2(int) NOT LEAKPROOF;	-- remove leakproof attributeSELECT proname, proleakproof FROM pg_proc       WHERE oid in ('functest_E_1'::regproc,                     'functest_E_2'::regproc) ORDER BY proname;
ALTER FUNCTION functest_E_1(int) OWNER TO regress_unpriv_user;
ALTER FUNCTION functest_E_2(int) OWNER TO regress_unpriv_user;
SET SESSION AUTHORIZATION regress_unpriv_user;
SET search_path TO temp_func_test, public;
ALTER FUNCTION functest_E_1(int) NOT LEAKPROOF;
ALTER FUNCTION functest_E_2(int) LEAKPROOF;
CREATE FUNCTION functest_E_3(int) RETURNS bool LANGUAGE 'sql'       LEAKPROOF AS 'SELECT $1 < 200';	-- failRESET SESSION AUTHORIZATION;
CREATE FUNCTION functest_F_1(int) RETURNS bool LANGUAGE 'sql'       AS 'SELECT $1 > 50';
CREATE FUNCTION functest_F_2(int) RETURNS bool LANGUAGE 'sql'       CALLED ON NULL INPUT AS 'SELECT $1 = 50';
CREATE FUNCTION functest_F_3(int) RETURNS bool LANGUAGE 'sql'       RETURNS NULL ON NULL INPUT AS 'SELECT $1 < 50';
CREATE FUNCTION functest_F_4(int) RETURNS bool LANGUAGE 'sql'       STRICT AS 'SELECT $1 = 50';
::::::::ALTER FUNCTION functest_F_1(int) IMMUTABLE;	-- unrelated change, no effectALTER FUNCTION functest_F_2(int) STRICT;
ALTER FUNCTION functest_F_3(int) CALLED ON NULL INPUT;
::::::::::::::::CREATE FUNCTION functest_IS_1(a int, b int default 1, c text default 'foo')    RETURNS int    LANGUAGE SQL    AS 'SELECT $1 + $2';
CREATE FUNCTION functest_IS_2(out a int, b int default 1)    RETURNS int    LANGUAGE SQL    AS 'SELECT $1';
CREATE FUNCTION functest_IS_3(a int default 1, out b int)    RETURNS int    LANGUAGE SQL    AS 'SELECT $1';
SELECT routine_name, ordinal_position, parameter_name, parameter_default    FROM information_schema.parameters JOIN information_schema.routines USING (specific_schema, specific_name)    WHERE routine_schema = 'temp_func_test' AND routine_name ~ '^functest_is_'    ORDER BY 1, 2;
DROP FUNCTION functest_IS_1(int, int, text), functest_IS_2(int), functest_IS_3(int);
CREATE FUNCTION functest_B_2(bigint) RETURNS bool LANGUAGE 'sql'       IMMUTABLE AS 'SELECT $1 > 0';
DROP FUNCTION functest_b_1;
DROP FUNCTION functest_b_1;  -- error, not foundDROP FUNCTION functest_b_2;  -- error, ambiguousCREATE FUNCTION functest1(a int) RETURNS int LANGUAGE SQL AS 'SELECT $1';
CREATE OR REPLACE FUNCTION functest1(a int) RETURNS int LANGUAGE SQL WINDOW AS 'SELECT $1';
CREATE OR REPLACE PROCEDURE functest1(a int) LANGUAGE SQL AS 'SELECT $1';
DROP FUNCTION functest1(a int);
CREATE FUNCTION voidtest1(a int) RETURNS VOID LANGUAGE SQL AS$$ SELECT a + 1 $$;
CREATE FUNCTION voidtest2(a int, b int) RETURNS VOID LANGUAGE SQL AS$$ SELECT voidtest1(a + b) $$;
EXPLAIN (verbose, costs off) SELECT voidtest2(11,22);
CREATE FUNCTION voidtest3(a int) RETURNS VOID LANGUAGE SQL AS$$ INSERT INTO sometable VALUES(a + 1) $$;
CREATE FUNCTION voidtest4(a int) RETURNS VOID LANGUAGE SQL AS$$ INSERT INTO sometable VALUES(a - 1) RETURNING f1 $$;
TABLE sometable;
CREATE FUNCTION voidtest5(a int) RETURNS SETOF VOID LANGUAGE SQL AS$$ SELECT generate_series(1, a) $$ STABLE;
DROP SCHEMA temp_func_test CASCADE;
DROP USER regress_unpriv_user;
RESET search_path;
SET extra_float_digits = 0;
::SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
SELECT max(student.gpa) AS max_3_7 FROM student;
::SELECT stddev_pop(b::numeric) FROM aggtest;
::SELECT stddev_samp(b::numeric) FROM aggtest;
::SELECT var_pop(b::numeric) FROM aggtest;
::SELECT var_samp(b::numeric) FROM aggtest;
::SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
select sum(null::int4) from generate_series(1,3);
select sum(null::int8) from generate_series(1,3);
select sum(null::numeric) from generate_series(1,3);
select sum(null::float8) from generate_series(1,3);
select avg(null::int4) from generate_series(1,3);
select avg(null::int8) from generate_series(1,3);
select avg(null::numeric) from generate_series(1,3);
select avg(null::float8) from generate_series(1,3);
::select sum('NaN'::numeric) from generate_series(1,3);
::select avg('NaN'::numeric) from generate_series(1,3);
::::SELECT avg(x::float8), var_pop(x::float8)FROM (VALUES ('1'), ('infinity')) v(x);
::::SELECT avg(x::float8), var_pop(x::float8)FROM (VALUES ('infinity'), ('1')) v(x);
::::SELECT avg(x::float8), var_pop(x::float8)FROM (VALUES ('infinity'), ('infinity')) v(x);
::::SELECT avg(x::float8), var_pop(x::float8)FROM (VALUES ('-infinity'), ('infinity')) v(x);
::::SELECT avg(x::float8), var_pop(x::float8)FROM (VALUES (100000003), (100000004), (100000006), (100000007)) v(x);
::::SELECT avg(x::float8), var_pop(x::float8)FROM (VALUES (7000000000005), (7000000000007)) v(x);
CREATE TABLE regr_test (x float8, y float8);
::SELECT float8_accum('{4,140,2900}'::float8[], 100);
::SELECT float8_regr_accum('{4,140,2900,1290,83075,15050}'::float8[], 200, 100);
::SELECT float8_combine('{3,60,200}'::float8[], '{0,0,0}'::float8[]);
::SELECT float8_combine('{0,0,0}'::float8[], '{2,180,200}'::float8[]);
::SELECT float8_combine('{3,60,200}'::float8[], '{2,180,200}'::float8[]);
::SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],                           '{0,0,0,0,0,0}'::float8[]);
::SELECT float8_regr_combine('{0,0,0,0,0,0}'::float8[],                           '{2,180,200,740,57800,-3400}'::float8[]);
::SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],                           '{2,180,200,740,57800,-3400}'::float8[]);
select ten, count(*), sum(four) from onekgroup by ten order by ten;
select ten, count(four), sum(DISTINCT four) from onekgroup by ten order by ten;
select ten, sum(distinct four) from onek agroup by tenhaving exists (select 1 from onek b where sum(distinct a.four) = b.four);
select ten, sum(distinct four) from onek agroup by tenhaving exists (select 1 from onek b               where sum(distinct a.four + b.four) = b.four);
select  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))from tenk1 o;
explain (verbose, costs off)select s1, s2, smfrom generate_series(1, 3) s1,     lateral (select s2, sum(s1 + s2) sm              from generate_series(1, 3) s2 group by s2) ssorder by 1, 2;
select s1, s2, smfrom generate_series(1, 3) s1,     lateral (select s2, sum(s1 + s2) sm              from generate_series(1, 3) s2 group by s2) ssorder by 1, 2;
explain (verbose, costs off)select array(select sum(x+y) s            from generate_series(1,3) y group by y order by s)  from generate_series(1,3) x;
select array(select sum(x+y) s            from generate_series(1,3) y group by y order by s)  from generate_series(1,3) x;
CREATE TEMPORARY TABLE bitwise_test(  i2 INT2,  i4 INT4,  i8 INT8,  i INTEGER,  x INT2,  y BIT(4));
COPY bitwise_test FROM STDIN NULL 'null';
1	1	1	1	1	B01013	3	3	null	2	B01007	7	7	3	4	B1100\.SELECT  BIT_AND(i2) AS "1",  BIT_AND(i4) AS "1",  BIT_AND(i8) AS "1",  BIT_AND(i)  AS "?",  BIT_AND(x)  AS "0",  BIT_AND(y)  AS "0100",  BIT_OR(i2)  AS "7",  BIT_OR(i4)  AS "7",  BIT_OR(i8)  AS "7",  BIT_OR(i)   AS "?",  BIT_OR(x)   AS "7",  BIT_OR(y)   AS "1101"FROM bitwise_test;
SELECT  -- boolean and transitions  -- null because strict  booland_statefunc(NULL, NULL)  IS NULL AS "t",  booland_statefunc(TRUE, NULL)  IS NULL AS "t",  booland_statefunc(FALSE, NULL) IS NULL AS "t",  booland_statefunc(NULL, TRUE)  IS NULL AS "t",  booland_statefunc(NULL, FALSE) IS NULL AS "t",  -- and actual computations  booland_statefunc(TRUE, TRUE) AS "t",  NOT booland_statefunc(TRUE, FALSE) AS "t",  NOT booland_statefunc(FALSE, TRUE) AS "t",  NOT booland_statefunc(FALSE, FALSE) AS "t";
SELECT  -- boolean or transitions  -- null because strict  boolor_statefunc(NULL, NULL)  IS NULL AS "t",  boolor_statefunc(TRUE, NULL)  IS NULL AS "t",  boolor_statefunc(FALSE, NULL) IS NULL AS "t",  boolor_statefunc(NULL, TRUE)  IS NULL AS "t",  boolor_statefunc(NULL, FALSE) IS NULL AS "t",  -- actual computations  boolor_statefunc(TRUE, TRUE) AS "t",  boolor_statefunc(TRUE, FALSE) AS "t",  boolor_statefunc(FALSE, TRUE) AS "t",  NOT boolor_statefunc(FALSE, FALSE) AS "t";
CREATE TEMPORARY TABLE bool_test(  b1 BOOL,  b2 BOOL,  b3 BOOL,  b4 BOOL);
COPY bool_test FROM STDIN NULL 'null';
TRUE	null	FALSE	nullFALSE	TRUE	null	nullnull	TRUE	FALSE	null\.SELECT  BOOL_AND(b1)     AS "f",  BOOL_AND(b2)     AS "t",  BOOL_AND(b3)     AS "f",  BOOL_AND(b4)     AS "n",  BOOL_AND(NOT b2) AS "f",  BOOL_AND(NOT b3) AS "t"FROM bool_test;
explain (costs off)  select min(unique1) from tenk1;
explain (costs off)  select max(unique1) from tenk1;
explain (costs off)  select max(unique1) from tenk1 where unique1 < 42;
explain (costs off)  select max(unique1) from tenk1 where unique1 > 42;
begin;
set local max_parallel_workers_per_gather = 0;
explain (costs off)  select max(unique1) from tenk1 where unique1 > 42000;
rollback;
explain (costs off)  select max(tenthous) from tenk1 where thousand = 33;
explain (costs off)  select min(tenthous) from tenk1 where thousand = 33;
explain (costs off)  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt    from int4_tbl;
explain (costs off)  select distinct max(unique2) from tenk1;
explain (costs off)  select max(unique2) from tenk1 order by 1;
explain (costs off)  select max(unique2) from tenk1 order by max(unique2);
explain (costs off)  select max(unique2) from tenk1 order by max(unique2)+1;
explain (costs off)  select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
explain (costs off)  select max(100) from tenk1;
create table minmaxtest1() inherits (minmaxtest);
create table minmaxtest2() inherits (minmaxtest);
create table minmaxtest3() inherits (minmaxtest);
explain (costs off)  select min(f1), max(f1) from minmaxtest;
explain (costs off)  select distinct min(f1), max(f1) from minmaxtest;
drop table minmaxtest cascade;
create temp table t1 (a int, b int, c int, d int, primary key (a, b));
create temp table t2 (x int, y int, z int, primary key (x, y));
create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
explain (costs off) select * from t1 group by a,b,c,d;
explain (costs off) select a,c from t1 group by a,c,d;
explain (costs off) select *from t1 inner join t2 on t1.a = t2.x and t1.b = t2.ygroup by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
explain (costs off) select t1.*,t2.x,t2.zfrom t1 inner join t2 on t1.a = t2.x and t1.b = t2.ygroup by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
explain (costs off) select * from t3 group by a,b,c;
create temp table t1c () inherits (t1);
explain (costs off) select * from t1 group by a,b,c,d;
explain (costs off) select * from only t1 group by a,b,c,d;
create temp table p_t1 (  a int,  b int,  c int,  d int,  primary key(a,b)) partition by list(a);
create temp table p_t1_1 partition of p_t1 for values in(1);
create temp table p_t1_2 partition of p_t1 for values in(2);
explain (costs off) select * from p_t1 group by a,b,c,d;
drop table t1 cascade;
select array_agg(a order by b)  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
select array_agg(a order by a)  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
select array_agg(a order by a desc)  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
select array_agg(b order by a desc)  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
select array_agg(distinct a)  from (values (1),(2),(1),(3),(null),(2)) v(a);
select array_agg(distinct a order by a)  from (values (1),(2),(1),(3),(null),(2)) v(a);
select array_agg(distinct a order by a desc)  from (values (1),(2),(1),(3),(null),(2)) v(a);
select array_agg(distinct a order by a desc nulls last)  from (values (1),(2),(1),(3),(null),(2)) v(a);
select aggfstr(a,b,c)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
select aggfns(a,b,c)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
select aggfstr(distinct a,b,c)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,3) i;
select aggfns(distinct a,b,c)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,3) i;
select aggfstr(distinct a,b,c order by b)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,3) i;
select aggfns(distinct a,b,c order by b)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,3) i;
select aggfns(distinct a,a,c order by c using ~<~,a)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,2) i;
select aggfns(distinct a,a,c order by c using ~<~)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,2) i;
select aggfns(distinct a,a,c order by a)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,2) i;
select aggfns(distinct a,b,c order by a,c using ~<~,b)  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),       generate_series(1,2) i;
create view agg_view1 as  select aggfns(a,b,c)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
::create or replace view agg_view1 as  select aggfns(distinct a,b,c)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),         generate_series(1,3) i;
::create or replace view agg_view1 as  select aggfns(distinct a,b,c order by b)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),         generate_series(1,3) i;
::create or replace view agg_view1 as  select aggfns(a,b,c order by b+1)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
::create or replace view agg_view1 as  select aggfns(a,a,c order by b)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
::create or replace view agg_view1 as  select aggfns(a,b,c order by c using ~<~)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
::create or replace view agg_view1 as  select aggfns(distinct a,b,c order by a,c using ~<~,b)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),         generate_series(1,2) i;
::select aggfns(distinct a,b,c order by i)  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
select aggfns(distinct a,b,c order by a,b+1)  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
select aggfns(distinct a,b,c order by a,b,i,c)  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
select aggfns(distinct a,a,c order by a,b)  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
select string_agg(a,',') from (values(null),(null)) g(a);
select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- okselect string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not okselect string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not okselect string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- okcreate table bytea_test_table(v bytea);
select string_agg(v, NULL) from bytea_test_table;
::select ten, sum(distinct four) filter (where four::text ~ '123') from onek agroup by ten;
select ten, sum(distinct four) filter (where four > 10) from onek agroup by tenhaving exists (select 1 from onek b where sum(distinct a.four) = b.four);
select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')from (values ('a', 'b')) AS v(foo,bar);
select (select count(*)        from (values (1)) t0(inner_c))from (values (2),(3)) t1(outer_c); -- inner query is aggregation queryselect (select count(*) filter (where outer_c <> 0)        from (values (1)) t0(inner_c))from (values (2),(3)) t1(outer_c); -- outer query is aggregation queryselect (select count(inner_c) filter (where outer_c <> 0)        from (values (1)) t0(inner_c))from (values (2),(3)) t1(outer_c); -- inner query is aggregation queryselect  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))     filter (where o.unique1 < 10))from tenk1 o;					-- outer query is aggregation queryselect sum(unique1) FILTER (WHERE  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),    generate_series(1,2) i;
select p, percentile_cont(p) within group (order by x::float8)from generate_series(1,5) x,     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)group by p order by p;
select p, percentile_cont(p order by p) within group (order by x)  -- errorfrom generate_series(1,5) x,     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)group by p order by p;
select p, sum() within group (order by x::float8)  -- errorfrom generate_series(1,5) x,     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)group by p order by p;
select p, percentile_cont(p,p)  -- errorfrom generate_series(1,5) x,     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)group by p order by p;
select percentile_cont(0.5) within group (order by b) from aggtest;
select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
select percentile_cont(0.5) within group (order by thousand) from tenk1;
select percentile_disc(0.5) within group (order by thousand) from tenk1;
select rank(3) within group (order by x)from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
select cume_dist(3) within group (order by x)from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
select percent_rank(3) within group (order by x)from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
select dense_rank(3) within group (order by x)from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)from tenk1;
select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)from tenk1;
select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)from tenk1;
select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)from generate_series(1,6) x;
select ten, mode() within group (order by string4) from tenk1 group by ten;
select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))  from (values ('fred'),('jim')) v(x);
select test_rank(3) within group (order by x)from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
select rank(x) within group (order by x) from generate_series(1,5) x;
select array(select percentile_disc(a) within group (order by x)               from (values (0.3),(0.7)) v(a) group by a)  from generate_series(1,5) g(x);
select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
select rank(3) within group (order by stringu1,stringu2) from tenk1;
select rank('fred') within group (order by x) from generate_series(1,5) x;
::select rank('adam'::text collate "C") within group (order by x collate "POSIX")  from (values ('fred'),('jim')) v(x);
::select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
select rank('3') within group (order by x) from generate_series(1,5) x;
select percent_rank(0) within group (order by x) from generate_series(1,0) x;
create view aggordview1 asselect ten,       percentile_disc(0.5) within group (order by thousand) as p50,       percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,       rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)  from tenk1 group by ten order by ten;
select least_agg(variadic array[q1,q2]) from int8_tbl;
begin work;
create type avg_state as (total bigint, count bigint);
create or replace function avg_transfn(state avg_state, n int) returns avg_state as$$declare new_state avg_state;
begin	raise notice 'avg_transfn called with %', n;
	if state is null then		if n is not null then			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;
	return null;
end$$ language plpgsql;
create function avg_finalfn(state avg_state) returns int4 as$$begin	if state is null then		return NULL;
	else		return state.total / state.count;
	end if;
end$$ language plpgsql;
create function sum_finalfn(state avg_state) returns int4 as$$begin	if state is null then		return NULL;
	else		return state.total;
	end if;
end$$ language plpgsql;
create aggregate my_avg(int4)   stype = avg_state,   sfunc = avg_transfn,   finalfunc = avg_finalfn);
create aggregate my_sum(int4)   stype = avg_state,   sfunc = avg_transfn,   finalfunc = sum_finalfn);
select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
select  percentile_cont(0.5) within group (order by a),  percentile_disc(0.5) within group (order by a)from (values(1::float8),(3),(5),(7)) t(a);
select  percentile_cont(0.25) within group (order by a),  percentile_disc(0.5) within group (order by a)from (values(1::float8),(3),(5),(7)) t(a);
select  rank(4) within group (order by a),  dense_rank(4) within group (order by a)from (values(1),(3),(5),(7)) t(a);
create aggregate my_sum_init(int4)   stype = avg_state,   sfunc = avg_transfn,   finalfunc = sum_finalfn,   initcond = '(10,0)');
create aggregate my_avg_init(int4)   stype = avg_state,   sfunc = avg_transfn,   finalfunc = avg_finalfn,   initcond = '(10,0)');
create aggregate my_avg_init2(int4)   stype = avg_state,   sfunc = avg_transfn,   finalfunc = avg_finalfn,   initcond = '(4,0)');
select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
rollback;
begin work;
create or replace function sum_transfn(state int4, n int4) returns int4 as$$declare new_state int4;
begin	raise notice 'sum_transfn called with %', n;
	if state is null then		if n is not null then			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then		state := state + n;
		return state;
	end if;
	return null;
end$$ language plpgsql;
create function halfsum_finalfn(state int4) returns int4 as$$begin	if state is null then		return NULL;
	else		return state / 2;
	end if;
end$$ language plpgsql;
create aggregate my_sum(int4)   stype = int4,   sfunc = sum_transfn);
create aggregate my_half_sum(int4)   stype = int4,   sfunc = sum_transfn,   finalfunc = halfsum_finalfn);
select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
rollback;
BEGIN;
CREATE FUNCTION balkifnull(int8, int4)RETURNS int8STRICTLANGUAGE plpgsql AS $$BEGIN    IF $1 IS NULL THEN       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$$;
CREATE AGGREGATE balk(int4)    SFUNC = balkifnull(int8, int4),    STYPE = int8,    PARALLEL = SAFE,    INITCOND = '0');
ROLLBACK;
BEGIN ISOLATION LEVEL REPEATABLE READ;
CREATE FUNCTION balkifnull(int8, int8)RETURNS int8PARALLEL SAFESTRICTLANGUAGE plpgsql AS $$BEGIN    IF $1 IS NULL THEN       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$$;
CREATE AGGREGATE balk(int4)    SFUNC = int4_sum(int8, int4),    STYPE = int8,    COMBINEFUNC = balkifnull(int8, int8),    PARALLEL = SAFE,    INITCOND = '0');
ALTER TABLE tenk1 set (parallel_workers = 4);
SET LOCAL parallel_setup_cost=0;
SET LOCAL max_parallel_workers_per_gather=4;
EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
ROLLBACK;
BEGIN ISOLATION LEVEL REPEATABLE READ;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET max_parallel_workers_per_gather = 4;
SET enable_indexonlyscan = off;
EXPLAIN (COSTS OFF, VERBOSE)  SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8) FROM tenk1;
::::::::ROLLBACK;
SELECT dense_rank(x) WITHIN GROUP (ORDER BY x) FROM (VALUES (1),(1),(2),(2),(3),(3)) v(x) GROUP BY (x) ORDER BY 1;
SELECT min(x ORDER BY y) FROM (VALUES(1, NULL)) AS d(x,y);
SELECT min(x ORDER BY y) FROM (VALUES(1, 2)) AS d(x,y);
||select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)  from unnest(array['a','b']) u(v) group by v||'a' order by 1;
||select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)  from unnest(array['a','b']) u(v) group by v||'a' order by 1;
explain (costs off)  select 1 from tenk1   where (hundred, thousand) in (select twothousand, twothousand from onek);
/* * This test is for Linux/glibc systems and others that implement proper * locale classification of Unicode characters with high code values. * It must be run in a database with UTF8 encoding and a Unicode-aware locale. */SET client_encoding TO UTF8;
~&SELECT 'a' ~ U&'a\24D0' AS t;
~&SELECT 'a' ~ U&'a\24D1' AS f;
~SELECT 'a' ~ 'a[-]' AS t;
~SELECT 'a' ~ 'a[-]' AS f;
~SELECT 'a' ~ 'a[-]' AS t;
~SELECT 'a' ~ 'a[-]' AS t;
~SELECT 'a' ~ 'a[-]' AS f;
~SELECT 'a' ~ 'a[-]' AS t;
~SELECT 'a' ~ 'a[-]' AS f;
~SELECT 'a' ~ 'a[-]' AS t;
~SELECT 'a' ~ 'a[-][-]' AS t;
~SELECT 'a' ~ 'a[-][-]' AS t;
~SELECT 'a' ~ 'a[-][-]' AS t;
~SELECT 'a' ~ 'a[-][-]' AS f;
~SELECT 'a' ~ 'a[-][-]' AS f;
~SELECT 'a0' ~ 'a[a-]' AS f;
~SELECT 'aq' ~ 'a[a-]' AS t;
~SELECT 'a' ~ 'a[a-]' AS t;
~SELECT 'a' ~ 'a[a-]' AS f;
~SELECT 'a' ~ '[[:alpha:]][[:alpha:]][[:alpha:]][[:graph:]]' AS t;
~SELECT 'a' ~ '[[:alpha:]][[:alpha:]][[:alpha:]][[:alpha:]]' AS f;
~SELECT 'a' ~ '[a-z][[:alpha:]][-][[:graph:]]' AS t;
~SELECT 'a' ~ '[a-z][[:alpha:]][-][[:graph:]]' AS f;
~SELECT 'a' ~ '[a-z][-][[:alpha:]][[:graph:]]' AS t;
~SELECT 'a' ~ '[a-z][-][[:alpha:]][[:graph:]]' AS f;
CREATE TABLE delete_test (    id SERIAL PRIMARY KEY,    a INT,    b text);
DELETE FROM delete_test AS dt WHERE dt.a > 75;
DELETE FROM delete_test dt WHERE delete_test.a > 25;
DELETE FROM delete_test WHERE a > 25;
CREATE TABLE DATE_TBL (f1 date);
SET datestyle TO iso;  -- display results in ISOSET datestyle TO ymd;
SELECT date 'January 8, 1999';
SELECT date '1999-01-08';
SELECT date '1999-01-18';
SELECT date '1/8/1999';
SELECT date '1/18/1999';
SELECT date '18/1/1999';
SELECT date '01/02/03';
SELECT date '19990108';
SELECT date '990108';
SELECT date '1999.008';
SELECT date 'J2451187';
SELECT date 'January 8, 99 BC';
SELECT date '99-Jan-08';
SELECT date '1999-Jan-08';
SELECT date '08-Jan-99';
SELECT date '08-Jan-1999';
SELECT date 'Jan-08-99';
SELECT date 'Jan-08-1999';
SELECT date '99-08-Jan';
SELECT date '1999-08-Jan';
SELECT date '99 Jan 08';
SELECT date '1999 Jan 08';
SELECT date '08 Jan 99';
SELECT date '08 Jan 1999';
SELECT date 'Jan 08 99';
SELECT date 'Jan 08 1999';
SELECT date '99 08 Jan';
SELECT date '1999 08 Jan';
SELECT date '99-01-08';
SELECT date '1999-01-08';
SELECT date '08-01-99';
SELECT date '08-01-1999';
SELECT date '01-08-99';
SELECT date '01-08-1999';
SELECT date '99-08-01';
SELECT date '1999-08-01';
SELECT date '99 01 08';
SELECT date '1999 01 08';
SELECT date '08 01 99';
SELECT date '08 01 1999';
SELECT date '01 08 99';
SELECT date '01 08 1999';
SELECT date '99 08 01';
SELECT date '1999 08 01';
SET datestyle TO dmy;
SELECT date 'January 8, 1999';
SELECT date '1999-01-08';
SELECT date '1999-01-18';
SELECT date '1/8/1999';
SELECT date '1/18/1999';
SELECT date '18/1/1999';
SELECT date '01/02/03';
SELECT date '19990108';
SELECT date '990108';
SELECT date '1999.008';
SELECT date 'J2451187';
SELECT date 'January 8, 99 BC';
SELECT date '99-Jan-08';
SELECT date '1999-Jan-08';
SELECT date '08-Jan-99';
SELECT date '08-Jan-1999';
SELECT date 'Jan-08-99';
SELECT date 'Jan-08-1999';
SELECT date '99-08-Jan';
SELECT date '1999-08-Jan';
SELECT date '99 Jan 08';
SELECT date '1999 Jan 08';
SELECT date '08 Jan 99';
SELECT date '08 Jan 1999';
SELECT date 'Jan 08 99';
SELECT date 'Jan 08 1999';
SELECT date '99 08 Jan';
SELECT date '1999 08 Jan';
SELECT date '99-01-08';
SELECT date '1999-01-08';
SELECT date '08-01-99';
SELECT date '08-01-1999';
SELECT date '01-08-99';
SELECT date '01-08-1999';
SELECT date '99-08-01';
SELECT date '1999-08-01';
SELECT date '99 01 08';
SELECT date '1999 01 08';
SELECT date '08 01 99';
SELECT date '08 01 1999';
SELECT date '01 08 99';
SELECT date '01 08 1999';
SELECT date '99 08 01';
SELECT date '1999 08 01';
SET datestyle TO mdy;
SELECT date 'January 8, 1999';
SELECT date '1999-01-08';
SELECT date '1999-01-18';
SELECT date '1/8/1999';
SELECT date '1/18/1999';
SELECT date '18/1/1999';
SELECT date '01/02/03';
SELECT date '19990108';
SELECT date '990108';
SELECT date '1999.008';
SELECT date 'J2451187';
SELECT date 'January 8, 99 BC';
SELECT date '99-Jan-08';
SELECT date '1999-Jan-08';
SELECT date '08-Jan-99';
SELECT date '08-Jan-1999';
SELECT date 'Jan-08-99';
SELECT date 'Jan-08-1999';
SELECT date '99-08-Jan';
SELECT date '1999-08-Jan';
SELECT date '99 Jan 08';
SELECT date '1999 Jan 08';
SELECT date '08 Jan 99';
SELECT date '08 Jan 1999';
SELECT date 'Jan 08 99';
SELECT date 'Jan 08 1999';
SELECT date '99 08 Jan';
SELECT date '1999 08 Jan';
SELECT date '99-01-08';
SELECT date '1999-01-08';
SELECT date '08-01-99';
SELECT date '08-01-1999';
SELECT date '01-08-99';
SELECT date '01-08-1999';
SELECT date '99-08-01';
SELECT date '1999-08-01';
SELECT date '99 01 08';
SELECT date '1999 01 08';
SELECT date '08 01 99';
SELECT date '08 01 1999';
SELECT date '01 08 99';
SELECT date '01 08 1999';
SELECT date '99 08 01';
SELECT date '1999 08 01';
SELECT date '4714-11-24 BC';
SELECT date '4714-11-23 BC';  -- out of rangeSELECT date '5874897-12-31';
SELECT date '5874898-01-01';  -- out of rangeRESET datestyle;
SELECT f1 - date '2000-01-01' AS "Days From 2K" FROM DATE_TBL;
SELECT f1 - date 'epoch' AS "Days From Epoch" FROM DATE_TBL;
SELECT date 'yesterday' - date 'today' AS "One day";
SELECT date 'today' - date 'tomorrow' AS "One day";
SELECT date 'yesterday' - date 'tomorrow' AS "Two days";
SELECT date 'tomorrow' - date 'today' AS "One day";
SELECT date 'today' - date 'yesterday' AS "One day";
SELECT date 'tomorrow' - date 'yesterday' AS "Two days";
SELECT EXTRACT(EPOCH FROM DATE        '1970-01-01');     --  0SELECT EXTRACT(EPOCH FROM TIMESTAMP   '1970-01-01');     --  0SELECT EXTRACT(EPOCH FROM TIMESTAMPTZ '1970-01-01+00');  --  0SELECT EXTRACT(CENTURY FROM DATE '0101-12-31 BC'); -- -2SELECT EXTRACT(CENTURY FROM DATE '0100-12-31 BC'); -- -1SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC'); -- -1SELECT EXTRACT(CENTURY FROM DATE '0001-01-01');    --  1SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD'); --  1SELECT EXTRACT(CENTURY FROM DATE '1900-12-31');    -- 19SELECT EXTRACT(CENTURY FROM DATE '1901-01-01');    -- 20SELECT EXTRACT(CENTURY FROM DATE '2000-12-31');    -- 20SELECT EXTRACT(CENTURY FROM DATE '2001-01-01');    -- 21SELECT EXTRACT(CENTURY FROM CURRENT_DATE)>=21 AS True;     -- trueSELECT EXTRACT(MILLENNIUM FROM DATE '0001-12-31 BC'); -- -1SELECT EXTRACT(MILLENNIUM FROM DATE '0001-01-01 AD'); --  1SELECT EXTRACT(MILLENNIUM FROM DATE '1000-12-31');    --  1SELECT EXTRACT(MILLENNIUM FROM DATE '1001-01-01');    --  2SELECT EXTRACT(MILLENNIUM FROM DATE '2000-12-31');    --  2SELECT EXTRACT(MILLENNIUM FROM DATE '2001-01-01');    --  3SELECT EXTRACT(MILLENNIUM FROM CURRENT_DATE);         --  3SELECT EXTRACT(DECADE FROM DATE '1994-12-25');    -- 199SELECT EXTRACT(DECADE FROM DATE '0010-01-01');    --   1SELECT EXTRACT(DECADE FROM DATE '0009-12-31');    --   0SELECT EXTRACT(DECADE FROM DATE '0001-01-01 BC'); --   0SELECT EXTRACT(DECADE FROM DATE '0002-12-31 BC'); --  -1SELECT EXTRACT(DECADE FROM DATE '0011-01-01 BC'); --  -1SELECT EXTRACT(DECADE FROM DATE '0012-12-31 BC'); --  -2SELECT EXTRACT(CENTURY FROM NOW())>=21 AS True;       -- trueSELECT EXTRACT(CENTURY FROM TIMESTAMP '1970-03-20 04:30:00.00000'); -- 20SELECT EXTRACT(CENTURY FROM INTERVAL '100 y');  -- 1SELECT EXTRACT(CENTURY FROM INTERVAL '99 y');   -- 0SELECT EXTRACT(CENTURY FROM INTERVAL '-99 y');  -- 0SELECT EXTRACT(CENTURY FROM INTERVAL '-100 y'); -- -1SELECT DATE_TRUNC('MILLENNIUM', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1001SELECT DATE_TRUNC('MILLENNIUM', DATE '1970-03-20'); -- 1001-01-01SELECT DATE_TRUNC('CENTURY', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1901SELECT DATE_TRUNC('CENTURY', DATE '1970-03-20'); -- 1901SELECT DATE_TRUNC('CENTURY', DATE '2004-08-10'); -- 2001-01-01SELECT DATE_TRUNC('CENTURY', DATE '0002-02-04'); -- 0001-01-01SELECT DATE_TRUNC('CENTURY', DATE '0055-08-10 BC'); -- 0100-01-01 BCSELECT DATE_TRUNC('DECADE', DATE '1993-12-25'); -- 1990-01-01SELECT DATE_TRUNC('DECADE', DATE '0004-12-25'); -- 0001-01-01 BCSELECT DATE_TRUNC('DECADE', DATE '0002-12-31 BC'); -- 0011-01-01 BCselect 'infinity'::date, '-infinity'::date;
::select 'infinity'::date > 'today'::date as t;
::select '-infinity'::date < 'today'::date as t;
::::::SELECT EXTRACT(HOUR FROM DATE 'infinity');      -- NULLSELECT EXTRACT(HOUR FROM DATE '-infinity');     -- NULLSELECT EXTRACT(HOUR FROM TIMESTAMP   'infinity');      -- NULLSELECT EXTRACT(HOUR FROM TIMESTAMP   '-infinity');     -- NULLSELECT EXTRACT(HOUR FROM TIMESTAMPTZ 'infinity');      -- NULLSELECT EXTRACT(HOUR FROM TIMESTAMPTZ '-infinity');     -- NULLSELECT EXTRACT(MICROSECONDS  FROM DATE 'infinity');    -- NULLSELECT EXTRACT(MILLISECONDS  FROM DATE 'infinity');    -- NULLSELECT EXTRACT(SECOND        FROM DATE 'infinity');    -- NULLSELECT EXTRACT(MINUTE        FROM DATE 'infinity');    -- NULLSELECT EXTRACT(HOUR          FROM DATE 'infinity');    -- NULLSELECT EXTRACT(DAY           FROM DATE 'infinity');    -- NULLSELECT EXTRACT(MONTH         FROM DATE 'infinity');    -- NULLSELECT EXTRACT(QUARTER       FROM DATE 'infinity');    -- NULLSELECT EXTRACT(WEEK          FROM DATE 'infinity');    -- NULLSELECT EXTRACT(DOW           FROM DATE 'infinity');    -- NULLSELECT EXTRACT(ISODOW        FROM DATE 'infinity');    -- NULLSELECT EXTRACT(DOY           FROM DATE 'infinity');    -- NULLSELECT EXTRACT(TIMEZONE      FROM DATE 'infinity');    -- NULLSELECT EXTRACT(TIMEZONE_M    FROM DATE 'infinity');    -- NULLSELECT EXTRACT(TIMEZONE_H    FROM DATE 'infinity');    -- NULLSELECT EXTRACT(EPOCH FROM DATE 'infinity');         --  InfinitySELECT EXTRACT(EPOCH FROM DATE '-infinity');        -- -InfinitySELECT EXTRACT(EPOCH FROM TIMESTAMP   'infinity');  --  InfinitySELECT EXTRACT(EPOCH FROM TIMESTAMP   '-infinity'); -- -InfinitySELECT EXTRACT(EPOCH FROM TIMESTAMPTZ 'infinity');  --  InfinitySELECT EXTRACT(EPOCH FROM TIMESTAMPTZ '-infinity'); -- -InfinitySELECT EXTRACT(YEAR       FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(DECADE     FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(CENTURY    FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(MILLENNIUM FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(JULIAN     FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(ISOYEAR    FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(EPOCH      FROM DATE 'infinity');    --  InfinitySELECT EXTRACT(MICROSEC  FROM DATE 'infinity');     -- ERROR:  timestamp units "microsec" not recognizedselect make_date(2013, 7, 15);
SELECT c, count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
SELECT test_missing_target.b, count(*)  FROM test_missing_target GROUP BY b ORDER BY b;
SELECT count(*) FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY b ORDER BY b;
SELECT x.b, count(*) FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY x.b ORDER BY x.b;
SELECT count(*) FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY x.b ORDER BY x.b;
SELECT count(*) INTO TABLE test_missing_target2FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY x.b ORDER BY x.b;
SELECT a%2, count(b) FROM test_missing_targetGROUP BY test_missing_target.a%2ORDER BY test_missing_target.a%2;
SELECT count(c) FROM test_missing_targetGROUP BY lower(test_missing_target.c)ORDER BY lower(test_missing_target.c);
SELECT lower(test_missing_target.c), count(c)  FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);
SELECT count(x.a) FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY b/2 ORDER BY b/2;
SELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY x.b/2 ORDER BY x.b/2;
SELECT count(b) FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY x.b/2;
SELECT count(x.b) INTO TABLE test_missing_target3FROM test_missing_target x, test_missing_target y	WHERE x.a = y.a	GROUP BY x.b/2 ORDER BY x.b/2;
INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
INSERT INTO J2_TBL VALUES (0, NULL);
INSERT INTO J2_TBL VALUES (NULL, NULL);
INSERT INTO J2_TBL VALUES (NULL, 0);
create temp table onerow();
analyze onerow;
SELECT '' AS "xxx", *  FROM J1_TBL AS t1 (a, b, c);
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b, c);
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);
SELECT '' AS "xxx", t1.a, t2.e  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)  WHERE t1.a = t2.d;
SELECT '' AS "xxx", *  FROM J1_TBL CROSS JOIN J2_TBL;
SELECT '' AS "xxx", i, k, t  FROM J1_TBL CROSS JOIN J2_TBL;
SELECT '' AS "xxx", t1.i, k, t  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
SELECT '' AS "xxx", ii, tt, kk  FROM (J1_TBL CROSS JOIN J2_TBL)    AS tx (ii, jj, tt, ii2, kk);
SELECT '' AS "xxx", tx.ii, tx.jj, tx.kk  FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))    AS tx (ii, jj, tt, ii2, kk);
SELECT '' AS "xxx", *  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
SELECT '' AS "xxx", *  FROM J1_TBL INNER JOIN J2_TBL USING (i);
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)  ORDER BY a, d;
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)  ORDER BY b, t1.a;
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);
SELECT '' AS "xxx", *  FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
SELECT '' AS "xxx", *  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
SELECT '' AS "xxx", *  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
SELECT '' AS "xxx", *  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
SELECT '' AS "xxx", *  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)  ORDER BY i, k, t;
SELECT '' AS "xxx", *  FROM J1_TBL LEFT JOIN J2_TBL USING (i)  ORDER BY i, k, t;
SELECT '' AS "xxx", *  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
SELECT '' AS "xxx", *  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)  ORDER BY i, k, t;
SELECT '' AS "xxx", *  FROM J1_TBL FULL JOIN J2_TBL USING (i)  ORDER BY i, k, t;
SELECT '' AS "xxx", *  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
SELECT '' AS "xxx", *  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
explain (costs off)select * from int4_tbl i4, tenk1 awhere exists(select * from tenk1 b             where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)      and i4.f1 = a.tenthous;
SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
SELECT * FROM(SELECT * FROM t2) as s2INNER JOIN(SELECT * FROM t3) s3USING (name);
SELECT * FROM(SELECT * FROM t2) as s2LEFT JOIN(SELECT * FROM t3) s3USING (name);
SELECT * FROM(SELECT * FROM t2) as s2FULL JOIN(SELECT * FROM t3) s3USING (name);
SELECT * FROM(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2NATURAL INNER JOIN(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
SELECT * FROM(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2NATURAL LEFT JOIN(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
SELECT * FROM(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2NATURAL FULL JOIN(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
SELECT * FROM(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1NATURAL INNER JOIN(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2NATURAL INNER JOIN(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
SELECT * FROM(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1NATURAL FULL JOIN(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2NATURAL FULL JOIN(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
SELECT * FROM(SELECT name, n as s1_n FROM t1) as s1NATURAL FULL JOIN  (SELECT * FROM    (SELECT name, n as s2_n FROM t2) as s2    NATURAL FULL JOIN    (SELECT name, n as s3_n FROM t3) as s3  ) ss2;
SELECT * FROM(SELECT name, n as s1_n FROM t1) as s1NATURAL FULL JOIN  (SELECT * FROM    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2    NATURAL FULL JOIN    (SELECT name, n as s3_n FROM t3) as s3  ) ss2;
SELECT * FROM  (SELECT name, n as s1_n FROM t1) as s1FULL JOIN  (SELECT name, 2 as s2_n FROM t2) as s2ON (s1_n = s2_n);
insert into x values (3,null);
insert into x values (5,null);
insert into y values (4,null);
select * from x left join y on (x1 = y1 and x2 is not null);
select * from x left join y on (x1 = y1 and y2 is not null);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1 and x2 is not null);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1 and y2 is not null);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1 and xx2 is not null);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1) where (x2 is not null);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1) where (y2 is not null);
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)on (x1 = xx1) where (xx2 is not null);
select count(*) from tenk1 a where unique1 in  (select unique1 from tenk1 b join tenk1 c using (unique1)   where b.unique2 = 42);
select count(*) from tenk1 x where  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and  x.unique1 = 0 and  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
begin;
set geqo = on;
set geqo_threshold = 2;
select count(*) from tenk1 x where  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and  x.unique1 = 0 and  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
rollback;
explain (costs off)select aa, bb, unique1, unique1  from tenk1 right join b on aa = unique1  where bb < bb and bb is null;
explain (costs off)select * from int8_tbl i1 left join (int8_tbl i2 join  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2order by 1, 2;
select * from int8_tbl i1 left join (int8_tbl i2 join  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2order by 1, 2;
select count(*)from  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2   from tenk1 t1   left join tenk1 t2 on t1.unique1 = t2.unique1   join tenk1 t3 on t1.unique2 = t3.unique2) ss,  tenk1 t4,  tenk1 t5where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;
explain (costs off)select a.f1, b.f1, t.thousand, t.tenthous from  tenk1 t,  (select sum(f1)+1 as f1 from int4_tbl i4a) a,  (select sum(f1) as f1 from int4_tbl i4b) bwhere b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
select a.f1, b.f1, t.thousand, t.tenthous from  tenk1 t,  (select sum(f1)+1 as f1 from int4_tbl i4a) a,  (select sum(f1) as f1 from int4_tbl i4b) bwhere b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
explain (costs off)select * from  j1_tbl full join  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
select * from  j1_tbl full join  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
explain (costs off)select count(*) from  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x  left join  (select * from tenk1 y order by y.unique2) y  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
select count(*) from  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x  left join  (select * from tenk1 y order by y.unique2) y  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;
DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
create temp table t2a () inherits (t2);
select * from t1 left join t2 on (t1.a = t2.a);
select t1.x from t1 join t3 on (t1.a = t3.x);
CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
INSERT INTO tt1 VALUES (2, NULL);
CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
set enable_hashjoin to off;
set enable_nestloop to off;
select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
reset enable_hashjoin;
reset enable_nestloop;
set work_mem to '64kB';
set enable_mergejoin to off;
explain (costs off)select count(*) from tenk1 a, tenk1 b  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
select count(*) from tenk1 a, tenk1 b  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
reset work_mem;
reset enable_mergejoin;
analyze tt3;
analyze tt4;
SELECT a.f1FROM tt4 aLEFT JOIN (        SELECT b.f1        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)        WHERE c.f1 IS NULL) AS d ON (a.f1 = d.f1)WHERE d.f1 IS NULL;
explain (costs off)select * from tt4x t1where not exists (  select 1 from tt4x t2    left join tt4x t3 on t2.c3 = t3.c1    left join ( select t5.c1 as c1                from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1              ) a1 on t3.c2 = a1.c1  where t1.c1 = t2.c2);
select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;
insert into yy values (301, NULL);
select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxxfrom yy     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy     left join xx xxa on yya.pkxx = xxa.pkxx     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;
select * from  zt2 left join zt3 on (f2 = f3)      left join zt1 on (f3 = f1)where f2 = 53;
::create temp view zv1 as select *,'dummy'::text AS junk from zt1;
select * from  zt2 left join zt3 on (f2 = f3)      left join zv1 on (f3 = f1)where f2 = 53;
select a.unique2, a.ten, b.tenthous, b.unique2, b.hundredfrom tenk1 a left join tenk1 b on a.unique2 = b.tenthouswhere a.unique1 = 42 and      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
prepare foo(bool) as  select count(*) from tenk1 a left join tenk1 b    on (a.unique2 = b.unique1 and exists        (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
execute foo(true);
execute foo(false);
begin;
set enable_mergejoin = 1;
set enable_hashjoin = 0;
set enable_nestloop = 0;
select * from a left join b on i = x and i = y and x = i;
rollback;
begin;
create type mycomptype as (id int, v bigint);
create temp table tidv (idv mycomptype);
create index on tidv (idv);
explain (costs off)select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
set enable_mergejoin = 0;
explain (costs off)select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
rollback;
select t1.q2, count(t2.*)from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)group by t1.q2 order by 1;
select t1.q2, count(t2.*)from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)group by t1.q2 order by 1;
select t1.q2, count(t2.*)from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)group by t1.q2 order by 1;
select t1.q2, count(t2.*)from int8_tbl t1 left join  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2  on (t1.q2 = t2.q1)group by t1.q2 order by 1;
begin;
create temp table a (     code char not null,     constraint a_pk primary key (code));
create temp table b (     a char not null,     num integer not null,     constraint b_pk primary key (a, num));
create temp table c (     name char not null,     a char,     constraint c_pk primary key (name));
insert into c (name, a) values ('C', null);
select c.name, ss.code, ss.b_cnt, ss.constfrom c left join  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const   from a left join     (select count(1) as cnt, b.a from b group by b.a) as b_grp     on a.code = b_grp.a  ) as ss  on (c.a = ss.code)order by c.name;
rollback;
SELECT * FROM( SELECT 1 as key1 ) sub1LEFT JOIN( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM    ( SELECT 1 as key3 ) sub3    LEFT JOIN    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM        ( SELECT 1 as key5 ) sub5        LEFT JOIN        ( SELECT 2 as key6, 42 as value1 ) sub6        ON sub5.key5 = sub6.key6    ) sub4    ON sub4.key5 = sub3.key3) sub2ON sub1.key1 = sub2.key3;
SELECT * FROM( SELECT 1 as key1 ) sub1LEFT JOIN( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM    ( SELECT 1 as key3 ) sub3    LEFT JOIN    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM        ( SELECT 1 as key5 ) sub5        LEFT JOIN        ( SELECT 2 as key6, 42 as value1 ) sub6        ON sub5.key5 = sub6.key6    ) sub4    ON sub4.key5 = sub3.key3) sub2ON sub1.key1 = sub2.key3;
EXPLAIN (COSTS OFF)SELECT qq, unique1  FROM  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1  FULL OUTER JOIN  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2  USING (qq)  INNER JOIN tenk1 c ON qq = unique2;
SELECT qq, unique1  FROM  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1  FULL OUTER JOIN  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2  USING (qq)  INNER JOIN tenk1 c ON qq = unique2;
create temp table nt2 (  id int primary key,  nt1_id int,  b1 boolean,  b2 boolean,  foreign key (nt1_id) references nt1(id));
create temp table nt3 (  id int primary key,  nt2_id int,  c1 boolean,  foreign key (nt2_id) references nt2(id));
explain (costs off)select nt3.idfrom nt3 as nt3  left join    (select nt2.*, (nt2.b1 and ss1.a3) AS b3     from nt2 as nt2       left join         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1         on ss1.id = nt2.nt1_id    ) as ss2    on ss2.id = nt3.nt2_idwhere nt3.id = 1 and ss2.b3;
select nt3.idfrom nt3 as nt3  left join    (select nt2.*, (nt2.b1 and ss1.a3) AS b3     from nt2 as nt2       left join         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1         on ss1.id = nt2.nt1_id    ) as ss2    on ss2.id = nt3.nt2_idwhere nt3.id = 1 and ss2.b3;
explain (costs off)select * from  int8_tbl t1 left join  (select q1 as x, 42 as y from int8_tbl t2) ss  on t1.q2 = ss.xwhere  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)order by 1,2;
select * from  int8_tbl t1 left join  (select q1 as x, 42 as y from int8_tbl t2) ss  on t1.q2 = ss.xwhere  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)order by 1,2;
select * from int4_tbl a full join int4_tbl b on true;
select * from int4_tbl a full join int4_tbl b on false;
analyze q1;
analyze q2;
explain (costs off)select * from  tenk1 join int4_tbl on f1 = twothousand,  q1, q2where q1 = thousand or q2 = thousand;
explain (costs off)select * from  tenk1 join int4_tbl on f1 = twothousand,  q1, q2where thousand = (q1 + q2);
explain (costs off)select * from  tenk1, int8_tbl a, int8_tbl bwhere thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;
explain (costs off)select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from  tenk1 t1  inner join int4_tbl i1    left join (select v1.x2, v2.y1, 11 AS d1               from (select 1,0 from onerow) v1(x1,x2)               left join (select 3,1 from onerow) v2(y1,y2)               on v1.x1 = v2.y2) subq1    on (i1.f1 = subq1.x2)  on (t1.unique2 = subq1.d1)  left join tenk1 t2  on (subq1.y1 = t2.unique1)where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from  tenk1 t1  inner join int4_tbl i1    left join (select v1.x2, v2.y1, 11 AS d1               from (select 1,0 from onerow) v1(x1,x2)               left join (select 3,1 from onerow) v2(y1,y2)               on v1.x1 = v2.y2) subq1    on (i1.f1 = subq1.x2)  on (t1.unique2 = subq1.d1)  left join tenk1 t2  on (subq1.y1 = t2.unique1)where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
select ss1.d1 from  tenk1 as t1  inner join tenk1 as t2  on t1.tenthous = t2.ten  inner join    int8_tbl as i8    left join int4_tbl as i4      inner join (select 64::information_schema.cardinal_number as d1                  from tenk1 t3,                       lateral (select abs(t3.unique1) + random()) ss0(x)                  where t3.fivethous < 0) as ss1      on i4.f1 = ss1.d1    on i8.q1 = i4.f1  on t1.tenthous = ss1.d1where t1.unique1 < i4.f1;
explain (costs off)select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from  tenk1 t1  inner join int4_tbl i1    left join (select v1.x2, v2.y1, 11 AS d1               from (values(1,0)) v1(x1,x2)               left join (values(3,1)) v2(y1,y2)               on v1.x1 = v2.y2) subq1    on (i1.f1 = subq1.x2)  on (t1.unique2 = subq1.d1)  left join tenk1 t2  on (subq1.y1 = t2.unique1)where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from  tenk1 t1  inner join int4_tbl i1    left join (select v1.x2, v2.y1, 11 AS d1               from (values(1,0)) v1(x1,x2)               left join (values(3,1)) v2(y1,y2)               on v1.x1 = v2.y2) subq1    on (i1.f1 = subq1.x2)  on (t1.unique2 = subq1.d1)  left join tenk1 t2  on (subq1.y1 = t2.unique1)where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
create function f_immutable_int4(i integer) returns integer as$$ begin return i; end; $$ language plpgsql immutable;
explain (costs off)select unique1 from tenk1, (select * from f_immutable_int4(1) x) xwhere x = unique1;
explain (verbose, costs off)select unique1, x.*from tenk1, (select *, random() from f_immutable_int4(1) x) xwhere x = unique1;
explain (costs off)select unique1 from tenk1, f_immutable_int4(1) x where x = unique1;
explain (costs off)select unique1 from tenk1, lateral f_immutable_int4(1) x where x = unique1;
explain (costs off)select unique1, x from tenk1 join f_immutable_int4(1) x on unique1 = x;
explain (costs off)select unique1, x from tenk1 left join f_immutable_int4(1) x on unique1 = x;
explain (costs off)select unique1, x from tenk1 right join f_immutable_int4(1) x on unique1 = x;
explain (costs off)select unique1, x from tenk1 full join f_immutable_int4(1) x on unique1 = x;
explain (costs off)select unique1 from tenk1, f_immutable_int4(1) x where x = 42;
explain (costs off)select nt3.idfrom nt3 as nt3  left join    (select nt2.*, (nt2.b1 or i4 = 42) AS b3     from nt2 as nt2       left join         f_immutable_int4(0) i4         on i4 = nt2.nt1_id    ) as ss2    on ss2.id = nt3.nt2_idwhere nt3.id = 1 and ss2.b3;
drop function f_immutable_int4(int);
create function mki8(bigint, bigint) returns int8_tbl as$$select row($1,$2)::int8_tbl$$ language sql;
create function mki4(int) returns int4_tbl as$$select row($1)::int4_tbl$$ language sql;
explain (verbose, costs off)select * from mki8(1,2);
explain (verbose, costs off)select * from mki4(42);
drop function mki8(bigint, bigint);
drop function mki4(int);
explain (costs off)select * from tenk1 a join tenk1 b on  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
explain (costs off)select * from tenk1 a join tenk1 b on  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
explain (costs off)select * from tenk1 a join tenk1 b on  (a.unique1 = 1 and b.unique1 = 2) or  ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
explain (costs off)select * from tenk1 t1 left join  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)  on t1.hundred = t2.hundred and t1.ten = t3.tenwhere t1.unique1 = 1;
explain (costs off)select * from tenk1 t1 left join  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)  on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.tenwhere t1.unique1 = 1;
explain (costs off)select count(*) from  tenk1 a join tenk1 b on a.unique1 = b.unique2  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand  join int4_tbl on b.thousand = f1;
select count(*) from  tenk1 a join tenk1 b on a.unique1 = b.unique2  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand  join int4_tbl on b.thousand = f1;
explain (costs off)select b.unique1 from  tenk1 a join tenk1 b on a.unique1 = b.unique2  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand  join int4_tbl i1 on b.thousand = f1  right join int4_tbl i2 on i2.f1 = b.tenthous  order by 1;
select b.unique1 from  tenk1 a join tenk1 b on a.unique1 = b.unique2  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand  join int4_tbl i1 on b.thousand = f1  right join int4_tbl i2 on i2.f1 = b.tenthous  order by 1;
explain (costs off)select * from  select unique1, q1, coalesce(unique1, -1) + q1 as fault  from int8_tbl left join tenk1 on (q2 = unique2)) sswhere fault = 122order by fault;
select * from  select unique1, q1, coalesce(unique1, -1) + q1 as fault  from int8_tbl left join tenk1 on (q2 = unique2)) sswhere fault = 122order by fault;
explain (costs off)select * from(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1xleft join unnest(v1ys) as u1(u1y) on u1y = v2y;
select * from(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1xleft join unnest(v1ys) as u1(u1y) on u1y = v2y;
explain (costs off)select q1, unique2, thousand, hundred  from int8_tbl a left join tenk1 b on q1 = unique2  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
select q1, unique2, thousand, hundred  from int8_tbl a left join tenk1 b on q1 = unique2  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
explain (costs off)select f1, unique2, case when unique2 is null then f1 else 0 end  from int4_tbl a left join tenk1 b on f1 = unique2  where (case when unique2 is null then f1 else 0 end) = 0;
select f1, unique2, case when unique2 is null then f1 else 0 end  from int4_tbl a left join tenk1 b on f1 = unique2  where (case when unique2 is null then f1 else 0 end) = 0;
explain (costs off)select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
explain (verbose, costs off)select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from  (values (0),(1)) foo1(join_key)left join  (select join_key, bug_field from    (select ss1.join_key, ss1.bug_field from      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1    ) foo2   left join    (select unique2 as join_key from tenk1 i2) ss2   using (join_key)  ) foo3using (join_key);
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from  (values (0),(1)) foo1(join_key)left join  (select join_key, bug_field from    (select ss1.join_key, ss1.bug_field from      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1    ) foo2   left join    (select unique2 as join_key from tenk1 i2) ss2   using (join_key)  ) foo3using (join_key);
explain (verbose, costs off)select t1.* from  text_tbl t1  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1    left join int8_tbl i8      left join (select *, null::int as d2 from int8_tbl i8b2) b2      on (i8.q1 = b2.q1)    on (b2.d2 = b1.q2)  on (t1.f1 = b1.d1)  left join int4_tbl i4  on (i8.q2 = i4.f1);
select t1.* from  text_tbl t1  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1    left join int8_tbl i8      left join (select *, null::int as d2 from int8_tbl i8b2) b2      on (i8.q1 = b2.q1)    on (b2.d2 = b1.q2)  on (t1.f1 = b1.d1)  left join int4_tbl i4  on (i8.q2 = i4.f1);
explain (verbose, costs off)select t1.* from  text_tbl t1  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1    left join int8_tbl i8      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2      on (i8.q1 = b2.q1)    on (b2.d2 = b1.q2)  on (t1.f1 = b1.d1)  left join int4_tbl i4  on (i8.q2 = i4.f1);
select t1.* from  text_tbl t1  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1    left join int8_tbl i8      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2      on (i8.q1 = b2.q1)    on (b2.d2 = b1.q2)  on (t1.f1 = b1.d1)  left join int4_tbl i4  on (i8.q2 = i4.f1);
explain (verbose, costs off)select t1.* from  text_tbl t1  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1    left join int8_tbl i8      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2                 where q1 = f1) b2      on (i8.q1 = b2.q1)    on (b2.d2 = b1.q2)  on (t1.f1 = b1.d1)  left join int4_tbl i4  on (i8.q2 = i4.f1);
select t1.* from  text_tbl t1  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1    left join int8_tbl i8      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2                 where q1 = f1) b2      on (i8.q1 = b2.q1)    on (b2.d2 = b1.q2)  on (t1.f1 = b1.d1)  left join int4_tbl i4  on (i8.q2 = i4.f1);
explain (verbose, costs off)select * from  text_tbl t1  inner join int8_tbl i8  on i8.q2 = 456  right join text_tbl t2  on t1.f1 = 'doh!'  left join int4_tbl i4  on i8.q1 = i4.f1;
select * from  text_tbl t1  inner join int8_tbl i8  on i8.q2 = 456  right join text_tbl t2  on t1.f1 = 'doh!'  left join int4_tbl i4  on i8.q1 = i4.f1;
explain (verbose, costs off)select * from  text_tbl t1  left join int8_tbl i8  on i8.q2 = 123,  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as sswhere t1.f1 = ss.f1;
select * from  text_tbl t1  left join int8_tbl i8  on i8.q2 = 123,  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as sswhere t1.f1 = ss.f1;
explain (verbose, costs off)select * from  text_tbl t1  left join int8_tbl i8  on i8.q2 = 123,  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,  lateral (select ss1.* from text_tbl t3 limit 1) as ss2where t1.f1 = ss2.f1;
select * from  text_tbl t1  left join int8_tbl i8  on i8.q2 = 123,  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,  lateral (select ss1.* from text_tbl t3 limit 1) as ss2where t1.f1 = ss2.f1;
explain (verbose, costs off)select 1 from  text_tbl as tt1  inner join text_tbl as tt2 on (tt1.f1 = 'foo')  left join text_tbl as tt3 on (tt3.f1 = 'foo')  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1where tt1.f1 = ss1.c0;
select 1 from  text_tbl as tt1  inner join text_tbl as tt2 on (tt1.f1 = 'foo')  left join text_tbl as tt3 on (tt3.f1 = 'foo')  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1where tt1.f1 = ss1.c0;
explain (verbose, costs off)select ss2.* from  int4_tbl i41  left join int8_tbl i8    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3          from int4_tbl i42, int4_tbl i43) ss1    on i8.q1 = ss1.c2  on i41.f1 = ss1.c1,  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2where ss1.c2 = 0;
select ss2.* from  int4_tbl i41  left join int8_tbl i8    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3          from int4_tbl i42, int4_tbl i43) ss1    on i8.q1 = ss1.c2  on i41.f1 = ss1.c1,  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2where ss1.c2 = 0;
explain (costs off)select * from  (select 1 as id) as xx  left join    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))  on (xx.id = coalesce(yy.id));
select * from  (select 1 as id) as xx  left join    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))  on (xx.id = coalesce(yy.id));
explain (costs off)  select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
explain (costs off)  select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
set enable_hashjoin to off;
set enable_nestloop to off;
explain (verbose, costs off)  select a.q2, b.q1    from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)    where coalesce(b.q1, 1) > 0;
select a.q2, b.q1  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)  where coalesce(b.q1, 1) > 0;
reset enable_hashjoin;
reset enable_nestloop;
begin;
INSERT INTO a VALUES (0, 0), (1, NULL);
INSERT INTO b VALUES (0, 0), (1, NULL);
explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
explain (costs off)  SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)  ON (a.b_id = b.id);
explain (costs off)select id from a where id in (	select b.id from b left join c on b.id = c.id);
explain (costs off)select d.* from d left join (select * from b group by b.id, b.c_id) s  on d.a = s.id and d.b = s.c_id;
explain (costs off)select d.* from d left join (select distinct * from b) s  on d.a = s.id and d.b = s.c_id;
explain (costs off)select d.* from d left join (select * from b group by b.id, b.c_id) s  on d.a = s.id;
explain (costs off)select d.* from d left join (select distinct * from b) s  on d.a = s.id;
explain (costs off)select d.* from d left join (select id from a union select id from b) s  on d.a = s.id;
explain (costs off)select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4  on i8.q1 = i4.f1;
explain (costs off)select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,			  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;
rollback;
select p.* from parent p left join child c on (p.k = c.k);
explain (costs off)  select p.* from parent p left join child c on (p.k = c.k);
select p.*, linked from parent p  left join (select c.*, true as linked from child c) as ss  on (p.k = ss.k);
explain (costs off)  select p.*, linked from parent p    left join (select c.*, true as linked from child c) as ss    on (p.k = ss.k);
select p.* from  parent p left join child c on (p.k = c.k)  where p.k = 1 and p.k = 2;
explain (costs off)select p.* from  parent p left join child c on (p.k = c.k)  where p.k = 1 and p.k = 2;
select p.* from  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k  where p.k = 1 and p.k = 2;
explain (costs off)select p.* from  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k  where p.k = 1 and p.k = 2;
begin;
INSERT INTO b VALUES (0, 0), (1, NULL);
SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
rollback;
begin;
create temp table innertab (id int8 primary key, dat1 int8);
SELECT * FROM    (SELECT 1 AS x) ss1  LEFT JOIN    (SELECT q1, q2, COALESCE(dat1, q1) AS y     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2  ON true;
rollback;
begin;
explain (costs off)select t1.* from  uniquetbl as t1  left join (select *, '***'::text as d1 from uniquetbl) t2  on t1.f1 = t2.f1  left join uniquetbl t3  on t2.d1 = t3.f1;
explain (costs off)select t0.*from text_tbl t0 left join   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,           t1.stringu2     from tenk1 t1     join int4_tbl i4 ON i4.f1 = t1.unique2     left join uniquetbl u1 ON u1.f1 = t1.string4) ss  on t0.f1 = ss.case1where ss.stringu2 !~* ss.case1;
select t0.*from text_tbl t0 left join   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,           t1.stringu2     from tenk1 t1     join int4_tbl i4 ON i4.f1 = t1.unique2     left join uniquetbl u1 ON u1.f1 = t1.string4) ss  on t0.f1 = ss.case1where ss.stringu2 !~* ss.case1;
rollback;
select * from  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- errorselect * from  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- errorselect * from  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- okselect t1.uunique1 from  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t1" suggestionselect t2.uunique1 from  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t2" suggestionselect uunique1 from  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at onceselect atts.relid::regclass, s.* from pg_stats s join    pg_attribute a on s.attname = a.attname and s.tablename =    a.attrelid::regclass::text join (select unnest(indkey) attnum,    indexrelid from pg_index i) atts on atts.attnum = a.attnum where    schemaname != 'pg_catalog';
select unique2, x.*from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
explain (costs off)  select unique2, x.*  from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
select unique2, x.*from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
explain (costs off)  select unique2, x.*  from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
explain (costs off)  select unique2, x.*  from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
select unique2, x.*from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
explain (costs off)  select unique2, x.*  from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;
select count(*) from tenk1 a, lateral generate_series(1,two) g;
explain (costs off)  select count(*) from tenk1 a, lateral generate_series(1,two) g;
explain (costs off)  select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
explain (costs off)  select count(*) from tenk1 a, generate_series(1,two) g;
explain (costs off)  select * from generate_series(100,200) g,    lateral (select * from int8_tbl a where g = q1 union all             select * from int8_tbl b where g = q2) ss;
select * from generate_series(100,200) g,  lateral (select * from int8_tbl a where g = q1 union all           select * from int8_tbl b where g = q2) ss;
explain (costs off)  select count(*) from tenk1 a,    tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
select count(*) from tenk1 a,  tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
explain (costs off)  select count(*) from tenk1 a,    tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
select count(*) from tenk1 a,  tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
explain (costs off)  select * from int8_tbl a,    int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)      on x.q2 = ss.z  order by a.q1, a.q2, x.q1, x.q2, ss.z;
select * from int8_tbl a,  int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)    on x.q2 = ss.z  order by a.q1, a.q2, x.q1, x.q2, ss.z;
select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,  lateral (select x) ss2(y);
select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,  lateral (values(x)) ss2(y);
select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,  lateral (select x) ss2(y);
select * from (values(1)) x(lb),  lateral generate_series(lb,4) x4;
select * from (select f1/1000000000 from int4_tbl) x(lb),  lateral generate_series(lb,4) x4;
select * from (values(1)) x(lb),  lateral (values(lb)) y(lbcopy);
select * from (values(1)) x(lb),  lateral (select lb from int4_tbl) y(lbcopy);
select * from  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,  lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
select * from  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
select x.* from  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
select v.* from  (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)  left join int4_tbl z on z.f1 = x.q2,  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
select v.* from  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)  left join int4_tbl z on z.f1 = x.q2,  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
select v.* from  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)  left join int4_tbl z on z.f1 = x.q2,  lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);
explain (verbose, costs off)select * from  int8_tbl a left join  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
select * from  int8_tbl a left join  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
explain (verbose, costs off)select * from  int8_tbl a left join  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
select * from  int8_tbl a left join  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
explain (verbose, costs off)select * from int4_tbl i left join  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
select * from int4_tbl i left join  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
explain (verbose, costs off)select * from int4_tbl i left join  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
select * from int4_tbl i left join  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
explain (verbose, costs off)select * from int4_tbl a,  lateral (    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)  ) ss;
select * from int4_tbl a,  lateral (    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)  ) ss;
explain (verbose, costs off)select * from  int8_tbl a left join lateral  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from   int8_tbl b cross join int8_tbl c) ss  on a.q2 = ss.bq1;
select * from  int8_tbl a left join lateral  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from   int8_tbl b cross join int8_tbl c) ss  on a.q2 = ss.bq1;
explain (verbose, costs off)select * from  int8_tbl c left join (    int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1      on a.q2 = ss1.q1    cross join    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2  ) on c.q2 = ss2.q1,  lateral (select ss2.y offset 0) ss3;
explain (verbose, costs off)select c.*,a.*,ss1.q1,ss2.q1,ss3.* from  int8_tbl c left join (    int8_tbl a left join      (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2       where q1 < f1) ss1      on a.q2 = ss1.q1    cross join    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2  ) on c.q2 = ss2.q1,  lateral (select * from int4_tbl i where ss2.y > f1) ss3;
explain (verbose, costs off)select * from  (select 1 as x offset 0) x cross join (select 2 as y offset 0) y  left join lateral (    select * from (select 3 as z offset 0) z where z.z = x.x  ) zz on zz.z = y.y;
explain (verbose, costs off)select * from int8_tbl i8 left join lateral  (select *, i8.q2 from int4_tbl where false) ss on true;
explain (verbose, costs off)select * from int8_tbl i8 left join lateral  (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;
select * from  ((select 2 as v) union all (select 3 as v)) as q1  cross join lateral  ((select * from      ((select 4 as v) union all (select 5 as v)) as q3)   union all   (select q1.v)  ) as q2;
explain (verbose, costs off)select * from  (values (0,9998), (1,1000)) v(id,x),  lateral (select f1 from int4_tbl           where f1 = any (select unique1 from tenk1                           where unique2 = v.x offset 0)) ss;
select * from  (values (0,9998), (1,1000)) v(id,x),  lateral (select f1 from int4_tbl           where f1 = any (select unique1 from tenk1                           where unique2 = v.x offset 0)) ss;
explain (verbose, costs off)select * from (values (0), (1)) v(id),lateral (select * from int8_tbl t1,         lateral (select * from                    (select * from int8_tbl t2                     where q1 = any (select q2 from int8_tbl t3                                     where q2 = (select greatest(t1.q1,t2.q2))                                       and (select v.id=0)) offset 0) ss2) ss         where t1.q1 = ss.q2) ss0;
select * from (values (0), (1)) v(id),lateral (select * from int8_tbl t1,         lateral (select * from                    (select * from int8_tbl t2                     where q1 = any (select q2 from int8_tbl t3                                     where q2 = (select greatest(t1.q1,t2.q2))                                       and (select v.id=0)) offset 0) ss2) ss         where t1.q1 = ss.q2) ss0;
select f1,g from int4_tbl a, (select a.f1 as g) ss;
select f1,g from int4_tbl a cross join (select f1 as g) ss;
select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
select * from  int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
create table join_pt1 (a int, b int, c varchar) partition by range(a);
create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);
create table join_pt1p2 partition of join_pt1 for values from (100) to (200);
create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);
explain (verbose, costs off)select t1.b, ss.phv from join_ut1 t1 left join lateral              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss              on t1.a = ss.t2a order by t1.a;
select t1.b, ss.phv from join_ut1 t1 left join lateral              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss              on t1.a = ss.t2a order by t1.a;
begin;
create table fkest (a int, b int, c int unique, primary key(a,b));
create table fkest1 (a int, b int, primary key(a,b));
alter table fkest1  add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;
analyze fkest;
analyze fkest1;
explain (costs off)select *from fkest f  left join fkest1 f1 on f.a = f1.a and f.b = f1.b  left join fkest1 f2 on f.a = f2.a and f.b = f2.b  left join fkest1 f3 on f.a = f3.a and f.b = f3.bwhere f.c = 1;
rollback;
analyze j1;
analyze j2;
analyze j3;
explain (verbose, costs off)select * from j1 inner join j2 on j1.id = j2.id;
explain (verbose, costs off)select * from j1 inner join j2 on j1.id > j2.id;
explain (verbose, costs off)select * from j1 inner join j3 on j1.id = j3.id;
explain (verbose, costs off)select * from j1 left join j2 on j1.id = j2.id;
explain (verbose, costs off)select * from j1 right join j2 on j1.id = j2.id;
explain (verbose, costs off)select * from j1 full join j2 on j1.id = j2.id;
explain (verbose, costs off)select * from j1 cross join j2;
explain (verbose, costs off)select * from j1 natural join j2;
explain (verbose, costs off)select * from j1inner join (select distinct id from j3) j3 on j1.id = j3.id;
explain (verbose, costs off)select * from j1inner join (select id from j3 group by id) j3 on j1.id = j3.id;
create table j1 (id1 int, id2 int, primary key(id1,id2));
create table j2 (id1 int, id2 int, primary key(id1,id2));
create table j3 (id1 int, id2 int, primary key(id1,id2));
analyze j1;
analyze j2;
analyze j3;
explain (verbose, costs off)select * from j1inner join j2 on j1.id1 = j2.id1;
explain (verbose, costs off)select * from j1inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;
explain (verbose, costs off)select * from j1inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
explain (verbose, costs off)select * from j1left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
set enable_nestloop to 0;
set enable_hashjoin to 0;
set enable_sort to 0;
analyze j2;
explain (costs off) select * from j1inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
select * from j1inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
reset enable_nestloop;
reset enable_hashjoin;
reset enable_sort;
explain (verbose, costs off)select t1.unique1, t2.hundredfrom onek t1, tenk1 t2where exists (select 1 from tenk1 t3              where t3.thousand = t1.unique1 and t3.tenthous = t2.hundred)      and t1.unique1 < 1;
vacuum analyze j3;
create unique index on j3(unique1, tenthous);
explain (verbose, costs off)select t1.unique1, t2.hundredfrom onek t1, tenk1 t2where exists (select 1 from j3              where j3.unique1 = t1.unique1 and j3.tenthous = t2.hundred)      and t1.unique1 < 1;
SELECT * FROM pg_partition_tree(NULL);
SELECT * FROM pg_partition_ancestors(NULL);
SELECT pg_partition_root(NULL);
CREATE TABLE ptif_test (a int, b int) PARTITION BY range (a);
CREATE TABLE ptif_test0 PARTITION OF ptif_test  FOR VALUES FROM (minvalue) TO (0) PARTITION BY list (b);
CREATE TABLE ptif_test01 PARTITION OF ptif_test0 FOR VALUES IN (1);
CREATE TABLE ptif_test1 PARTITION OF ptif_test  FOR VALUES FROM (0) TO (100) PARTITION BY list (b);
CREATE TABLE ptif_test11 PARTITION OF ptif_test1 FOR VALUES IN (1);
CREATE TABLE ptif_test2 PARTITION OF ptif_test  FOR VALUES FROM (100) TO (200);
CREATE TABLE ptif_test3 PARTITION OF ptif_test  FOR VALUES FROM (200) TO (maxvalue) PARTITION BY list (b);
CREATE INDEX ptif_test_index ON ONLY ptif_test (a);
CREATE INDEX ptif_test0_index ON ONLY ptif_test0 (a);
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test0_index;
ALTER INDEX ptif_test0_index ATTACH PARTITION ptif_test01_index;
CREATE INDEX ptif_test1_index ON ONLY ptif_test1 (a);
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test1_index;
ALTER INDEX ptif_test1_index ATTACH PARTITION ptif_test11_index;
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test2_index;
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test3_index;
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree('ptif_test0') p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree('ptif_test01') p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree('ptif_test3') p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree(pg_partition_root('ptif_test01')) p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree('ptif_test0_index') p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree('ptif_test01_index') p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree('ptif_test3_index') p  JOIN pg_class c ON (p.relid = c.oid);
SELECT relid, parentrelid, level, isleaf  FROM pg_partition_tree(pg_partition_root('ptif_test01_index')) p  JOIN pg_class c ON (p.relid = c.oid);
CREATE MATERIALIZED VIEW ptif_test_matview AS SELECT 1;
CREATE TABLE ptif_li_parent ();
CREATE TABLE ptif_li_child () INHERITS (ptif_li_parent);
DROP MATERIALIZED VIEW ptif_test_matview;
DROP TABLE ptif_li_parent, ptif_li_child;
CREATE VIEW street AS   SELECT r.name, r.thepath, c.cname AS cname   FROM ONLY road r, real_city c   WHERE c.outline ## r.thepath;
CREATE VIEW iexit AS   SELECT ih.name, ih.thepath,	interpt_pp(ih.thepath, r.thepath) AS exit   FROM ihighway ih, ramp r   WHERE ih.thepath ## r.thepath;
COMMENT ON VIEW noview IS 'no view';
COMMENT ON VIEW toyemp IS 'is a view';
COMMENT ON VIEW toyemp IS NULL;
CREATE TABLE view_base_table (key int PRIMARY KEY, data varchar(20));
CREATE VIEW key_dependent_view AS   SELECT * FROM view_base_table GROUP BY key;
ALTER TABLE view_base_table DROP CONSTRAINT view_base_table_pkey;  -- failsCREATE VIEW key_dependent_view_no_cols AS   SELECT FROM view_base_table GROUP BY key HAVING length(data) > 0;
COPY viewtest_tbl FROM stdin;
5	1010	1515	2020	25\.CREATE OR REPLACE VIEW viewtest AS	SELECT * FROM viewtest_tbl;
CREATE OR REPLACE VIEW viewtest AS	SELECT a FROM viewtest_tbl WHERE a <> 20;
::CREATE OR REPLACE VIEW viewtest AS	SELECT a, b::numeric FROM viewtest_tbl;
CREATE SCHEMA temp_view_test    CREATE TABLE base_table (a int, id int)    CREATE TABLE base_table2 (a int, id int);
SET search_path TO temp_view_test, public;
CREATE VIEW temp_view_test.v2 AS SELECT * FROM base_table;
CREATE VIEW temp_view_test.v3_temp AS SELECT * FROM temp_table;
CREATE SCHEMA test_view_schema    CREATE TEMP VIEW testview AS SELECT 1;
CREATE VIEW v3 AS    SELECT t1.a AS t1_a, t2.a AS t2_a    FROM base_table t1, base_table2 t2    WHERE t1.id = t2.id;
CREATE VIEW v4_temp AS    SELECT t1.a AS t1_a, t2.a AS t2_a    FROM base_table t1, temp_table t2    WHERE t1.id = t2.id;
CREATE VIEW v5_temp AS    SELECT t1.a AS t1_a, t2.a AS t2_a, t3.a AS t3_a    FROM base_table t1, base_table2 t2, temp_table t3    WHERE t1.id = t2.id and t2.id = t3.id;
CREATE VIEW v5 AS SELECT t1.id, t2.a FROM base_table t1, (SELECT * FROM base_table2) t2;
CREATE VIEW v7_temp AS SELECT t1.id, t2.a FROM base_table t1, (SELECT * FROM temp_table) t2;
CREATE VIEW v11_temp AS SELECT t1.id, t2.a FROM base_table t1, v10_temp t2;
CREATE SEQUENCE seq1;
CREATE TEMPORARY SEQUENCE seq1_temp;
CREATE VIEW v9 AS SELECT seq1.is_called FROM seq1;
CREATE VIEW v13_temp AS SELECT seq1_temp.is_called FROM seq1_temp;
SELECT relname FROM pg_class    WHERE relname LIKE 'v%'    AND relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname LIKE 'pg_temp%')    ORDER BY relname;
CREATE SCHEMA testviewschm2;
SET search_path TO testviewschm2, public;
CREATE VIEW nontemp1 AS SELECT * FROM t1 CROSS JOIN t2;
CREATE VIEW temporal1 AS SELECT * FROM t1 CROSS JOIN tt;
CREATE VIEW nontemp2 AS SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num2;
CREATE VIEW temporal2 AS SELECT * FROM t1 INNER JOIN tt ON t1.num = tt.num2;
CREATE VIEW nontemp3 AS SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num2;
CREATE VIEW temporal3 AS SELECT * FROM t1 LEFT JOIN tt ON t1.num = tt.num2;
CREATE VIEW nontemp4 AS SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num2 AND t2.value = 'xxx';
CREATE VIEW temporal4 AS SELECT * FROM t1 LEFT JOIN tt ON t1.num = tt.num2 AND tt.value = 'xxx';
SELECT relname FROM pg_class    WHERE relname LIKE 'temporal%'    AND relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname LIKE 'pg_temp%')    ORDER BY relname;
CREATE   VIEW  pubview AS SELECT * FROM tbl1 WHERE tbl1.aBETWEEN (SELECT d FROM tbl2 WHERE c = 1) AND (SELECT e FROM tbl3 WHERE f = 2)AND EXISTS (SELECT g FROM tbl4 LEFT JOIN tbl3 ON tbl4.h = tbl3.f);
SELECT count(*) FROM pg_class where relname = 'pubview'AND relnamespace IN (SELECT OID FROM pg_namespace WHERE nspname = 'testviewschm2');
CREATE   VIEW  mytempview AS SELECT * FROM tbl1 WHERE tbl1.aBETWEEN (SELECT d FROM tbl2 WHERE c = 1) AND (SELECT e FROM tbl3 WHERE f = 2)AND EXISTS (SELECT g FROM tbl4 LEFT JOIN tbl3 ON tbl4.h = tbl3.f)AND NOT EXISTS (SELECT g FROM tbl4 LEFT JOIN tmptbl ON tbl4.h = tmptbl.j);
SELECT count(*) FROM pg_class where relname LIKE 'mytempview'And relnamespace IN (SELECT OID FROM pg_namespace WHERE nspname LIKE 'pg_temp%');
CREATE VIEW mysecview2 WITH (security_barrier=true)       AS SELECT * FROM tbl1 WHERE a > 0;
CREATE VIEW mysecview3 WITH (security_barrier=false)       AS SELECT * FROM tbl1 WHERE a < 0;
CREATE VIEW mysecview4 WITH (security_barrier)       AS SELECT * FROM tbl1 WHERE a <> 0;
CREATE VIEW mysecview5 WITH (security_barrier=100)	-- Error       AS SELECT * FROM tbl1 WHERE a > 100;
CREATE VIEW mysecview6 WITH (invalid_option)		-- Error       AS SELECT * FROM tbl1 WHERE a < 100;
::::::::CREATE OR REPLACE VIEW mysecview3 WITH (security_barrier=true)       AS SELECT * FROM tbl1 WHERE a < 256;
CREATE OR REPLACE VIEW mysecview4 WITH (security_barrier=false)       AS SELECT * FROM tbl1 WHERE a <> 256;
::::::::::CREATE VIEW unspecified_types AS  SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
CREATE VIEW tt1 AS  SELECT * FROM (    VALUES       ('abc'::varchar(3), '0123456789', 42, 'abcd'::varchar(4)),       ('0123456789', 'abc'::varchar(3), 42.12, 'abc'::varchar(4))  ) vv(a,b,c,d);
::SELECT a::varchar(3) FROM tt1;
CREATE TABLE temp_view_test.tt1 (y1 int, f2 int, f3 text);
CREATE VIEW aliased_view_1 AS  select * from tt1    where exists (select 1 from tx1 where tt1.f1 = tx1.x1);
CREATE VIEW aliased_view_2 AS  select * from tt1 a1    where exists (select 1 from tx1 where a1.f1 = tx1.x1);
CREATE VIEW aliased_view_3 AS  select * from tt1    where exists (select 1 from tx1 a2 where tt1.f1 = a2.x1);
CREATE VIEW aliased_view_4 AS  select * from temp_view_test.tt1    where exists (select 1 from tt1 where temp_view_test.tt1.y1 = tt1.f1);
ALTER TABLE tx1 SET SCHEMA temp_view_test;
ALTER TABLE temp_view_test.tt1 RENAME TO tmp1;
ALTER TABLE temp_view_test.tmp1 SET SCHEMA testviewschm2;
create view view_of_joins asselect * from  (select * from (tbl1 cross join tbl2) same) ss,  (tbl3 cross join tbl4) same;
create table tt3 (ax int8, b int2, c numeric);
create view v3 as select * from tt2 join tt3 using (b,c) full join tt4 using (b);
alter table tt2 drop column d;
create view vv1 as select * from (tt5 cross join tt6) j(aa,bb,cc,dd);
alter table tt5 drop column c;
alter view v1 rename column a to x;
alter table tt7 drop column xx;
create view vv2 asselect * from (values(1,2,3,4,5)) v(a,b,c,d,e)union allselect * from tt7 full join tt8 using (x), tt8 tt8x;
create view vv3 asselect * from (values(1,2,3,4,5,6)) v(a,b,c,x,e,f)union allselect * from  tt7 full join tt8 using (x),  tt7 tt7x full join tt8 tt8x using (x);
create view vv4 asselect * from (values(1,2,3,4,5,6,7)) v(a,b,c,x,e,f,g)union allselect * from  tt7 full join tt8 using (x),  tt7 tt7x full join tt8 tt8x using (x) full join tt8 tt8y using (x);
alter table tt7 drop column zz;
create table tt7a (x date, xx int, y int);
alter table tt7a drop column xx;
create table tt8a (x timestamptz, z int);
create view vv2a asselect * from (values(now(),2,3,now(),5)) v(a,b,c,d,e)union allselect * from tt7a left join tt8a using (x), tt8a tt8ax;
alter table tt9 drop column xx;
alter table tt14t drop column f2;
create function tt14f() returns setof tt14t as$$declare    rec1 record;
begin    for rec1 in select * from tt14t    loop        return next rec1;
    end loop;
end;
$$language plpgsql;
create view tt14v as select t.* from tt14f() t;
begin;
alter table tt14t drop column f3;
rollback;
begin;
alter table tt14t alter column f4 type integer using f4::integer;
rollback;
create type nestedcomposite as (x int8_tbl);
create view tt15v as select row(i)::nestedcomposite from int8_tbl i;
select row(i.*::int8_tbl)::nestedcomposite from int8_tbl i;
create view tt16v as select * from int8_tbl i, lateral(values(i)) ss;
select * from int8_tbl i, lateral(values(i.*::int8_tbl)) ss;
create view tt17v as select * from int8_tbl i where i in (values(i));
select * from int8_tbl i where i.* in (values(i.*::int8_tbl));
create view tt18v as  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy  union all  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz;
explain (costs off) select * from tt18v;
::select 'foo'::text = any(array['abc','def','foo']::text[]);
::select 'foo'::text = any((select array['abc','def','foo']::text[]));  -- failselect 'foo'::text = any((select array['abc','def','foo']::text[])::text[]);
create view tt19v asselect 'foo'::text = any(array['abc','def','foo']::text[]) c1,       'foo'::text = any((select array['abc','def','foo']::text[])::text[]) c2;
create view tt20v asselect * from  coalesce(1,2) as c,  collation for ('x'::text) col,  current_date as d,  localtimestamp(3) as t,  cast(1+2 as int4) as i4,  cast(1+2 as int8) as i8;
create view tt21v asselect * from tt5 natural inner join tt6;
create view tt22v asselect * from tt5 natural left join tt6;
create view tt23v (col_a, col_b) asselect q1 as other_name1, q2 as other_name2 from int8_tblunionselect 42, 43;
::select pg_get_ruledef(oid, true) from pg_rewrite  where ev_class = 'tt23v'::regclass and ev_type = '1';
create view tt24v aswith cte as materialized (select r from (values(1,2),(3,4)) r)select (r).column2 as col_a, (rr).column2 as col_b from  cte join (select rr from (values(1,7),(3,8)) rr limit 2) ss  on (r).column1 = (rr).column1;
create view tt25v aswith cte as materialized (select pg_get_keywords() k)select (k).word from cte;
explain (verbose, costs off)select * from tt24v;
explain (verbose, costs off)select (r).column2 from (select r from (values(1,2),(3,4)) r limit 1) ss;
create view tt26v asselect x + y + z as c1,       (x * y) + z as c2,       x + (y * z) as c3,       (x + y) * z as c4,       x * (y + z) as c5,       x + (y + z) as c6,       x + (y # z) as c7,       (x > y) AND (y > z OR x > z) as c8,       (x > y) OR (y > z AND NOT (x > z)) as c9,       (x,y) <> ALL (values(1,2),(3,4)) as c10,       (x,y) <= ANY (values(1,2),(3,4)) as c11from (values(1,2,3)) v(x,y,z);
DROP SCHEMA temp_view_test CASCADE;
DROP SCHEMA testviewschm2 CASCADE;
CREATE TABLE xmltest (    id int,    data xml);
SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
SELECT xmlconcat(NULL);
SELECT xmlconcat(NULL, NULL);
SELECT xmlelement(name foo, text 'bar');
SELECT xmlelement(name foo, xml 'bar');
SELECT xmlelement(name foo, text 'b<a/>r');
SELECT xmlelement(name foo, xml 'b<a/>r');
SET xmlbinary TO base64;
SELECT xmlelement(name foo, bytea 'bar');
SET xmlbinary TO hex;
SELECT xmlelement(name foo, bytea 'bar');
::SELECT xmlelement(name foo, xmlattributes('2009-04-09 00:24:37'::timestamp as bar));
::SELECT xmlelement(name foo, xmlattributes('infinity'::timestamp as bar));
SELECT xmlelement(name foo, xmlattributes('<>&"''' as funny, xml 'b<a/>r' as funnier));
SELECT xmlparse(content '');
SELECT xmlparse(content '  ');
SELECT xmlparse(content 'abc');
SELECT xmlparse(content '<abc>x</abc>');
SELECT xmlparse(content '<invalidentity>&</invalidentity>');
SELECT xmlparse(content '<undefinedentity>&idontexist;</undefinedentity>');
SELECT xmlparse(content '<invalidns xmlns=''&lt;''/>');
SELECT xmlparse(content '<relativens xmlns=''relative''/>');
SELECT xmlparse(content '<twoerrors>&idontexist;</unbalanced>');
SELECT xmlparse(content '<nosuchprefix:tag/>');
SELECT xmlparse(document '   ');
SELECT xmlparse(document 'abc');
SELECT xmlparse(document '<abc>x</abc>');
SELECT xmlparse(document '<invalidentity>&</abc>');
SELECT xmlparse(document '<undefinedentity>&idontexist;</abc>');
SELECT xmlparse(document '<invalidns xmlns=''&lt;''/>');
SELECT xmlparse(document '<relativens xmlns=''relative''/>');
SELECT xmlparse(document '<twoerrors>&idontexist;</unbalanced>');
SELECT xmlparse(document '<nosuchprefix:tag/>');
SELECT xmlpi(name foo, null);
SELECT xmlpi(name xml, null);
SELECT xmlpi(name xmlstuff, null);
SELECT xmlroot(xml '<foo/>', version no value, standalone no value);
SELECT xmlroot(xml '<foo/>', version '2.0');
SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no value, standalone yes);
SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version '1.1', standalone no);
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no);
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no value);
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value);
SELECT xmlroot (  xmlelement (    name gazonk,    xmlattributes (      'val' AS name,      1 + 1 AS num    ),    xmlelement (      NAME qux,      'foo'    )  ),  version '1.0',  standalone yes);
SELECT xmlserialize(content data as character varying(20)) FROM xmltest;
SELECT xmlserialize(content 'good' as char(10));
SELECT xmlserialize(document 'bad' as text);
SELECT xml '<foo>bar</foo>' IS DOCUMENT;
SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT;
SELECT xml '<abc/>' IS NOT DOCUMENT;
SELECT xml 'abc' IS NOT DOCUMENT;
SELECT '<>' IS NOT DOCUMENT;
PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
SET XML OPTION DOCUMENT;
EXECUTE foo ('<bar/>');
EXECUTE foo ('bad');
SELECT xml '<!DOCTYPE a><a/><b/>';
SET XML OPTION CONTENT;
EXECUTE foo ('<bar/>');
EXECUTE foo ('good');
SELECT xml '<!-- in SQL:2006+ a doc is content too--> <?y z?> <!DOCTYPE a><a/>';
SELECT xml '<?xml version="1.0"?> <!-- hi--> <!DOCTYPE a><a/>';
SELECT xml '<!DOCTYPE a><a/>';
SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>';
SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>';
SELECT xml '<!DOCTYPE a><a/><b/>';
CREATE VIEW xmlview5 AS SELECT xmlparse(content '<abc>x</abc>');
CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
CREATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as char(10));
CREATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as text);
SELECT table_name, view_definition FROM information_schema.views  WHERE table_name LIKE 'xmlview%' ORDER BY 1;
SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
DO $$DECLARE  xml_declaration text := '<?xml version="1.0" encoding="ISO-8859-1"?>';
  degree_symbol text;
  res xml[];
BEGIN  -- Per the documentation, except when the server encoding is UTF8, xpath()  -- may not work on non-ASCII data.  The untranslatable_character and  -- undefined_function traps below, currently dead code, will become relevant  -- if we remove this limitation.  IF current_setting('server_encoding') <> 'UTF8' THEN    RAISE LOG 'skip: encoding % unsupported for xpath',      current_setting('server_encoding');
    RETURN;
  END IF;
  degree_symbol := convert_from('\xc2b0', 'UTF8');
  res := xpath('text()', (xml_declaration ||    '<x>' || degree_symbol || '</x>')::xml);
  IF degree_symbol <> res[1]::text THEN    RAISE 'expected % (%), got % (%)',      degree_symbol, convert_to(degree_symbol, 'UTF8'),      res[1], convert_to(res[1]::text, 'UTF8');
  END IF;
EXCEPTION  -- character with byte sequence 0xc2 0xb0 in encoding "UTF8" has no equivalent in encoding "LATIN8"  WHEN untranslatable_character  -- default conversion function for encoding "UTF8" to "MULE_INTERNAL" does not exist  OR undefined_function  -- unsupported XML feature  OR feature_not_supported THEN    RAISE LOG 'skip: %', SQLERRM;
END$$;
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
SELECT xmlexists('//town[text() = ''Cwmbran'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
SELECT xmlexists('count(/nosuchtag)' PASSING BY REF '<root/>');
::::::::::::::SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING data);
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING BY REF data BY REF);
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers' PASSING BY REF data);
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers/name[text() = ''Molson'']' PASSING BY REF data);
SELECT COUNT(id) FROM xmltest, query WHERE xmlexists(expr PASSING BY REF data);
SET xmloption TO DOCUMENT;
SET xmloption TO CONTENT;
\\set VERBOSITY terseSELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
\\set VERBOSITY defaultSELECT xpath('/*', '<nosuchprefix:tag/>');
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/passwd">]><foo>&c;</foo>');
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c;</foo>');
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"><chapter>&nbsp;</chapter>');
CREATE TABLE xmldata(data xml);
SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
CREATE VIEW xmltableview1 AS SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
\\sv xmltableview1EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1;
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM xmltableview1;
SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),                      '/zz:rows/zz:row'                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'                      COLUMNS a int PATH 'zz:a');
CREATE VIEW xmltableview2 AS SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),                      '/zz:rows/zz:row'                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'                      COLUMNS a int PATH 'zz:a');
SELECT * FROM XMLTABLE(XMLNAMESPACES(DEFAULT 'http://x.y'),                      '/rows/row'                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'                      COLUMNS a int PATH 'a');
SELECT * FROM XMLTABLE('.'                       PASSING '<foo/>'                       COLUMNS a text PATH 'foo/namespace::node()');
PREPARE pp ASSELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
EXECUTE pp;
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int);
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY, "COUNTRY_NAME" text, "REGION_ID" int);
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int);
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id');
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY);
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH '.');
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH './*');
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text);
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text PATH 'element/text()'); -- should failselect * from xmltable('d/r' passing '<d><r><c><![CDATA[<hello> &"<>!<a>foo</a>]]></c></r><r><c>2</c></r></d>' columns c text);
SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent text);
SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent xml);
EXPLAIN (VERBOSE, COSTS OFF)SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) WHERE "COUNTRY_NAME" = 'Japan';
EXPLAIN (VERBOSE, COSTS OFF)SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) WHERE "COUNTRY_NAME" = 'Japan';
SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')  WHERE region_id = 2;
EXPLAIN (VERBOSE, COSTS OFF)SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE',                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')  WHERE region_id = 2;
SELECT  xmltable.*   FROM (SELECT data FROM xmldata) x,        LATERAL XMLTABLE('/ROWS/ROW'                         PASSING data                         COLUMNS id int PATH '@id',                                  _id FOR ORDINALITY,                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,                                  country_id text PATH 'COUNTRY_ID',                                  region_id int PATH 'REGION_ID',                                  size float PATH 'SIZE' NOT NULL,                                  unit text PATH 'SIZE/@unit',                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
::WITH   x AS (SELECT proname, proowner, procost::numeric, pronargs,                array_to_string(proargnames,',') as proargnames,                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes           FROM pg_proc WHERE proname = 'f_leak'),   y AS (SELECT xmlelement(name proc,                           xmlforest(proname, proowner,                                     procost, pronargs,                                     proargnames, proargtypes)) as proc           FROM x),   z AS (SELECT xmltable.*           FROM y,                LATERAL xmltable('/proc' PASSING proc                                 COLUMNS proname name,                                         proowner oid,                                         procost float,                                         pronargs int,                                         proargnames text,                                         proargtypes text))   SELECT * FROM z   EXCEPT SELECT * FROM x;
::WITH   x AS (SELECT proname, proowner, procost::numeric, pronargs,                array_to_string(proargnames,',') as proargnames,                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes           FROM pg_proc),   y AS (SELECT xmlelement(name data,                           xmlagg(xmlelement(name proc,                                             xmlforest(proname, proowner, procost,                                                       pronargs, proargnames, proargtypes)))) as doc           FROM x),   z AS (SELECT xmltable.*           FROM y,                LATERAL xmltable('/data/proc' PASSING doc                                 COLUMNS proname name,                                         proowner oid,                                         procost float,                                         pronargs int,                                         proargnames text,                                         proargtypes text))   SELECT * FROM z   EXCEPT SELECT * FROM x;
CREATE TABLE xmltest2(x xml, _path text);
SELECT xmltable.* FROM xmltest2, LATERAL xmltable('/d/r' PASSING x COLUMNS a int PATH '' || lower(_path) || 'c');
SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH '.');
SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH 'x' DEFAULT ascii(_path) - 54);
SELECT * FROM XMLTABLE('*' PASSING '<a>a</a>' COLUMNS a xml PATH '.', b text PATH '.', c text PATH '"hi"', d boolean PATH '. = "a"', e integer PATH 'string-length(.)');
\\xSELECT * FROM XMLTABLE('*' PASSING '<e>pre<!--c1--><?pi arg?><![CDATA[&ent1]]><n2>&amp;deep</n2>post</e>' COLUMNS x xml PATH 'node()', y xml PATH '/');
\\xSELECT * FROM XMLTABLE('.' PASSING XMLELEMENT(NAME a) columns a varchar(20) PATH '"<foo/>"', b xml PATH '"<foo/>"');
CREATE TEMP TABLE foo (f1 serial, f2 text, f3 int default 42);
INSERT INTO foo (f2,f3)  VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9)  RETURNING *, f1+f3 AS sum;
UPDATE foo SET f2 = lower(f2), f3 = DEFAULT RETURNING foo.*, f1+f3 AS sum13;
DELETE FROM foo WHERE f1 > 2 RETURNING f3, f2, f1, least(f1,f3);
INSERT INTO foo SELECT f1+10, f2, f3+99 FROM foo  RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,    EXISTS(SELECT * FROM int4_tbl) AS initplan;
UPDATE foo SET f3 = f3 * 2  WHERE f1 > 10  RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,    EXISTS(SELECT * FROM int4_tbl) AS initplan;
DELETE FROM foo  WHERE f1 > 10  RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,    EXISTS(SELECT * FROM int4_tbl) AS initplan;
UPDATE foo SET f3 = f3*2  FROM int4_tbl i  WHERE foo.f1 + 123455 = i.f1  RETURNING foo.*, i.f1 as "i.f1";
DELETE FROM foo  USING int4_tbl i  WHERE foo.f1 + 123455 = i.f1  RETURNING foo.*, i.f1 as "i.f1";
CREATE TEMP TABLE foochild (fc int) INHERITS (foo);
ALTER TABLE foo ADD COLUMN f4 int8 DEFAULT 99;
UPDATE foo SET f4 = f4 + f3 WHERE f4 = 99 RETURNING *;
UPDATE foo SET f3 = f3*2  FROM int8_tbl i  WHERE foo.f1 = i.q2  RETURNING *;
DELETE FROM foo  USING int8_tbl i  WHERE foo.f1 = i.q2  RETURNING *;
CREATE RULE voo_i AS ON INSERT TO voo DO INSTEAD  INSERT INTO foo VALUES(new.*, 57);
INSERT INTO voo VALUES(12,'zoo') RETURNING *, f1*2;
CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD  INSERT INTO foo VALUES(new.*, 57) RETURNING *;
CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD  INSERT INTO foo VALUES(new.*, 57) RETURNING f1, f2;
INSERT INTO voo VALUES(14,'zoo2') RETURNING *;
CREATE OR REPLACE RULE voo_u AS ON UPDATE TO voo DO INSTEAD  UPDATE foo SET f1 = new.f1, f2 = new.f2 WHERE f1 = old.f1  RETURNING f1, f2;
update voo set f1 = f1 + 1 where f2 = 'zoo2' RETURNING *, f1*2;
CREATE OR REPLACE RULE voo_d AS ON DELETE TO voo DO INSTEAD  DELETE FROM foo WHERE f1 = old.f1  RETURNING f1, f2;
DELETE FROM foo WHERE f1 = 13;
DELETE FROM foo WHERE f2 = 'zit' RETURNING *;
CREATE TEMP VIEW joinview AS  SELECT foo.*, other FROM foo JOIN joinme ON (f2 = f2j);
CREATE RULE joinview_u AS ON UPDATE TO joinview DO INSTEAD  UPDATE foo SET f1 = new.f1, f3 = new.f3    FROM joinme WHERE f2 = f2j AND f2 = old.f2    RETURNING foo.*, other;
UPDATE joinview SET f1 = f1 + 1 WHERE f3 = 57 RETURNING *, other + 1;
INSERT INTO foo AS bar DEFAULT VALUES RETURNING *; -- okINSERT INTO foo AS bar DEFAULT VALUES RETURNING foo.*; -- fails, wrong nameINSERT INTO foo AS bar DEFAULT VALUES RETURNING bar.*; -- okINSERT INTO foo AS bar DEFAULT VALUES RETURNING bar.f3; -- okSET transaction_read_only = off;
begin transaction read write;
commit;
select * from hs1 FOR SHARE;
select * from hs1 FOR UPDATE;
BEGIN;
ROLLBACK;
BEGIN;
delete from hs1 where col1 = 1;
ROLLBACK;
BEGIN;
update hs1 set col1 = NULL where col1 > 0;
ROLLBACK;
BEGIN;
truncate hs3;
ROLLBACK;
BEGIN;
ROLLBACK;
BEGIN;
ROLLBACK;
BEGIN;
PREPARE TRANSACTION 'foobar';
ROLLBACK;
BEGIN;
COMMIT PREPARED 'foobar';
ROLLBACK;
BEGIN;
PREPARE TRANSACTION 'foobar';
ROLLBACK PREPARED 'foobar';
ROLLBACK;
BEGIN;
ROLLBACK PREPARED 'foobar';
ROLLBACK;
BEGIN;
LOCK hs1;
COMMIT;
BEGIN;
LOCK hs1 IN SHARE UPDATE EXCLUSIVE MODE;
COMMIT;
BEGIN;
LOCK hs1 IN SHARE MODE;
COMMIT;
BEGIN;
LOCK hs1 IN SHARE ROW EXCLUSIVE MODE;
COMMIT;
BEGIN;
LOCK hs1 IN EXCLUSIVE MODE;
COMMIT;
BEGIN;
LOCK hs1 IN ACCESS EXCLUSIVE MODE;
COMMIT;
listen a;
notify a;
ANALYZE hs1;
VACUUM hs2;
CLUSTER hs2 using hs1_pkey;
REVOKE SELECT ON hs1 FROM PUBLIC;
GRANT SELECT ON hs1 TO PUBLIC;
/* Test inheritance of structure (LIKE) */CREATE TABLE inhx (xx text DEFAULT 'text');
/* * Test double inheritance * * Ensure that defaults are NOT included unless * INCLUDING DEFAULTS is specified */CREATE TABLE ctla (aa TEXT);
CREATE TABLE ctlb (bb TEXT) INHERITS (ctla);
CREATE TABLE foo (LIKE nonexistent);
CREATE TABLE inhe (ee text, LIKE inhx) inherits (ctlb);
INSERT INTO inhe VALUES ('ee-col1', 'ee-col2', DEFAULT, 'ee-col4');
SELECT * FROM inhe; /* Columns aa, bb, xx value NULL, ee */SELECT * FROM inhx; /* Empty set since LIKE inherits structure only */SELECT * FROM ctlb; /* Has ee entry */SELECT * FROM ctla; /* Has ee entry */CREATE TABLE inhf (LIKE inhx, LIKE inhx); /* Throw error */CREATE TABLE inhf (LIKE inhx INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
SELECT * FROM inhf; /* Single entry with value 'text' */ALTER TABLE inhx add constraint foo CHECK (xx = 'text');
ALTER TABLE inhx ADD PRIMARY KEY (xx);
CREATE TABLE inhg (LIKE inhx); /* Doesn't copy constraint */INSERT INTO inhg VALUES ('foo');
CREATE TABLE inhg (x text, LIKE inhx INCLUDING CONSTRAINTS, y text); /* Copies constraints */INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds */INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds -- Unique constraints not copied */INSERT INTO inhg VALUES ('x', 'foo',  'y');  /* fails due to constraint */SELECT * FROM inhg; /* Two records with three columns in order x=x, xx=text, y=y */DROP TABLE inhg;
CREATE TABLE test_like_id_1 (a bigint GENERATED ALWAYS AS IDENTITY, b text);
CREATE TABLE test_like_id_2 (LIKE test_like_id_1);
SELECT * FROM test_like_id_2;  -- identity was not copiedCREATE TABLE test_like_id_3 (LIKE test_like_id_1 INCLUDING IDENTITY);
SELECT * FROM test_like_id_3;  -- identity was copied and appliedDROP TABLE test_like_id_1, test_like_id_2, test_like_id_3;
CREATE TABLE test_like_gen_1 (a int, b int GENERATED ALWAYS AS (a * 2) STORED);
CREATE TABLE test_like_gen_2 (LIKE test_like_gen_1);
CREATE TABLE test_like_gen_3 (LIKE test_like_gen_1 INCLUDING GENERATED);
DROP TABLE test_like_gen_1, test_like_gen_2, test_like_gen_3;
CREATE TABLE test_like_4 (a int, b int DEFAULT 42, c int GENERATED ALWAYS AS (a * 2) STORED);
CREATE TABLE test_like_4a (LIKE test_like_4);
CREATE TABLE test_like_4b (LIKE test_like_4 INCLUDING DEFAULTS);
CREATE TABLE test_like_4c (LIKE test_like_4 INCLUDING GENERATED);
CREATE TABLE test_like_4d (LIKE test_like_4 INCLUDING DEFAULTS INCLUDING GENERATED);
TABLE test_like_4a;
TABLE test_like_4b;
TABLE test_like_4c;
TABLE test_like_4d;
DROP TABLE test_like_4, test_like_4a, test_like_4b, test_like_4c, test_like_4d;
CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, y text); /* copies indexes */INSERT INTO inhg VALUES (5, 10);
INSERT INTO inhg VALUES (20, 10); -- should failDROP TABLE inhg;
/* Multiple primary keys creation should fail */CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x)); /* fails */CREATE TABLE inhz (xx text DEFAULT 'text', yy int UNIQUE);
CREATE UNIQUE INDEX inhz_xx_idx on inhz (xx) WHERE xx <> 'test';
/* Ok to create multiple unique indexes */CREATE TABLE inhg (x text UNIQUE, LIKE inhz INCLUDING INDEXES);
INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15); -- should failDROP TABLE inhg;
||CREATE STATISTICS ctlt1_a_b_stat ON a,b FROM ctlt1;
COMMENT ON STATISTICS ctlt1_a_b_stat IS 'ab stats';
COMMENT ON COLUMN ctlt1.a IS 'A';
COMMENT ON COLUMN ctlt1.b IS 'B';
COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
ALTER TABLE ctlt1 ALTER COLUMN a SET STORAGE MAIN;
ALTER TABLE ctlt2 ALTER COLUMN c SET STORAGE EXTERNAL;
COMMENT ON COLUMN ctlt2.c IS 'C';
ALTER TABLE ctlt3 ALTER COLUMN c SET STORAGE EXTERNAL;
ALTER TABLE ctlt3 ALTER COLUMN a SET STORAGE MAIN;
COMMENT ON COLUMN ctlt3.a IS 'A3';
COMMENT ON COLUMN ctlt3.c IS 'C';
COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
ALTER TABLE ctlt4 ALTER COLUMN c SET STORAGE EXTERNAL;
CREATE TABLE ctlt12_storage (LIKE ctlt1 INCLUDING STORAGE, LIKE ctlt2 INCLUDING STORAGE);
CREATE TABLE ctlt12_comments (LIKE ctlt1 INCLUDING COMMENTS, LIKE ctlt2 INCLUDING COMMENTS);
CREATE TABLE ctlt1_inh (LIKE ctlt1 INCLUDING CONSTRAINTS INCLUDING COMMENTS) INHERITS (ctlt1);
::SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt1_inh'::regclass;
CREATE TABLE ctlt13_inh () INHERITS (ctlt1, ctlt3);
CREATE TABLE ctlt13_like (LIKE ctlt3 INCLUDING CONSTRAINTS INCLUDING COMMENTS INCLUDING STORAGE) INHERITS (ctlt1);
::SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt13_like'::regclass;
CREATE TABLE ctlt_all (LIKE ctlt1 INCLUDING ALL);
SELECT c.relname, objsubid, description FROM pg_description, pg_index i, pg_class c WHERE classoid = 'pg_class'::regclass AND objoid = i.indexrelid AND c.oid = i.indexrelid AND i.indrelid = 'ctlt_all'::regclass ORDER BY c.relname, objsubid;
SELECT s.stxname, objsubid, description FROM pg_description, pg_statistic_ext s WHERE classoid = 'pg_statistic_ext'::regclass AND objoid = s.oid AND s.stxrelid = 'ctlt_all'::regclass ORDER BY s.stxname, objsubid;
CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
DROP TABLE ctlt1, ctlt2, ctlt3, ctlt4, ctlt12_storage, ctlt12_comments, ctlt1_inh, ctlt13_inh, ctlt13_like, ctlt_all, ctla, ctlb CASCADE;
/* LIKE with other relation kinds */CREATE TABLE ctlt4 (a int, b text);
CREATE SEQUENCE ctlseq1;
CREATE TABLE ctlt10 (LIKE ctlseq1);  -- failCREATE VIEW ctlv1 AS SELECT * FROM ctlt4;
CREATE TABLE ctlt11 (LIKE ctlv1);
CREATE TABLE ctlt11a (LIKE ctlv1 INCLUDING ALL);
CREATE TYPE ctlty1 AS (a int, b text);
CREATE TABLE ctlt12 (LIKE ctlty1);
DROP SEQUENCE ctlseq1;
DROP TYPE ctlty1;
DROP TABLE IF EXISTS ctlt4, ctlt10, ctlt11, ctlt11a, ctlt12;
set timezone_abbreviations = 'Australia';
set timezone_abbreviations = 'India';
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_foreign_data_user, regress_test_role, regress_test_role2, regress_test_role_super, regress_test_indirect, regress_unprivileged_role;
RESET client_min_messages;
CREATE ROLE regress_foreign_data_user LOGIN SUPERUSER;
SET SESSION AUTHORIZATION 'regress_foreign_data_user';
CREATE ROLE regress_test_role;
CREATE ROLE regress_test_role2;
CREATE ROLE regress_test_role_super SUPERUSER;
CREATE ROLE regress_test_indirect;
CREATE ROLE regress_unprivileged_role;
CREATE FOREIGN DATA WRAPPER dummy;
COMMENT ON FOREIGN DATA WRAPPER dummy IS 'useless';
CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;
::::SELECT fdwname, fdwhandler::regproc, fdwvalidator::regproc, fdwoptions FROM pg_foreign_data_wrapper ORDER BY 1, 2, 3;
CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;            -- ERRORCREATE FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foo; -- duplicateDROP FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
DROP FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');   -- ERRORCREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
DROP FOREIGN DATA WRAPPER foo;
SET ROLE regress_test_role;
CREATE FOREIGN DATA WRAPPER foo; -- ERRORRESET ROLE;
CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
CREATE FUNCTION invalid_fdw_handler() RETURNS int LANGUAGE SQL AS 'SELECT 1;';
CREATE FOREIGN DATA WRAPPER test_fdw HANDLER invalid_fdw_handler;  -- ERRORCREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler HANDLER invalid_fdw_handler;  -- ERRORCREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler;
DROP FOREIGN DATA WRAPPER test_fdw;
ALTER FOREIGN DATA WRAPPER foo;                             -- ERRORALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;               -- ERRORALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '1', b '2');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');         -- ERRORALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);            -- ERRORALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP a, SET b '3', ADD c '4');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '2');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');             -- ERRORSET ROLE regress_test_role;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');         -- ERRORSET ROLE regress_test_role_super;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role;  -- ERRORALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role_super;
ALTER ROLE regress_test_role_super NOSUPERUSER;
SET ROLE regress_test_role_super;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');         -- ERRORRESET ROLE;
ALTER FOREIGN DATA WRAPPER foo RENAME TO foo1;
ALTER FOREIGN DATA WRAPPER foo1 RENAME TO foo;
ALTER FOREIGN DATA WRAPPER foo HANDLER invalid_fdw_handler;  -- ERRORALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler HANDLER anything;  -- ERRORALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler;
DROP FUNCTION invalid_fdw_handler();
DROP FOREIGN DATA WRAPPER nonexistent;                      -- ERRORDROP FOREIGN DATA WRAPPER IF EXISTS nonexistent;
DROP ROLE regress_test_role_super;                          -- ERRORSET ROLE regress_test_role_super;
DROP FOREIGN DATA WRAPPER foo;
RESET ROLE;
DROP ROLE regress_test_role_super;
CREATE FOREIGN DATA WRAPPER foo;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
COMMENT ON SERVER s1 IS 'foreign server';
CREATE USER MAPPING FOR current_user SERVER s1;
CREATE USER MAPPING FOR current_user SERVER s1;				-- ERRORCREATE USER MAPPING IF NOT EXISTS FOR current_user SERVER s1; -- NOTICEDROP FOREIGN DATA WRAPPER foo;                              -- ERRORSET ROLE regress_test_role;
DROP FOREIGN DATA WRAPPER foo CASCADE;                      -- ERRORRESET ROLE;
DROP FOREIGN DATA WRAPPER foo CASCADE;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERRORCREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERRORCREATE SERVER IF NOT EXISTS s1 FOREIGN DATA WRAPPER foo;	-- No ERROR, just NOTICECREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s3 TYPE 'oracle' FOREIGN DATA WRAPPER foo;
CREATE SERVER s4 TYPE 'oracle' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s5 VERSION '15.0' FOREIGN DATA WRAPPER foo;
CREATE SERVER s6 VERSION '16.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s7 TYPE 'oracle' VERSION '17.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1'); -- ERRORCREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (host 'localhost', dbname 's8db');
SET ROLE regress_test_role;
CREATE SERVER t1 FOREIGN DATA WRAPPER foo;                 -- ERROR: no usage on FDWRESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
SET ROLE regress_test_role;
CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
RESET ROLE;
REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_test_role;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
SET ROLE regress_test_role;
CREATE SERVER t2 FOREIGN DATA WRAPPER foo;                 -- ERRORRESET ROLE;
GRANT regress_test_indirect TO regress_test_role;
SET ROLE regress_test_role;
CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
RESET ROLE;
REVOKE regress_test_indirect FROM regress_test_role;
ALTER SERVER s0;                                            -- ERRORALTER SERVER s0 OPTIONS (a '1');                            -- ERRORALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
ALTER SERVER s2 VERSION '1.1';
ALTER SERVER s3 OPTIONS ("tns name" 'orcl', port '1521');
GRANT USAGE ON FOREIGN SERVER s1 TO regress_test_role;
GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role2 WITH GRANT OPTION;
SET ROLE regress_test_role;
ALTER SERVER s1 VERSION '1.1';                              -- ERRORALTER SERVER s1 OWNER TO regress_test_role;                 -- ERRORRESET ROLE;
ALTER SERVER s1 OWNER TO regress_test_role;
GRANT regress_test_role2 TO regress_test_role;
SET ROLE regress_test_role;
ALTER SERVER s1 VERSION '1.1';
ALTER SERVER s1 OWNER TO regress_test_role2;                -- ERRORRESET ROLE;
ALTER SERVER s8 OPTIONS (foo '1');                          -- ERROR option validationALTER SERVER s8 OPTIONS (connect_timeout '30', SET dbname 'db1', DROP host);
SET ROLE regress_test_role;
ALTER SERVER s1 OWNER TO regress_test_indirect;             -- ERRORRESET ROLE;
GRANT regress_test_indirect TO regress_test_role;
SET ROLE regress_test_role;
ALTER SERVER s1 OWNER TO regress_test_indirect;
RESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
SET ROLE regress_test_role;
ALTER SERVER s1 OWNER TO regress_test_indirect;
RESET ROLE;
DROP ROLE regress_test_indirect;                            -- ERRORALTER SERVER s8 RENAME to s8new;
ALTER SERVER s8new RENAME to s8;
DROP SERVER nonexistent;                                    -- ERRORDROP SERVER IF EXISTS nonexistent;
SET ROLE regress_test_role;
DROP SERVER s2;                                             -- ERRORDROP SERVER s1;
RESET ROLE;
ALTER SERVER s2 OWNER TO regress_test_role;
SET ROLE regress_test_role;
DROP SERVER s2;
RESET ROLE;
CREATE USER MAPPING FOR current_user SERVER s3;
DROP SERVER s3;                                             -- ERRORDROP SERVER s3 CASCADE;
CREATE USER MAPPING FOR regress_test_missing_role SERVER s1;  -- ERRORCREATE USER MAPPING FOR current_user SERVER s1;             -- ERRORCREATE USER MAPPING FOR current_user SERVER s4;
CREATE USER MAPPING FOR user SERVER s4;                     -- ERROR duplicateCREATE USER MAPPING FOR public SERVER s4 OPTIONS ("this mapping" 'is public');
CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');    -- ERRORCREATE USER MAPPING FOR user SERVER s8 OPTIONS (user 'test', password 'secret');
ALTER SERVER s5 OWNER TO regress_test_role;
ALTER SERVER s6 OWNER TO regress_test_indirect;
SET ROLE regress_test_role;
CREATE USER MAPPING FOR current_user SERVER s5;
CREATE USER MAPPING FOR current_user SERVER s6 OPTIONS (username 'test');
CREATE USER MAPPING FOR current_user SERVER s7;             -- ERRORCREATE USER MAPPING FOR public SERVER s8;                   -- ERRORRESET ROLE;
ALTER SERVER t1 OWNER TO regress_test_indirect;
SET ROLE regress_test_role;
CREATE USER MAPPING FOR current_user SERVER t1 OPTIONS (username 'bob', password 'boo');
CREATE USER MAPPING FOR public SERVER t1;
RESET ROLE;
ALTER USER MAPPING FOR regress_test_missing_role SERVER s4 OPTIONS (gotcha 'true'); -- ERRORALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true'); -- ERRORALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');            -- ERRORALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');    -- ERRORALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (DROP user, SET password 'public');
SET ROLE regress_test_role;
ALTER USER MAPPING FOR current_user SERVER s5 OPTIONS (ADD modified '1');
ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1'); -- ERRORALTER USER MAPPING FOR public SERVER t1 OPTIONS (ADD modified '1');
RESET ROLE;
DROP USER MAPPING FOR regress_test_missing_role SERVER s4;  -- ERRORDROP USER MAPPING FOR user SERVER ss4;
DROP USER MAPPING FOR public SERVER s7;                     -- ERRORDROP USER MAPPING IF EXISTS FOR regress_test_missing_role SERVER s4;
DROP USER MAPPING IF EXISTS FOR user SERVER ss4;
DROP USER MAPPING IF EXISTS FOR public SERVER s7;
CREATE USER MAPPING FOR public SERVER s8;
SET ROLE regress_test_role;
DROP USER MAPPING FOR public SERVER s8;                     -- ERRORRESET ROLE;
DROP SERVER s7;
CREATE SCHEMA foreign_schema;
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
CREATE FOREIGN TABLE ft1 ();                                    -- ERRORCREATE FOREIGN TABLE ft1 () SERVER no_server;                   -- ERRORCREATE FOREIGN TABLE ft1 (	c1 integer OPTIONS ("param 1" 'val1') PRIMARY KEY,	c2 text OPTIONS (param2 'val2', param3 'val3'),	c3 date) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value'); -- ERRORCREATE TABLE ref_table (id integer PRIMARY KEY);
CREATE FOREIGN TABLE ft1 (	c1 integer OPTIONS ("param 1" 'val1') REFERENCES ref_table (id),	c2 text OPTIONS (param2 'val2', param3 'val3'),	c3 date) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value'); -- ERRORDROP TABLE ref_table;
CREATE FOREIGN TABLE ft1 (	c1 integer OPTIONS ("param 1" 'val1') NOT NULL,	c2 text OPTIONS (param2 'val2', param3 'val3'),	c3 date,	UNIQUE (c3)) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value'); -- ERRORCREATE FOREIGN TABLE ft1 (	c1 integer OPTIONS ("param 1" 'val1') NOT NULL,	c2 text OPTIONS (param2 'val2', param3 'val3') CHECK (c2 <> ''),	c3 date,	CHECK (c3 BETWEEN '1994-01-01'::date AND '1994-01-31'::date)) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
COMMENT ON FOREIGN TABLE ft1 IS 'ft1';
COMMENT ON COLUMN ft1.c1 IS 'ft1.c1';
CREATE INDEX id_ft1_c2 ON ft1 (c2);                             -- ERRORSELECT * FROM ft1;                                              -- ERROREXPLAIN SELECT * FROM ft1;                                      -- ERRORCREATE TABLE lt1 (a INT) PARTITION BY RANGE (a);
CREATE FOREIGN TABLE ft_part1  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
CREATE INDEX ON lt1 (a);                              -- skips partitionCREATE UNIQUE INDEX ON lt1 (a);                                 -- ERRORALTER TABLE lt1 ADD PRIMARY KEY (a);                            -- ERRORDROP TABLE lt1;
CREATE TABLE lt1 (a INT) PARTITION BY RANGE (a);
CREATE INDEX ON lt1 (a);
CREATE FOREIGN TABLE ft_part1  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
CREATE FOREIGN TABLE ft_part2 (a INT) SERVER s0;
ALTER TABLE lt1 ATTACH PARTITION ft_part2 FOR VALUES FROM (1000) TO (2000);
DROP FOREIGN TABLE ft_part1, ft_part2;
CREATE UNIQUE INDEX ON lt1 (a);
ALTER TABLE lt1 ADD PRIMARY KEY (a);
CREATE FOREIGN TABLE ft_part1  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;     -- ERRORCREATE FOREIGN TABLE ft_part2 (a INT NOT NULL) SERVER s0;
ALTER TABLE lt1 ATTACH PARTITION ft_part2  FOR VALUES FROM (1000) TO (2000);                             -- ERRORDROP TABLE lt1;
DROP FOREIGN TABLE ft_part2;
CREATE TABLE lt1 (a INT) PARTITION BY RANGE (a);
CREATE INDEX ON lt1 (a);
CREATE TABLE lt1_part1  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000)  PARTITION BY RANGE (a);
CREATE FOREIGN TABLE ft_part_1_1  PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_2 (a INT) SERVER s0;
ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
CREATE UNIQUE INDEX ON lt1 (a);
ALTER TABLE lt1 ADD PRIMARY KEY (a);
DROP FOREIGN TABLE ft_part_1_1, ft_part_1_2;
CREATE UNIQUE INDEX ON lt1 (a);
ALTER TABLE lt1 ADD PRIMARY KEY (a);
CREATE FOREIGN TABLE ft_part_1_1  PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_2 (a INT NOT NULL) SERVER s0;
ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
DROP FOREIGN TABLE ft_part_1_2;
COMMENT ON FOREIGN TABLE ft1 IS 'foreign table';
COMMENT ON FOREIGN TABLE ft1 IS NULL;
COMMENT ON COLUMN ft1.c1 IS 'foreign column';
COMMENT ON COLUMN ft1.c1 IS NULL;
ALTER FOREIGN TABLE ft1 ADD COLUMN c4 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c5 integer DEFAULT 0;
ALTER FOREIGN TABLE ft1 ADD COLUMN c6 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c7 integer NOT NULL;
ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c9 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
ALTER FOREIGN TABLE ft1 ALTER COLUMN c4 SET DEFAULT 0;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c5 DROP DEFAULT;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c6 SET NOT NULL;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 DROP NOT NULL;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0'; -- ERRORALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1'); -- ERRORALTER FOREIGN TABLE ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),                        ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET STATISTICS 10000;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET (n_distinct = 100);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STATISTICS -1;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STORAGE PLAIN;
CREATE TABLE use_ft1_column_type (x ft1);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;	-- ERRORDROP TABLE use_ft1_column_type;
ALTER FOREIGN TABLE ft1 ADD PRIMARY KEY (c7);                   -- ERRORALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c9 < 0) NOT VALID;
ALTER FOREIGN TABLE ft1 ALTER CONSTRAINT ft1_c9_check DEFERRABLE; -- ERRORALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c9_check;
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;               -- ERRORALTER FOREIGN TABLE ft1 DROP CONSTRAINT IF EXISTS no_const;
ALTER FOREIGN TABLE ft1 OWNER TO regress_test_role;
ALTER FOREIGN TABLE ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;                  -- ERRORALTER FOREIGN TABLE ft1 DROP COLUMN IF EXISTS no_column;
ALTER FOREIGN TABLE ft1 DROP COLUMN c9;
ALTER FOREIGN TABLE ft1 SET SCHEMA foreign_schema;
ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;                      -- ERRORALTER FOREIGN TABLE foreign_schema.ft1 RENAME c1 TO foreign_column_1;
ALTER FOREIGN TABLE foreign_schema.ft1 RENAME TO foreign_table_1;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c4 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c6 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c7 integer NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c8 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c9 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c6 SET NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 DROP NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),                        ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT IF EXISTS no_const;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT ft1_c1_check;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OWNER TO regress_test_role;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN IF EXISTS no_column;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN c9;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 SET SCHEMA foreign_schema;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME c1 TO foreign_column_1;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME TO foreign_table_1;
SELECT * FROM information_schema.foreign_data_wrappers ORDER BY 1, 2;
SELECT * FROM information_schema.foreign_data_wrapper_options ORDER BY 1, 2, 3;
SELECT * FROM information_schema.foreign_servers ORDER BY 1, 2;
SELECT * FROM information_schema.foreign_server_options ORDER BY 1, 2, 3;
SELECT * FROM information_schema.user_mappings ORDER BY lower(authorization_identifier), 2, 3;
SELECT * FROM information_schema.user_mapping_options ORDER BY lower(authorization_identifier), 2, 3, 4;
SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
SELECT * FROM information_schema.foreign_tables ORDER BY 1, 2, 3;
SELECT * FROM information_schema.foreign_table_options ORDER BY 1, 2, 3, 4;
SET ROLE regress_test_role;
SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
SELECT * FROM information_schema.usage_privileges WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
SELECT * FROM information_schema.role_usage_grants WHERE object_type LIKE 'FOREIGN%' AND object_name IN ('s6', 'foo') ORDER BY 1, 2, 3, 4, 5;
DROP USER MAPPING FOR current_user SERVER t1;
SET ROLE regress_test_role2;
SELECT * FROM information_schema.user_mapping_options ORDER BY 1, 2, 3, 4;
RESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
GRANT USAGE ON FOREIGN SERVER s8 TO regress_test_role;
REVOKE USAGE ON FOREIGN SERVER s8 FROM regress_test_role;
GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
DROP USER MAPPING FOR public SERVER s4;
ALTER SERVER s6 OPTIONS (DROP host, DROP dbname);
ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (DROP username);
ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
SET ROLE regress_unprivileged_role;
CREATE FOREIGN DATA WRAPPER foobar;                             -- ERRORALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERRORALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role; -- ERRORDROP FOREIGN DATA WRAPPER foo;                                  -- ERRORGRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERRORCREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERRORALTER SERVER s4 VERSION '0.5';                                  -- ERRORALTER SERVER s4 OWNER TO regress_unprivileged_role;             -- ERRORDROP SERVER s4;                                                 -- ERRORGRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERRORCREATE USER MAPPING FOR public SERVER s4;                       -- ERRORALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERRORDROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERRORRESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_unprivileged_role;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_unprivileged_role WITH GRANT OPTION;
SET ROLE regress_unprivileged_role;
CREATE FOREIGN DATA WRAPPER foobar;                             -- ERRORALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERRORDROP FOREIGN DATA WRAPPER foo;                                  -- ERRORGRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_test_role; -- WARNINGGRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
ALTER SERVER s6 VERSION '0.5';                                  -- ERRORDROP SERVER s6;                                                 -- ERRORGRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;          -- ERRORGRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
CREATE USER MAPPING FOR public SERVER s6;                       -- ERRORCREATE USER MAPPING FOR public SERVER s9;
ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERRORDROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERRORRESET ROLE;
REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role; -- ERRORREVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role CASCADE;
SET ROLE regress_unprivileged_role;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERRORCREATE SERVER s10 FOREIGN DATA WRAPPER foo;                     -- ERRORALTER SERVER s9 VERSION '1.1';
GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
CREATE USER MAPPING FOR current_user SERVER s9;
DROP SERVER s9 CASCADE;
RESET ROLE;
CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
GRANT USAGE ON FOREIGN SERVER s9 TO regress_unprivileged_role;
SET ROLE regress_unprivileged_role;
ALTER SERVER s9 VERSION '1.2';                                  -- ERRORGRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;          -- WARNINGCREATE USER MAPPING FOR current_user SERVER s9;
DROP SERVER s9 CASCADE;                                         -- ERRORSET ROLE regress_test_role;
CREATE SERVER s10 FOREIGN DATA WRAPPER foo;
CREATE USER MAPPING FOR public SERVER s10 OPTIONS (user 'secret');
CREATE USER MAPPING FOR regress_unprivileged_role SERVER s10 OPTIONS (user 'secret');
RESET ROLE;
SET ROLE regress_unprivileged_role;
RESET ROLE;
DROP SERVER s10 CASCADE;
CREATE FUNCTION dummy_trigger() RETURNS TRIGGER AS $$  BEGIN    RETURN NULL;
  END$$ language plpgsql;
CREATE TRIGGER trigtest_before_stmt BEFORE INSERT OR UPDATE OR DELETEON foreign_schema.foreign_table_1FOR EACH STATEMENTEXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETEON foreign_schema.foreign_table_1FOR EACH STATEMENTEXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE -- ERRORON foreign_schema.foreign_table_1REFERENCING NEW TABLE AS new_tableFOR EACH STATEMENTEXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETEON foreign_schema.foreign_table_1FOR EACH ROWEXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETEON foreign_schema.foreign_table_1FOR EACH ROWEXECUTE PROCEDURE dummy_trigger();
CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETEON foreign_schema.foreign_table_1FOR EACH ROWEXECUTE PROCEDURE dummy_trigger();
ALTER FOREIGN TABLE foreign_schema.foreign_table_1	DISABLE TRIGGER trigtest_before_stmt;
ALTER FOREIGN TABLE foreign_schema.foreign_table_1	ENABLE TRIGGER trigtest_before_stmt;
DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
DROP FUNCTION dummy_trigger();
CREATE TABLE fd_pt1 (	c1 integer NOT NULL,	c2 text,	c3 date);
CREATE FOREIGN TABLE ft2 () INHERITS (fd_pt1)  SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
DROP FOREIGN TABLE ft2;
CREATE FOREIGN TABLE ft2 (	c1 integer NOT NULL,	c2 text,	c3 date) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
CREATE TABLE ct3() INHERITS(ft2);
CREATE FOREIGN TABLE ft3 (	c1 integer NOT NULL,	c2 text,	c3 date) INHERITS(ft2)  SERVER s0;
ALTER TABLE fd_pt1 ADD COLUMN c5 integer DEFAULT 0;
ALTER TABLE fd_pt1 ALTER COLUMN c4 SET DEFAULT 0;
ALTER TABLE fd_pt1 ALTER COLUMN c5 DROP DEFAULT;
ALTER TABLE fd_pt1 ALTER COLUMN c6 SET NOT NULL;
ALTER TABLE fd_pt1 ALTER COLUMN c7 DROP NOT NULL;
ALTER TABLE fd_pt1 ALTER COLUMN c8 TYPE char(10) USING '0';        -- ERRORALTER TABLE fd_pt1 ALTER COLUMN c8 TYPE char(10);
ALTER TABLE fd_pt1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER TABLE fd_pt1 ALTER COLUMN c1 SET STATISTICS 10000;
ALTER TABLE fd_pt1 ALTER COLUMN c1 SET (n_distinct = 100);
ALTER TABLE fd_pt1 ALTER COLUMN c8 SET STATISTICS -1;
ALTER TABLE fd_pt1 ALTER COLUMN c8 SET STORAGE EXTERNAL;
ALTER TABLE fd_pt1 DROP COLUMN c4;
ALTER TABLE fd_pt1 DROP COLUMN c5;
ALTER TABLE fd_pt1 DROP COLUMN c6;
ALTER TABLE fd_pt1 DROP COLUMN c7;
ALTER TABLE fd_pt1 DROP COLUMN c8;
ALTER TABLE fd_pt1 ADD CONSTRAINT fd_pt1chk1 CHECK (c1 > 0) NO INHERIT;
ALTER TABLE fd_pt1 ADD CONSTRAINT fd_pt1chk2 CHECK (c2 <> '');
SELECT relname, conname, contype, conislocal, coninhcount, connoinherit  FROM pg_class AS pc JOIN pg_constraint AS pgc ON (conrelid = pc.oid)  WHERE pc.relname = 'fd_pt1'  ORDER BY 1,2;
DROP FOREIGN TABLE ft2; -- ERRORDROP FOREIGN TABLE ft2 CASCADE;
CREATE FOREIGN TABLE ft2 (	c1 integer NOT NULL,	c2 text,	c3 date) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;                            -- ERRORALTER FOREIGN TABLE ft2 ADD CONSTRAINT fd_pt1chk2 CHECK (c2 <> '');
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
ALTER TABLE fd_pt1 DROP CONSTRAINT fd_pt1chk1 CASCADE;
ALTER TABLE fd_pt1 DROP CONSTRAINT fd_pt1chk2 CASCADE;
::INSERT INTO fd_pt1 VALUES (1, 'fd_pt1'::text, '1994-01-01'::date);
ALTER TABLE fd_pt1 ADD CONSTRAINT fd_pt1chk3 CHECK (c2 <> '') NOT VALID;
ALTER TABLE fd_pt1 VALIDATE CONSTRAINT fd_pt1chk3;
ALTER TABLE fd_pt1 RENAME CONSTRAINT fd_pt1chk3 TO f2_check;
TRUNCATE ft2;  -- ERRORTRUNCATE fd_pt1;  -- ERRORDROP TABLE fd_pt1 CASCADE;
IMPORT FOREIGN SCHEMA s1 FROM SERVER s9 INTO public; -- ERRORIMPORT FOREIGN SCHEMA s1 LIMIT TO (t1) FROM SERVER s9 INTO public; --ERRORIMPORT FOREIGN SCHEMA s1 EXCEPT (t1) FROM SERVER s9 INTO public; -- ERRORIMPORT FOREIGN SCHEMA s1 EXCEPT (t1, t2) FROM SERVER s9 INTO publicOPTIONS (option1 'value1', option2 'value2'); -- ERRORDROP FOREIGN TABLE no_table;                                    -- ERRORDROP FOREIGN TABLE IF EXISTS no_table;
DROP FOREIGN TABLE foreign_schema.foreign_table_1;
REASSIGN OWNED BY regress_test_role TO regress_test_role2;
DROP OWNED BY regress_test_role2;
DROP OWNED BY regress_test_role2 CASCADE;
CREATE TABLE fd_pt2 (	c1 integer NOT NULL,	c2 text,	c3 date) PARTITION BY LIST (c1);
CREATE FOREIGN TABLE fd_pt2_1 PARTITION OF fd_pt2 FOR VALUES IN (1)  SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
DROP FOREIGN TABLE fd_pt2_1;
CREATE FOREIGN TABLE fd_pt2_1 (	c1 integer NOT NULL,	c2 text,	c3 date,	c4 char) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);       -- ERRORDROP FOREIGN TABLE fd_pt2_1;
CREATE FOREIGN TABLE fd_pt2_1 (	c1 integer NOT NULL,	c2 text,	c3 date) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
ALTER TABLE fd_pt2_1 ALTER c3 SET NOT NULL;
ALTER TABLE fd_pt2_1 ADD CONSTRAINT p21chk CHECK (c2 <> '');
ALTER TABLE fd_pt2_1 ALTER c1 DROP NOT NULL;
ALTER TABLE fd_pt2 DETACH PARTITION fd_pt2_1;
ALTER TABLE fd_pt2 ALTER c2 SET NOT NULL;
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);       -- ERRORALTER FOREIGN TABLE fd_pt2_1 ALTER c2 SET NOT NULL;
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
ALTER TABLE fd_pt2 DETACH PARTITION fd_pt2_1;
ALTER TABLE fd_pt2 ADD CONSTRAINT fd_pt2chk1 CHECK (c1 > 0);
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);       -- ERRORALTER FOREIGN TABLE fd_pt2_1 ADD CONSTRAINT fd_pt2chk1 CHECK (c1 > 0);
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
TRUNCATE fd_pt2_1;  -- ERRORTRUNCATE fd_pt2;  -- ERRORDROP FOREIGN TABLE fd_pt2_1;
CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
CREATE FOREIGN TABLE foreign_part PARTITION OF temp_parted DEFAULT  SERVER s0;  -- ERRORCREATE FOREIGN TABLE foreign_part (a int) SERVER s0;
ALTER TABLE temp_parted ATTACH PARTITION foreign_part DEFAULT;  -- ERRORDROP FOREIGN TABLE foreign_part;
DROP SCHEMA foreign_schema CASCADE;
DROP ROLE regress_test_role;                                -- ERRORDROP SERVER t1 CASCADE;
DROP USER MAPPING FOR regress_test_role SERVER s6;
DROP FOREIGN DATA WRAPPER foo CASCADE;
DROP SERVER s8 CASCADE;
DROP ROLE regress_test_indirect;
DROP ROLE regress_test_role;
DROP ROLE regress_unprivileged_role;                        -- ERRORREVOKE ALL ON FOREIGN DATA WRAPPER postgresql FROM regress_unprivileged_role;
DROP ROLE regress_unprivileged_role;
DROP ROLE regress_test_role2;
DROP FOREIGN DATA WRAPPER postgresql CASCADE;
DROP FOREIGN DATA WRAPPER dummy CASCADE;
\\cDROP ROLE regress_foreign_data_user;
SELECT * FROM onek   WHERE onek.unique1 < 10   ORDER BY onek.unique1;
SELECT onek.unique1, onek.stringu1 FROM onek   WHERE onek.unique1 < 20   ORDER BY unique1 using >;
SELECT onek.unique1, onek.stringu1 FROM onek   WHERE onek.unique1 > 980   ORDER BY stringu1 using <;
SELECT onek.unique1, onek.string4 FROM onek   WHERE onek.unique1 > 980   ORDER BY string4 using <, unique1 using >;
SELECT onek.unique1, onek.string4 FROM onek   WHERE onek.unique1 > 980   ORDER BY string4 using >, unique1 using <;
SELECT onek.unique1, onek.string4 FROM onek   WHERE onek.unique1 < 20   ORDER BY unique1 using >, string4 using <;
SELECT onek.unique1, onek.string4 FROM onek   WHERE onek.unique1 < 20   ORDER BY unique1 using <, string4 using >;
ANALYZE onek2;
SET enable_seqscan TO off;
SET enable_bitmapscan TO off;
SET enable_sort TO off;
SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;
SELECT onek2.unique1, onek2.stringu1 FROM onek2    WHERE onek2.unique1 < 20    ORDER BY unique1 using >;
SELECT onek2.unique1, onek2.stringu1 FROM onek2   WHERE onek2.unique1 > 980;
RESET enable_seqscan;
RESET enable_bitmapscan;
RESET enable_sort;
SELECT two, stringu1, ten, string4   INTO TABLE tmp   FROM onek;
SELECT p.name, p.age FROM person* p;
SELECT p.name, p.age FROM person* p ORDER BY age using >, name;
select foo from (select 1 offset 0) as foo;
select foo from (select null offset 0) as foo;
select foo from (select 'xyzzy',1,null offset 0) as foo;
select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)    WHERE onek.unique1 = v.i and onek.stringu1 = v.j;
select * from onek,  (values ((select i from    (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)    order by i asc limit 1))) bar (i)  where onek.unique1 = bar.i;
select * from onek    where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))    order by unique1;
VALUES (1,2), (3,4+4), (7,77.7);
VALUES (1,2), (3,4+4), (7,77.7)UNION ALLSELECT 2+2, 57UNION ALLTABLE int8_tbl;
INSERT INTO foo VALUES (42),(3),(10),(7),(null),(null),(1);
SELECT * FROM foo ORDER BY f1 ASC;	-- same thingSELECT * FROM foo ORDER BY f1 NULLS FIRST;
SET enable_sort = false;
CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
explain (costs off)select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
explain (costs off, analyze on, timing off, summary off)select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
explain (costs off)select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
explain (costs off)select * from onek2 where unique2 = 11 and stringu1 < 'B';
explain (costs off)select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
explain (costs off)select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
explain (costs off)select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
SET enable_indexscan TO off;
explain (costs off)select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
RESET enable_indexscan;
explain (costs off)select unique1, unique2 from onek2  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
explain (costs off)select unique1, unique2 from onek2  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
create function sillysrf(int) returns setof int as  'values (1),(10),(2),($1)' language sql immutable;
drop function sillysrf(int);
select * from (values (2),(null),(1)) v(k) where k = k order by k;
select * from (values (2),(null),(1)) v(k) where k = k;
create table list_parted_tbl (a int,b int) partition by list (a);
create table list_parted_tbl1 partition of list_parted_tbl  for values in (1) partition by list(b);
explain (costs off) select * from list_parted_tbl;
BEGIN;
DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
FETCH 1 in foo1;
FETCH 2 in foo2;
FETCH 3 in foo3;
FETCH 4 in foo4;
FETCH 5 in foo5;
FETCH 6 in foo6;
FETCH 7 in foo7;
FETCH 8 in foo8;
FETCH 9 in foo9;
FETCH 10 in foo10;
FETCH 11 in foo11;
FETCH 12 in foo12;
FETCH 13 in foo13;
FETCH 14 in foo14;
FETCH 15 in foo15;
FETCH 16 in foo16;
FETCH 17 in foo17;
FETCH 18 in foo18;
FETCH 19 in foo19;
FETCH 20 in foo20;
FETCH 21 in foo21;
FETCH 22 in foo22;
FETCH 23 in foo23;
FETCH backward 1 in foo23;
FETCH backward 2 in foo22;
FETCH backward 3 in foo21;
FETCH backward 4 in foo20;
FETCH backward 5 in foo19;
FETCH backward 6 in foo18;
FETCH backward 7 in foo17;
FETCH backward 8 in foo16;
FETCH backward 9 in foo15;
FETCH backward 10 in foo14;
FETCH backward 11 in foo13;
FETCH backward 12 in foo12;
FETCH backward 13 in foo11;
FETCH backward 14 in foo10;
FETCH backward 15 in foo9;
FETCH backward 16 in foo8;
FETCH backward 17 in foo7;
FETCH backward 18 in foo6;
FETCH backward 19 in foo5;
FETCH backward 20 in foo4;
FETCH backward 21 in foo3;
FETCH backward 22 in foo2;
FETCH backward 23 in foo1;
CLOSE foo1;
CLOSE foo2;
CLOSE foo3;
CLOSE foo4;
CLOSE foo5;
CLOSE foo6;
CLOSE foo7;
CLOSE foo8;
CLOSE foo9;
CLOSE foo10;
CLOSE foo11;
CLOSE foo12;
END;
BEGIN;
DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
FETCH 1 FROM foo24;
FETCH BACKWARD 1 FROM foo24; -- should failEND;
BEGIN;
DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
FETCH FROM foo25;
FETCH FROM foo25;
COMMIT;
FETCH FROM foo25;
FETCH BACKWARD FROM foo25;
FETCH ABSOLUTE -1 FROM foo25;
CLOSE foo25;
BEGIN;
DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM tenk1 ORDER BY unique2;
ROLLBACK;
FETCH FROM foo26;
BEGIN;
CREATE FUNCTION declares_cursor(text)   RETURNS void   AS 'DECLARE c CURSOR FOR SELECT stringu1 FROM tenk1 WHERE stringu1 LIKE $1;'   LANGUAGE SQL;
FETCH ALL FROM c;
ROLLBACK;
create function count_tt1_v() returns int8 as'select count(*) from tt1' language sql volatile;
create function count_tt1_s() returns int8 as'select count(*) from tt1' language sql stable;
begin;
declare c1 cursor for select count_tt1_v(), count_tt1_s();
fetch all from c1;
rollback;
begin;
declare c2 cursor with hold for select count_tt1_v(), count_tt1_s();
commit;
delete from tt1;
fetch all from c2;
drop function count_tt1_v();
drop function count_tt1_s();
BEGIN;
DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;
ROLLBACK;
PREPARE cprep AS  SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
EXECUTE cprep;
CLOSE ALL;
BEGIN;
DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1;
DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1;
CLOSE ALL;
COMMIT;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
FETCH 2 FROM c1;
DELETE FROM uctest WHERE CURRENT OF c1;
FETCH ALL FROM c1;
MOVE BACKWARD ALL IN c1;
FETCH ALL FROM c1;
COMMIT;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
FETCH c1;
UPDATE uctest SET f1 = 8 WHERE CURRENT OF c1;
COMMIT;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
FETCH c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
FETCH RELATIVE 0 FROM c1;
DELETE FROM uctest WHERE CURRENT OF c1;
DELETE FROM uctest WHERE CURRENT OF c1; -- no-opSELECT * FROM uctest;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-opSELECT * FROM uctest;
FETCH RELATIVE 0 FROM c1;
ROLLBACK;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
FETCH c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
DELETE FROM uctest WHERE CURRENT OF c1;
DELETE FROM uctest WHERE CURRENT OF c1; -- no-opSELECT * FROM uctest;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-opSELECT * FROM uctest;
FETCH RELATIVE 0 FROM c1;
ROLLBACK;
CREATE TEMP TABLE ucchild () inherits (uctest);
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
FETCH 1 FROM c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
FETCH 1 FROM c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
FETCH 1 FROM c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
FETCH 1 FROM c1;
COMMIT;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5;
FETCH 1 FROM c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- failROLLBACK;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR UPDATE;
FETCH 1 FROM c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- failROLLBACK;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR SHARE OF a;
FETCH 1 FROM c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
ROLLBACK;
DELETE FROM uctest WHERE CURRENT OF c1;  -- fail, no such cursorDECLARE cx CURSOR WITH HOLD FOR SELECT * FROM uctest;
DELETE FROM uctest WHERE CURRENT OF cx;  -- fail, can't use held cursorBEGIN;
DECLARE c CURSOR FOR SELECT * FROM tenk2;
DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong tableROLLBACK;
BEGIN;
DECLARE c CURSOR FOR SELECT * FROM tenk2 FOR SHARE;
DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong tableROLLBACK;
BEGIN;
DECLARE c CURSOR FOR SELECT * FROM tenk1 JOIN tenk2 USING (unique1);
DELETE FROM tenk1 WHERE CURRENT OF c;  -- fail, cursor is on a joinROLLBACK;
BEGIN;
DECLARE c CURSOR FOR SELECT f1,count(*) FROM uctest GROUP BY f1;
DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor is on aggregationROLLBACK;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
DELETE FROM uctest WHERE CURRENT OF c1; -- fail, no current rowROLLBACK;
BEGIN;
DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
ROLLBACK;
CREATE RULE ucrule AS ON DELETE TO ucview DO INSTEAD  DELETE FROM uctest WHERE f1 = OLD.f1;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM ucview;
FETCH FROM c1;
DELETE FROM ucview WHERE CURRENT OF c1; -- fail, views not supportedROLLBACK;
BEGIN;
EXPLAIN (costs off)DECLARE c1 CURSOR FOR SELECT stringu1 FROM onek WHERE stringu1 = 'DZAAAA';
DECLARE c1 CURSOR FOR SELECT stringu1 FROM onek WHERE stringu1 = 'DZAAAA';
FETCH FROM c1;
DELETE FROM onek WHERE CURRENT OF c1;
ROLLBACK;
BEGIN;
CREATE TABLE current_check_1 () INHERITS (current_check);
CREATE TABLE current_check_2 () INHERITS (current_check);
||||DECLARE c1 SCROLL CURSOR FOR SELECT * FROM current_check;
FETCH ABSOLUTE 12 FROM c1;
FETCH ABSOLUTE 8 FROM c1;
DELETE FROM current_check WHERE CURRENT OF c1 RETURNING *;
FETCH ABSOLUTE 13 FROM c1;
FETCH ABSOLUTE 1 FROM c1;
DELETE FROM current_check WHERE CURRENT OF c1 RETURNING *;
ROLLBACK;
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
FETCH ALL FROM c1;
COMMIT;
begin;
create function nochange(int) returns int  as 'select $1 limit 1' language sql stable;
declare c cursor for select * from int8_tbl limit nochange(3);
fetch all from c;
move backward all in c;
fetch all from c;
rollback;
begin;
explain (costs off) declare c1 cursor for select (select 42) as x;
explain (costs off) declare c1 scroll cursor for select (select 42) as x;
declare c1 scroll cursor for select (select 42) as x;
fetch all in c1;
fetch backward all in c1;
rollback;
begin;
explain (costs off) declare c2 cursor for select generate_series(1,3) as g;
explain (costs off) declare c2 scroll cursor for select generate_series(1,3) as g;
declare c2 scroll cursor for select generate_series(1,3) as g;
fetch all in c2;
fetch backward all in c2;
rollback;
SET enable_partitionwise_join to true;
CREATE TABLE prt1 (a int, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_p1 PARTITION OF prt1 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_p3 PARTITION OF prt1 FOR VALUES FROM (500) TO (600);
CREATE TABLE prt1_p2 PARTITION OF prt1 FOR VALUES FROM (250) TO (500);
ANALYZE prt1;
CREATE TABLE prt2 (a int, b int, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_p1 PARTITION OF prt2 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_p2 PARTITION OF prt2 FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_p3 PARTITION OF prt2 FOR VALUES FROM (500) TO (600);
ANALYZE prt2;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a < 450 AND t2.b > 250 AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a < 450 AND t2.b > 250 AND t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 FULL JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 OR t2.a = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 FULL JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 OR t2.a = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t2.b FROM prt2 t2 WHERE t2.a = 0) AND t1.b = 0 ORDER BY t1.a;
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t2.b FROM prt2 t2 WHERE t2.a = 0) AND t1.b = 0 ORDER BY t1.a;
EXPLAIN (COSTS OFF)SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
EXPLAIN (COSTS OFF)SELECT * FROM prt1 t1 LEFT JOIN LATERAL			  (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss			  ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
SELECT * FROM prt1 t1 LEFT JOIN LATERAL			  (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss			  ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
EXPLAIN (COSTS OFF)SELECT t1.a, ss.t2a, ss.t2c FROM prt1 t1 LEFT JOIN LATERAL			  (SELECT t2.a AS t2a, t3.a AS t3a, t2.b t2b, t2.c t2c, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss			  ON t1.c = ss.t2c WHERE (t1.b + coalesce(ss.t2b, 0)) = 0 ORDER BY t1.a;
SELECT t1.a, ss.t2a, ss.t2c FROM prt1 t1 LEFT JOIN LATERAL			  (SELECT t2.a AS t2a, t3.a AS t3a, t2.b t2b, t2.c t2c, least(t1.a,t2.a,t3.a) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss			  ON t1.c = ss.t2c WHERE (t1.b + coalesce(ss.t2b, 0)) = 0 ORDER BY t1.a;
SET enable_partitionwise_aggregate TO true;
SET enable_hashjoin TO false;
EXPLAIN (COSTS OFF)SELECT a, b FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b)  WHERE a BETWEEN 490 AND 510  GROUP BY 1, 2 ORDER BY 1, 2;
SELECT a, b FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b)  WHERE a BETWEEN 490 AND 510  GROUP BY 1, 2 ORDER BY 1, 2;
RESET enable_partitionwise_aggregate;
RESET enable_hashjoin;
CREATE TABLE prt1_e (a int, b int, c int) PARTITION BY RANGE(((a + b)/2));
CREATE TABLE prt1_e_p1 PARTITION OF prt1_e FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_e_p2 PARTITION OF prt1_e FOR VALUES FROM (250) TO (500);
CREATE TABLE prt1_e_p3 PARTITION OF prt1_e FOR VALUES FROM (500) TO (600);
ANALYZE prt1_e;
CREATE TABLE prt2_e (a int, b int, c int) PARTITION BY RANGE(((b + a)/2));
CREATE TABLE prt2_e_p1 PARTITION OF prt2_e FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_e_p2 PARTITION OF prt2_e FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_e_p3 PARTITION OF prt2_e FOR VALUES FROM (500) TO (600);
ANALYZE prt2_e;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM prt1 t1, prt2 t2, prt1_e t3 WHERE t1.a = t2.b AND t1.a = (t3.a + t3.b)/2 AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM prt1 t1, prt2 t2, prt1_e t3 WHERE t1.a = t2.b AND t1.a = (t3.a + t3.b)/2 AND t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.phv, t2.b, t2.phv, t3.a + t3.b, t3.phv FROM ((SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b)) FULL JOIN (SELECT 50 phv, * FROM prt1_e WHERE prt1_e.c = 0) t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.a = t1.phv OR t2.b = t2.phv OR (t3.a + t3.b)/2 = t3.phv ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT t1.a, t1.phv, t2.b, t2.phv, t3.a + t3.b, t3.phv FROM ((SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b)) FULL JOIN (SELECT 50 phv, * FROM prt1_e WHERE prt1_e.c = 0) t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.a = t1.phv OR t2.b = t2.phv OR (t3.a + t3.b)/2 = t3.phv ORDER BY t1.a, t2.b, t3.a + t3.b;
EXPLAIN (COSTS OFF)SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
EXPLAIN (COSTS OFF)SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
SET enable_hashjoin TO off;
SET enable_nestloop TO off;
EXPLAIN (COSTS OFF)SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t2.b FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t2.b FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
RESET enable_hashjoin;
RESET enable_nestloop;
CREATE TABLE prt1_m (a int, b int, c int) PARTITION BY RANGE(a, ((a + b)/2));
CREATE TABLE prt1_m_p1 PARTITION OF prt1_m FOR VALUES FROM (0, 0) TO (250, 250);
CREATE TABLE prt1_m_p2 PARTITION OF prt1_m FOR VALUES FROM (250, 250) TO (500, 500);
CREATE TABLE prt1_m_p3 PARTITION OF prt1_m FOR VALUES FROM (500, 500) TO (600, 600);
ANALYZE prt1_m;
CREATE TABLE prt2_m (a int, b int, c int) PARTITION BY RANGE(((b + a)/2), b);
CREATE TABLE prt2_m_p1 PARTITION OF prt2_m FOR VALUES FROM (0, 0) TO (250, 250);
CREATE TABLE prt2_m_p2 PARTITION OF prt2_m FOR VALUES FROM (250, 250) TO (500, 500);
CREATE TABLE prt2_m_p3 PARTITION OF prt2_m FOR VALUES FROM (500, 500) TO (600, 600);
ANALYZE prt2_m;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_m WHERE prt1_m.c = 0) t1 FULL JOIN (SELECT * FROM prt2_m WHERE prt2_m.c = 0) t2 ON (t1.a = (t2.b + t2.a)/2 AND t2.b = (t1.a + t1.b)/2) ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_m WHERE prt1_m.c = 0) t1 FULL JOIN (SELECT * FROM prt2_m WHERE prt2_m.c = 0) t2 ON (t1.a = (t2.b + t2.a)/2 AND t2.b = (t1.a + t1.b)/2) ORDER BY t1.a, t2.b;
CREATE TABLE plt1 (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE plt1_p1 PARTITION OF plt1 FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE plt1_p2 PARTITION OF plt1 FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE plt1_p3 PARTITION OF plt1 FOR VALUES IN ('0006', '0007', '0008', '0011');
ANALYZE plt1;
CREATE TABLE plt2 (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE plt2_p1 PARTITION OF plt2 FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE plt2_p2 PARTITION OF plt2 FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE plt2_p3 PARTITION OF plt2 FOR VALUES IN ('0006', '0007', '0008', '0011');
ANALYZE plt2;
CREATE TABLE plt1_e (a int, b int, c text) PARTITION BY LIST(ltrim(c, 'A'));
CREATE TABLE plt1_e_p1 PARTITION OF plt1_e FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE plt1_e_p2 PARTITION OF plt1_e FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE plt1_e_p3 PARTITION OF plt1_e FOR VALUES IN ('0006', '0007', '0008', '0011');
||INSERT INTO plt1_e SELECT i, i, 'A' || to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE plt1_e;
EXPLAIN (COSTS OFF)SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM plt1 t1, plt2 t2, plt1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM plt1 t1, plt2 t2, plt1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a = 1 AND t1.a = 2;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 LEFT JOIN prt2 t2 ON t1.a = t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b, prt1 t3 WHERE t2.b = t3.a;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 FULL JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
CREATE TABLE pht1 (a int, b int, c text) PARTITION BY HASH(c);
CREATE TABLE pht1_p1 PARTITION OF pht1 FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE pht1_p2 PARTITION OF pht1 FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE pht1_p3 PARTITION OF pht1 FOR VALUES WITH (MODULUS 3, REMAINDER 2);
ANALYZE pht1;
CREATE TABLE pht2 (a int, b int, c text) PARTITION BY HASH(c);
CREATE TABLE pht2_p1 PARTITION OF pht2 FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE pht2_p2 PARTITION OF pht2 FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE pht2_p3 PARTITION OF pht2 FOR VALUES WITH (MODULUS 3, REMAINDER 2);
ANALYZE pht2;
CREATE TABLE pht1_e (a int, b int, c text) PARTITION BY HASH(ltrim(c, 'A'));
CREATE TABLE pht1_e_p1 PARTITION OF pht1_e FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE pht1_e_p2 PARTITION OF pht1_e FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE pht1_e_p3 PARTITION OF pht1_e FOR VALUES WITH (MODULUS 3, REMAINDER 2);
||INSERT INTO pht1_e SELECT i, i, 'A' || to_char(i/50, 'FM0000') FROM generate_series(0, 299, 2) i;
ANALYZE pht1_e;
EXPLAIN (COSTS OFF)SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM pht1 t1, pht2 t2, pht1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM pht1 t1, pht2 t2, pht1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
ALTER TABLE prt1 DETACH PARTITION prt1_p3;
ALTER TABLE prt1 ATTACH PARTITION prt1_p3 DEFAULT;
ANALYZE prt1;
ALTER TABLE prt2 DETACH PARTITION prt2_p3;
ALTER TABLE prt2 ATTACH PARTITION prt2_p3 DEFAULT;
ANALYZE prt2;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
ALTER TABLE plt1 DETACH PARTITION plt1_p3;
ALTER TABLE plt1 ATTACH PARTITION plt1_p3 DEFAULT;
ANALYZE plt1;
ALTER TABLE plt2 DETACH PARTITION plt2_p3;
ALTER TABLE plt2 ATTACH PARTITION plt2_p3 DEFAULT;
ANALYZE plt2;
EXPLAIN (COSTS OFF)SELECT avg(t1.a), avg(t2.b), t1.c, t2.c FROM plt1 t1 RIGHT JOIN plt2 t2 ON t1.c = t2.c WHERE t1.a % 25 = 0 GROUP BY t1.c, t2.c ORDER BY t1.c, t2.c;
CREATE TABLE prt1_l (a int, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_l_p1 PARTITION OF prt1_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_l_p2 PARTITION OF prt1_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt1_l_p2_p1 PARTITION OF prt1_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt1_l_p2_p2 PARTITION OF prt1_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt1_l_p3 PARTITION OF prt1_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (b);
CREATE TABLE prt1_l_p3_p1 PARTITION OF prt1_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt1_l_p3_p2 PARTITION OF prt1_l_p3 FOR VALUES FROM (13) TO (25);
ANALYZE prt1_l;
CREATE TABLE prt2_l (a int, b int, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_l_p1 PARTITION OF prt2_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_l_p2 PARTITION OF prt2_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt2_l_p2_p1 PARTITION OF prt2_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt2_l_p2_p2 PARTITION OF prt2_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt2_l_p3 PARTITION OF prt2_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (a);
CREATE TABLE prt2_l_p3_p1 PARTITION OF prt2_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt2_l_p3_p2 PARTITION OF prt2_l_p3 FOR VALUES FROM (13) TO (25);
ANALYZE prt2_l;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 LEFT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 LEFT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t1.b = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t2.a = 0 ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t2.a = 0 ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE prt1_l.b = 0) t1 FULL JOIN (SELECT * FROM prt2_l WHERE prt2_l.a = 0) t2 ON (t1.a = t2.b AND t1.c = t2.c) ORDER BY t1.a, t2.b;
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE prt1_l.b = 0) t1 FULL JOIN (SELECT * FROM prt2_l WHERE prt2_l.a = 0) t2 ON (t1.a = t2.b AND t1.c = t2.c) ORDER BY t1.a, t2.b;
EXPLAIN (COSTS OFF)SELECT * FROM prt1_l t1 LEFT JOIN LATERAL			  (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss			  ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
SELECT * FROM prt1_l t1 LEFT JOIN LATERAL			  (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss			  ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE a = 1 AND a = 2) t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.b = t2.a AND t1.c = t2.c;
EXPLAIN (COSTS OFF)DELETE FROM prt1_lWHERE EXISTS (  SELECT 1    FROM int4_tbl,         LATERAL (SELECT int4_tbl.f1 FROM int8_tbl LIMIT 2) ss    WHERE prt1_l.c IS NULL);
CREATE TABLE prt1_n (a int, b int, c varchar) PARTITION BY RANGE(c);
CREATE TABLE prt1_n_p1 PARTITION OF prt1_n FOR VALUES FROM ('0000') TO ('0250');
CREATE TABLE prt1_n_p2 PARTITION OF prt1_n FOR VALUES FROM ('0250') TO ('0500');
ANALYZE prt1_n;
CREATE TABLE prt2_n (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE prt2_n_p1 PARTITION OF prt2_n FOR VALUES IN ('0000', '0003', '0004', '0010', '0006', '0007');
CREATE TABLE prt2_n_p2 PARTITION OF prt2_n FOR VALUES IN ('0001', '0005', '0002', '0009', '0008', '0011');
ANALYZE prt2_n;
CREATE TABLE prt3_n (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE prt3_n_p1 PARTITION OF prt3_n FOR VALUES IN ('0000', '0004', '0006', '0007');
CREATE TABLE prt3_n_p2 PARTITION OF prt3_n FOR VALUES IN ('0001', '0002', '0008', '0010');
CREATE TABLE prt3_n_p3 PARTITION OF prt3_n FOR VALUES IN ('0003', '0005', '0009', '0011');
ANALYZE prt3_n;
CREATE TABLE prt4_n (a int, b int, c text) PARTITION BY RANGE(a);
CREATE TABLE prt4_n_p1 PARTITION OF prt4_n FOR VALUES FROM (0) TO (300);
CREATE TABLE prt4_n_p2 PARTITION OF prt4_n FOR VALUES FROM (300) TO (500);
CREATE TABLE prt4_n_p3 PARTITION OF prt4_n FOR VALUES FROM (500) TO (600);
ANALYZE prt4_n;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt4_n t2 WHERE t1.a = t2.a;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt4_n t2, prt2 t3 WHERE t1.a = t2.a and t1.a = t3.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 LEFT JOIN prt2 t2 ON (t1.a < t2.b);
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1, prt2_m t2 WHERE t1.a = (t2.b + t2.a)/2;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1 LEFT JOIN prt2_m t2 ON t1.a = t2.b;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1 LEFT JOIN prt2_m t2 ON t1.c = t2.c;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 LEFT JOIN prt2_n t2 ON (t1.c = t2.c);
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 JOIN prt2_n t2 ON (t1.c = t2.c) JOIN plt1 t3 ON (t1.c = t3.c);
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 FULL JOIN prt1 t2 ON (t1.c = t2.c);
ALTER TABLE prt2 DETACH PARTITION prt2_p3;
ALTER TABLE prt2 ATTACH PARTITION prt2_p3 FOR VALUES FROM (500) TO (600);
ANALYZE prt2;
EXPLAIN (COSTS OFF)SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
SET extra_float_digits = 0;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
||INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl; -- DISTINCT not supportedCREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b; -- GROUP BY not supportedCREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0; -- HAVING not supportedCREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl; -- Aggregate functions not supportedCREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl; -- Window functions not supportedCREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl; -- Set ops not supportedCREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t; -- WITH not supportedCREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1; -- OFFSET not supportedCREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1; -- LIMIT not supportedCREATE VIEW ro_view10 AS SELECT 1 AS a; -- No base relationsCREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2; -- Multiple base relationsCREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a); -- SRF in rangetableCREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t; -- Subselect in rangetableCREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl; -- System columns may be part of an updatable viewCREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl; -- Expression/function may be part of an updatable viewCREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl; -- Repeated column may be part of an updatable viewCREATE VIEW ro_view17 AS SELECT * FROM ro_view1; -- Base relation not updatableCREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a); -- VALUES in rangetableCREATE SEQUENCE uv_seq;
CREATE VIEW ro_view19 AS SELECT * FROM uv_seq; -- View based on a sequenceCREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl; -- SRF in targetlist not supportedSELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE E'r_\\_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name LIKE E'r_\\_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE E'r_\\_view%' ORDER BY table_name, ordinal_position;
DELETE FROM ro_view1;
DELETE FROM ro_view2;
DELETE FROM ro_view3;
DELETE FROM ro_view4;
DELETE FROM ro_view5;
DELETE FROM ro_view6;
INSERT INTO rw_view14 VALUES (null, 3, 'Row 3'); -- should failINSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3'); -- should be OKUPDATE rw_view14 SET ctid=null WHERE a=3; -- should failUPDATE rw_view14 SET b='ROW 3' WHERE a=3; -- should be OKSELECT * FROM base_tbl;
DELETE FROM rw_view14 WHERE a=3; -- should be OKINSERT INTO rw_view15 VALUES (3, 'ROW 3'); -- should failINSERT INTO rw_view15 (a) VALUES (3); -- should be OKINSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT DO NOTHING; -- succeedsSELECT * FROM rw_view15;
INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO NOTHING; -- succeedsSELECT * FROM rw_view15;
INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set a = excluded.a; -- succeedsSELECT * FROM rw_view15;
INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set upper = 'blarg'; -- failsSELECT * FROM rw_view15;
ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
INSERT INTO rw_view15 (a) VALUES (4); -- should failUPDATE rw_view15 SET upper='ROW 3' WHERE a=3; -- should failUPDATE rw_view15 SET upper=DEFAULT WHERE a=3; -- should failUPDATE rw_view15 SET a=4 WHERE a=3; -- should be OKSELECT * FROM base_tbl;
DELETE FROM rw_view15 WHERE a=4; -- should be OKINSERT INTO rw_view16 VALUES (3, 'Row 3', 3); -- should failINSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3'); -- should be OKUPDATE rw_view16 SET a=3, aa=-3 WHERE a=3; -- should failUPDATE rw_view16 SET aa=-3 WHERE a=3; -- should be OKSELECT * FROM base_tbl;
DELETE FROM rw_view16 WHERE a=-3; -- should be OKINSERT INTO ro_view17 VALUES (3, 'ROW 3');
DELETE FROM ro_view18;
DROP TABLE base_tbl CASCADE;
DROP VIEW ro_view10, ro_view12, ro_view18;
DROP SEQUENCE uv_seq CASCADE;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
||INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name = 'rw_view1';
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name = 'rw_view1';
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name = 'rw_view1' ORDER BY ordinal_position;
DELETE FROM rw_view1 WHERE b='Row 2';
EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
DROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
||INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name = 'rw_view2';
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name = 'rw_view2';
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name = 'rw_view2' ORDER BY ordinal_position;
DELETE FROM rw_view2 WHERE aaa=2;
EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
DROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
||INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggersCREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1  DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1  DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
DELETE FROM rw_view2 WHERE a=3 RETURNING *;
EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
DROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
||INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggersCREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into,       is_trigger_updatable, is_trigger_deletable,       is_trigger_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
CREATE FUNCTION rw_view1_trig_fn()RETURNS trigger AS$$BEGIN  IF TG_OP = 'INSERT' THEN    INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN    UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN    DELETE FROM base_tbl WHERE a=OLD.a;
    RETURN OLD;
  END IF;
END;
$$LANGUAGE plpgsql;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into,       is_trigger_updatable, is_trigger_deletable,       is_trigger_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into,       is_trigger_updatable, is_trigger_deletable,       is_trigger_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into,       is_trigger_updatable, is_trigger_deletable,       is_trigger_insertable_into  FROM information_schema.views WHERE table_name LIKE 'rw_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE 'rw_view%' ORDER BY table_name, ordinal_position;
INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
DELETE FROM rw_view2 WHERE a=3 RETURNING *;
EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
DROP TABLE base_tbl CASCADE;
DROP FUNCTION rw_view1_trig_fn();
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
||INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
CREATE FUNCTION rw_view1_aa(x rw_view1)  RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2  RETURNING rw_view1_aa(v), v.bb;
EXPLAIN (costs off)UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2  RETURNING rw_view1_aa(v), v.bb;
DROP TABLE base_tbl CASCADE;
CREATE USER regress_view_user1;
CREATE USER regress_view_user2;
SET SESSION AUTHORIZATION regress_view_user1;
GRANT SELECT ON base_tbl TO regress_view_user2;
GRANT SELECT ON rw_view1 TO regress_view_user2;
GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM base_tbl; -- okSELECT * FROM rw_view1; -- okSELECT * FROM rw_view2; -- okINSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowedINSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowedINSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowedUPDATE base_tbl SET a=a, c=c; -- okUPDATE base_tbl SET b=b; -- not allowedUPDATE rw_view1 SET bb=bb, cc=cc; -- okUPDATE rw_view1 SET aa=aa; -- not allowedUPDATE rw_view2 SET aa=aa, cc=cc; -- okUPDATE rw_view2 SET bb=bb; -- not allowedDELETE FROM base_tbl; -- not allowedDELETE FROM rw_view1; -- not allowedDELETE FROM rw_view2; -- not allowedRESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user1;
GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- okINSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowedINSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- okDELETE FROM base_tbl WHERE a=1; -- okDELETE FROM rw_view1 WHERE aa=2; -- not allowedDELETE FROM rw_view2 WHERE aa=2; -- okSELECT * FROM base_tbl;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user1;
REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowedINSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- okINSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowedDELETE FROM base_tbl WHERE a=3; -- not allowedDELETE FROM rw_view1 WHERE aa=3; -- okDELETE FROM rw_view2 WHERE aa=4; -- not allowedSELECT * FROM base_tbl;
RESET SESSION AUTHORIZATION;
DROP TABLE base_tbl CASCADE;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM rw_view1;  -- not allowedSELECT * FROM rw_view1 FOR UPDATE;  -- not allowedUPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowedSET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM rw_view2;  -- not allowedSELECT * FROM rw_view2 FOR UPDATE;  -- not allowedUPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowedRESET SESSION AUTHORIZATION;
GRANT SELECT ON base_tbl TO regress_view_user1;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM rw_view1 FOR UPDATE;  -- not allowedUPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowedSET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM rw_view2;  -- not allowedSELECT * FROM rw_view2 FOR UPDATE;  -- not allowedUPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowedSET SESSION AUTHORIZATION regress_view_user1;
GRANT SELECT ON rw_view1 TO regress_view_user2;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM rw_view2 FOR UPDATE;  -- not allowedUPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowedRESET SESSION AUTHORIZATION;
GRANT UPDATE ON base_tbl TO regress_view_user1;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM rw_view1 FOR UPDATE;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM rw_view2 FOR UPDATE;  -- not allowedUPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowedSET SESSION AUTHORIZATION regress_view_user1;
GRANT UPDATE ON rw_view1 TO regress_view_user2;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM rw_view2 FOR UPDATE;
RESET SESSION AUTHORIZATION;
REVOKE UPDATE ON base_tbl FROM regress_view_user1;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM rw_view1 FOR UPDATE;  -- not allowedUPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowedSET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM rw_view2 FOR UPDATE;  -- not allowedUPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowedRESET SESSION AUTHORIZATION;
DROP TABLE base_tbl CASCADE;
DROP USER regress_view_user1;
DROP USER regress_view_user2;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial);
ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
DROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
CREATE FUNCTION rw_view1_trig_fn()RETURNS trigger AS$$BEGIN  IF TG_OP = 'INSERT' THEN    UPDATE base_tbl SET b=NEW.b WHERE a=1;
    RETURN NULL;
  END IF;
  RETURN NULL;
END;
$$LANGUAGE plpgsql;
DROP TRIGGER rw_view1_ins_trig on base_tbl;
DROP FUNCTION rw_view1_trig_fn();
EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
UPDATE rw_view1 SET b = b + 1 RETURNING *;
DROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl (a int, arr int[]);
UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
DROP TABLE base_tbl CASCADE;
INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
INSERT INTO rw_view1 VALUES (null, null, 1.1, null); -- should failINSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1); -- should failINSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c; -- OKUPDATE rw_view1 SET s = s WHERE a = 1.1; -- should failUPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s; -- OKDELETE FROM rw_view1 WHERE a = 1.05; -- OKCREATE VIEW rw_view2 AS  SELECT s, c, s/c t, a base_a, ctid  FROM rw_view1;
INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null); -- should failINSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1); -- should failINSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t; -- OKUPDATE rw_view2 SET s = s WHERE base_a = 1.1; -- should failUPDATE rw_view2 SET t = t WHERE base_a = 1.1; -- should failUPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1; -- OKDELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t; -- OKCREATE VIEW rw_view3 AS  SELECT s, c, s/c t, ctid  FROM rw_view1;
INSERT INTO rw_view3 VALUES (null, null, null, null); -- should failINSERT INTO rw_view3(s) VALUES (null); -- should failUPDATE rw_view3 SET s = s; -- should failDELETE FROM rw_view3 WHERE s = sin(0.1); -- should be OKSELECT * FROM base_tbl ORDER BY a;
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name LIKE E'r_\\_view%' ORDER BY table_name;
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name LIKE E'r_\\_view%' ORDER BY table_name;
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name LIKE E'r_\\_view%' ORDER BY table_name, ordinal_position;
&SELECT events & 4 != 0 AS upd,       events & 8 != 0 AS ins,       events & 16 != 0 AS del  FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
DROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent);
UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1); -- Should produce -10 and 10UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2); -- Should produce -20 and 20UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3); -- Should produce -30 onlyUPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4); -- Should produce -40 onlyDELETE FROM rw_view1 WHERE a IN (-5, 5); -- Should delete -5 and 5DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6); -- Should delete -6 and 6DELETE FROM rw_view2 WHERE a IN (-7, 7); -- Should delete -7 onlyDELETE FROM ONLY rw_view2 WHERE a IN (-8, 8); -- Should delete -8 onlySELECT * FROM ONLY base_tbl_parent ORDER BY a;
CREATE TABLE other_tbl_child () INHERITS (other_tbl_parent);
EXPLAIN (costs off)UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
DROP TABLE other_tbl_parent CASCADE;
CREATE TABLE base_tbl (a int, b int DEFAULT 10);
SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
INSERT INTO rw_view1 VALUES(3,4); -- okINSERT INTO rw_view1 VALUES(4,3); -- should failINSERT INTO rw_view1 VALUES(5,null); -- should failUPDATE rw_view1 SET b = 5 WHERE a = 3; -- okUPDATE rw_view1 SET b = -5 WHERE a = 3; -- should failINSERT INTO rw_view1(a) VALUES (9); -- okINSERT INTO rw_view1(a) VALUES (10); -- should failSELECT * FROM base_tbl;
DROP TABLE base_tbl CASCADE;
CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10  WITH CHECK OPTION; -- implicitly cascadedSELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
INSERT INTO rw_view2 VALUES (-5); -- should failINSERT INTO rw_view2 VALUES (5); -- okINSERT INTO rw_view2 VALUES (15); -- should failSELECT * FROM base_tbl;
UPDATE rw_view2 SET a = a - 10; -- should failUPDATE rw_view2 SET a = a + 10; -- should failCREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10  WITH LOCAL CHECK OPTION;
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
INSERT INTO rw_view2 VALUES (-10); -- ok, but not in viewINSERT INTO rw_view2 VALUES (20); -- should failSELECT * FROM base_tbl;
ALTER VIEW rw_view1 SET (check_option=here); -- invalidALTER VIEW rw_view1 SET (check_option=local);
INSERT INTO rw_view2 VALUES (-20); -- should failINSERT INTO rw_view2 VALUES (30); -- should failALTER VIEW rw_view2 RESET (check_option);
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
INSERT INTO rw_view2 VALUES (30); -- ok, but not in viewSELECT * FROM base_tbl;
DROP TABLE base_tbl CASCADE;
SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
INSERT INTO rw_view1 VALUES (-1); -- okINSERT INTO rw_view1 VALUES (1); -- okINSERT INTO rw_view2 VALUES (-2); -- ok, but not in viewINSERT INTO rw_view2 VALUES (2); -- okINSERT INTO rw_view3 VALUES (-3); -- should failINSERT INTO rw_view3 VALUES (3); -- okDROP TABLE base_tbl CASCADE;
CREATE TABLE base_tbl (a int, b int[]);
INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]); -- okINSERT INTO rw_view1 VALUES (10, ARRAY[4,5]); -- should failUPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1; -- okUPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1; -- should failPREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
EXECUTE ins(2, ARRAY[1,2,3]); -- okEXECUTE ins(10, ARRAY[4,5]); -- should failDEALLOCATE PREPARE ins;
DROP TABLE base_tbl CASCADE;
CREATE VIEW rw_view1 AS  SELECT * FROM base_tbl b  WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)  WITH CHECK OPTION;
INSERT INTO rw_view1 VALUES (5); -- okINSERT INTO rw_view1 VALUES (15); -- should failUPDATE rw_view1 SET a = a + 5; -- okUPDATE rw_view1 SET a = a + 5; -- should failEXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
DROP TABLE base_tbl, ref_tbl CASCADE;
CREATE FUNCTION base_tbl_trig_fn()RETURNS trigger AS$$BEGIN  NEW.b := 10;
  RETURN NEW;
END;
$$LANGUAGE plpgsql;
CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl  FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
INSERT INTO rw_view1 VALUES (5,0); -- okINSERT INTO rw_view1 VALUES (15, 20); -- should failUPDATE rw_view1 SET a = 20, b = 30; -- should failDROP TABLE base_tbl CASCADE;
DROP FUNCTION base_tbl_trig_fn();
CREATE FUNCTION rw_view1_trig_fn()RETURNS trigger AS$$BEGIN  IF TG_OP = 'INSERT' THEN    INSERT INTO base_tbl VALUES (NEW.a, 10);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN    UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN    DELETE FROM base_tbl WHERE a=OLD.a;
    RETURN OLD;
  END IF;
END;
$$LANGUAGE plpgsql;
CREATE TRIGGER rw_view1_trig  INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
INSERT INTO rw_view2 VALUES (-5); -- should failINSERT INTO rw_view2 VALUES (5); -- okINSERT INTO rw_view2 VALUES (50); -- ok, but not in viewUPDATE rw_view2 SET a = a - 10; -- should failSELECT * FROM base_tbl;
ALTER VIEW rw_view2 SET (check_option=cascaded);
INSERT INTO rw_view2 VALUES (100); -- ok, but not in view (doesn't fail rw_view1's check)UPDATE rw_view2 SET a = 200 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)SELECT * FROM base_tbl;
DROP TRIGGER rw_view1_trig ON rw_view1;
CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1  DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view (doesn't fail rw_view2's check)INSERT INTO rw_view2 VALUES (5); -- okINSERT INTO rw_view2 VALUES (20); -- ok, but not in view (doesn't fail rw_view1's check)UPDATE rw_view2 SET a = 30 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)INSERT INTO rw_view2 VALUES (5); -- okUPDATE rw_view2 SET a = -5 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view2's check)SELECT * FROM base_tbl;
DROP TABLE base_tbl CASCADE;
DROP FUNCTION rw_view1_trig_fn();
CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
INSERT INTO rw_view2 VALUES (2,3); -- ok, but not in view (doesn't fail rw_view2's check)DROP TABLE base_tbl CASCADE;
CREATE FUNCTION snoop(anyelement)RETURNS boolean AS$$BEGIN  RAISE NOTICE 'snooped value: %', $1;
  RETURN true;
END;
$$LANGUAGE plpgsql COST 0.000001;
CREATE OR REPLACE FUNCTION leakproof(anyelement)RETURNS boolean AS$$BEGIN  RETURN true;
END;
$$LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
DELETE FROM rw_view1 WHERE NOT snoop(person);
ALTER VIEW rw_view1 SET (security_barrier = true);
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name = 'rw_view1';
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name = 'rw_view1';
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name = 'rw_view1' ORDER BY ordinal_position;
DELETE FROM rw_view1 WHERE NOT snoop(person);
EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
CREATE VIEW rw_view2 WITH (security_barrier = true) AS  SELECT * FROM rw_view1 WHERE snoop(person);
SELECT table_name, is_insertable_into  FROM information_schema.tables WHERE table_name = 'rw_view2';
SELECT table_name, is_updatable, is_insertable_into  FROM information_schema.views WHERE table_name = 'rw_view2';
SELECT table_name, column_name, is_updatable  FROM information_schema.columns WHERE table_name = 'rw_view2' ORDER BY ordinal_position;
DELETE FROM rw_view2 WHERE NOT snoop(person);
EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
DROP TABLE base_tbl CASCADE;
CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl  WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)  DO INSTEAD    UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl  DO INSTEAD    UPDATE base_tbl SET deleted = true WHERE id = old.id;
CREATE VIEW rw_view1 WITH (security_barrier=true) AS  SELECT id, data FROM base_tbl WHERE NOT deleted;
EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
DROP TABLE base_tbl CASCADE;
INSERT INTO t1SELECT i,i,'t1' FROM generate_series(1,10) g(i);
ANALYZE t1;
CREATE TABLE t11 (d text) INHERITS (t1);
INSERT INTO t11SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
ANALYZE t11;
CREATE TABLE t12 (e int[]) INHERITS (t1);
INSERT INTO t12SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
ANALYZE t12;
CREATE TABLE t111 () INHERITS (t11, t12);
INSERT INTO t111SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
ANALYZE t111;
CREATE VIEW v1 WITH (security_barrier=true) ASSELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS dFROM t1WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
SELECT * FROM v1 WHERE a=3; -- should not see anythingSELECT * FROM v1 WHERE a=8;
EXPLAIN (VERBOSE, COSTS OFF)UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
SELECT * FROM v1 WHERE a=100; -- Nothing should have been changed to 100SELECT * FROM t1 WHERE a=100; -- Nothing should have been changed to 100EXPLAIN (VERBOSE, COSTS OFF)UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
DELETE FROM v1 WHERE snoop(a) AND leakproof(a); -- should not delete everything, just where a>5TABLE t1; -- verify all a<=5 are intactDROP TABLE t1, t11, t12, t111 CASCADE;
DROP FUNCTION snoop(anyelement);
DROP FUNCTION leakproof(anyelement);
ALTER TABLE tx1 DROP COLUMN b;
ALTER TABLE tx2 DROP COLUMN c;
ALTER TABLE tx3 DROP COLUMN d;
CREATE VIEW v1 WITH (security_barrier = true) AS  SELECT * FROM t1 WHERE (a > 0)  WITH CHECK OPTION;
CREATE VIEW v2 WITH (security_barrier = true) AS  SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)  WITH CHECK OPTION;
INSERT INTO v2 VALUES (2, 'two', 20); -- okINSERT INTO v2 VALUES (-2, 'minus two', 20); -- not allowedINSERT INTO v2 VALUES (3, 'three', 30); -- not allowedUPDATE v2 SET b = 'ONE' WHERE a = 1; -- okUPDATE v2 SET a = -1 WHERE a = 1; -- not allowedUPDATE v2 SET c = 30 WHERE a = 1; -- not allowedDELETE FROM v2 WHERE a = 2; -- okSELECT * FROM v2;
CREATE VIEW v1 AS SELECT null::int AS a;
INSERT INTO v1 VALUES (1, 'ok'); -- okINSERT INTO v1 VALUES (-1, 'invalid'); -- should failDROP VIEW v1;
create table uv_pt (a int, b int, v varchar) partition by range (a, b);
create table uv_pt1 (b int not null, v varchar, a int not null) partition by range (b);
create table uv_pt11 (like uv_pt1);
alter table uv_pt11 drop a;
alter table uv_pt11 drop a;
alter table uv_pt1 attach partition uv_pt11 for values from (2) to (5);
alter table uv_pt attach partition uv_pt1 for values from (1, 2) to (1, 10);
&select events & 4 != 0 AS upd,       events & 8 != 0 AS ins,       events & 16 != 0 AS del  from pg_catalog.pg_relation_is_updatable('uv_pt'::regclass, false) t(events);
select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 1::smallint, false);
select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 2::smallint, false);
select table_name, is_updatable, is_insertable_into  from information_schema.views where table_name = 'uv_ptv';
select table_name, column_name, is_updatable  from information_schema.columns where table_name = 'uv_ptv' order by column_name;
::drop view uv_ptv, uv_ptv_wco;
drop table uv_pt, uv_pt1, uv_pt11;
create table wcowrtest (a int) partition by list (a);
create table wcowrtest1 partition of wcowrtest for values in (1);
::create view wcowrtest_v as select * from wcowrtest where wcowrtest = '(2)'::wcowrtest with check option;
alter table wcowrtest2 drop c;
alter table wcowrtest attach partition wcowrtest2 for values in (2);
create view wcowrtest_v2 as    select *      from wcowrtest r      where r in (select s from sometable s where r.a = s.a)with check option;
drop view wcowrtest_v, wcowrtest_v2;
drop table wcowrtest, sometable;
::create view uv_iocu_view as   select b, b+1 as c, a, '2.0'::text as two from uv_iocu_tab;
insert into uv_iocu_view (a, b) values ('xyxyxy', 1)   on conflict (a) do update set b = uv_iocu_view.b;
insert into uv_iocu_view (a, b) values ('xyxyxy', 1)   on conflict (a) do update set b = excluded.b;
insert into uv_iocu_view (a, b) values ('xyxyxy', 3)   on conflict (a) do update set b = cast(excluded.two as float);
explain (costs off)insert into uv_iocu_view (a, b) values ('xyxyxy', 3)   on conflict (a) do update set b = excluded.b where excluded.c > 0;
insert into uv_iocu_view (a, b) values ('xyxyxy', 3)   on conflict (a) do update set b = excluded.b where excluded.c > 0;
::create view uv_iocu_view as    select b as bb, a as aa, uv_iocu_tab::text as cc from uv_iocu_tab;
explain (costs off)insert into uv_iocu_view (aa,bb) values (1,'y')   on conflict (aa) do update set bb = 'Rejected: '||excluded.*   where excluded.aa > 0   and excluded.bb != ''   and excluded.cc is not null;
insert into uv_iocu_view (aa,bb) values (1,'y')   on conflict (aa) do update set bb = 'Rejected: '||excluded.*   where excluded.aa > 0   and excluded.bb != ''   and excluded.cc is not null;
delete from uv_iocu_view;
insert into uv_iocu_view (aa) values (1)   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
alter table uv_iocu_tab alter column b set default 'table default';
insert into uv_iocu_view (aa) values (1)   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
alter view uv_iocu_view alter column bb set default 'view default';
insert into uv_iocu_view (aa) values (1)   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
insert into uv_iocu_view (aa) values (1)   on conflict (aa) do update set cc = 'XXX';
create user regress_view_user1;
create user regress_view_user2;
set session authorization regress_view_user1;
grant select (aa,bb) on rw_view1 to regress_view_user2;
grant insert on rw_view1 to regress_view_user2;
grant update (bb) on rw_view1 to regress_view_user2;
set session authorization regress_view_user2;
insert into rw_view1 values ('yyy',2.0,1)  on conflict (aa) do update set bb = excluded.cc; -- Not allowedinsert into rw_view1 values ('yyy',2.0,1)  on conflict (aa) do update set bb = rw_view1.cc; -- Not allowedinsert into rw_view1 values ('yyy',2.0,1)  on conflict (aa) do update set bb = excluded.bb; -- OKinsert into rw_view1 values ('zzz',2.0,1)  on conflict (aa) do update set bb = rw_view1.bb||'xxx'; -- OKinsert into rw_view1 values ('zzz',2.0,1)  on conflict (aa) do update set cc = 3.0; -- Not allowedreset session authorization;
set session authorization regress_view_user1;
grant select (a,b) on base_tbl to regress_view_user2;
grant insert (a,b) on base_tbl to regress_view_user2;
grant update (a,b) on base_tbl to regress_view_user2;
set session authorization regress_view_user2;
insert into rw_view2 (aa,bb) values (1,'xxx')  on conflict (aa) do update set bb = excluded.bb; -- Not allowedcreate view rw_view3 as select b as bb, a as aa from base_tbl;
insert into rw_view3 (aa,bb) values (1,'xxx')  on conflict (aa) do update set bb = excluded.bb; -- OKreset session authorization;
set session authorization regress_view_user2;
insert into rw_view4 (aa,bb) values (1,'yyy')  on conflict (aa) do update set bb = excluded.bb; -- Not allowedcreate view rw_view5 as select aa, bb FROM rw_view1;
insert into rw_view5 (aa,bb) values (1,'yyy')  on conflict (aa) do update set bb = excluded.bb; -- OKreset session authorization;
drop user regress_view_user1;
drop user regress_view_user2;
create table base_tab_def (a int, b text default 'Table default',                           c text default 'Table default', d text, e text);
alter view base_tab_def_view alter b set default 'View default';
alter view base_tab_def_view alter d set default 'View default';
insert into base_tab_def values (4, default, default, default, default);
insert into base_tab_def values (5, default, default, default, default),                                (6, default, default, default, default);
insert into base_tab_def_view values (14, default, default, default, default);
insert into base_tab_def_view values (15, default, default, default, default),                                     (16, default, default, default, default);
insert into base_tab_def_view values (17), (default);
create function base_tab_def_view_instrig_func() returns triggeras$$begin  insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
  return new;
end;
$$language plpgsql;
create trigger base_tab_def_view_instrig instead of insert on base_tab_def_view  for each row execute function base_tab_def_view_instrig_func();
truncate base_tab_def;
insert into base_tab_def values (4, default, default, default, default);
insert into base_tab_def values (5, default, default, default, default),                                (6, default, default, default, default);
insert into base_tab_def_view values (14, default, default, default, default);
insert into base_tab_def_view values (15, default, default, default, default),                                     (16, default, default, default, default);
insert into base_tab_def_view values (17), (default);
drop trigger base_tab_def_view_instrig on base_tab_def_view;
drop function base_tab_def_view_instrig_func;
create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view  do instead insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
truncate base_tab_def;
insert into base_tab_def values (4, default, default, default, default);
insert into base_tab_def values (5, default, default, default, default),                                (6, default, default, default, default);
insert into base_tab_def_view values (14, default, default, default, default);
insert into base_tab_def_view values (15, default, default, default, default),                                     (16, default, default, default, default);
insert into base_tab_def_view values (17), (default);
drop rule base_tab_def_view_ins_rule on base_tab_def_view;
create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view  do also insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
truncate base_tab_def;
insert into base_tab_def values (4, default, default, default, default);
insert into base_tab_def values (5, default, default, default, default),                                (6, default, default, default, default);
insert into base_tab_def_view values (14, default, default, default, default);
insert into base_tab_def_view values (15, default, default, default, default),                                     (16, default, default, default, default);
insert into base_tab_def_view values (17), (default);
select * from base_tab_def order by a, c NULLS LAST;
create table base_tab (a serial, b int[], c text, d text default 'Table default');
alter view base_tab_view alter column c set default 'View default';
insert into base_tab_view (b[1], b[2], c, b[5], b[4], a, b[3])values (1, 2, default, 5, 4, default, 3), (10, 11, 'C value', 14, 13, 100, 12);
CREATE TABLE INET_TBL (c cidr, i inet);
SELECT '' AS ten, i AS inet, host(i), text(i), family(i) FROM INET_TBL;
SELECT '' AS ten, i, c,  i < c AS lt, i <= c AS le, i = c AS eq,  i >= c AS ge, i > c AS gt, i <> c AS ne,  i << c AS sb, i <<= c AS sbe,  i >> c AS sup, i >>= c AS spe,  i && c AS ovr  FROM INET_TBL;
SELECT '' AS ten, set_masklen(inet(text(i)), 24) FROM INET_TBL;
SET enable_seqscan TO off;
EXPLAIN (COSTS OFF)SELECT * FROM inet_tbl WHERE i<<'192.168.1.0/24'::cidr;
SELECT * FROM inet_tbl WHERE i<<'192.168.1.0/24'::cidr;
EXPLAIN (COSTS OFF)SELECT * FROM inet_tbl WHERE i<<='192.168.1.0/24'::cidr;
SELECT * FROM inet_tbl WHERE i<<='192.168.1.0/24'::cidr;
EXPLAIN (COSTS OFF)SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >>= i;
::SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >>= i;
EXPLAIN (COSTS OFF)SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >> i;
::SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >> i;
SET enable_seqscan TO on;
CREATE INDEX inet_idx2 ON inet_tbl using gist (i inet_ops);
SET enable_seqscan TO off;
SELECT * FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <<= '192.168.1.0/24'::cidr ORDER BY i;
&&SELECT * FROM inet_tbl WHERE i && '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >>= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >> '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i < '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i <= '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i = '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i >= '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i > '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <> '192.168.1.0/24'::cidr ORDER BY i;
EXPLAIN (COSTS OFF)SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SET enable_seqscan TO on;
CREATE INDEX inet_idx3 ON inet_tbl using spgist (i);
SET enable_seqscan TO off;
SELECT * FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <<= '192.168.1.0/24'::cidr ORDER BY i;
&&SELECT * FROM inet_tbl WHERE i && '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >>= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >> '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i < '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i <= '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i = '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i >= '192.168.1.0/24'::cidr ORDER BY i;
::SELECT * FROM inet_tbl WHERE i > '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <> '192.168.1.0/24'::cidr ORDER BY i;
EXPLAIN (COSTS OFF)SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SET enable_seqscan TO on;
~&SELECT i, c, i & c AS "and" FROM inet_tbl;
|SELECT i, c, i | c AS "or" FROM inet_tbl;
::SELECT '127.0.0.1'::inet + 257;
::SELECT ('127.0.0.1'::inet + 257) - 257;
::SELECT '127::1'::inet + 257;
::SELECT ('127::1'::inet + 257) - 257;
::SELECT '127.0.0.2'::inet  - ('127.0.0.2'::inet + 500);
::SELECT '127.0.0.2'::inet  - ('127.0.0.2'::inet - 500);
::SELECT '127::2'::inet  - ('127::2'::inet + 500);
::SELECT '127::2'::inet  - ('127::2'::inet - 500);
::SELECT '127.0.0.1'::inet + 10000000000;
::SELECT '127.0.0.1'::inet - 10000000000;
::SELECT '126::1'::inet - '127::2'::inet;
::SELECT '127::1'::inet - '126::2'::inet;
::SELECT '127::1'::inet + 10000000000;
::SELECT '127::1'::inet - '127::2'::inet;
SELECT a FROM (VALUES  ('0.0.0.0/0'::inet),  ('0.0.0.0/1'::inet),  ('0.0.0.0/32'::inet),  ('0.0.0.1/0'::inet),  ('0.0.0.1/1'::inet),  ('127.126.127.127/0'::inet),  ('127.127.127.127/0'::inet),  ('127.128.127.127/0'::inet),  ('192.168.1.0/24'::inet),  ('192.168.1.0/25'::inet),  ('192.168.1.1/23'::inet),  ('192.168.1.1/5'::inet),  ('192.168.1.1/6'::inet),  ('192.168.1.1/25'::inet),  ('192.168.1.2/25'::inet),  ('192.168.1.1/26'::inet),  ('192.168.1.2/26'::inet),  ('192.168.1.2/23'::inet),  ('192.168.1.255/5'::inet),  ('192.168.1.255/6'::inet),  ('192.168.1.3/1'::inet),  ('192.168.1.3/23'::inet),  ('192.168.1.4/0'::inet),  ('192.168.1.5/0'::inet),  ('255.0.0.0/0'::inet),  ('255.1.0.0/0'::inet),  ('255.2.0.0/0'::inet),  ('255.255.000.000/0'::inet),  ('255.255.000.000/0'::inet),  ('255.255.000.000/15'::inet),  ('255.255.000.000/16'::inet),  ('255.255.255.254/32'::inet),  ('255.255.255.000/32'::inet),  ('255.255.255.001/31'::inet),  ('255.255.255.002/31'::inet),  ('255.255.255.003/31'::inet),  ('255.255.255.003/32'::inet),  ('255.255.255.001/32'::inet),  ('255.255.255.255/0'::inet),  ('255.255.255.255/0'::inet),  ('255.255.255.255/0'::inet),  ('255.255.255.255/1'::inet),  ('255.255.255.255/16'::inet),  ('255.255.255.255/16'::inet),  ('255.255.255.255/31'::inet),  ('255.255.255.255/32'::inet),  ('255.255.255.253/32'::inet),  ('255.255.255.252/32'::inet),  ('255.3.0.0/0'::inet),  ('0000:0000:0000:0000:0000:0000:0000:0000/0'::inet),  ('0000:0000:0000:0000:0000:0000:0000:0000/128'::inet),  ('0000:0000:0000:0000:0000:0000:0000:0001/128'::inet),  ('10:23::f1/64'::inet),  ('10:23::f1/65'::inet),  ('10:23::ffff'::inet),  ('127::1'::inet),  ('127::2'::inet),  ('8000:0000:0000:0000:0000:0000:0000:0000/1'::inet),  ('::1:ffff:ffff:ffff:ffff/128'::inet),  ('::2:ffff:ffff:ffff:ffff/128'::inet),  ('::4:3:2:0/24'::inet),  ('::4:3:2:1/24'::inet),  ('::4:3:2:2/24'::inet),  ('ffff:83e7:f118:57dc:6093:6d92:689d:58cf/70'::inet),  ('ffff:84b0:4775:536e:c3ed:7116:a6d6:34f0/44'::inet),  ('ffff:8566:f84:5867:47f1:7867:d2ba:8a1a/69'::inet),  ('ffff:8883:f028:7d2:4d68:d510:7d6b:ac43/73'::inet),  ('ffff:8ae8:7c14:65b3:196:8e4a:89ae:fb30/89'::inet),  ('ffff:8dd0:646:694c:7c16:7e35:6a26:171/104'::inet),  ('ffff:8eef:cbf:700:eda3:ae32:f4b4:318b/121'::inet),  ('ffff:90e7:e744:664:a93:8efe:1f25:7663/122'::inet),  ('ffff:9597:c69c:8b24:57a:8639:ec78:6026/111'::inet),  ('ffff:9e86:79ea:f16e:df31:8e4d:7783:532e/88'::inet),  ('ffff:a0c7:82d3:24de:f762:6e1f:316d:3fb2/23'::inet),  ('ffff:fffa:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:fffb:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:fffc:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:fffd:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:fffe:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:fffa:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:fffb:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:fffc:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:fffd::/128'::inet),  ('ffff:ffff:ffff:fffd:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:fffe::/128'::inet),  ('ffff:ffff:ffff:fffe:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:ffff:4:3:2:0/24'::inet),  ('ffff:ffff:ffff:ffff:4:3:2:1/24'::inet),  ('ffff:ffff:ffff:ffff:4:3:2:2/24'::inet),  ('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),  ('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128'::inet)) AS i(a) ORDER BY a;
CREATE TABLE guid1	guid_field UUID,	text_field TEXT DEFAULT(now()));
CREATE TABLE guid2	guid_field UUID,	text_field TEXT DEFAULT(now()));
SELECT COUNT(*) FROM guid1 WHERE guid_field <> '11111111111111111111111111111111';
CREATE INDEX guid1_btree ON guid1 USING BTREE (guid_field);
CREATE INDEX guid1_hash  ON guid1 USING HASH  (guid_field);
CREATE UNIQUE INDEX guid1_unique_BTREE ON guid1 USING BTREE (guid_field);
SELECT COUNT(*) FROM guid1 g1 INNER JOIN guid2 g2 ON g1.guid_field = g2.guid_field;
SELECT COUNT(*) FROM guid1 g1 LEFT JOIN guid2 g2 ON g1.guid_field = g2.guid_field WHERE g2.guid_field IS NULL;
TRUNCATE guid1;
DROP TABLE guid1, guid2 CASCADE;
SELECT DISTINCT ON (string4) string4, two, ten   FROM tmp   ORDER BY string4 using <, two using >, ten using <;
SELECT DISTINCT ON (string4, ten) string4, two, ten   FROM tmp   ORDER BY string4 using <, two using <, ten using <;
SELECT DISTINCT ON (string4, ten) string4, ten, two   FROM tmp   ORDER BY string4 using <, ten using >, two using <;
select distinct on (1) floor(random()) as r, f1 from int4_tbl order by 1,2;
create temp view gstest1(a,b,v)  as values (1,1,10),(1,1,11),(1,2,12),(1,2,13),(1,3,14),            (2,3,15),            (3,3,16),(3,4,17),            (4,1,18),(4,1,19);
copy gstest2 from stdin;
1	1	1	1	1	1	1	11	1	1	1	1	1	1	21	1	1	1	1	1	2	21	1	1	1	1	2	2	21	1	1	1	2	2	2	21	1	1	2	2	2	2	21	1	2	2	2	2	2	21	2	2	2	2	2	2	22	2	2	2	2	2	2	2\.create temp table gstest3 (a integer, b integer, c integer, d integer);
copy gstest3 from stdin;
1	1	1	12	2	2	2\.alter table gstest3 add primary key (a);
create temp table gstest4(id integer, v integer,                          unhashable_col bit(4), unsortable_col xid);
insert into gstest4values (1,1,b'0000','1'), (2,2,b'0001','1'),       (3,4,b'0010','2'), (4,8,b'0011','2'),       (5,16,b'0000','2'), (6,32,b'0001','2'),       (7,64,b'0010','1'), (8,128,b'0011','1');
create function gstest_data(v integer, out a integer, out b integer)  returns setof record  as $f$    begin      return query select v, i from generate_series(1,3) i;
    end;
$  $f$ language plpgsql;
set enable_hashagg = false;  -- test hashing explicitly laterselect a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by rollup (a,b);
select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by rollup (a,b) order by a,b;
select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by rollup (a,b) order by b desc, a;
select a, b, grouping(a,b),       array_agg(v order by v),       string_agg(v::text, ':' order by v desc),       percentile_disc(0.5) within group (order by v),       rank(1,2,12) within group (order by a,b,v)  from gstest1 group by rollup (a,b) order by a,b;
select grouping(a), a, array_agg(b),       rank(a) within group (order by b nulls first),       rank(a) within group (order by b nulls last)  from (values (1,1),(1,4),(1,5),(3,1),(3,2)) v(a,b) group by rollup (a) order by a;
select a, b, sum(c), sum(sum(c)) over (order by a,b) as rsum  from gstest2 group by rollup (a,b) order by rsum, a, b;
select sum(c) from gstest2  group by grouping sets((), grouping sets((), grouping sets(())))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets((), grouping sets((), grouping sets(((a, b)))))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets(grouping sets(rollup(c), grouping sets(cube(c))))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets(a, grouping sets(a, cube(b)))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets(grouping sets((a, (b))))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets(grouping sets((a, b)))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets(grouping sets(a, grouping sets(a), a))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets(grouping sets(a, grouping sets(a, grouping sets(a), ((a)), a, grouping sets(a), (a)), a))  order by 1 desc;
select sum(c) from gstest2  group by grouping sets((a,(a,b)), grouping sets((a,(a,b)),a))  order by 1 desc;
select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),a);
select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),());
select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),(),(),());
select sum(v), count(*) from gstest_empty group by grouping sets ((),(),());
select t1.a, t2.b, sum(t1.v), count(*) from gstest_empty t1, gstest_empty t2 group by grouping sets ((t1.a,t2.b),());
select t1.a, t2.b, grouping(t1.a, t2.b), sum(t1.v), max(t2.a)  from gstest1 t1, gstest2 t2 group by grouping sets ((t1.a, t2.b), ());
select t1.a, t2.b, grouping(t1.a, t2.b), sum(t1.v), max(t2.a)  from gstest1 t1 join gstest2 t2 on (t1.a=t2.a) group by grouping sets ((t1.a, t2.b), ());
select a, b, grouping(a, b), sum(t1.v), max(t2.c)  from gstest1 t1 join gstest2 t2 using (a,b) group by grouping sets ((a, b), ());
select a, d, grouping(a,b,c)  from gstest3 group by grouping sets ((a,b), (a,c));
explain (costs off)select g as alias1, g as alias2  from generate_series(1,3) g group by alias1, rollup(alias2);
::select four, x  from (select four, ten, 'foo'::text as x from tenk1) as t  group by grouping sets (four, x)  having x = 'foo';
||select four, x || 'x'  from (select four, ten, 'foo'::text as x from tenk1) as t  group by grouping sets (four, x)  order by four;
select (x+y)*1, sum(z) from (select 1 as x, 2 as y, 3 as z) s group by grouping sets (x+y, x);
select x, not x as not_x, q2 from  (select *, q1 = 1 as x from int8_tbl i1) as t  group by grouping sets(x, q2)  order by x, q2;
select a, b, sum(v.x)  from (values (1),(2)) v(x), gstest_data(v.x) group by rollup (a,b);
select *  from (values (1),(2)) v(x),       lateral (select a, b, sum(v.x) from gstest_data(v.x) group by rollup (a,b)) s;
explain (costs off)  select min(unique1) from tenk1 GROUP BY ();
::select(select (select grouping(a,b) from (values (1)) v2(c)) from (values (1,2)) v1(a,b) group by (a,b)) from (values(6,7)) v3(e,f) GROUP BY ROLLUP(e,f);
select(select (select grouping(e,f) from (values (1)) v2(c)) from (values (1,2)) v1(a,b) group by (a,b)) from (values(6,7)) v3(e,f) GROUP BY ROLLUP(e,f);
select(select (select grouping(c) from (values (1)) v2(c) GROUP BY c) from (values (1,2)) v1(a,b) group by (a,b)) from (values(6,7)) v3(e,f) GROUP BY ROLLUP(e,f);
select a, b, c, d from gstest2 group by rollup(a,b),grouping sets(c,d);
select a, b from (values (1,2),(2,3)) v(a,b) group by a,b, grouping sets(a);
select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by grouping sets ((a,b),(a+1,b+1),(a+2,b+2)) order by 3,6;
select(select (select grouping(a,b) from (values (1)) v2(c)) from (values (1,2)) v1(a,b) group by (a,b)) from (values(6,7)) v3(e,f) GROUP BY ROLLUP((e+1),(f+1));
select(select (select grouping(a,b) from (values (1)) v2(c)) from (values (1,2)) v1(a,b) group by (a,b)) from (values(6,7)) v3(e,f) GROUP BY CUBE((e+1),(f+1)) ORDER BY (e+1),(f+1);
select a, b, sum(c), sum(sum(c)) over (order by a,b) as rsum  from gstest2 group by cube (a,b) order by rsum, a, b;
select a, b, sum(c) from (values (1,1,10),(1,1,11),(1,2,12),(1,2,13),(1,3,14),(2,3,15),(3,3,16),(3,4,17),(4,1,18),(4,1,19)) v(a,b,c) group by rollup (a,b);
select a, b, sum(v.x)  from (values (1),(2)) v(x), gstest_data(v.x) group by cube (a,b) order by a,b;
explain (costs off)select * from gstest1 group by grouping sets((a,b,v),(v)) order by v,b,a;
select a, b, sum(c), count(*) from gstest2 group by grouping sets (rollup(a,b),a);
select ten, sum(distinct four) from onek agroup by grouping sets((ten,four),(ten))having exists (select 1 from onek b where sum(distinct a.four) = b.four);
select a,count(*) from gstest2 group by rollup(a) having a is distinct from 1 order by a;
explain (costs off)  select a,count(*) from gstest2 group by rollup(a) having a is distinct from 1 order by a;
select v.c, (select count(*) from gstest2 group by () having v.c)  from (values (false),(true)) v(c) order by v.c;
explain (costs off)  select v.c, (select count(*) from gstest2 group by () having v.c)    from (values (false),(true)) v(c) order by v.c;
select ten, grouping(ten) from onekgroup by grouping sets(ten) having grouping(ten) >= 0order by 2,1;
select ten, grouping(ten) from onekgroup by grouping sets(ten, four) having grouping(ten) > 0order by 2,1;
select ten, grouping(ten) from onekgroup by rollup(ten) having grouping(ten) > 0order by 2,1;
select ten, grouping(ten) from onekgroup by cube(ten) having grouping(ten) > 0order by 2,1;
select ten, grouping(ten) from onekgroup by (ten) having grouping(ten) >= 0order by 2,1;
::select ten, sum(distinct four) filter (where four::text ~ '123') from onek agroup by rollup(ten);
select * from (values (1),(2)) v(a) left join lateral (select v.a, four, ten, count(*) from onek group by cube(four,ten)) s on true order by v.a,four,ten;
select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
::select sum(ten) from onek group by two, rollup(four::text) order by 1;
::select sum(ten) from onek group by rollup(four::text), two order by 1;
set enable_hashagg = true;
select array_agg(v order by v) from gstest4 group by grouping sets ((id,unsortable_col),(id));
select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by grouping sets ((a),(b)) order by 3,1,2;
explain (costs off) select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by grouping sets ((a),(b)) order by 3,1,2;
select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by cube(a,b) order by 3,1,2;
explain (costs off) select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by cube(a,b) order by 3,1,2;
explain (costs off)  select a, b, grouping(a,b), array_agg(v order by v)    from gstest1 group by cube(a,b);
select unsortable_col, count(*)  from gstest4 group by grouping sets ((unsortable_col),(unsortable_col))  order by unsortable_col::text;
select unhashable_col, unsortable_col,       grouping(unhashable_col, unsortable_col),       count(*), sum(v)  from gstest4 group by grouping sets ((unhashable_col),(unsortable_col)) order by 3, 5;
explain (costs off)  select unhashable_col, unsortable_col,         grouping(unhashable_col, unsortable_col),         count(*), sum(v)    from gstest4 group by grouping sets ((unhashable_col),(unsortable_col))   order by 3,5;
select unhashable_col, unsortable_col,       grouping(unhashable_col, unsortable_col),       count(*), sum(v)  from gstest4 group by grouping sets ((v,unhashable_col),(v,unsortable_col)) order by 3,5;
explain (costs off)  select unhashable_col, unsortable_col,         grouping(unhashable_col, unsortable_col),         count(*), sum(v)    from gstest4 group by grouping sets ((v,unhashable_col),(v,unsortable_col))   order by 3,5;
select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),a);
explain (costs off)  select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),a);
select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),());
select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),(),(),());
explain (costs off)  select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),(),(),());
select sum(v), count(*) from gstest_empty group by grouping sets ((),(),());
explain (costs off)  select sum(v), count(*) from gstest_empty group by grouping sets ((),(),());
select a, d, grouping(a,b,c)  from gstest3 group by grouping sets ((a,b), (a,c));
explain (costs off)  select a, d, grouping(a,b,c)    from gstest3   group by grouping sets ((a,b), (a,c));
select a, b, sum(v.x)  from (values (1),(2)) v(x), gstest_data(v.x) group by grouping sets (a,b) order by 1, 2, 3;
explain (costs off)  select a, b, sum(v.x)    from (values (1),(2)) v(x), gstest_data(v.x)   group by grouping sets (a,b)   order by 3, 1, 2;
select *  from (values (1),(2)) v(x),       lateral (select a, b, sum(v.x) from gstest_data(v.x) group by grouping sets (a,b)) s;
explain (costs off)  select *    from (values (1),(2)) v(x),         lateral (select a, b, sum(v.x) from gstest_data(v.x) group by grouping sets (a,b)) s;
select a, b, grouping(a,b), sum(v), count(*), max(v)  from gstest1 group by grouping sets ((a,b),(a+1,b+1),(a+2,b+2)) order by 3,6;
explain (costs off)  select a, b, grouping(a,b), sum(v), count(*), max(v)    from gstest1 group by grouping sets ((a,b),(a+1,b+1),(a+2,b+2)) order by 3,6;
select a, b, sum(c), sum(sum(c)) over (order by a,b) as rsum  from gstest2 group by cube (a,b) order by rsum, a, b;
explain (costs off)  select a, b, sum(c), sum(sum(c)) over (order by a,b) as rsum    from gstest2 group by cube (a,b) order by rsum, a, b;
select a, b, sum(v.x)  from (values (1),(2)) v(x), gstest_data(v.x) group by cube (a,b) order by a,b;
explain (costs off)  select a, b, sum(v.x)    from (values (1),(2)) v(x), gstest_data(v.x)   group by cube (a,b) order by a,b;
BEGIN;
SET LOCAL enable_hashagg = false;
EXPLAIN (COSTS OFF) SELECT a, b, count(*), max(a), max(b) FROM gstest3 GROUP BY GROUPING SETS(a, b,()) ORDER BY a, b;
SELECT a, b, count(*), max(a), max(b) FROM gstest3 GROUP BY GROUPING SETS(a, b,()) ORDER BY a, b;
SET LOCAL enable_seqscan = false;
EXPLAIN (COSTS OFF) SELECT a, b, count(*), max(a), max(b) FROM gstest3 GROUP BY GROUPING SETS(a, b,()) ORDER BY a, b;
SELECT a, b, count(*), max(a), max(b) FROM gstest3 GROUP BY GROUPING SETS(a, b,()) ORDER BY a, b;
COMMIT;
select * from (values (1),(2)) v(a) left join lateral (select v.a, four, ten, count(*) from onek group by cube(four,ten)) s on true order by v.a,four,ten;
select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
select * from (values (1),(2)) v(a) left join lateral (select v.a, four, ten, count(*) from onek group by grouping sets(four,ten)) s on true order by v.a,four,ten;
select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by grouping sets(two,four) order by two,four) s1) from (values (1),(2)) v(a);
set enable_indexscan = false;
set work_mem = '64kB';
explain (costs off)  select unique1,         count(two), count(four), count(ten),         count(hundred), count(thousand), count(twothousand),         count(*)    from tenk1 group by grouping sets (unique1,twothousand,thousand,hundred,ten,four,two);
explain (costs off)  select unique1,         count(two), count(four), count(ten),         count(hundred), count(thousand), count(twothousand),         count(*)    from tenk1 group by grouping sets (unique1,hundred,ten,four,two);
set work_mem = '384kB';
explain (costs off)  select unique1,         count(two), count(four), count(ten),         count(hundred), count(thousand), count(twothousand),         count(*)    from tenk1 group by grouping sets (unique1,twothousand,thousand,hundred,ten,four,two);
||select v||'a', case grouping(v||'a') when 1 then 1 else 0 end, count(*)  from unnest(array[1,1], array['a','b']) u(i,v) group by rollup(i, v||'a') order by 1,3;
||select v||'a', case when grouping(v||'a') = 1 then 1 else 0 end, count(*)  from unnest(array[1,1], array['a','b']) u(i,v) group by rollup(i, v||'a') order by 1,3;
SET enable_partitionwise_aggregate TO true;
SET enable_partitionwise_join TO true;
SET max_parallel_workers_per_gather TO 0;
CREATE TABLE pagg_tab (a int, b int, c text, d int) PARTITION BY LIST(c);
CREATE TABLE pagg_tab_p1 PARTITION OF pagg_tab FOR VALUES IN ('0000', '0001', '0002', '0003');
CREATE TABLE pagg_tab_p2 PARTITION OF pagg_tab FOR VALUES IN ('0004', '0005', '0006', '0007');
CREATE TABLE pagg_tab_p3 PARTITION OF pagg_tab FOR VALUES IN ('0008', '0009', '0010', '0011');
ANALYZE pagg_tab;
EXPLAIN (COSTS OFF)SELECT c, sum(a), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY c HAVING avg(d) < 15 ORDER BY 1, 2, 3;
SELECT c, sum(a), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY c HAVING avg(d) < 15 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY a HAVING avg(d) < 15 ORDER BY 1, 2, 3;
SELECT a, sum(b), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY a HAVING avg(d) < 15 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, c, count(*) FROM pagg_tab GROUP BY a, c;
EXPLAIN (COSTS OFF)SELECT a, c, count(*) FROM pagg_tab GROUP BY c, a;
EXPLAIN (COSTS OFF)SELECT c, a, count(*) FROM pagg_tab GROUP BY a, c;
EXPLAIN (COSTS OFF)SELECT c, sum(a) FROM pagg_tab WHERE 1 = 2 GROUP BY c;
EXPLAIN (COSTS OFF)SELECT c, sum(a) FROM pagg_tab WHERE c = 'x' GROUP BY c;
SET enable_hashagg TO false;
EXPLAIN (COSTS OFF)SELECT c, sum(a), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
SELECT c, sum(a), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
SELECT a, sum(b), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT c FROM pagg_tab GROUP BY c ORDER BY 1;
EXPLAIN (COSTS OFF)SELECT a FROM pagg_tab WHERE a < 3 GROUP BY a ORDER BY 1;
RESET enable_hashagg;
EXPLAIN (COSTS OFF)SELECT c, sum(a) FROM pagg_tab GROUP BY rollup(c) ORDER BY 1, 2;
EXPLAIN (COSTS OFF)SELECT c, sum(b order by a) FROM pagg_tab GROUP BY c ORDER BY 1, 2;
EXPLAIN (COSTS OFF)SELECT a, sum(b order by a) FROM pagg_tab GROUP BY a ORDER BY 1, 2;
CREATE TABLE pagg_tab1(x int, y int) PARTITION BY RANGE(x);
CREATE TABLE pagg_tab1_p1 PARTITION OF pagg_tab1 FOR VALUES FROM (0) TO (10);
CREATE TABLE pagg_tab1_p2 PARTITION OF pagg_tab1 FOR VALUES FROM (10) TO (20);
CREATE TABLE pagg_tab1_p3 PARTITION OF pagg_tab1 FOR VALUES FROM (20) TO (30);
CREATE TABLE pagg_tab2(x int, y int) PARTITION BY RANGE(y);
CREATE TABLE pagg_tab2_p1 PARTITION OF pagg_tab2 FOR VALUES FROM (0) TO (10);
CREATE TABLE pagg_tab2_p2 PARTITION OF pagg_tab2 FOR VALUES FROM (10) TO (20);
CREATE TABLE pagg_tab2_p3 PARTITION OF pagg_tab2 FOR VALUES FROM (20) TO (30);
ANALYZE pagg_tab1;
ANALYZE pagg_tab2;
EXPLAIN (COSTS OFF)SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
SELECT t1.x, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT t1.x, sum(t1.y), count(t1) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
SELECT t1.x, sum(t1.y), count(t1) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.x ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT t2.y, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t2.y ORDER BY 1, 2, 3;
SET enable_hashagg TO false;
EXPLAIN (COSTS OFF)SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
RESET enable_hashagg;
EXPLAIN (COSTS OFF)SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
EXPLAIN (COSTS OFF)SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
EXPLAIN (COSTS OFF)SELECT a.x, sum(b.x) FROM pagg_tab1 a FULL OUTER JOIN pagg_tab2 b ON a.x = b.y GROUP BY a.x ORDER BY 1 NULLS LAST;
SELECT a.x, sum(b.x) FROM pagg_tab1 a FULL OUTER JOIN pagg_tab2 b ON a.x = b.y GROUP BY a.x ORDER BY 1 NULLS LAST;
EXPLAIN (COSTS OFF)SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a LEFT JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a LEFT JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
EXPLAIN (COSTS OFF)SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a FULL JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a FULL JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20 GROUP BY a.x, b.y ORDER BY 1, 2;
EXPLAIN (COSTS OFF)SELECT a.x, a.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x = 1 AND x = 2) a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY a.x, a.y ORDER BY 1, 2;
SELECT a.x, a.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x = 1 AND x = 2) a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY a.x, a.y ORDER BY 1, 2;
CREATE TABLE pagg_tab_m (a int, b int, c int) PARTITION BY RANGE(a, ((a+b)/2));
CREATE TABLE pagg_tab_m_p1 PARTITION OF pagg_tab_m FOR VALUES FROM (0, 0) TO (10, 10);
CREATE TABLE pagg_tab_m_p2 PARTITION OF pagg_tab_m FOR VALUES FROM (10, 10) TO (20, 20);
CREATE TABLE pagg_tab_m_p3 PARTITION OF pagg_tab_m FOR VALUES FROM (20, 20) TO (30, 30);
ANALYZE pagg_tab_m;
EXPLAIN (COSTS OFF)SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a HAVING avg(c) < 22 ORDER BY 1, 2, 3;
SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a HAVING avg(c) < 22 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
CREATE TABLE pagg_tab_ml (a int, b int, c text) PARTITION BY RANGE(a);
CREATE TABLE pagg_tab_ml_p1 PARTITION OF pagg_tab_ml FOR VALUES FROM (0) TO (10);
CREATE TABLE pagg_tab_ml_p2 PARTITION OF pagg_tab_ml FOR VALUES FROM (10) TO (20) PARTITION BY LIST (c);
CREATE TABLE pagg_tab_ml_p2_s1 PARTITION OF pagg_tab_ml_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE pagg_tab_ml_p2_s2 PARTITION OF pagg_tab_ml_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE pagg_tab_ml_p3(b int, c text, a int) PARTITION BY RANGE (b);
CREATE TABLE pagg_tab_ml_p3_s2 PARTITION OF pagg_tab_ml_p3 FOR VALUES FROM (5) TO (10);
ALTER TABLE pagg_tab_ml_p3 ATTACH PARTITION pagg_tab_ml_p3_s1 FOR VALUES FROM (0) TO (5);
ALTER TABLE pagg_tab_ml ATTACH PARTITION pagg_tab_ml_p3 FOR VALUES FROM (20) TO (30);
ANALYZE pagg_tab_ml;
SET max_parallel_workers_per_gather TO 2;
EXPLAIN (COSTS OFF)SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b ORDER BY 1, 2, 3;
SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b HAVING avg(a) < 15 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
SET min_parallel_table_scan_size TO '8kB';
SET parallel_setup_cost TO 0;
EXPLAIN (COSTS OFF)SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b ORDER BY 1, 2, 3;
SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b HAVING avg(a) < 15 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
SET parallel_setup_cost TO 10;
CREATE TABLE pagg_tab_para(x int, y int) PARTITION BY RANGE(x);
CREATE TABLE pagg_tab_para_p1 PARTITION OF pagg_tab_para FOR VALUES FROM (0) TO (10);
CREATE TABLE pagg_tab_para_p2 PARTITION OF pagg_tab_para FOR VALUES FROM (10) TO (20);
CREATE TABLE pagg_tab_para_p3 PARTITION OF pagg_tab_para FOR VALUES FROM (20) TO (30);
ANALYZE pagg_tab_para;
EXPLAIN (COSTS OFF)SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF)SELECT y, sum(x), avg(x), count(*) FROM pagg_tab_para GROUP BY y HAVING avg(x) < 12 ORDER BY 1, 2, 3;
SELECT y, sum(x), avg(x), count(*) FROM pagg_tab_para GROUP BY y HAVING avg(x) < 12 ORDER BY 1, 2, 3;
ALTER TABLE pagg_tab_para_p1 SET (parallel_workers = 0);
ALTER TABLE pagg_tab_para_p3 SET (parallel_workers = 0);
ANALYZE pagg_tab_para;
EXPLAIN (COSTS OFF)SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
ALTER TABLE pagg_tab_para_p2 SET (parallel_workers = 0);
ANALYZE pagg_tab_para;
EXPLAIN (COSTS OFF)SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
RESET min_parallel_table_scan_size;
RESET parallel_setup_cost;
EXPLAIN (COSTS OFF)SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
CREATE TEMP TABLE articles (    id int CONSTRAINT articles_pkey PRIMARY KEY,    keywords text,    title text UNIQUE NOT NULL,    body text UNIQUE,    created date);
CREATE TEMP TABLE articles_in_category (    article_id int,    category_id int,    changed date,    PRIMARY KEY (article_id, category_id));
SELECT id, keywords, title, body, createdFROM articlesGROUP BY id;
SELECT id, keywords, title, body, createdFROM articlesGROUP BY title;
SELECT id, keywords, title, body, createdFROM articlesGROUP BY body;
SELECT id, keywords, title, body, createdFROM articlesGROUP BY keywords;
SELECT a.id, a.keywords, a.title, a.body, a.createdFROM articles AS a, articles_in_category AS aicWHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)GROUP BY a.id;
SELECT a.id, a.keywords, a.title, a.body, a.createdFROM articles AS a, articles_in_category AS aicWHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)GROUP BY aic.article_id, aic.category_id;
SELECT a.id, a.keywords, a.title, a.body, a.createdFROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_idWHERE aic.category_id in (14,62,70,53,138)GROUP BY a.id;
SELECT a.id, a.keywords, a.title, a.body, a.createdFROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_idWHERE aic.category_id in (14,62,70,53,138)GROUP BY aic.article_id, aic.category_id;
SELECT aic.changedFROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_idWHERE aic.category_id in (14,62,70,53,138)GROUP BY aic.category_id, aic.article_id;
SELECT aic.changedFROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_idWHERE aic.category_id in (14,62,70,53,138)GROUP BY aic.article_id;
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales    FROM products p LEFT JOIN sales s USING (product_id)    GROUP BY product_id, p.name, p.price;
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales    FROM products p LEFT JOIN sales s USING (product_id)    GROUP BY product_id;
ALTER TABLE products ADD PRIMARY KEY (product_id);
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales    FROM products p LEFT JOIN sales s USING (product_id)    GROUP BY product_id;
CREATE TEMP TABLE node (    nid SERIAL,    vid integer NOT NULL default '0',    type varchar(32) NOT NULL default '',    title varchar(128) NOT NULL default '',    uid integer NOT NULL default '0',    status integer NOT NULL default '1',    created integer NOT NULL default '0',    -- snip    PRIMARY KEY (nid, vid));
CREATE TEMP TABLE users (    uid integer NOT NULL default '0',    name varchar(60) NOT NULL default '',    pass varchar(32) NOT NULL default '',    -- snip    PRIMARY KEY (uid),    UNIQUE (name));
SELECT u.uid, u.name FROM node nINNER JOIN users u ON u.uid = n.uidWHERE n.type = 'blog' AND n.status = 1GROUP BY u.uid, u.name;
SELECT u.uid, u.name FROM node nINNER JOIN users u ON u.uid = n.uidWHERE n.type = 'blog' AND n.status = 1GROUP BY u.uid;
CREATE TEMP VIEW fdv1 ASSELECT id, keywords, title, body, createdFROM articlesGROUP BY body;
CREATE TEMP VIEW fdv1 ASSELECT id, keywords, title, body, createdFROM articlesGROUP BY id;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
CREATE TEMP VIEW fdv2 ASSELECT a.id, a.keywords, a.title, aic.category_id, aic.changedFROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_idWHERE aic.category_id in (14,62,70,53,138)GROUP BY a.id, aic.category_id, aic.article_id;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- failALTER TABLE articles_in_category DROP CONSTRAINT articles_in_category_pkey RESTRICT; --failDROP VIEW fdv2;
CREATE TEMP VIEW fdv3 ASSELECT id, keywords, title, body, createdFROM articlesGROUP BY idUNIONSELECT id, keywords, title, body, createdFROM articlesGROUP BY id;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- failDROP VIEW fdv3;
CREATE TEMP VIEW fdv4 ASSELECT * FROM articles WHERE title IN (SELECT title FROM articles GROUP BY id);
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- failDROP VIEW fdv4;
PREPARE foo AS  SELECT id, keywords, title, body, created  FROM articles  GROUP BY id;
EXECUTE foo;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
EXECUTE foo;  -- fail/* * 1.test CREATE INDEX * * Deliberately avoid dropping objects in this section, to get some pg_dump * coverage. */CREATE TABLE tbl_include_reg (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX tbl_include_reg_idx ON tbl_include_reg (c1, c2) INCLUDE (c3, c4);
CREATE INDEX ON tbl_include_reg (c1, c2) INCLUDE (c1, c3);
SELECT pg_get_indexdef(i.indexrelid)FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oidWHERE i.indrelid = 'tbl_include_reg'::regclass ORDER BY c.relname;
CREATE TABLE tbl_include_unique1 (c1 int, c2 int, c3 int, c4 box);
CREATE UNIQUE INDEX tbl_include_unique1_idx_unique ON tbl_include_unique1 using btree (c1, c2) INCLUDE (c3, c4);
ALTER TABLE tbl_include_unique1 add UNIQUE USING INDEX tbl_include_unique1_idx_unique;
ALTER TABLE tbl_include_unique1 add UNIQUE (c1, c2) INCLUDE (c3, c4);
SELECT pg_get_indexdef(i.indexrelid)FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oidWHERE i.indrelid = 'tbl_include_unique1'::regclass ORDER BY c.relname;
CREATE TABLE tbl_include_unique2 (c1 int, c2 int, c3 int, c4 box);
CREATE UNIQUE INDEX tbl_include_unique2_idx_unique ON tbl_include_unique2 using btree (c1, c2) INCLUDE (c3, c4);
ALTER TABLE tbl_include_unique2 add UNIQUE (c1, c2) INCLUDE (c3, c4);
CREATE TABLE tbl_include_pk (c1 int, c2 int, c3 int, c4 box);
ALTER TABLE tbl_include_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
SELECT pg_get_indexdef(i.indexrelid)FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oidWHERE i.indrelid = 'tbl_include_pk'::regclass ORDER BY c.relname;
CREATE TABLE tbl_include_box (c1 int, c2 int, c3 int, c4 box);
CREATE UNIQUE INDEX tbl_include_box_idx_unique ON tbl_include_box using btree (c1, c2) INCLUDE (c3, c4);
ALTER TABLE tbl_include_box add PRIMARY KEY USING INDEX tbl_include_box_idx_unique;
SELECT pg_get_indexdef(i.indexrelid)FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oidWHERE i.indrelid = 'tbl_include_box'::regclass ORDER BY c.relname;
CREATE TABLE tbl_include_box_pk (c1 int, c2 int, c3 int, c4 box);
ALTER TABLE tbl_include_box_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
/* * 2. Test CREATE TABLE with constraint */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,				CONSTRAINT covering UNIQUE(c1,c2) INCLUDE(c3,c4));
::::SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
::SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,				CONSTRAINT covering PRIMARY KEY(c1,c2) INCLUDE(c3,c4));
::::SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
::SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,300) AS x;
explain (costs off)select * from tbl where (c1,c2,c3) < (2,5,1);
SET enable_seqscan = off;
explain (costs off)select * from tbl where (c1,c2,c3) < (262,1,1) limit 1;
RESET enable_seqscan;
CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,				UNIQUE(c1,c2) INCLUDE(c3,c4));
::::SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
::SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,				PRIMARY KEY(c1,c2) INCLUDE(c3,c4));
::::SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
::SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,10) AS x;
CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box,				EXCLUDE USING btree (c1 WITH =) INCLUDE(c3,c4));
::::SELECT indexrelid::regclass, indnatts, indnkeyatts, indisunique, indisprimary, indkey, indclass FROM pg_index WHERE indrelid = 'tbl'::regclass::oid;
::SELECT pg_get_constraintdef(oid), conname, conkey FROM pg_constraint WHERE conrelid = 'tbl'::regclass::oid;
INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,10) AS x;
/* * 3.0 Test ALTER TABLE DROP COLUMN. * Any column deletion leads to index deletion. */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 int);
CREATE UNIQUE INDEX tbl_idx ON tbl using btree(c1, c2, c3, c4);
ALTER TABLE tbl DROP COLUMN c3;
/* * 3.1 Test ALTER TABLE DROP COLUMN. * Included column deletion leads to the index deletion, * AS well AS key columns deletion. It's explained in documentation. */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box);
CREATE UNIQUE INDEX tbl_idx ON tbl using btree(c1, c2) INCLUDE(c3,c4);
ALTER TABLE tbl DROP COLUMN c3;
/* * 3.2 Test ALTER TABLE DROP COLUMN. * Included column deletion leads to the index deletion. * AS well AS key columns deletion. It's explained in documentation. */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
ALTER TABLE tbl DROP COLUMN c3;
ALTER TABLE tbl DROP COLUMN c1;
/* * 3.3 Test ALTER TABLE SET STATISTICS */CREATE TABLE tbl (c1 int, c2 int);
CREATE INDEX tbl_idx ON tbl (c1, (c1+0)) INCLUDE (c2);
ALTER INDEX tbl_idx ALTER COLUMN 1 SET STATISTICS 1000;
ALTER INDEX tbl_idx ALTER COLUMN 2 SET STATISTICS 1000;
ALTER INDEX tbl_idx ALTER COLUMN 3 SET STATISTICS 1000;
ALTER INDEX tbl_idx ALTER COLUMN 4 SET STATISTICS 1000;
/* * 4. CREATE INDEX CONCURRENTLY */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
CREATE UNIQUE INDEX CONCURRENTLY on tbl (c1, c2) INCLUDE (c3, c4);
/* * 5. REINDEX */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
ALTER TABLE tbl DROP COLUMN c3;
ALTER TABLE tbl DROP COLUMN c1;
/* * 7. Check various AMs. All but btree and gist must fail. */CREATE TABLE tbl (c1 int,c2 int, c3 box, c4 box);
CREATE INDEX on tbl USING brin(c1, c2) INCLUDE (c3, c4);
CREATE INDEX on tbl USING gist(c3) INCLUDE (c1, c4);
CREATE INDEX on tbl USING spgist(c3) INCLUDE (c4);
CREATE INDEX on tbl USING gin(c1, c2) INCLUDE (c3, c4);
CREATE INDEX on tbl USING hash(c1, c2) INCLUDE (c3, c4);
CREATE INDEX on tbl USING rtree(c3) INCLUDE (c1, c4);
CREATE INDEX on tbl USING btree(c1, c2) INCLUDE (c3, c4);
/* * 8. Update, delete values in indexed table. */CREATE TABLE tbl (c1 int, c2 int, c3 int, c4 box);
CREATE UNIQUE INDEX tbl_idx_unique ON tbl using btree(c1, c2) INCLUDE (c3,c4);
DELETE FROM tbl WHERE c1 = 5 OR c3 = 12;
/* * 9. Alter column type. */CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
ALTER TABLE tbl ALTER c1 TYPE bigint;
ALTER TABLE tbl ALTER c3 TYPE bigint;
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
CREATE INDEX rix ON road USING btree (name text_ops);
CREATE INDEX iix ON ihighway USING btree (name text_ops);
CREATE INDEX six ON shighway USING btree (name text_ops);
COMMENT ON INDEX six_wrong IS 'bad index';
COMMENT ON INDEX six IS 'good index';
COMMENT ON INDEX six IS NULL;
CREATE INDEX bt_i4_index ON bt_i4_heap USING btree (seqno int4_ops);
CREATE INDEX bt_name_index ON bt_name_heap USING btree (seqno name_ops);
CREATE INDEX bt_txt_index ON bt_txt_heap USING btree (seqno text_ops);
CREATE INDEX bt_f8_index ON bt_f8_heap USING btree (seqno float8_ops);
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)	where unique1 < 20 or unique1 > 980;
CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)	where stringu1 < 'B';
CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
CREATE INDEX gpolygonind ON polygon_tbl USING gist (f1);
CREATE INDEX gcircleind ON circle_tbl USING gist (f1);
INSERT INTO POINT_TBL(f1) VALUES (NULL);
CREATE INDEX gpointind ON point_tbl USING gist (f1);
CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
@SELECT * FROM fast_emp4000    WHERE home_base @ '(200,200),(2000,1000)'::box    ORDER BY (home_base[0])[0];
&&SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
~SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon    ORDER BY (poly_center(f1))[0];
&&SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)    ORDER BY area(f1);
&&SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
&&SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
@SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
@SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
@SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
@::SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)SELECT * FROM fast_emp4000    WHERE home_base @ '(200,200),(2000,1000)'::box    ORDER BY (home_base[0])[0];
@SELECT * FROM fast_emp4000    WHERE home_base @ '(200,200),(2000,1000)'::box    ORDER BY (home_base[0])[0];
EXPLAIN (COSTS OFF)SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
&&SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
EXPLAIN (COSTS OFF)SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
EXPLAIN (COSTS OFF)SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon    ORDER BY (poly_center(f1))[0];
~SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon    ORDER BY (poly_center(f1))[0];
EXPLAIN (COSTS OFF)SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)    ORDER BY area(f1);
&&SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)    ORDER BY area(f1);
EXPLAIN (COSTS OFF)SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
&&SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
EXPLAIN (COSTS OFF)SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
&&SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
@SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
@SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
@SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
EXPLAIN (COSTS OFF)SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
EXPLAIN (COSTS OFF)SELECT * FROM point_tbl WHERE f1 IS NULL;
EXPLAIN (COSTS OFF)SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
EXPLAIN (COSTS OFF)SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
@::SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
EXPLAIN (COSTS OFF)SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
EXPLAIN (COSTS OFF)SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
@::SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
explain (costs off)SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
@@&&SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
@@&&SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
@CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
explain (costs off)SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
@@&&SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
@DROP INDEX intarrayidx, textarrayidx;
CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
@&&SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
@&&SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
&&SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
@RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
CREATE TABLE array_gin_test (a int[]);
CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
@CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)  WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
CREATE INDEX hash_i4_index ON hash_i4_heap USING hash (random int4_ops);
CREATE INDEX hash_name_index ON hash_name_heap USING hash (random name_ops);
CREATE INDEX hash_txt_index ON hash_txt_heap USING hash (random text_ops);
CREATE INDEX hash_f8_index ON hash_f8_heap USING hash (random float8_ops) WITH (fillfactor=60);
CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
SET maintenance_work_mem = '1MB';
CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
EXPLAIN (COSTS OFF)SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
RESET maintenance_work_mem;
||CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEXcovering_pkey;
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
||BEGIN;
CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
COMMIT;
BEGIN;
COMMIT;
VACUUM FULL concur_heap;
DELETE FROM concur_heap WHERE f1 = 'b';
VACUUM FULL concur_heap;
DROP INDEX CONCURRENTLY "concur_index2";				-- worksDROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- noticeDROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
BEGIN;
DROP INDEX CONCURRENTLY "concur_index5";
ROLLBACK;
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
DROP INDEX CONCURRENTLY "concur_index4";
DROP INDEX CONCURRENTLY "concur_index5";
DROP INDEX CONCURRENTLY "concur_index1";
DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY		USING INDEX cwi_uniq2_idx;
DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on itCREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;  -- failCREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;  -- failDROP TABLE cwi_test;
CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
create unique index on cwi_test (a);
alter table cwi_test add primary key using index cwi_test_a_idx ;
CREATE INDEX ON syscolcol_table (ctid);
CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
SELECT unique1, unique2 INTO onek_with_null FROM onek;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
EXPLAIN (COSTS OFF)SELECT * FROM tenk1  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
SELECT * FROM tenk1  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
EXPLAIN (COSTS OFF)SELECT count(*) FROM tenk1  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
::CREATE TABLE dupindexcols AS  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
ANALYZE dupindexcols;
EXPLAIN (COSTS OFF)  SELECT count(*) FROM dupindexcols    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
SELECT count(*) FROM dupindexcols  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
vacuum tenk1;		-- ensure we get consistent plans hereexplain (costs off)SELECT unique1 FROM tenk1WHERE unique1 IN (1,42,7)ORDER BY unique1;
SELECT unique1 FROM tenk1WHERE unique1 IN (1,42,7)ORDER BY unique1;
explain (costs off)SELECT thousand, tenthous FROM tenk1WHERE thousand < 2 AND tenthous IN (1001,3000)ORDER BY thousand;
SELECT thousand, tenthous FROM tenk1WHERE thousand < 2 AND tenthous IN (1001,3000)ORDER BY thousand;
SET enable_indexonlyscan = OFF;
explain (costs off)SELECT thousand, tenthous FROM tenk1WHERE thousand < 2 AND tenthous IN (1001,3000)ORDER BY thousand;
SELECT thousand, tenthous FROM tenk1WHERE thousand < 2 AND tenthous IN (1001,3000)ORDER BY thousand;
RESET enable_indexonlyscan;
explain (costs off)  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
create temp table boolindex (b bool, i int, unique(b, i), junk float);
explain (costs off)  select * from boolindex order by b, i limit 10;
explain (costs off)  select * from boolindex where b order by i limit 10;
explain (costs off)  select * from boolindex where b = true order by i desc limit 10;
explain (costs off)  select * from boolindex where not b order by i limit 10;
explain (costs off)  select * from boolindex where b is true order by i desc limit 10;
explain (costs off)  select * from boolindex where b is false order by i desc limit 10;
\\set VERBOSITY terse \\ -- suppress machine-dependent detailsREINDEX (VERBOSE) TABLE reindex_verbose;
\\set VERBOSITY defaultDROP TABLE reindex_verbose;
REINDEX TABLE concur_reindex_tab; -- noticeREINDEX TABLE CONCURRENTLY concur_reindex_tab; -- noticeALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast indexCREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- errorREINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warningINSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
SELECT pg_describe_object(classid, objid, objsubid) as obj,       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,       deptypeFROM pg_dependWHERE classid = 'pg_class'::regclass AND  objid in ('concur_reindex_tab'::regclass,            'concur_reindex_ind1'::regclass,	    'concur_reindex_ind2'::regclass,	    'concur_reindex_ind3'::regclass,	    'concur_reindex_ind4'::regclass,	    'concur_reindex_matview'::regclass)  ORDER BY 1, 2;
REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
SELECT pg_describe_object(classid, objid, objsubid) as obj,       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,       deptypeFROM pg_dependWHERE classid = 'pg_class'::regclass AND  objid in ('concur_reindex_tab'::regclass,            'concur_reindex_ind1'::regclass,	    'concur_reindex_ind2'::regclass,	    'concur_reindex_ind3'::regclass,	    'concur_reindex_ind4'::regclass,	    'concur_reindex_matview'::regclass)  ORDER BY 1, 2;
COMMENT ON INDEX testcomment_idx1 IS 'test comment';
::::REINDEX TABLE CONCURRENTLY testcomment ;
::CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0  FOR VALUES IN (1);
CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0  FOR VALUES IN (2);
CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')  ORDER BY relid, level;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_10;
REINDEX TABLE CONCURRENTLY concur_reindex_part_10;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')  ORDER BY relid, level;
SELECT pg_describe_object(classid, objid, objsubid) as obj,       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,       deptypeFROM pg_dependWHERE classid = 'pg_class'::regclass AND  objid in ('concur_reindex_part'::regclass,            'concur_reindex_part_0'::regclass,            'concur_reindex_part_0_1'::regclass,            'concur_reindex_part_0_2'::regclass,            'concur_reindex_part_index'::regclass,            'concur_reindex_part_index_0'::regclass,            'concur_reindex_part_index_0_1'::regclass,            'concur_reindex_part_index_0_2'::regclass)  ORDER BY 1, 2;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')  ORDER BY relid, level;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
SELECT pg_describe_object(classid, objid, objsubid) as obj,       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,       deptypeFROM pg_dependWHERE classid = 'pg_class'::regclass AND  objid in ('concur_reindex_part'::regclass,            'concur_reindex_part_0'::regclass,            'concur_reindex_part_0_1'::regclass,            'concur_reindex_part_0_2'::regclass,            'concur_reindex_part_index'::regclass,            'concur_reindex_part_index_0'::regclass,            'concur_reindex_part_index_0_1'::regclass,            'concur_reindex_part_index_0_2'::regclass)  ORDER BY 1, 2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')  ORDER BY relid, level;
BEGIN;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
COMMIT;
REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relationREINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog indexREINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast tableREINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast indexREINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEMREINDEX SCHEMA CONCURRENTLY pg_catalog;
DROP MATERIALIZED VIEW concur_reindex_matview;
DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
::CREATE UNIQUE INDEX concur_exprs_index_expr  ON concur_exprs_tab ((c1::text COLLATE "C"));
::CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)  WHERE (c1::text > 500000000::text COLLATE "C");
::CREATE UNIQUE INDEX concur_exprs_index_pred_2  ON concur_exprs_tab ((1 / c1))  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
::::::REINDEX TABLE CONCURRENTLY concur_exprs_tab;
::::::ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
::::::REINDEX SCHEMA schema_to_reindex; -- failure, schema does not existCREATE SCHEMA schema_to_reindex;
SET search_path = 'schema_to_reindex';
CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
CREATE INDEX ON table2(col2);
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
CREATE INDEX ON matview(col1);
CREATE VIEW view AS SELECT col2 FROM table2;
CREATE TABLE reindex_before ASSELECT oid, relname, relfilenode, relkind, reltoastrelid	FROM pg_class	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
INSERT INTO reindex_beforeSELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelidFROM pg_class WHERE oid IN	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT INTO reindex_beforeSELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelidFROM pg_class where oid in	(select indexrelid from pg_index where indrelid in		(select reltoastrelid from reindex_before where reltoastrelid > 0));
REINDEX SCHEMA schema_to_reindex;
SELECT  b.relname,        b.relkind,        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'        ELSE 'relfilenode has changed' END  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid  ORDER BY 1;
REINDEX SCHEMA schema_to_reindex;
BEGIN;
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transactionEND;
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
CREATE ROLE regress_reindexuser NOLOGIN;
SET SESSION ROLE regress_reindexuser;
REINDEX SCHEMA schema_to_reindex;
RESET ROLE;
GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
SET SESSION ROLE regress_reindexuser;
REINDEX TABLE pg_toast.pg_toast_1260;
REINDEX INDEX pg_toast.pg_toast_1260_index;
RESET ROLE;
REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
DROP ROLE regress_reindexuser;
DROP SCHEMA schema_to_reindex CASCADE;
CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler;
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER int4in;
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER heap_tableam_handler;
CREATE INDEX grect2ind2 ON fast_emp4000 USING gist2 (home_base);
CREATE OPERATOR CLASS box_ops DEFAULT	FOR TYPE box USING gist2 AS	OPERATOR 1	<<,	OPERATOR 2	&<,	OPERATOR 3	&&,	OPERATOR 4	&>,	OPERATOR 5	>>,	OPERATOR 6	~=,	OPERATOR 7	@>,	OPERATOR 8	<@,	OPERATOR 9	&<|,	OPERATOR 10	<<|,	OPERATOR 11	|>>,	OPERATOR 12	|&>,	OPERATOR 13	~,	OPERATOR 14	@,	FUNCTION 1	gist_box_consistent(internal, box, smallint, oid, internal),	FUNCTION 2	gist_box_union(internal, internal),	-- don't need compress, decompress, or fetch functions	FUNCTION 5	gist_box_penalty(internal, internal, internal),	FUNCTION 6	gist_box_picksplit(internal, internal),	FUNCTION 7	gist_box_same(box, box, internal);
CREATE INDEX grect2ind2 ON fast_emp4000 USING gist2 (home_base);
BEGIN;
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)SELECT * FROM fast_emp4000    WHERE home_base @ '(200,200),(2000,1000)'::box    ORDER BY (home_base[0])[0];
@SELECT * FROM fast_emp4000    WHERE home_base @ '(200,200),(2000,1000)'::box    ORDER BY (home_base[0])[0];
EXPLAIN (COSTS OFF)SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
&&SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
EXPLAIN (COSTS OFF)SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
ROLLBACK;
DROP ACCESS METHOD gist2;
DROP ACCESS METHOD gist2 CASCADE;
SET default_table_access_method = '';
SET default_table_access_method = 'I do not exist AM';
SET default_table_access_method = 'btree';
CREATE ACCESS METHOD heap2 TYPE TABLE HANDLER heap_tableam_handler;
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER int4in;
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER bthandler;
SELECT amname, amhandler, amtype FROM pg_am where amtype = 't' ORDER BY 1, 2;
CREATE TABLE tableam_tbl_heap2(f1 int) USING heap2;
CREATE TABLE tableam_tblas_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
SELECT INTO tableam_tblselectinto_heap2 USING heap2 FROM tableam_tbl_heap2;
CREATE VIEW tableam_view_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
CREATE SEQUENCE tableam_seq_heap2 USING heap2;
CREATE MATERIALIZED VIEW tableam_tblmv_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
CREATE TABLE tableam_parted_heap2 (a text, b int) PARTITION BY list (a) USING heap2;
CREATE TABLE tableam_parted_heap2 (a text, b int) PARTITION BY list (a);
SET default_table_access_method = 'heap';
CREATE TABLE tableam_parted_a_heap2 PARTITION OF tableam_parted_heap2 FOR VALUES IN ('a');
SET default_table_access_method = 'heap2';
CREATE TABLE tableam_parted_b_heap2 PARTITION OF tableam_parted_heap2 FOR VALUES IN ('b');
RESET default_table_access_method;
CREATE TABLE tableam_parted_c_heap2 PARTITION OF tableam_parted_heap2 FOR VALUES IN ('c') USING heap;
CREATE TABLE tableam_parted_d_heap2 PARTITION OF tableam_parted_heap2 FOR VALUES IN ('d') USING heap2;
SELECT    pc.relkind,    pa.amname,    CASE WHEN relkind = 't' THEN        (SELECT 'toast for ' || relname::regclass FROM pg_class pcm WHERE pcm.reltoastrelid = pc.oid)    ELSE        relname::regclass::text    END COLLATE "C" AS relnameFROM pg_class AS pc,    pg_am AS paWHERE pa.oid = pc.relam   AND pa.amname = 'heap2'ORDER BY 3, 1, 2;
SELECT pg_describe_object(classid,objid,objsubid) AS objFROM pg_depend, pg_amWHERE pg_depend.refclassid = 'pg_am'::regclass    AND pg_am.oid = pg_depend.refobjid    AND pg_am.amname = 'heap2'ORDER BY classid, objid, objsubid;
BEGIN;
SET LOCAL default_table_access_method = 'heap2';
SELECT INTO tableam_tblselectinto_heapx FROM tableam_tbl_heapx;
CREATE MATERIALIZED VIEW tableam_tblmv_heapx USING heap2 AS SELECT * FROM tableam_tbl_heapx;
CREATE TABLE tableam_parted_heapx (a text, b int) PARTITION BY list (a);
CREATE TABLE tableam_parted_1_heapx PARTITION OF tableam_parted_heapx FOR VALUES IN ('a', 'b');
CREATE TABLE tableam_parted_2_heapx PARTITION OF tableam_parted_heapx FOR VALUES IN ('c', 'd') USING heap;
CREATE SEQUENCE tableam_seq_heapx;
CREATE FOREIGN DATA WRAPPER fdw_heap2 VALIDATOR postgresql_fdw_validator;
CREATE SERVER fs_heap2 FOREIGN DATA WRAPPER fdw_heap2 ;
CREATE FOREIGN table tableam_fdw_heapx () SERVER fs_heap2;
SELECT    pc.relkind,    pa.amname,    CASE WHEN relkind = 't' THEN        (SELECT 'toast for ' || relname::regclass FROM pg_class pcm WHERE pcm.reltoastrelid = pc.oid)    ELSE        relname::regclass::text    END COLLATE "C" AS relnameFROM pg_class AS pc    LEFT JOIN pg_am AS pa ON (pa.oid = pc.relam)WHERE pc.relname LIKE 'tableam_%_heapx'ORDER BY 3, 1, 2;
ROLLBACK;
CREATE TABLE i_am_a_failure() USING "";
CREATE TABLE i_am_a_failure() USING i_do_not_exist_am;
CREATE TABLE i_am_a_failure() USING "I do not exist AM";
CREATE TABLE i_am_a_failure() USING "btree";
DROP ACCESS METHOD heap2;
CREATE TEMP TABLE x (	a serial,	b int,	c text not null default 'stuff',	d text,	e text) ;
CREATE FUNCTION fn_x_before () RETURNS TRIGGER AS '  BEGIN		NEW.e := ''before trigger fired''::text;
		return NEW;
	END;
' LANGUAGE plpgsql;
CREATE FUNCTION fn_x_after () RETURNS TRIGGER AS '  BEGIN		UPDATE x set e=''after trigger fired'' where c=''stuff'';
		return NULL;
	END;
' LANGUAGE plpgsql;
CREATE TRIGGER trg_x_after AFTER INSERT ON xFOR EACH ROW EXECUTE PROCEDURE fn_x_after();
CREATE TRIGGER trg_x_before BEFORE INSERT ON xFOR EACH ROW EXECUTE PROCEDURE fn_x_before();
COPY x (a, b, c, d, e) from stdin;
9999	\N	\\N	\NN	\N10000	21	31	41	51\.COPY x (b, d) from stdin;
1	test_1\.COPY x (b, d) from stdin;
2	test_23	test_34	test_45	test_5\.COPY x (a, b, c, d, e) from stdin;
10001	22	32	42	5210002	23	33	43	5310003	24	34	44	5410004	25	35	45	5510005	26	36	46	56\.COPY x (xyz) from stdin;
COPY x (a, b, c, d, e, d, c) from stdin;
COPY x from stdin;
\\.COPY x from stdin;
2000	230	23	23\.COPY x from stdin;
2001	231	\N	\N\.COPY x from stdin;
2002	232	40	50	60	70	80\.COPY x (b, c, d, e) from stdin delimiter ',' null 'x';
x,45,80,90x,\x,\\x,\\\xx,\,,\\\,,\\\.COPY x from stdin WITH DELIMITER AS ';' NULL AS '';
3000;;c;;
\\.COPY x from stdin WITH DELIMITER AS ':' NULL AS E'\\X' ENCODING 'sql_ascii';
4000:\X:C:\X:\X4001:1:empty::4002:2:null:\X:\X4003:3:Backslash:\\:\\4004:4:BackslashX:\\X:\\X4005:5:N:\N:\N4006:6:BackslashN:\\N:\\N4007:7:XX:\XX:\XX4008:8:Delimiter:\::\:\.COPY x TO stdout WHERE a = 1;
COPY x from stdin WHERE a = 50004;
50003	24	34	44	5450004	25	35	45	5550005	26	36	46	56\.COPY x from stdin WHERE a > 60003;
60001	22	32	42	5260002	23	33	43	5360003	24	34	44	5460004	25	35	45	5560005	26	36	46	56\.COPY x from stdin WHERE f > 60003;
COPY x from stdin WHERE a = max(x.b);
COPY x from stdin WHERE a IN (SELECT 1 FROM x);
COPY x from stdin WHERE a IN (generate_series(1,5));
COPY x from stdin WHERE a = row_number() over(b);
COPY x TO stdout;
COPY x (c, e) TO stdout;
COPY x (b, e) TO stdout WITH NULL 'I''m null';
INSERT INTO y VALUES ('Jackson, Sam', E'\\h');
INSERT INTO y VALUES ('It is "perfect".',E'\t');
INSERT INTO y VALUES ('', NULL);
COPY y TO stdout WITH CSV;
COPY y TO stdout WITH CSV QUOTE '''' DELIMITER '|';
COPY y TO stdout WITH CSV FORCE QUOTE col2 ESCAPE E'\\' ENCODING 'sql_ascii';
COPY y TO stdout WITH CSV FORCE QUOTE *;
COPY y TO stdout (FORMAT CSV);
COPY y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|');
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\');
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE *);
\\copy y TO stdout (FORMAT CSV)\copy y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|')\copy y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\')\copy y TO stdout (FORMAT CSV, FORCE_QUOTE *)CREATE TEMP TABLE testnl (a int, b text, c int);
COPY testnl FROM stdin CSV;
1,"a field with two LFsinside",2\.CREATE TEMP TABLE testeoc (a text);
COPY testeoc FROM stdin CSV;
a\.\.bc\.d"\."\.COPY testeoc TO stdout CSV;
INSERT INTO testnull VALUES (1, E'\\0'), (NULL, NULL);
COPY testnull TO stdout WITH NULL AS E'\\0';
COPY testnull FROM stdin WITH NULL AS E'\\0';
42	\\0\0	\0\.SELECT * FROM testnull;
BEGIN;
CREATE TABLE vistest (LIKE testeoc);
COPY vistest FROM stdin CSV;
a0\.COMMIT;
BEGIN;
TRUNCATE vistest;
COPY vistest FROM stdin CSV;
a1\.SELECT * FROM vistest;
SAVEPOINT s1;
TRUNCATE vistest;
COPY vistest FROM stdin CSV;
d1\.SELECT * FROM vistest;
COMMIT;
BEGIN;
TRUNCATE vistest;
COPY vistest FROM stdin CSV FREEZE;
a2\.SELECT * FROM vistest;
SAVEPOINT s1;
TRUNCATE vistest;
COPY vistest FROM stdin CSV FREEZE;
d2\.SELECT * FROM vistest;
COMMIT;
BEGIN;
TRUNCATE vistest;
COPY vistest FROM stdin CSV FREEZE;
\\.SELECT * FROM vistest;
COMMIT;
TRUNCATE vistest;
COPY vistest FROM stdin CSV FREEZE;
\\.BEGIN;
TRUNCATE vistest;
SAVEPOINT s1;
COPY vistest FROM stdin CSV FREEZE;
\\.COMMIT;
BEGIN;
SAVEPOINT s1;
TRUNCATE vistest;
ROLLBACK TO SAVEPOINT s1;
COPY vistest FROM stdin CSV FREEZE;
d3\.COMMIT;
CREATE FUNCTION truncate_in_subxact() RETURNS VOID AS$$BEGIN	TRUNCATE vistest;
EXCEPTION  WHEN OTHERS THEN	INSERT INTO vistest VALUES ('subxact failure');
END;
$$ language plpgsql;
BEGIN;
COPY vistest FROM stdin CSV FREEZE;
d4\.SELECT * FROM vistest;
COMMIT;
\\pset null NULLBEGIN;
COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b), FORCE_NULL(c));
1,,""\.COMMIT;
BEGIN;
COPY forcetest (a, b, c, d) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(c,d), FORCE_NULL(c,d));
2,'a',,""\.COMMIT;
BEGIN;
COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b), FORCE_NOT_NULL(c));
3,,""\.ROLLBACK;
BEGIN;
COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b));
ROLLBACK;
BEGIN;
COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b));
ROLLBACK;
\\pset null ''create table check_con_tbl (f1 int);
create function check_con_function(check_con_tbl) returns bool as $$begin  raise notice 'input = %', row_to_json($1);
  return $1.f1 > 0;
end $$ language plpgsql immutable;
alter table check_con_tbl add check (check_con_function(check_con_tbl.*));
copy check_con_tbl from stdin;
\\N\.copy check_con_tbl from stdin;
\\.select * from check_con_tbl;
CREATE ROLE regress_rls_copy_user;
CREATE ROLE regress_rls_copy_user_colperms;
COPY rls_t1 (a, b, c) from stdin;
1	4	12	3	23	2	34	1	4\.CREATE POLICY p1 ON rls_t1 FOR SELECT USING (a % 2 = 0);
ALTER TABLE rls_t1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_t1 FORCE ROW LEVEL SECURITY;
GRANT SELECT ON TABLE rls_t1 TO regress_rls_copy_user;
GRANT SELECT (a, b) ON TABLE rls_t1 TO regress_rls_copy_user_colperms;
COPY rls_t1 TO stdout;
COPY rls_t1 (a, b, c) TO stdout;
COPY rls_t1 (a) TO stdout;
COPY rls_t1 (a, b) TO stdout;
COPY rls_t1 (b, a) TO stdout;
SET SESSION AUTHORIZATION regress_rls_copy_user;
COPY rls_t1 TO stdout;
COPY rls_t1 (a, b, c) TO stdout;
COPY rls_t1 (a) TO stdout;
COPY rls_t1 (a, b) TO stdout;
COPY rls_t1 (b, a) TO stdout;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_rls_copy_user_colperms;
COPY rls_t1 TO stdout;
COPY rls_t1 (a, b, c) TO stdout;
COPY rls_t1 (c) TO stdout;
COPY rls_t1 (a) TO stdout;
COPY rls_t1 (a, b) TO stdout;
RESET SESSION AUTHORIZATION;
CREATE TABLE instead_of_insert_tbl(id serial, name text);
::CREATE VIEW instead_of_insert_tbl_view AS SELECT ''::text AS str;
COPY instead_of_insert_tbl_view FROM stdin; -- failtest1\.CREATE FUNCTION fun_instead_of_insert_tbl() RETURNS trigger AS $$BEGIN  INSERT INTO instead_of_insert_tbl (name) VALUES (NEW.str);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
COPY instead_of_insert_tbl_view FROM stdin;
test1\.SELECT * FROM instead_of_insert_tbl;
BEGIN;
::CREATE VIEW instead_of_insert_tbl_view_2 as select ''::text as str;
COPY instead_of_insert_tbl_view_2 FROM stdin;
test1\.SELECT * FROM instead_of_insert_tbl;
COMMIT;
DROP FUNCTION truncate_in_subxact();
DROP TABLE x, y;
DROP TABLE rls_t1 CASCADE;
DROP ROLE regress_rls_copy_user;
DROP ROLE regress_rls_copy_user_colperms;
DROP FUNCTION fn_x_before();
DROP FUNCTION fn_x_after();
DROP FUNCTION fun_instead_of_insert_tbl();
SELECT 'trailing' AS first; -- trailing single lineSELECT /* embedded single line */ 'embedded' AS second;
SELECT /* both embedded and trailing single line */ 'both' AS third; -- trailing single lineSELECT 'before multi-line' AS fourth;
/* This is an example of SQL which should not execute: * select 'multi-line';
 */SELECT 'after multi-line' AS fifth;
/*SELECT 'trailing' as x1; -- inside block comment*//* This block comment surrounds a query which itself has a block comment...SELECT /* embedded single line */ 'embedded' AS x2;
*/SELECT -- continued after the following block comments.../* Deeply nested comment.   This includes a single apostrophe to make sure we aren't decoding this part as a string.SELECT 'deep nest' AS n1;
/* Second level of nesting...SELECT 'deeper nest' as n2;
/* Third level of nesting...SELECT 'deepest nest' as n3;
*/Hoo boy. Still two deep...*/Now just one deep...*/'deeply nested example' AS sixth;
/* and this is the end of the file */SELECT b.*   FROM bt_i4_heap b   WHERE b.seqno < 1;
SELECT b.*   FROM bt_i4_heap b   WHERE b.seqno >= 9999;
SELECT b.*   FROM bt_i4_heap b   WHERE b.seqno = 4500;
SELECT b.*   FROM bt_name_heap b   WHERE b.seqno < '1'::name;
SELECT b.*   FROM bt_name_heap b   WHERE b.seqno >= '9999'::name;
SELECT b.*   FROM bt_name_heap b   WHERE b.seqno = '4500'::name;
SELECT b.*   FROM bt_txt_heap b   WHERE b.seqno < '1'::text;
SELECT b.*   FROM bt_txt_heap b   WHERE b.seqno >= '9999'::text;
SELECT b.*   FROM bt_txt_heap b   WHERE b.seqno = '4500'::text;
SELECT b.*   FROM bt_f8_heap b   WHERE b.seqno < '1'::float8;
SELECT b.*   FROM bt_f8_heap b   WHERE b.seqno >= '9999'::float8;
SELECT b.*   FROM bt_f8_heap b   WHERE b.seqno = '4500'::float8;
set enable_seqscan to false;
set enable_indexscan to true;
set enable_bitmapscan to false;
explain (costs off)select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
explain (costs off)select proname from pg_proc where proname ilike '00%foo' order by 1;
select proname from pg_proc where proname ilike '00%foo' order by 1;
explain (costs off)select proname from pg_proc where proname ilike 'ri%foo' order by 1;
set enable_indexscan to false;
set enable_bitmapscan to true;
explain (costs off)select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
explain (costs off)select proname from pg_proc where proname ilike '00%foo' order by 1;
select proname from pg_proc where proname ilike '00%foo' order by 1;
explain (costs off)select proname from pg_proc where proname ilike 'ri%foo' order by 1;
reset enable_seqscan;
reset enable_indexscan;
reset enable_bitmapscan;
create temp table btree_bpchar (f1 text collate "C");
create index on btree_bpchar(f1 bpchar_ops);
explain (costs off)select * from btree_bpchar where f1 like 'foo';
explain (costs off)select * from btree_bpchar where f1 like 'foo%';
explain (costs off)select * from btree_bpchar where f1::bpchar like 'foo';
::select * from btree_bpchar where f1::bpchar like 'foo';
explain (costs off)select * from btree_bpchar where f1::bpchar like 'foo%';
::select * from btree_bpchar where f1::bpchar like 'foo%';
create table btree_tall_tbl(id int4, t text);
alter table btree_tall_tbl alter COLUMN t set storage plain;
create index btree_tall_idx on btree_tall_tbl (t, id) with (fillfactor = 10);
create index btree_idx1 on btree_test(a) with (vacuum_cleanup_index_scale_factor = 40.0);
::select reloptions from pg_class WHERE oid = 'btree_idx1'::regclass;
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = -10.0);
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = 100.0);
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = 'string');
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = true);
alter index btree_idx1 set (vacuum_cleanup_index_scale_factor = 70.0);
::select reloptions from pg_class WHERE oid = 'btree_idx1'::regclass;
ALTER TABLE delete_test_table ADD PRIMARY KEY (a,b,c,d);
DELETE FROM delete_test_table WHERE a < 79990;
VACUUM delete_test_table;
CREATE TABLE macaddr_data (a int, b macaddr);
INSERT INTO macaddr_data VALUES (8, '0800:2b01:0203'); -- invalidINSERT INTO macaddr_data VALUES (9, 'not even close'); -- invalidINSERT INTO macaddr_data VALUES (10, '08:00:2b:01:02:04');
CREATE INDEX macaddr_data_btree ON macaddr_data USING btree (b);
CREATE INDEX macaddr_data_hash ON macaddr_data USING hash (b);
SELECT a, b, trunc(b) FROM macaddr_data ORDER BY 2, 1;
SELECT b <  '08:00:2b:01:02:04' FROM macaddr_data WHERE a = 1; -- trueSELECT b >  '08:00:2b:01:02:04' FROM macaddr_data WHERE a = 1; -- falseSELECT b >  '08:00:2b:01:02:03' FROM macaddr_data WHERE a = 1; -- falseSELECT b <= '08:00:2b:01:02:04' FROM macaddr_data WHERE a = 1; -- trueSELECT b >= '08:00:2b:01:02:04' FROM macaddr_data WHERE a = 1; -- falseSELECT b =  '08:00:2b:01:02:03' FROM macaddr_data WHERE a = 1; -- trueSELECT b <> '08:00:2b:01:02:04' FROM macaddr_data WHERE a = 1; -- trueSELECT b <> '08:00:2b:01:02:03' FROM macaddr_data WHERE a = 1; -- falseSELECT ~b                       FROM macaddr_data;
&SELECT  b & '00:00:00:ff:ff:ff' FROM macaddr_data;
|SELECT  b | '01:02:03:04:05:06' FROM macaddr_data;
#SELECT name, #thepath FROM iexit ORDER BY name COLLATE "C", 2;
CREATE ROLE regress_alice;
CREATE FUNCTION f_leak (text)       RETURNS bool LANGUAGE 'plpgsql' COST 0.0000001       AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1; RETURN true; END';
CREATE TABLE credit_usage (       cid      int references customer(cid),       ymd      date,       usage    int);
CREATE VIEW my_property_secure WITH (security_barrier) AS       SELECT * FROM customer WHERE name = current_user;
CREATE VIEW my_credit_card_normal AS       SELECT * FROM customer l NATURAL JOIN credit_card r       WHERE l.name = current_user;
CREATE VIEW my_credit_card_secure WITH (security_barrier) AS       SELECT * FROM customer l NATURAL JOIN credit_card r       WHERE l.name = current_user;
CREATE VIEW my_credit_card_usage_secure WITH (security_barrier) AS       SELECT * FROM my_credit_card_secure l NATURAL JOIN credit_usage r;
GRANT SELECT ON my_property_normal TO public;
GRANT SELECT ON my_property_secure TO public;
GRANT SELECT ON my_credit_card_normal TO public;
GRANT SELECT ON my_credit_card_secure TO public;
GRANT SELECT ON my_credit_card_usage_normal TO public;
GRANT SELECT ON my_credit_card_usage_secure TO public;
SET SESSION AUTHORIZATION regress_alice;
EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal WHERE f_leak(passwd);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure WHERE f_leak(passwd);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal v		WHERE f_leak('passwd') AND f_leak(passwd);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure v		WHERE f_leak('passwd') AND f_leak(passwd);
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
SELECT * FROM my_credit_card_usage_normal       WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal       WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
SELECT * FROM my_credit_card_usage_secure       WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure       WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(passwd);
PREPARE p2 AS SELECT * FROM my_property_secure WHERE f_leak(passwd);
EXECUTE p1;
EXECUTE p2;
RESET SESSION AUTHORIZATION;
ALTER VIEW my_property_normal SET (security_barrier=true);
ALTER VIEW my_property_secure SET (security_barrier=false);
SET SESSION AUTHORIZATION regress_alice;
EXECUTE p1;		-- To be perform as a view with security-barrierEXECUTE p2;		-- To be perform as a view without security-barrierRESET SESSION AUTHORIZATION;
DROP ROLE regress_alice;
CREATE TYPE casttesttype;
CREATE FUNCTION casttesttype_in(cstring)   RETURNS casttesttype   AS 'textin'   LANGUAGE internal STRICT IMMUTABLE;
CREATE FUNCTION casttesttype_out(casttesttype)   RETURNS cstring   AS 'textout'   LANGUAGE internal STRICT IMMUTABLE;
CREATE TYPE casttesttype (   internallength = variable,   input = casttesttype_in,   output = casttesttype_out,   alignment = int4);
CREATE FUNCTION casttestfunc(casttesttype) RETURNS int4 LANGUAGE SQL AS$$ SELECT 1; $$;
::SELECT casttestfunc('foo'::text); -- fails, as there's no castCREATE CAST (text AS casttesttype) WITHOUT FUNCTION;
::SELECT casttestfunc('foo'::text); -- doesn't work, as the cast is explicitSELECT casttestfunc('foo'::text::casttesttype); -- should workDROP CAST (text AS casttesttype); -- cleanupCREATE CAST (text AS casttesttype) WITHOUT FUNCTION AS IMPLICIT;
::SELECT casttestfunc('foo'::text); -- Should work nowSELECT 1234::int4::casttesttype; -- No cast yet, should failCREATE CAST (int4 AS casttesttype) WITH INOUT;
::::SELECT 1234::int4::casttesttype; -- Should work nowDROP CAST (int4 AS casttesttype);
CREATE FUNCTION int4_casttesttype(int4) RETURNS casttesttype LANGUAGE SQL AS$$ SELECT ('foo'::text || $1::text)::casttesttype; $$;
CREATE CAST (int4 AS casttesttype) WITH FUNCTION int4_casttesttype(int4) AS IMPLICIT;
::::SELECT 1234::int4::casttesttype; -- Should work nowCREATE TABLE INT2_TBL(f1 int2);
SELECT '' AS four, i.* FROM INT2_TBL i WHERE i.f1 <> int2 '0';
SELECT '' AS four, i.* FROM INT2_TBL i WHERE i.f1 <> int4 '0';
SELECT '' AS one, i.* FROM INT2_TBL i WHERE i.f1 = int2 '0';
SELECT '' AS one, i.* FROM INT2_TBL i WHERE i.f1 = int4 '0';
SELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 < int2 '0';
SELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 < int4 '0';
SELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 <= int2 '0';
SELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 <= int4 '0';
SELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 > int2 '0';
SELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 > int4 '0';
SELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 >= int2 '0';
SELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 >= int4 '0';
SELECT '' AS one, i.* FROM INT2_TBL i WHERE (i.f1 % int2 '2') = int2 '1';
SELECT '' AS three, i.* FROM INT2_TBL i WHERE (i.f1 % int4 '2') = int2 '0';
SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL iWHERE abs(f1) < 16384;
SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL iWHERE f1 < 32766;
SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL iWHERE f1 > -32767;
SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 / int2 '2' AS x FROM INT2_TBL i;
SELECT '' AS five, i.f1, i.f1 / int4 '2' AS x FROM INT2_TBL i;
::SELECT (-1::int2<<15)::text;
::SELECT ((-1::int2<<15)+1::int2)::text;
::SELECT (-32768)::int2 * (-1)::int2;
::SELECT (-32768)::int2 / (-1)::int2;
::SELECT (-32768)::int2 % (-1)::int2;
::SELECT x, x::int2 AS int2_valueFROM (VALUES (-2.5::float8),             (-1.5::float8),             (-0.5::float8),             (0.0::float8),             (0.5::float8),             (1.5::float8),             (2.5::float8)) t(x);
::SELECT x, x::int2 AS int2_valueFROM (VALUES (-2.5::numeric),             (-1.5::numeric),             (-0.5::numeric),             (0.0::numeric),             (0.5::numeric),             (1.5::numeric),             (2.5::numeric)) t(x);
BEGIN;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
COMMIT;
BEGIN;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
ROLLBACK;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
BEGIN;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
ROLLBACK;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
BEGIN;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
COMMIT;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
SELECT locktype, classid, objid, objsubid, mode, granted	FROM pg_locks WHERE locktype = 'advisory'	ORDER BY classid, objid, objsubid;
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE p1.typnamespace = 0 OR    (p1.typlen <= 0 AND p1.typlen != -1 AND p1.typlen != -2) OR    (p1.typtype not in ('b', 'c', 'd', 'e', 'p', 'r')) OR    NOT p1.typisdefined OR    (p1.typalign not in ('c', 's', 'i', 'd')) OR    (p1.typstorage not in ('p', 'x', 'e', 'm'));
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE p1.typbyval AND    (p1.typlen != 1 OR p1.typalign != 'c') AND    (p1.typlen != 2 OR p1.typalign != 's') AND    (p1.typlen != 4 OR p1.typalign != 'i') AND    (p1.typlen != 8 OR p1.typalign != 'd');
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE p1.typstorage != 'p' AND    (p1.typbyval OR p1.typlen != -1);
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE (p1.typtype = 'c' AND p1.typrelid = 0) OR    (p1.typtype != 'c' AND p1.typrelid != 0);
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE p1.typtype not in ('c','d','p') AND p1.typname NOT LIKE E'\\_%'    AND NOT EXISTS    (SELECT 1 FROM pg_type as p2     WHERE p2.typname = ('_' || p1.typname)::name AND           p2.typelem = p1.oid and p1.typarray = p2.oid);
SELECT p1.oid, p1.typname as basetype, p2.typname as arraytype,       p2.typelem, p2.typlenFROM   pg_type p1 LEFT JOIN pg_type p2 ON (p1.typarray = p2.oid)WHERE  p1.typarray <> 0 AND       (p2.oid IS NULL OR p2.typelem <> p1.oid OR p2.typlen <> -1);
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE p1.typtype = 'r' AND   NOT EXISTS(SELECT 1 FROM pg_range r WHERE rngtypid = p1.oid);
SELECT p1.oid, p1.typname, p1.typalign, p2.typname, p2.typalignFROM pg_type as p1     LEFT JOIN pg_range as r ON rngtypid = p1.oid     LEFT JOIN pg_type as p2 ON rngsubtype = p2.oidWHERE p1.typtype = 'r' AND    (p1.typalign != (CASE WHEN p2.typalign = 'd' THEN 'd'::"char"                          ELSE 'i'::"char" END)     OR p2.oid IS NULL);
SELECT p1.oid, p1.typnameFROM pg_type as p1WHERE (p1.typinput = 0 OR p1.typoutput = 0);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typinput = p2.oid AND NOT    ((p2.pronargs = 1 AND p2.proargtypes[0] = 'cstring'::regtype) OR     (p2.pronargs = 2 AND p2.proargtypes[0] = 'cstring'::regtype AND      p2.proargtypes[1] = 'oid'::regtype) OR     (p2.pronargs = 3 AND p2.proargtypes[0] = 'cstring'::regtype AND      p2.proargtypes[1] = 'oid'::regtype AND      p2.proargtypes[2] = 'int4'::regtype));
::::::SELECT oid::regprocedure, provariadic::regtype, proargtypes::regtype[]FROM pg_procWHERE provariadic != 0AND case proargtypes[array_length(proargtypes, 1)-1]    WHEN 2276 THEN 2276 -- any -> any	WHEN 2277 THEN 2283 -- anyarray -> anyelement	ELSE (SELECT t.oid		  FROM pg_type t		  WHERE t.typarray = proargtypes[array_length(proargtypes, 1)-1])	END  != provariadic;
::SELECT oid::regprocedure, proargmodes, provariadicFROM pg_procWHERE (proargmodes IS NOT NULL AND 'v' = any(proargmodes))    IS DISTINCT FROM    (provariadic != 0);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typinput = p2.oid AND p1.typtype in ('b', 'p') AND NOT    (p1.typelem != 0 AND p1.typlen < 0) AND NOT    (p2.prorettype = p1.oid AND NOT p2.proretset)ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typinput = p2.oid AND    (p1.typelem != 0 AND p1.typlen < 0) AND NOT    (p2.oid = 'array_in'::regproc)ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typinput = p2.oid AND p2.provolatile NOT IN ('i', 's');
SELECT DISTINCT typtype, typinputFROM pg_type AS p1WHERE p1.typtype not in ('b', 'p')ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typoutput = p2.oid AND p1.typtype in ('b', 'p') AND NOT    (p2.pronargs = 1 AND     (p2.proargtypes[0] = p1.oid OR      (p2.oid = 'array_out'::regproc AND       p1.typelem != 0 AND p1.typlen = -1)))ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typoutput = p2.oid AND NOT    (p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typoutput = p2.oid AND p2.provolatile NOT IN ('i', 's');
SELECT DISTINCT typtype, typoutputFROM pg_type AS p1WHERE p1.typtype not in ('b', 'd', 'p')ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.typnameFROM pg_type AS p1 LEFT JOIN pg_type AS p2 ON p1.typbasetype = p2.oidWHERE p1.typtype = 'd' AND p1.typoutput IS DISTINCT FROM p2.typoutput;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typreceive = p2.oid AND NOT    ((p2.pronargs = 1 AND p2.proargtypes[0] = 'internal'::regtype) OR     (p2.pronargs = 2 AND p2.proargtypes[0] = 'internal'::regtype AND      p2.proargtypes[1] = 'oid'::regtype) OR     (p2.pronargs = 3 AND p2.proargtypes[0] = 'internal'::regtype AND      p2.proargtypes[1] = 'oid'::regtype AND      p2.proargtypes[2] = 'int4'::regtype));
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typreceive = p2.oid AND p1.typtype in ('b', 'p') AND NOT    (p1.typelem != 0 AND p1.typlen < 0) AND NOT    (p2.prorettype = p1.oid AND NOT p2.proretset)ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typreceive = p2.oid AND    (p1.typelem != 0 AND p1.typlen < 0) AND NOT    (p2.oid = 'array_recv'::regproc)ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.proname, p3.oid, p3.pronameFROM pg_type AS p1, pg_proc AS p2, pg_proc AS p3WHERE p1.typinput = p2.oid AND p1.typreceive = p3.oid AND    p2.pronargs != p3.pronargs;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typreceive = p2.oid AND p2.provolatile NOT IN ('i', 's');
SELECT DISTINCT typtype, typreceiveFROM pg_type AS p1WHERE p1.typtype not in ('b', 'p')ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typsend = p2.oid AND p1.typtype in ('b', 'p') AND NOT    (p2.pronargs = 1 AND     (p2.proargtypes[0] = p1.oid OR      (p2.oid = 'array_send'::regproc AND       p1.typelem != 0 AND p1.typlen = -1)))ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typsend = p2.oid AND NOT    (p2.prorettype = 'bytea'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typsend = p2.oid AND p2.provolatile NOT IN ('i', 's');
SELECT DISTINCT typtype, typsendFROM pg_type AS p1WHERE p1.typtype not in ('b', 'd', 'p')ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.typnameFROM pg_type AS p1 LEFT JOIN pg_type AS p2 ON p1.typbasetype = p2.oidWHERE p1.typtype = 'd' AND p1.typsend IS DISTINCT FROM p2.typsend;
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typmodin = p2.oid AND NOT    (p2.pronargs = 1 AND     p2.proargtypes[0] = 'cstring[]'::regtype AND     p2.prorettype = 'int4'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typmodin = p2.oid AND p2.provolatile NOT IN ('i', 's');
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typmodout = p2.oid AND NOT    (p2.pronargs = 1 AND     p2.proargtypes[0] = 'int4'::regtype AND     p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typmodout = p2.oid AND p2.provolatile NOT IN ('i', 's');
SELECT p1.oid, p1.typname, p2.oid, p2.typnameFROM pg_type AS p1, pg_type AS p2WHERE p1.typelem = p2.oid AND NOT    (p1.typmodin = p2.typmodin AND p1.typmodout = p2.typmodout);
SELECT p1.oid, p1.typname, p2.oid, p2.typnameFROM pg_type AS p1, pg_type AS p2WHERE p1.typarray = p2.oid AND NOT (p1.typdelim = p2.typdelim);
SELECT p1.oid, p1.typname, p1.typalign, p2.typname, p2.typalignFROM pg_type AS p1, pg_type AS p2WHERE p1.typarray = p2.oid AND    p2.typalign != (CASE WHEN p1.typalign = 'd' THEN 'd'::"char"                         ELSE 'i'::"char" END);
SELECT p1.oid, p1.typname, p2.oid, p2.pronameFROM pg_type AS p1, pg_proc AS p2WHERE p1.typanalyze = p2.oid AND NOT    (p2.pronargs = 1 AND     p2.proargtypes[0] = 'internal'::regtype AND     p2.prorettype = 'bool'::regtype AND NOT p2.proretset);
SELECT d.oid, d.typname, d.typanalyze, t.oid, t.typname, t.typanalyzeFROM pg_type d JOIN pg_type t ON d.typbasetype = t.oidWHERE d.typanalyze != t.typanalyze;
SELECT t.oid, t.typname, t.typanalyzeFROM pg_type t LEFT JOIN pg_range r on t.oid = r.rngtypidWHERE t.typbasetype = 0 AND    (t.typanalyze = 'range_typanalyze'::regproc) != (r.rngtypid IS NOT NULL);
SELECT t.oid, t.typname, t.typanalyzeFROM pg_type tWHERE t.typbasetype = 0 AND    (t.typanalyze = 'array_typanalyze'::regproc) !=    (typelem != 0 AND typlen < 0)ORDER BY 1;
SELECT p1.oid, p1.relnameFROM pg_class as p1WHERE relkind NOT IN ('r', 'i', 'S', 't', 'v', 'm', 'c', 'f', 'p') OR    relpersistence NOT IN ('p', 'u', 't') OR    relreplident NOT IN ('d', 'n', 'f', 'i');
SELECT p1.oid, p1.relnameFROM pg_class as p1WHERE p1.relkind NOT IN ('S', 'v', 'f', 'c') and    p1.relam = 0;
SELECT p1.oid, p1.relnameFROM pg_class as p1WHERE p1.relkind IN ('S', 'v', 'f', 'c') and    p1.relam != 0;
SELECT pc.oid, pc.relname, pa.amname, pa.amtypeFROM pg_class as pc JOIN pg_am AS pa ON (pc.relam = pa.oid)WHERE pc.relkind IN ('i') and    pa.amtype != 'i';
SELECT pc.oid, pc.relname, pa.amname, pa.amtypeFROM pg_class as pc JOIN pg_am AS pa ON (pc.relam = pa.oid)WHERE pc.relkind IN ('r', 't', 'm') and    pa.amtype != 't';
SELECT p1.attrelid, p1.attnameFROM pg_attribute as p1WHERE p1.attrelid = 0 OR p1.atttypid = 0 OR p1.attnum = 0 OR    p1.attcacheoff != -1 OR p1.attinhcount < 0 OR    (p1.attinhcount = 0 AND NOT p1.attislocal);
SELECT p1.attrelid, p1.attname, p2.oid, p2.relnameFROM pg_attribute AS p1, pg_class AS p2WHERE p1.attrelid = p2.oid AND p1.attnum > p2.relnatts;
SELECT p1.oid, p1.relnameFROM pg_class AS p1WHERE p1.relnatts != (SELECT count(*) FROM pg_attribute AS p2                      WHERE p2.attrelid = p1.oid AND p2.attnum > 0);
SELECT p1.attrelid, p1.attname, p2.oid, p2.typnameFROM pg_attribute AS p1, pg_type AS p2WHERE p1.atttypid = p2.oid AND    (p1.attlen != p2.typlen OR     p1.attalign != p2.typalign OR     p1.attbyval != p2.typbyval OR     (p1.attstorage != p2.typstorage AND p1.attstorage != 'p'));
SELECT p1.rngtypid, p1.rngsubtypeFROM pg_range as p1WHERE p1.rngtypid = 0 OR p1.rngsubtype = 0 OR p1.rngsubopc = 0;
SELECT p1.rngtypid, p1.rngsubtype, p1.rngcollation, t.typcollationFROM pg_range p1 JOIN pg_type t ON t.oid = p1.rngsubtypeWHERE (rngcollation = 0) != (typcollation = 0);
SELECT p1.rngtypid, p1.rngsubtype, o.opcmethod, o.opcnameFROM pg_range p1 JOIN pg_opclass o ON o.oid = p1.rngsubopcWHERE o.opcmethod != 403 OR    ((o.opcintype != p1.rngsubtype) AND NOT     (o.opcintype = 'pg_catalog.anyarray'::regtype AND      EXISTS(select 1 from pg_catalog.pg_type where             oid = p1.rngsubtype and typelem != 0 and typlen = -1)));
SELECT p1.rngtypid, p1.rngsubtype, p.pronameFROM pg_range p1 JOIN pg_proc p ON p.oid = p1.rngcanonicalWHERE pronargs != 1 OR proargtypes[0] != rngtypid OR prorettype != rngtypid;
SELECT p1.rngtypid, p1.rngsubtype, p.pronameFROM pg_range p1 JOIN pg_proc p ON p.oid = p1.rngsubdiffWHERE pronargs != 2    OR proargtypes[0] != rngsubtype OR proargtypes[1] != rngsubtype    OR prorettype != 'pg_catalog.float8'::regtype;
create table inserttest (col1 int4, col2 int4 NOT NULL, col3 text default 'testing');
insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
insert into inserttest (col2, col3) values (3, DEFAULT);
insert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
insert into inserttest values (DEFAULT, 5, 'test');
insert into inserttest values (DEFAULT, 7);
insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT);
insert into inserttest (col1) values (DEFAULT, DEFAULT);
insert into inserttest values(10, 20, '40'), (-1, 2, DEFAULT),    ((select 2), (select i from (values(3)) as foo (i)), 'values are fun!');
create type insert_test_type as (if1 int, if2 text[]);
create table inserttest (f1 int, f2 int[],                         f3 insert_test_type, f4 insert_test_type[]);
insert into inserttest (f2[1], f2[2]) values (1,2);
insert into inserttest (f2[1], f2[2]) values (3,4), (5,6);
insert into inserttest (f2[1], f2[2]) select 7,8;
insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supportedinsert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
insert into inserttest (f3.if1, f3.if2) values (1,'{foo}'), (2,'{bar}');
insert into inserttest (f3.if1, f3.if2) select 3, '{baz,quux}';
insert into inserttest (f3.if1, f3.if2) values (1,default);  -- not supportedinsert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar');
insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar'), ('baz', 'quux');
insert into inserttest (f3.if2[1], f3.if2[2]) select 'bear', 'beer';
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar');
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar'), ('baz', 'quux');
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) select 'bear', 'beer';
create rule irule1 as on insert to inserttest2 do also  insert into inserttest (f3.if2[1], f3.if2[2])  values (new.f1,new.f2);
create rule irule2 as on insert to inserttest2 do also  insert into inserttest (f4[1].if1, f4[1].if2[2])  values (1,'fool'),(new.f1,new.f2);
create rule irule3 as on insert to inserttest2 do also  insert into inserttest (f4[1].if1, f4[1].if2[2])  select new.f1, new.f2;
drop type insert_test_type;
create table range_parted (	a text,	b int) partition by range (a, (b+0));
create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
create table part3 partition of range_parted for values from ('b', 1) to ('b', 10);
create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
insert into part1 values (null);
create table list_parted (	a text,	b int) partition by list (lower(a));
create table part_aa_bb partition of list_parted FOR VALUES IN ('aa', 'bb');
create table part_cc_dd partition of list_parted FOR VALUES IN ('cc', 'dd');
create table part_null partition of list_parted FOR VALUES IN (null);
insert into part_aa_bb values (null);
insert into part_null values (null, 0);
create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
create table part_ee_ff2 partition of part_ee_ff for values from (10) to (20);
create table part_default partition of list_parted default;
insert into part_default values (null, 2);
create table part_xx_yy partition of list_parted for values in ('xx', 'yy') partition by list (a);
create table part_xx_yy_p1 partition of part_xx_yy for values in ('xx');
create table part_xx_yy_defpart partition of part_xx_yy default;
create table part_default partition of list_parted default partition by range(b);
create table part_default_p1 partition of part_default for values from (20) to (30);
create table part_default_p2 partition of part_default for values from (30) to (40);
::create table part_def partition of range_parted default;
insert into range_parted values (null, null);
insert into range_parted values ('a', null);
insert into range_parted values (null, 19);
::insert into list_parted values (null, 1);
::create table part_gg partition of list_parted for values in ('gg') partition by range (b);
create table part_gg1 partition of part_gg for values from (minvalue) to (1);
create table part_gg2 partition of part_gg for values from (1) to (10) partition by range (b);
create table part_gg2_1 partition of part_gg2 for values from (1) to (5);
create table part_gg2_2 partition of part_gg2 for values from (5) to (10);
create table part_ee_ff3 partition of part_ee_ff for values from (20) to (30) partition by range (b);
create table part_ee_ff3_1 partition of part_ee_ff3 for values from (20) to (25);
create table part_ee_ff3_2 partition of part_ee_ff3 for values from (25) to (30);
truncate list_parted;
insert into list_parted select 'Ff', s.a from generate_series(1, 29) s(a);
insert into list_parted select 'gg', s.a from generate_series(1, 9) s(a);
::::select tableoid::regclass::text, a, min(b) as min_b, max(b) as max_b from list_parted group by 1, 2 order by 1;
create or replace function part_hashint4_noop(value int4, seed int8)returns int8 as $$select value + seed;
$$ language sql immutable;
create operator class part_test_int4_opsfor type int4using hash asoperator 1 =,function 2 part_hashint4_noop(int4, int8);
create or replace function part_hashtext_length(value text, seed int8)RETURNS int8 AS $$select length(coalesce(value, ''))::int8$$ language sql immutable;
create operator class part_test_text_opsfor type textusing hash asoperator 1 =,function 2 part_hashtext_length(text, int8);
create table hash_parted (	a int) partition by hash (a part_test_int4_ops);
create table hpart0 partition of hash_parted for values with (modulus 4, remainder 0);
create table hpart1 partition of hash_parted for values with (modulus 4, remainder 1);
create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
create table hpart3 partition of hash_parted for values with (modulus 4, remainder 3);
::select tableoid::regclass as part, a, a%4 as "remainder = a % 4"from hash_parted order by part;
drop table range_parted, list_parted;
create table list_parted (a int) partition by list (a);
create table part_default partition of list_parted default;
insert into part_default values (null);
::create table mlparted (a int, b int) partition by range (a, b);
create table mlparted1 (b int not null, a int not null) partition by range ((b+0));
create table mlparted11 (like mlparted1);
alter table mlparted11 drop a;
alter table mlparted11 drop a;
::select attrelid::regclass, attname, attnumfrom pg_attributewhere attname = 'a' and (attrelid = 'mlparted'::regclass   or attrelid = 'mlparted1'::regclass   or attrelid = 'mlparted11'::regclass)order by attrelid::regclass::text;
alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
::truncate mlparted;
alter table mlparted add constraint check_b check (b = 3);
create function mlparted11_trig_fn()returns trigger AS$$begin  NEW.b := 4;
  return NEW;
end;
$$language plpgsql;
drop trigger mlparted11_trig on mlparted11;
drop function mlparted11_trig_fn();
create table lparted_nonullpart (a int, b char) partition by list (b);
create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
alter table mlparted drop constraint check_b;
create table mlparted12 partition of mlparted1 for values from (5) to (10);
alter table mlparted attach partition mlparted2 for values from (1, 10) to (1, 20);
create table mlparted3 partition of mlparted for values from (1, 20) to (1, 30);
create table mlparted4 (like mlparted);
alter table mlparted4 drop a;
alter table mlparted attach partition mlparted4 for values from (1, 30) to (1, 40);
with ins (a, b, c) as  (insert into mlparted (b, a) select s.a, 1 from generate_series(2, 39) s(a) returning tableoid::regclass, *)  select a, b, min(c), max(c) from ins group by a, b order by 1;
create table mlparted5 (c text, a int not null, b int not null) partition by list (c);
alter table mlparted5 attach partition mlparted5a for values in ('a');
alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
alter table mlparted add constraint check_b check (a = 1 and b < 45);
create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
alter table mlparted drop constraint check_b;
create table mlparted_def partition of mlparted default partition by range(a);
create table mlparted_def1 partition of mlparted_def for values from (40) to (50);
create table mlparted_def2 partition of mlparted_def for values from (50) to (60);
create table mlparted_defd partition of mlparted_def default;
::alter table mlparted add d int, add e int;
alter table mlparted drop e;
create table mlparted5 partition of mlparted  for values from (1, 40) to (1, 50) partition by range (c);
create table mlparted5_ab partition of mlparted5  for values from ('a') to ('c') partition by list (c);
create table mlparted5_cd partition of mlparted5  for values from ('c') to ('e') partition by list (c);
create table mlparted5_a partition of mlparted5_ab for values in ('a');
alter table mlparted5_ab attach partition mlparted5_b for values in ('b');
truncate mlparted;
insert into mlparted values (1, 40, 'a', 1);  -- goes to mlparted5_ainsert into mlparted values (1, 45, 'b', 1);  -- goes to mlparted5_binsert into mlparted values (1, 45, 'c', 1);  -- goes to mlparted5_cd, failsinsert into mlparted values (1, 45, 'f', 1);  -- goes to mlparted5, failsselect tableoid::regclass, * from mlparted order by a, b, c, d;
alter table mlparted drop d;
truncate mlparted;
alter table mlparted add e int, add d int;
alter table mlparted drop e;
insert into mlparted values (1, 40, 'a', 1);  -- goes to mlparted5_ainsert into mlparted values (1, 45, 'b', 1);  -- goes to mlparted5_binsert into mlparted values (1, 45, 'c', 1);  -- goes to mlparted5_cd, failsinsert into mlparted values (1, 45, 'f', 1);  -- goes to mlparted5, failsselect tableoid::regclass, * from mlparted order by a, b, c, d;
alter table mlparted drop d;
create table key_desc (a int, b int) partition by list ((a+0));
create table key_desc_1 partition of key_desc for values in (1) partition by range (b);
create user regress_insert_other_user;
grant select (a) on key_desc_1 to regress_insert_other_user;
grant insert on key_desc to regress_insert_other_user;
set role regress_insert_other_user;
reset role;
grant select (b) on key_desc_1 to regress_insert_other_user;
set role regress_insert_other_user;
reset role;
revoke all on key_desc from regress_insert_other_user;
revoke all on key_desc_1 from regress_insert_other_user;
drop role regress_insert_other_user;
drop table key_desc, key_desc_1;
create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
create table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue);
create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue);
create table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue);
create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, maxvalue, maxvalue);
create table mcrparted1 partition of mcrparted for values from (2, 1, minvalue) to (10, 5, 10);
create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, maxvalue);
create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
create table mcrparted4 partition of mcrparted for values from (21, minvalue, minvalue) to (30, 20, maxvalue);
create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
insert into mcrparted values (null, null, null);
insert into mcrparted4 values (30, 21, 20);	-- errorselect tableoid::regclass::text, * from mcrparted order by 1;
create table brtrigpartcon (a int, b text) partition by list (a);
create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
create table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int);
create role regress_coldesc_role;
grant insert on inserttest3 to regress_coldesc_role;
grant insert on brtrigpartcon to regress_coldesc_role;
revoke select on brtrigpartcon from regress_coldesc_role;
set role regress_coldesc_role;
with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)  insert into inserttest3 (f3) select * from result;
reset role;
revoke all on inserttest3 from regress_coldesc_role;
revoke all on brtrigpartcon from regress_coldesc_role;
drop role regress_coldesc_role;
drop function brtrigpartcon1trigf();
create table donothingbrtrig_test (a int, b text) partition by list (a);
alter table donothingbrtrig_test2 drop column c;
create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
copy donothingbrtrig_test from stdout;
1	baz2	qux\.select tableoid::regclass, * from donothingbrtrig_test;
drop function donothingbrtrig_func();
create table mcrparted (a text, b int) partition by range(a, b);
create table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue);
create table mcrparted2_b partition of mcrparted for values from ('b', minvalue) to ('c', minvalue);
create table mcrparted3_c_to_common partition of mcrparted for values from ('c', minvalue) to ('common', minvalue);
create table mcrparted4_common_lt_0 partition of mcrparted for values from ('common', minvalue) to ('common', 0);
create table mcrparted5_common_0_to_10 partition of mcrparted for values from ('common', 0) to ('common', 10);
create table mcrparted6_common_ge_10 partition of mcrparted for values from ('common', 10) to ('common', maxvalue);
create table mcrparted7_gt_common_lt_d partition of mcrparted for values from ('common', maxvalue) to ('d', minvalue);
create table mcrparted8_ge_d partition of mcrparted for values from ('d', minvalue) to (maxvalue, maxvalue);
::select tableoid::regclass, * from mcrparted order by a, b;
create table returningwrtest (a int) partition by list (a);
create table returningwrtest1 partition of returningwrtest for values in (1);
insert into returningwrtest values (1) returning returningwrtest;
alter table returningwrtest2 drop c;
alter table returningwrtest attach partition returningwrtest2 for values in (2);
insert into returningwrtest values (2, 'foo') returning returningwrtest;
::INSERT INTO quad_point_tbl VALUES (NULL), (NULL), (NULL);
CREATE INDEX sp_quad_ind ON quad_point_tbl USING spgist (p);
CREATE INDEX sp_kd_ind ON kd_point_tbl USING spgist (p kd_point_ops);
!~CREATE TABLE radix_text_tbl AS    SELECT name AS t FROM road WHERE name !~ '^[0-9]';
CREATE INDEX sp_radix_ind ON radix_text_tbl USING spgist (t);
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
@SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
~CREATE TEMP TABLE quad_point_tbl_ord_seq1 ASSELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM quad_point_tbl;
CREATE TEMP TABLE quad_point_tbl_ord_seq2 ASSELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE quad_point_tbl_ord_seq3 ASSELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, pFROM quad_point_tbl WHERE p IS NOT NULL;
~~~~~~~~@SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
@SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
~EXPLAIN (COSTS OFF)SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM quad_point_tbl;
CREATE TEMP TABLE quad_point_tbl_ord_idx1 ASSELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM quad_point_tbl;
SELECT * FROM quad_point_tbl_ord_seq1 seq FULL JOIN quad_point_tbl_ord_idx1 idxON seq.n = idx.nWHERE seq.dist IS DISTINCT FROM idx.dist;
EXPLAIN (COSTS OFF)SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE quad_point_tbl_ord_idx2 ASSELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
SELECT * FROM quad_point_tbl_ord_seq2 seq FULL JOIN quad_point_tbl_ord_idx2 idxON seq.n = idx.nWHERE seq.dist IS DISTINCT FROM idx.dist;
EXPLAIN (COSTS OFF)SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, pFROM quad_point_tbl WHERE p IS NOT NULL;
CREATE TEMP TABLE quad_point_tbl_ord_idx3 ASSELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, pFROM quad_point_tbl WHERE p IS NOT NULL;
SELECT * FROM quad_point_tbl_ord_seq3 seq FULL JOIN quad_point_tbl_ord_idx3 idxON seq.n = idx.nWHERE seq.dist IS DISTINCT FROM idx.dist;
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
@SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
~EXPLAIN (COSTS OFF)SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM kd_point_tbl;
CREATE TEMP TABLE kd_point_tbl_ord_idx1 ASSELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM kd_point_tbl;
SELECT * FROM quad_point_tbl_ord_seq1 seq FULL JOIN kd_point_tbl_ord_idx1 idxON seq.n = idx.nWHERE seq.dist IS DISTINCT FROM idx.dist;
EXPLAIN (COSTS OFF)SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE kd_point_tbl_ord_idx2 ASSELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, pFROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
SELECT * FROM quad_point_tbl_ord_seq2 seq FULL JOIN kd_point_tbl_ord_idx2 idxON seq.n = idx.nWHERE seq.dist IS DISTINCT FROM idx.dist;
EXPLAIN (COSTS OFF)SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, pFROM kd_point_tbl WHERE p IS NOT NULL;
CREATE TEMP TABLE kd_point_tbl_ord_idx3 ASSELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, pFROM kd_point_tbl WHERE p IS NOT NULL;
SELECT * FROM quad_point_tbl_ord_seq3 seq FULL JOIN kd_point_tbl_ord_idx3 idxON seq.n = idx.nWHERE seq.dist IS DISTINCT FROM idx.dist;
SELECT (SELECT p FROM kd_point_tbl ORDER BY p <-> pt, p <-> '0,0' LIMIT 1)FROM (VALUES (point '1,2'), (NULL), ('1234,5678')) pts(pt);
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
@SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
@SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
~EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
@SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
~~EXPLAIN (COSTS OFF)SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
@RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
CREATE TABLE DEFAULT_TBL (i int DEFAULT 100,	x text DEFAULT 'vadim', f float8 DEFAULT 123.456);
INSERT INTO DEFAULT_TBL VALUES (3, null, 1.0);
CREATE SEQUENCE DEFAULT_SEQ;
CREATE TABLE DEFAULTEXPR_TBL (i1 int DEFAULT 100 + (200-199) * 2,	i2 int DEFAULT nextval('default_seq'));
INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (NULL);
CREATE TABLE error_tbl (i int DEFAULT (100, ));
CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
CREATE TABLE error_tbl (b1 bool DEFAULT (1 IN (1, 2)));
CREATE TABLE CHECK_TBL (x int,	CONSTRAINT CHECK_CON CHECK (x > 3));
CREATE SEQUENCE CHECK_SEQ;
CREATE TABLE CHECK2_TBL (x int, y text, z int,	CONSTRAINT SEQUENCE_CON	CHECK (x > 3 and y <> 'check failed' and z < 8));
CREATE SEQUENCE INSERT_SEQ;
CREATE TABLE INSERT_TBL (x INT DEFAULT nextval('insert_seq'),	y TEXT DEFAULT '-NULL-',	z INT DEFAULT -1 * currval('insert_seq'),	CONSTRAINT INSERT_TBL_CON CHECK (x >= 3 AND y <> 'check failed' AND x < 8),	CHECK (x + z = 0));
INSERT INTO INSERT_TBL VALUES (null, null, null);
CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,                  altitude int,                  CHECK (NOT (is_capital AND tableoid::regclass::text = 'sys_col_check_tbl')));
::::SELECT *, tableoid::regclass::text FROM SYS_COL_CHECK_TBL;
CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,                  altitude int,				  CHECK (NOT (is_capital AND ctid::text = 'sys_col_check_tbl')));
CREATE TABLE INSERT_CHILD (cx INT default 42,	cy INT CHECK (cy > x))	INHERITS (INSERT_TBL);
CREATE TABLE ATACC1 (TEST INT	CHECK (TEST > 0) NO INHERIT);
CREATE TABLE ATACC2 (TEST2 INT) INHERITS (ATACC1);
DROP TABLE ATACC1 CASCADE;
CREATE TABLE ATACC1 (TEST INT, TEST2 INT	CHECK (TEST > 0), CHECK (TEST2 > 10) NO INHERIT);
CREATE TABLE ATACC2 () INHERITS (ATACC1);
DROP TABLE ATACC1 CASCADE;
DELETE FROM INSERT_TBL;
ALTER SEQUENCE INSERT_SEQ RESTART WITH 4;
INSERT INTO tmp VALUES (null, 'Y', null);
INSERT INTO tmp VALUES (5, '!check failed', null);
INSERT INTO tmp VALUES (null, 'try again', null);
UPDATE INSERT_TBL SET x = NULL WHERE x = 5;
CREATE TABLE COPY_TBL (x INT, y TEXT, z INT,	CONSTRAINT COPY_CON	CHECK (x > 3 AND y <> 'check failed' AND x < 7 ));
COPY COPY_TBL FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/constro.data';
COPY COPY_TBL FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/constrf.data';
CREATE TABLE PRIMARY_TBL (i int, t text,	PRIMARY KEY(i,t));
INSERT INTO UNIQUE_TBL VALUES (5, 'five-upsert-insert') ON CONFLICT (i) DO UPDATE SET t = 'five-upsert-update';
INSERT INTO UNIQUE_TBL VALUES (6, 'six-upsert-insert') ON CONFLICT (i) DO UPDATE SET t = 'six-upsert-update';
INSERT INTO UNIQUE_TBL VALUES (1, 'a'), (2, 'b'), (2, 'b') ON CONFLICT (i) DO UPDATE SET t = 'fails';
CREATE TABLE UNIQUE_TBL (i int, t text,	UNIQUE(i,t));
CREATE TABLE unique_tbl (i int UNIQUE DEFERRABLE, t text);
BEGIN;
ROLLBACK;
BEGIN;
SET CONSTRAINTS unique_tbl_i_key DEFERRED;
DELETE FROM unique_tbl WHERE t = 'tree'; -- makes constraint valid againCOMMIT; -- should succeedSELECT * FROM unique_tbl;
ALTER TABLE unique_tbl DROP CONSTRAINT unique_tbl_i_key;
ALTER TABLE unique_tbl ADD CONSTRAINT unique_tbl_i_key	UNIQUE (i) DEFERRABLE INITIALLY DEFERRED;
BEGIN;
DELETE FROM unique_tbl WHERE i = 1 AND t = 'one';
DELETE FROM unique_tbl WHERE i = 5 AND t = 'five';
COMMIT;
BEGIN;
INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for nowCOMMIT; -- should failBEGIN;
SET CONSTRAINTS ALL IMMEDIATE;
INSERT INTO unique_tbl VALUES (3, 'Three'); -- should failCOMMIT;
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for nowSET CONSTRAINTS ALL IMMEDIATE; -- should failCOMMIT;
CREATE TABLE parted_uniq_tbl (i int UNIQUE DEFERRABLE) partition by range (i);
CREATE TABLE parted_uniq_tbl_1 PARTITION OF parted_uniq_tbl FOR VALUES FROM (0) TO (10);
CREATE TABLE parted_uniq_tbl_2 PARTITION OF parted_uniq_tbl FOR VALUES FROM (20) TO (30);
::BEGIN;
SAVEPOINT f;
INSERT INTO parted_uniq_tbl VALUES (1);	-- unique violationROLLBACK TO f;
SET CONSTRAINTS parted_uniq_tbl_i_key DEFERRED;
INSERT INTO parted_uniq_tbl VALUES (1);	-- OK now, fail at commitCOMMIT;
BEGIN;
INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for nowUPDATE unique_tbl SET t = 'THREE' WHERE i = 3 AND t = 'Three';
COMMIT; -- should failSELECT * FROM unique_tbl;
BEGIN;
INSERT INTO unique_tbl VALUES(3, 'tree'); -- should succeed for nowUPDATE unique_tbl SET t = 'threex' WHERE t = 'tree';
DELETE FROM unique_tbl WHERE t = 'three';
COMMIT;
CREATE TABLE circles (  c1 CIRCLE,  c2 TEXT,  EXCLUDE USING gist    (c1 WITH &&, (c2::circle) WITH &&)    WHERE (circle_center(c1) <> '(0,0)'));
INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>')  ON CONFLICT ON CONSTRAINT circles_c1_c2_excl DO NOTHING;
INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>')  ON CONFLICT ON CONSTRAINT circles_c1_c2_excl DO UPDATE SET c2 = EXCLUDED.c2;
ALTER TABLE circles ADD EXCLUDE USING gist  (c1 WITH &&, (c2::circle) WITH &&);
CREATE TABLE deferred_excl (  f1 int,  f2 int,  CONSTRAINT deferred_excl_con EXCLUDE (f1 WITH =) INITIALLY DEFERRED);
INSERT INTO deferred_excl VALUES(1); -- failINSERT INTO deferred_excl VALUES(1) ON CONFLICT ON CONSTRAINT deferred_excl_con DO NOTHING; -- failBEGIN;
INSERT INTO deferred_excl VALUES(2); -- no fail hereCOMMIT; -- should fail hereBEGIN;
INSERT INTO deferred_excl VALUES(3); -- no fail hereCOMMIT; -- should fail hereBEGIN;
INSERT INTO deferred_excl VALUES(2, 1); -- no fail hereDELETE FROM deferred_excl WHERE f1 = 2 AND f2 IS NULL; -- remove old rowUPDATE deferred_excl SET f2 = 2 WHERE f1 = 2;
COMMIT; -- should not failSELECT * FROM deferred_excl;
ALTER TABLE deferred_excl DROP CONSTRAINT deferred_excl_con;
ALTER TABLE deferred_excl ADD EXCLUDE (f1 WITH =);
CREATE ROLE regress_constraint_comments;
SET SESSION AUTHORIZATION regress_constraint_comments;
CREATE DOMAIN constraint_comments_dom AS int CONSTRAINT the_constraint CHECK (value > 0);
COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'yes, the comment';
COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
COMMENT ON CONSTRAINT no_constraint ON constraint_comments_tbl IS 'yes, the comment';
COMMENT ON CONSTRAINT no_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
COMMENT ON CONSTRAINT the_constraint ON no_comments_tbl IS 'bad comment';
COMMENT ON CONSTRAINT the_constraint ON DOMAIN no_comments_dom IS 'another bad comment';
COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS NULL;
COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS NULL;
RESET SESSION AUTHORIZATION;
CREATE ROLE regress_constraint_comments_noaccess;
SET SESSION AUTHORIZATION regress_constraint_comments_noaccess;
COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'no, the comment';
COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'no, another comment';
RESET SESSION AUTHORIZATION;
DROP DOMAIN constraint_comments_dom;
DROP ROLE regress_constraint_comments;
DROP ROLE regress_constraint_comments_noaccess;
SET bytea_output TO escape;
CREATE TABLE lotest_stash_values (loid oid, fd integer);
CREATE ROLE regress_lo_user;
DO $$  BEGIN    EXECUTE 'ALTER LARGE OBJECT ' || (select loid from lotest_stash_values)		|| ' OWNER TO regress_lo_user';
  END$$;
SELECT	rol.rolnameFROM	lotest_stash_values s	JOIN pg_largeobject_metadata lo ON s.loid = lo.oid	JOIN pg_authid rol ON lo.lomowner = rol.oid;
BEGIN;
UPDATE lotest_stash_values SET fd = lo_open(loid, CAST(x'20000' | x'40000' AS integer));
SELECT lowrite(fd, 'I wandered lonely as a cloudThat floats on high o''er vales and hills,When all at once I saw a crowd,A host, of golden daffodils;
Beside the lake, beneath the trees,Fluttering and dancing in the breeze.Continuous as the stars that shineAnd twinkle on the milky way,They stretched in never-ending lineAlong the margin of a bay:Ten thousand saw I at a glance,Tossing their heads in sprightly dance.The waves beside them danced; but theyOut-did the sparkling waves in glee:A poet could not but be gay,In such a jocund company:I gazed--and gazed--but little thoughtWhat wealth the show to me had brought:For oft, when on my couch I lieIn vacant or in pensive mood,They flash upon that inward eyeWhich is the bliss of solitude;
And then my heart with pleasure fills,And dances with the daffodils.         -- William Wordsworth') FROM lotest_stash_values;
END;
\SELECT lo_from_bytea(0, lo_get(loid)) AS newloid FROM lotest_stash_values\gsetCOMMENT ON LARGE OBJECT :newloid IS 'I Wandered Lonely as a Cloud';
BEGIN;
UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
END;
BEGIN;
SELECT lo_open(loid, x'40000'::int) from lotest_stash_values;
ABORT;
BEGIN;
UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
END;
BEGIN;
UPDATE lotest_stash_values SET fd = lo_open(loid, CAST(x'20000' | x'40000' AS integer));
END;
TRUNCATE lotest_stash_values;
BEGIN;
UPDATE lotest_stash_values SET fd=lo_open(loid, CAST(x'20000' | x'40000' AS integer));
END;
\\lo_import '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/lotest.txt'\set newloid :LASTOID\lo_export :newloid '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/lotest2.txt'SELECT pageno, data FROM pg_largeobject WHERE loid = (SELECT loid from lotest_stash_values)EXCEPTSELECT pageno, data FROM pg_largeobject WHERE loid = :newloid;
TRUNCATE lotest_stash_values;
\\lo_unlink :newloid\lo_import '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/lotest.txt'\set newloid_1 :LASTOIDSELECT lo_from_bytea(0, lo_get(:newloid_1)) AS newloid_2\gsetSELECT md5(lo_get(:newloid_1)) = md5(lo_get(:newloid_2));
:::::::\\lo_unlink :newloid_1\lo_unlink :newloid_2SELECT lo_from_bytea(0, E'\\xdeadbeef') AS newloid\gsetSET bytea_output TO hex;
:COMMENT ON LARGE OBJECT 3001 IS 'testing comments';
DROP ROLE regress_lo_user;
set enable_indexscan=false;
set enable_seqscan=false;
set work_mem = 64;
create event trigger regress_event_trigger   on ddl_command_start   execute procedure pg_backend_pid();
create function test_event_trigger() returns event_trigger as $$BEGIN    RAISE NOTICE 'test_event_trigger: % %', tg_event, tg_tag;
END$$ language plpgsql;
create function test_event_trigger_arg(name text)returns event_trigger as $$ BEGIN RETURN 1; END $$ language plpgsql;
create function test_event_trigger_sql() returns event_trigger as $$SELECT 1 $$ language sql;
create event trigger regress_event_trigger on elephant_bootstrap   execute procedure test_event_trigger();
create event trigger regress_event_trigger on ddl_command_start   execute procedure test_event_trigger();
create event trigger regress_event_trigger_end on ddl_command_end   execute function test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when food in ('sandwich')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('sandwich')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('create table', 'create skunkcabbage')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('DROP EVENT TRIGGER')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('CREATE ROLE')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('CREATE DATABASE')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('CREATE TABLESPACE')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('create table') and tag in ('CREATE FUNCTION')   execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start   execute procedure test_event_trigger('argument not allowed');
create event trigger regress_event_trigger2 on ddl_command_start   when tag in ('create table', 'CREATE FUNCTION')   execute procedure test_event_trigger();
comment on event trigger regress_event_trigger is 'test comment';
create role regress_evt_user;
set role regress_evt_user;
create event trigger regress_event_trigger_noperms on ddl_command_start   execute procedure test_event_trigger();
reset role;
alter event trigger regress_event_trigger disable;
alter event trigger regress_event_trigger enable;
set session_replication_role = replica;
alter event trigger regress_event_trigger enable replica;
alter event trigger regress_event_trigger enable always;
reset session_replication_role;
create function f1() returns intlanguage plpgsqlas $$begin  create table event_trigger_fire6 (a int);
  return 0;
end $$;
create procedure p1()language plpgsqlas $$begin  create table event_trigger_fire7 (a int);
end $$;
call p1();
alter event trigger regress_event_trigger disable;
drop table event_trigger_fire2, event_trigger_fire3, event_trigger_fire4, event_trigger_fire5, event_trigger_fire6, event_trigger_fire7;
drop routine f1(), p1();
grant all on table event_trigger_fire1 to public;
comment on table event_trigger_fire1 is 'here is a comment';
revoke all on table event_trigger_fire1 from public;
create foreign data wrapper useless;
create server useless_server foreign data wrapper useless;
create user mapping for regress_evt_user server useless_server;
alter default privileges for role regress_evt_user revoke delete on tables from regress_evt_user;
alter event trigger regress_event_trigger owner to regress_evt_user;
alter role regress_evt_user superuser;
alter event trigger regress_event_trigger owner to regress_evt_user;
alter event trigger regress_event_trigger rename to regress_event_trigger2;
alter event trigger regress_event_trigger rename to regress_event_trigger3;
drop event trigger regress_event_trigger;
drop role regress_evt_user;
drop event trigger if exists regress_event_trigger2;
drop event trigger if exists regress_event_trigger2;
drop event trigger regress_event_trigger3;
drop event trigger regress_event_trigger_end;
CREATE SCHEMA schema_one authorization regress_evt_user;
CREATE SCHEMA schema_two authorization regress_evt_user;
CREATE SCHEMA audit_tbls authorization regress_evt_user;
CREATE TEMP TABLE a_temp_tbl ();
SET SESSION AUTHORIZATION regress_evt_user;
CREATE TABLE schema_one.table_one(a int);
CREATE TABLE schema_one."table two"(a int);
CREATE TABLE schema_one.table_three(a int);
CREATE TABLE audit_tbls.schema_one_table_two(the_value text);
CREATE TABLE schema_two.table_two(a int);
CREATE TABLE schema_two.table_three(a int, b text);
CREATE TABLE audit_tbls.schema_two_table_three(the_value text);
CREATE OR REPLACE FUNCTION schema_two.add(int, int) RETURNS int LANGUAGE plpgsql  CALLED ON NULL INPUT  AS $$ BEGIN RETURN coalesce($1,0) + coalesce($2,0); END; $$;
CREATE AGGREGATE schema_two.newton  (BASETYPE = int, SFUNC = schema_two.add, STYPE = int);
RESET SESSION AUTHORIZATION;
CREATE OR REPLACE FUNCTION undroppable() RETURNS event_triggerLANGUAGE plpgsql AS $$DECLARE	obj record;
BEGIN	PERFORM 1 FROM pg_tables WHERE tablename = 'undroppable_objs';
	IF NOT FOUND THEN		RAISE NOTICE 'table undroppable_objs not found, skipping';
		RETURN;
	END IF;
	FOR obj IN		SELECT * FROM pg_event_trigger_dropped_objects() JOIN			undroppable_objs USING (object_type, object_identity)	LOOP		RAISE EXCEPTION 'object % of type % cannot be dropped',			obj.object_identity, obj.object_type;
	END LOOP;
END;
$$;
CREATE EVENT TRIGGER undroppable ON sql_drop	EXECUTE PROCEDURE undroppable();
CREATE OR REPLACE FUNCTION test_evtrig_dropped_objects() RETURNS event_triggerLANGUAGE plpgsql AS $$DECLARE    obj record;
BEGIN    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()    LOOP        IF obj.object_type = 'table' THEN                EXECUTE format('DROP TABLE IF EXISTS audit_tbls.%I',					format('%s_%s', obj.schema_name, obj.object_name));
        END IF;
	INSERT INTO dropped_objects		(type, schema, object) VALUES		(obj.object_type, obj.schema_name, obj.object_identity);
    END LOOP;
END$$;
CREATE EVENT TRIGGER regress_event_trigger_drop_objects ON sql_drop	WHEN TAG IN ('drop table', 'drop function', 'drop view',		'drop owned', 'drop schema', 'alter table')	EXECUTE PROCEDURE test_evtrig_dropped_objects();
ALTER TABLE schema_one.table_one DROP COLUMN a;
DROP SCHEMA schema_one, schema_two CASCADE;
DELETE FROM undroppable_objs WHERE object_identity = 'audit_tbls.schema_two_table_three';
DROP SCHEMA schema_one, schema_two CASCADE;
DELETE FROM undroppable_objs WHERE object_identity = 'schema_one.table_three';
DROP SCHEMA schema_one, schema_two CASCADE;
SELECT * FROM dropped_objects WHERE schema IS NULL OR schema <> 'pg_toast';
DROP OWNED BY regress_evt_user;
DROP ROLE regress_evt_user;
DROP EVENT TRIGGER regress_event_trigger_drop_objects;
DROP EVENT TRIGGER undroppable;
CREATE OR REPLACE FUNCTION event_trigger_report_dropped() RETURNS event_trigger LANGUAGE plpgsqlAS $$DECLARE r record;
BEGIN    FOR r IN SELECT * from pg_event_trigger_dropped_objects()    LOOP    IF NOT r.normal AND NOT r.original THEN        CONTINUE;
    END IF;
    RAISE NOTICE 'NORMAL: orig=% normal=% istemp=% type=% identity=% name=% args=%',        r.original, r.normal, r.is_temporary, r.object_type,        r.object_identity, r.address_names, r.address_args;
    END LOOP;
END; $$;
CREATE EVENT TRIGGER regress_event_trigger_report_dropped ON sql_drop    EXECUTE PROCEDURE event_trigger_report_dropped();
CREATE SCHEMA evttrig	CREATE TABLE one (col_a SERIAL PRIMARY KEY, col_b text DEFAULT 'forty two')	CREATE INDEX one_idx ON one (col_b)	CREATE TABLE two (col_c INTEGER CHECK (col_c > 0) REFERENCES one DEFAULT 42);
CREATE TABLE evttrig.parted (    id int PRIMARY KEY)    PARTITION BY RANGE (id);
CREATE TABLE evttrig.part_1_10 PARTITION OF evttrig.parted (id)  FOR VALUES FROM (1) TO (10);
CREATE TABLE evttrig.part_10_20 PARTITION OF evttrig.parted (id)  FOR VALUES FROM (10) TO (20) PARTITION BY RANGE (id);
CREATE TABLE evttrig.part_10_15 PARTITION OF evttrig.part_10_20 (id)  FOR VALUES FROM (10) TO (15);
CREATE TABLE evttrig.part_15_20 PARTITION OF evttrig.part_10_20 (id)  FOR VALUES FROM (15) TO (20);
ALTER TABLE evttrig.two DROP COLUMN col_c;
ALTER TABLE evttrig.one ALTER COLUMN col_b DROP DEFAULT;
ALTER TABLE evttrig.one DROP CONSTRAINT one_pkey;
DROP INDEX evttrig.one_idx;
DROP SCHEMA evttrig CASCADE;
DROP EVENT TRIGGER regress_event_trigger_report_dropped;
CREATE OR REPLACE FUNCTION test_evtrig_no_rewrite() RETURNS event_triggerLANGUAGE plpgsql AS $$BEGIN  RAISE EXCEPTION 'rewrites not allowed';
END;
$$;
create event trigger no_rewrite_allowed on table_rewrite  execute procedure test_evtrig_no_rewrite();
create table rewriteme (id serial primary key, foo float, bar timestamptz);
insert into rewriteme     select x * 1.001 from generate_series(1, 500) as t(x);
alter table rewriteme alter column foo type numeric;
alter table rewriteme add column baz int default 0;
CREATE OR REPLACE FUNCTION test_evtrig_no_rewrite() RETURNS event_triggerLANGUAGE plpgsql AS $$BEGIN  RAISE NOTICE 'Table ''%'' is being rewritten (reason = %)',               pg_event_trigger_table_rewrite_oid()::regclass,               pg_event_trigger_table_rewrite_reason();
END;
$$;
alter table rewriteme add column onemore int default 0, add column another int default -1, alter column foo type numeric(10,4);
alter table rewriteme alter column foo type numeric(12,4);
begin;
set timezone to 'UTC';
alter table rewriteme alter column bar type timestamp;
set timezone to '0';
alter table rewriteme alter column bar type timestamptz;
set timezone to 'Europe/London';
alter table rewriteme alter column bar type timestamp; -- does rewriterollback;
CREATE OR REPLACE FUNCTION test_evtrig_no_rewrite() RETURNS event_triggerLANGUAGE plpgsql AS $$BEGIN  RAISE NOTICE 'Table is being rewritten (reason = %)',               pg_event_trigger_table_rewrite_reason();
END;
$$;
create type rewritetype as (a int);
create table rewritemetoo1 of rewritetype;
create table rewritemetoo2 of rewritetype;
alter type rewritetype alter attribute a type text cascade;
create table rewritemetoo3 (a rewritetype);
alter type rewritetype alter attribute a type varchar cascade;
drop event trigger no_rewrite_allowed;
drop function test_evtrig_no_rewrite();
RESET SESSION AUTHORIZATION;
CREATE OR REPLACE FUNCTION start_command()RETURNS event_trigger AS $$BEGINRAISE NOTICE '% - ddl_command_start', tg_tag;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION end_command()RETURNS event_trigger AS $$BEGINRAISE NOTICE '% - ddl_command_end', tg_tag;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION drop_sql_command()RETURNS event_trigger AS $$BEGINRAISE NOTICE '% - sql_drop', tg_tag;
END;
$$ LANGUAGE plpgsql;
CREATE EVENT TRIGGER start_rls_command ON ddl_command_start    WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE start_command();
CREATE EVENT TRIGGER end_rls_command ON ddl_command_end    WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE end_command();
CREATE EVENT TRIGGER sql_drop_command ON sql_drop    WHEN TAG IN ('DROP POLICY') EXECUTE PROCEDURE drop_sql_command();
CREATE POLICY p1 ON event_trigger_test USING (FALSE);
ALTER POLICY p1 ON event_trigger_test USING (TRUE);
ALTER POLICY p1 ON event_trigger_test RENAME TO p2;
DROP POLICY p2 ON event_trigger_test;
DROP EVENT TRIGGER start_rls_command;
DROP EVENT TRIGGER end_rls_command;
DROP EVENT TRIGGER sql_drop_command;
SELECT	ctid, aggfnoidFROM	pg_catalog.pg_aggregate fkWHERE	aggfnoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggfnoid);
SELECT	ctid, aggtransfnFROM	pg_catalog.pg_aggregate fkWHERE	aggtransfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggtransfn);
SELECT	ctid, aggfinalfnFROM	pg_catalog.pg_aggregate fkWHERE	aggfinalfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggfinalfn);
SELECT	ctid, aggcombinefnFROM	pg_catalog.pg_aggregate fkWHERE	aggcombinefn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggcombinefn);
SELECT	ctid, aggserialfnFROM	pg_catalog.pg_aggregate fkWHERE	aggserialfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggserialfn);
SELECT	ctid, aggdeserialfnFROM	pg_catalog.pg_aggregate fkWHERE	aggdeserialfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggdeserialfn);
SELECT	ctid, aggmtransfnFROM	pg_catalog.pg_aggregate fkWHERE	aggmtransfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggmtransfn);
SELECT	ctid, aggminvtransfnFROM	pg_catalog.pg_aggregate fkWHERE	aggminvtransfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggminvtransfn);
SELECT	ctid, aggmfinalfnFROM	pg_catalog.pg_aggregate fkWHERE	aggmfinalfn != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggmfinalfn);
SELECT	ctid, aggsortopFROM	pg_catalog.pg_aggregate fkWHERE	aggsortop != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.aggsortop);
SELECT	ctid, aggtranstypeFROM	pg_catalog.pg_aggregate fkWHERE	aggtranstype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.aggtranstype);
SELECT	ctid, aggmtranstypeFROM	pg_catalog.pg_aggregate fkWHERE	aggmtranstype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.aggmtranstype);
SELECT	ctid, amhandlerFROM	pg_catalog.pg_am fkWHERE	amhandler != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.amhandler);
SELECT	ctid, amopfamilyFROM	pg_catalog.pg_amop fkWHERE	amopfamily != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.amopfamily);
SELECT	ctid, amoplefttypeFROM	pg_catalog.pg_amop fkWHERE	amoplefttype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amoplefttype);
SELECT	ctid, amoprighttypeFROM	pg_catalog.pg_amop fkWHERE	amoprighttype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amoprighttype);
SELECT	ctid, amopoprFROM	pg_catalog.pg_amop fkWHERE	amopopr != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.amopopr);
SELECT	ctid, amopmethodFROM	pg_catalog.pg_amop fkWHERE	amopmethod != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.amopmethod);
SELECT	ctid, amopsortfamilyFROM	pg_catalog.pg_amop fkWHERE	amopsortfamily != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.amopsortfamily);
SELECT	ctid, amprocfamilyFROM	pg_catalog.pg_amproc fkWHERE	amprocfamily != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.amprocfamily);
SELECT	ctid, amproclefttypeFROM	pg_catalog.pg_amproc fkWHERE	amproclefttype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amproclefttype);
SELECT	ctid, amprocrighttypeFROM	pg_catalog.pg_amproc fkWHERE	amprocrighttype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amprocrighttype);
SELECT	ctid, amprocFROM	pg_catalog.pg_amproc fkWHERE	amproc != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.amproc);
SELECT	ctid, adrelidFROM	pg_catalog.pg_attrdef fkWHERE	adrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.adrelid);
SELECT	ctid, attrelidFROM	pg_catalog.pg_attribute fkWHERE	attrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.attrelid);
SELECT	ctid, atttypidFROM	pg_catalog.pg_attribute fkWHERE	atttypid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.atttypid);
SELECT	ctid, attcollationFROM	pg_catalog.pg_attribute fkWHERE	attcollation != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_collation pk WHERE pk.oid = fk.attcollation);
SELECT	ctid, roleidFROM	pg_catalog.pg_auth_members fkWHERE	roleid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.roleid);
SELECT	ctid, memberFROM	pg_catalog.pg_auth_members fkWHERE	member != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.member);
SELECT	ctid, grantorFROM	pg_catalog.pg_auth_members fkWHERE	grantor != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.grantor);
SELECT	ctid, castsourceFROM	pg_catalog.pg_cast fkWHERE	castsource != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.castsource);
SELECT	ctid, casttargetFROM	pg_catalog.pg_cast fkWHERE	casttarget != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.casttarget);
SELECT	ctid, castfuncFROM	pg_catalog.pg_cast fkWHERE	castfunc != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.castfunc);
SELECT	ctid, relnamespaceFROM	pg_catalog.pg_class fkWHERE	relnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.relnamespace);
SELECT	ctid, reltypeFROM	pg_catalog.pg_class fkWHERE	reltype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.reltype);
SELECT	ctid, reloftypeFROM	pg_catalog.pg_class fkWHERE	reloftype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.reloftype);
SELECT	ctid, relownerFROM	pg_catalog.pg_class fkWHERE	relowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.relowner);
SELECT	ctid, relamFROM	pg_catalog.pg_class fkWHERE	relam != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.relam);
SELECT	ctid, reltablespaceFROM	pg_catalog.pg_class fkWHERE	reltablespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_tablespace pk WHERE pk.oid = fk.reltablespace);
SELECT	ctid, reltoastrelidFROM	pg_catalog.pg_class fkWHERE	reltoastrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.reltoastrelid);
SELECT	ctid, collnamespaceFROM	pg_catalog.pg_collation fkWHERE	collnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.collnamespace);
SELECT	ctid, collownerFROM	pg_catalog.pg_collation fkWHERE	collowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.collowner);
SELECT	ctid, connamespaceFROM	pg_catalog.pg_constraint fkWHERE	connamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.connamespace);
SELECT	ctid, conrelidFROM	pg_catalog.pg_constraint fkWHERE	conrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.conrelid);
SELECT	ctid, contypidFROM	pg_catalog.pg_constraint fkWHERE	contypid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.contypid);
SELECT	ctid, conindidFROM	pg_catalog.pg_constraint fkWHERE	conindid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.conindid);
SELECT	ctid, conparentidFROM	pg_catalog.pg_constraint fkWHERE	conparentid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_constraint pk WHERE pk.oid = fk.conparentid);
SELECT	ctid, confrelidFROM	pg_catalog.pg_constraint fkWHERE	confrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.confrelid);
SELECT	ctid, connamespaceFROM	pg_catalog.pg_conversion fkWHERE	connamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.connamespace);
SELECT	ctid, conownerFROM	pg_catalog.pg_conversion fkWHERE	conowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.conowner);
SELECT	ctid, conprocFROM	pg_catalog.pg_conversion fkWHERE	conproc != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.conproc);
SELECT	ctid, datdbaFROM	pg_catalog.pg_database fkWHERE	datdba != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.datdba);
SELECT	ctid, dattablespaceFROM	pg_catalog.pg_database fkWHERE	dattablespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_tablespace pk WHERE pk.oid = fk.dattablespace);
SELECT	ctid, setdatabaseFROM	pg_catalog.pg_db_role_setting fkWHERE	setdatabase != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_database pk WHERE pk.oid = fk.setdatabase);
SELECT	ctid, classidFROM	pg_catalog.pg_depend fkWHERE	classid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classid);
SELECT	ctid, refclassidFROM	pg_catalog.pg_depend fkWHERE	refclassid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.refclassid);
SELECT	ctid, classoidFROM	pg_catalog.pg_description fkWHERE	classoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classoid);
SELECT	ctid, enumtypidFROM	pg_catalog.pg_enum fkWHERE	enumtypid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.enumtypid);
SELECT	ctid, extownerFROM	pg_catalog.pg_extension fkWHERE	extowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.extowner);
SELECT	ctid, extnamespaceFROM	pg_catalog.pg_extension fkWHERE	extnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.extnamespace);
SELECT	ctid, fdwownerFROM	pg_catalog.pg_foreign_data_wrapper fkWHERE	fdwowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.fdwowner);
SELECT	ctid, srvownerFROM	pg_catalog.pg_foreign_server fkWHERE	srvowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.srvowner);
SELECT	ctid, srvfdwFROM	pg_catalog.pg_foreign_server fkWHERE	srvfdw != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_foreign_data_wrapper pk WHERE pk.oid = fk.srvfdw);
SELECT	ctid, indexrelidFROM	pg_catalog.pg_index fkWHERE	indexrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.indexrelid);
SELECT	ctid, indrelidFROM	pg_catalog.pg_index fkWHERE	indrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.indrelid);
SELECT	ctid, inhrelidFROM	pg_catalog.pg_inherits fkWHERE	inhrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.inhrelid);
SELECT	ctid, inhparentFROM	pg_catalog.pg_inherits fkWHERE	inhparent != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.inhparent);
SELECT	ctid, classoidFROM	pg_catalog.pg_init_privs fkWHERE	classoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classoid);
SELECT	ctid, lanownerFROM	pg_catalog.pg_language fkWHERE	lanowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.lanowner);
SELECT	ctid, lanplcallfoidFROM	pg_catalog.pg_language fkWHERE	lanplcallfoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.lanplcallfoid);
SELECT	ctid, laninlineFROM	pg_catalog.pg_language fkWHERE	laninline != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.laninline);
SELECT	ctid, lanvalidatorFROM	pg_catalog.pg_language fkWHERE	lanvalidator != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.lanvalidator);
SELECT	ctid, loidFROM	pg_catalog.pg_largeobject fkWHERE	loid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_largeobject_metadata pk WHERE pk.oid = fk.loid);
SELECT	ctid, lomownerFROM	pg_catalog.pg_largeobject_metadata fkWHERE	lomowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.lomowner);
SELECT	ctid, nspownerFROM	pg_catalog.pg_namespace fkWHERE	nspowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.nspowner);
SELECT	ctid, opcmethodFROM	pg_catalog.pg_opclass fkWHERE	opcmethod != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.opcmethod);
SELECT	ctid, opcnamespaceFROM	pg_catalog.pg_opclass fkWHERE	opcnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.opcnamespace);
SELECT	ctid, opcownerFROM	pg_catalog.pg_opclass fkWHERE	opcowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.opcowner);
SELECT	ctid, opcfamilyFROM	pg_catalog.pg_opclass fkWHERE	opcfamily != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.opcfamily);
SELECT	ctid, opcintypeFROM	pg_catalog.pg_opclass fkWHERE	opcintype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.opcintype);
SELECT	ctid, opckeytypeFROM	pg_catalog.pg_opclass fkWHERE	opckeytype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.opckeytype);
SELECT	ctid, oprnamespaceFROM	pg_catalog.pg_operator fkWHERE	oprnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.oprnamespace);
SELECT	ctid, oprownerFROM	pg_catalog.pg_operator fkWHERE	oprowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.oprowner);
SELECT	ctid, oprleftFROM	pg_catalog.pg_operator fkWHERE	oprleft != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.oprleft);
SELECT	ctid, oprrightFROM	pg_catalog.pg_operator fkWHERE	oprright != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.oprright);
SELECT	ctid, oprresultFROM	pg_catalog.pg_operator fkWHERE	oprresult != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.oprresult);
SELECT	ctid, oprcomFROM	pg_catalog.pg_operator fkWHERE	oprcom != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprcom);
SELECT	ctid, oprnegateFROM	pg_catalog.pg_operator fkWHERE	oprnegate != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprnegate);
SELECT	ctid, oprcodeFROM	pg_catalog.pg_operator fkWHERE	oprcode != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.oprcode);
SELECT	ctid, oprrestFROM	pg_catalog.pg_operator fkWHERE	oprrest != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.oprrest);
SELECT	ctid, oprjoinFROM	pg_catalog.pg_operator fkWHERE	oprjoin != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.oprjoin);
SELECT	ctid, opfmethodFROM	pg_catalog.pg_opfamily fkWHERE	opfmethod != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.opfmethod);
SELECT	ctid, opfnamespaceFROM	pg_catalog.pg_opfamily fkWHERE	opfnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.opfnamespace);
SELECT	ctid, opfownerFROM	pg_catalog.pg_opfamily fkWHERE	opfowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.opfowner);
SELECT	ctid, partrelidFROM	pg_catalog.pg_partitioned_table fkWHERE	partrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.partrelid);
SELECT	ctid, partdefidFROM	pg_catalog.pg_partitioned_table fkWHERE	partdefid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.partdefid);
SELECT	ctid, polrelidFROM	pg_catalog.pg_policy fkWHERE	polrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.polrelid);
SELECT	ctid, pronamespaceFROM	pg_catalog.pg_proc fkWHERE	pronamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.pronamespace);
SELECT	ctid, proownerFROM	pg_catalog.pg_proc fkWHERE	proowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.proowner);
SELECT	ctid, prolangFROM	pg_catalog.pg_proc fkWHERE	prolang != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_language pk WHERE pk.oid = fk.prolang);
SELECT	ctid, provariadicFROM	pg_catalog.pg_proc fkWHERE	provariadic != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.provariadic);
SELECT	ctid, prosupportFROM	pg_catalog.pg_proc fkWHERE	prosupport != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prosupport);
SELECT	ctid, prorettypeFROM	pg_catalog.pg_proc fkWHERE	prorettype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.prorettype);
SELECT	ctid, rngtypidFROM	pg_catalog.pg_range fkWHERE	rngtypid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.rngtypid);
SELECT	ctid, rngsubtypeFROM	pg_catalog.pg_range fkWHERE	rngsubtype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.rngsubtype);
SELECT	ctid, rngcollationFROM	pg_catalog.pg_range fkWHERE	rngcollation != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_collation pk WHERE pk.oid = fk.rngcollation);
SELECT	ctid, rngsubopcFROM	pg_catalog.pg_range fkWHERE	rngsubopc != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_opclass pk WHERE pk.oid = fk.rngsubopc);
SELECT	ctid, rngcanonicalFROM	pg_catalog.pg_range fkWHERE	rngcanonical != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.rngcanonical);
SELECT	ctid, rngsubdiffFROM	pg_catalog.pg_range fkWHERE	rngsubdiff != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.rngsubdiff);
SELECT	ctid, ev_classFROM	pg_catalog.pg_rewrite fkWHERE	ev_class != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.ev_class);
SELECT	ctid, seqrelidFROM	pg_catalog.pg_sequence fkWHERE	seqrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.seqrelid);
SELECT	ctid, seqtypidFROM	pg_catalog.pg_sequence fkWHERE	seqtypid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.seqtypid);
SELECT	ctid, refclassidFROM	pg_catalog.pg_shdepend fkWHERE	refclassid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.refclassid);
SELECT	ctid, classoidFROM	pg_catalog.pg_shdescription fkWHERE	classoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classoid);
SELECT	ctid, starelidFROM	pg_catalog.pg_statistic fkWHERE	starelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.starelid);
SELECT	ctid, staop1FROM	pg_catalog.pg_statistic fkWHERE	staop1 != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop1);
SELECT	ctid, staop2FROM	pg_catalog.pg_statistic fkWHERE	staop2 != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop2);
SELECT	ctid, staop3FROM	pg_catalog.pg_statistic fkWHERE	staop3 != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop3);
SELECT	ctid, staop4FROM	pg_catalog.pg_statistic fkWHERE	staop4 != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop4);
SELECT	ctid, staop5FROM	pg_catalog.pg_statistic fkWHERE	staop5 != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop5);
SELECT	ctid, stxrelidFROM	pg_catalog.pg_statistic_ext fkWHERE	stxrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.stxrelid);
SELECT	ctid, stxnamespaceFROM	pg_catalog.pg_statistic_ext fkWHERE	stxnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.stxnamespace);
SELECT	ctid, stxownerFROM	pg_catalog.pg_statistic_ext fkWHERE	stxowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.stxowner);
SELECT	ctid, stxoidFROM	pg_catalog.pg_statistic_ext_data fkWHERE	stxoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_statistic_ext pk WHERE pk.oid = fk.stxoid);
SELECT	ctid, spcownerFROM	pg_catalog.pg_tablespace fkWHERE	spcowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.spcowner);
SELECT	ctid, trftypeFROM	pg_catalog.pg_transform fkWHERE	trftype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.trftype);
SELECT	ctid, trflangFROM	pg_catalog.pg_transform fkWHERE	trflang != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_language pk WHERE pk.oid = fk.trflang);
SELECT	ctid, trffromsqlFROM	pg_catalog.pg_transform fkWHERE	trffromsql != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.trffromsql);
SELECT	ctid, trftosqlFROM	pg_catalog.pg_transform fkWHERE	trftosql != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.trftosql);
SELECT	ctid, tgrelidFROM	pg_catalog.pg_trigger fkWHERE	tgrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.tgrelid);
SELECT	ctid, tgfoidFROM	pg_catalog.pg_trigger fkWHERE	tgfoid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.tgfoid);
SELECT	ctid, tgconstrrelidFROM	pg_catalog.pg_trigger fkWHERE	tgconstrrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.tgconstrrelid);
SELECT	ctid, tgconstrindidFROM	pg_catalog.pg_trigger fkWHERE	tgconstrindid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.tgconstrindid);
SELECT	ctid, tgconstraintFROM	pg_catalog.pg_trigger fkWHERE	tgconstraint != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_constraint pk WHERE pk.oid = fk.tgconstraint);
SELECT	ctid, cfgnamespaceFROM	pg_catalog.pg_ts_config fkWHERE	cfgnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.cfgnamespace);
SELECT	ctid, cfgownerFROM	pg_catalog.pg_ts_config fkWHERE	cfgowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.cfgowner);
SELECT	ctid, cfgparserFROM	pg_catalog.pg_ts_config fkWHERE	cfgparser != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_parser pk WHERE pk.oid = fk.cfgparser);
SELECT	ctid, mapcfgFROM	pg_catalog.pg_ts_config_map fkWHERE	mapcfg != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_config pk WHERE pk.oid = fk.mapcfg);
SELECT	ctid, mapdictFROM	pg_catalog.pg_ts_config_map fkWHERE	mapdict != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_dict pk WHERE pk.oid = fk.mapdict);
SELECT	ctid, dictnamespaceFROM	pg_catalog.pg_ts_dict fkWHERE	dictnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.dictnamespace);
SELECT	ctid, dictownerFROM	pg_catalog.pg_ts_dict fkWHERE	dictowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.dictowner);
SELECT	ctid, dicttemplateFROM	pg_catalog.pg_ts_dict fkWHERE	dicttemplate != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_template pk WHERE pk.oid = fk.dicttemplate);
SELECT	ctid, prsnamespaceFROM	pg_catalog.pg_ts_parser fkWHERE	prsnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.prsnamespace);
SELECT	ctid, prsstartFROM	pg_catalog.pg_ts_parser fkWHERE	prsstart != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prsstart);
SELECT	ctid, prstokenFROM	pg_catalog.pg_ts_parser fkWHERE	prstoken != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prstoken);
SELECT	ctid, prsendFROM	pg_catalog.pg_ts_parser fkWHERE	prsend != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prsend);
SELECT	ctid, prsheadlineFROM	pg_catalog.pg_ts_parser fkWHERE	prsheadline != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prsheadline);
SELECT	ctid, prslextypeFROM	pg_catalog.pg_ts_parser fkWHERE	prslextype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prslextype);
SELECT	ctid, tmplnamespaceFROM	pg_catalog.pg_ts_template fkWHERE	tmplnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.tmplnamespace);
SELECT	ctid, tmplinitFROM	pg_catalog.pg_ts_template fkWHERE	tmplinit != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.tmplinit);
SELECT	ctid, tmpllexizeFROM	pg_catalog.pg_ts_template fkWHERE	tmpllexize != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.tmpllexize);
SELECT	ctid, typnamespaceFROM	pg_catalog.pg_type fkWHERE	typnamespace != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.typnamespace);
SELECT	ctid, typownerFROM	pg_catalog.pg_type fkWHERE	typowner != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.typowner);
SELECT	ctid, typrelidFROM	pg_catalog.pg_type fkWHERE	typrelid != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.typrelid);
SELECT	ctid, typelemFROM	pg_catalog.pg_type fkWHERE	typelem != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typelem);
SELECT	ctid, typarrayFROM	pg_catalog.pg_type fkWHERE	typarray != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typarray);
SELECT	ctid, typinputFROM	pg_catalog.pg_type fkWHERE	typinput != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typinput);
SELECT	ctid, typoutputFROM	pg_catalog.pg_type fkWHERE	typoutput != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typoutput);
SELECT	ctid, typreceiveFROM	pg_catalog.pg_type fkWHERE	typreceive != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typreceive);
SELECT	ctid, typsendFROM	pg_catalog.pg_type fkWHERE	typsend != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typsend);
SELECT	ctid, typmodinFROM	pg_catalog.pg_type fkWHERE	typmodin != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typmodin);
SELECT	ctid, typmodoutFROM	pg_catalog.pg_type fkWHERE	typmodout != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typmodout);
SELECT	ctid, typanalyzeFROM	pg_catalog.pg_type fkWHERE	typanalyze != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typanalyze);
SELECT	ctid, typbasetypeFROM	pg_catalog.pg_type fkWHERE	typbasetype != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typbasetype);
SELECT	ctid, typcollationFROM	pg_catalog.pg_type fkWHERE	typcollation != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_collation pk WHERE pk.oid = fk.typcollation);
SELECT	ctid, conpfeqopFROM	(SELECT ctid, unnest(conpfeqop) AS conpfeqop FROM pg_catalog.pg_constraint) fkWHERE	conpfeqop != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conpfeqop);
SELECT	ctid, conppeqopFROM	(SELECT ctid, unnest(conppeqop) AS conppeqop FROM pg_catalog.pg_constraint) fkWHERE	conppeqop != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conppeqop);
SELECT	ctid, conffeqopFROM	(SELECT ctid, unnest(conffeqop) AS conffeqop FROM pg_catalog.pg_constraint) fkWHERE	conffeqop != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conffeqop);
SELECT	ctid, conexclopFROM	(SELECT ctid, unnest(conexclop) AS conexclop FROM pg_catalog.pg_constraint) fkWHERE	conexclop != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conexclop);
SELECT	ctid, proallargtypesFROM	(SELECT ctid, unnest(proallargtypes) AS proallargtypes FROM pg_catalog.pg_proc) fkWHERE	proallargtypes != 0 AND	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.proallargtypes);
SET extra_float_digits = -1;
CREATE TABLE CIRCLE_TBL (f1 circle);
INSERT INTO CIRCLE_TBL VALUES ('<(3,5),0>');	-- Zero radiusINSERT INTO CIRCLE_TBL VALUES ('<(3,5),NaN>');	-- NaN radiusINSERT INTO CIRCLE_TBL VALUES ('<(-100,0),-100>');
SELECT '' as five, c1.f1 AS one, c2.f1 AS two, (c1.f1 <-> c2.f1) AS distance  FROM CIRCLE_TBL c1, CIRCLE_TBL c2  WHERE (c1.f1 < c2.f1) AND ((c1.f1 <-> c2.f1) > 0)  ORDER BY distance, area(c1.f1), area(c2.f1);
/* * 1.1. test CREATE INDEX with buffered build */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c2,c3);
SELECT pg_get_indexdef(i.indexrelid)FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oidWHERE i.indrelid = 'tbl_gist'::regclass ORDER BY c.relname;
@SET enable_bitmapscan TO off;
EXPLAIN  (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
SET enable_bitmapscan TO default;
/* * 1.2. test CREATE INDEX with inserts */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c2,c3);
SELECT pg_get_indexdef(i.indexrelid)FROM pg_index i JOIN pg_class c ON i.indexrelid = c.oidWHERE i.indrelid = 'tbl_gist'::regclass ORDER BY c.relname;
@SET enable_bitmapscan TO off;
EXPLAIN  (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
SET enable_bitmapscan TO default;
/* * 2. CREATE INDEX CONCURRENTLY */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX CONCURRENTLY tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c2,c3);
/* * 3. REINDEX */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c3);
ALTER TABLE tbl_gist DROP COLUMN c1;
/* * 4. Update, delete values in indexed table. */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c3);
DELETE FROM tbl_gist WHERE c1 = 5 OR c3 = 12;
/* * 5. Alter column type. */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box);
CREATE INDEX tbl_gist_idx ON tbl_gist using gist (c4) INCLUDE (c1,c3);
ALTER TABLE tbl_gist ALTER c1 TYPE bigint;
ALTER TABLE tbl_gist ALTER c3 TYPE bigint;
/* * 6. EXCLUDE constraint. */CREATE TABLE tbl_gist (c1 int, c2 int, c3 int, c4 box, EXCLUDE USING gist (c4 WITH &&) INCLUDE (c1, c2, c3));
EXPLAIN  (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
SELECT true AS true;
SELECT false AS false;
SELECT bool 't' AS true;
SELECT bool '   f           ' AS false;
SELECT bool 'true' AS true;
SELECT bool 'test' AS error;
SELECT bool 'false' AS false;
SELECT bool 'foo' AS error;
SELECT bool 'y' AS true;
SELECT bool 'yes' AS true;
SELECT bool 'yeah' AS error;
SELECT bool 'n' AS false;
SELECT bool 'no' AS false;
SELECT bool 'nay' AS error;
SELECT bool 'on' AS true;
SELECT bool 'off' AS false;
SELECT bool 'of' AS false;
SELECT bool 'o' AS error;
SELECT bool 'on_' AS error;
SELECT bool 'off_' AS error;
SELECT bool '1' AS true;
SELECT bool '11' AS error;
SELECT bool '0' AS false;
SELECT bool '000' AS error;
SELECT bool '' AS error;
SELECT bool 't' or bool 'f' AS true;
SELECT bool 't' and bool 'f' AS false;
SELECT not bool 'f' AS true;
SELECT bool 't' = bool 'f' AS false;
SELECT bool 't' <> bool 'f' AS true;
SELECT bool 't' > bool 'f' AS true;
SELECT bool 't' >= bool 'f' AS true;
SELECT bool 'f' < bool 't' AS true;
SELECT bool 'f' <= bool 't' AS true;
::SELECT 'TrUe'::text::boolean AS true, 'fAlse'::text::boolean AS false;
::SELECT '    true   '::text::boolean AS true,       '     FALSE'::text::boolean AS false;
::SELECT true::boolean::text AS true, false::boolean::text AS false;
::SELECT '  tru e '::text::boolean AS invalid;    -- errorSELECT ''::text::boolean AS invalid;            -- errorCREATE TABLE BOOLTBL1 (f1 bool);
INSERT INTO BOOLTBL1 (f1) VALUES (bool 't');
INSERT INTO BOOLTBL1 (f1) VALUES (bool 'True');
INSERT INTO BOOLTBL1 (f1) VALUES (bool 'true');
SELECT '' AS t_3, BOOLTBL1.* FROM BOOLTBL1;
SELECT '' AS t_3, BOOLTBL1.*   FROM BOOLTBL1   WHERE f1 = bool 'true';
SELECT '' AS t_3, BOOLTBL1.*   FROM BOOLTBL1   WHERE f1 <> bool 'false';
SELECT '' AS zero, BOOLTBL1.*   FROM BOOLTBL1   WHERE booleq(bool 'false', f1);
INSERT INTO BOOLTBL1 (f1) VALUES (bool 'f');
SELECT '' AS f_1, BOOLTBL1.*   FROM BOOLTBL1   WHERE f1 = bool 'false';
CREATE TABLE BOOLTBL2 (f1 bool);
INSERT INTO BOOLTBL2 (f1) VALUES (bool 'f');
INSERT INTO BOOLTBL2 (f1) VALUES (bool 'false');
INSERT INTO BOOLTBL2 (f1) VALUES (bool 'False');
INSERT INTO BOOLTBL2 (f1) VALUES (bool 'FALSE');
INSERT INTO BOOLTBL2 (f1)   VALUES (bool 'XXX');
SELECT '' AS f_4, BOOLTBL2.* FROM BOOLTBL2;
SELECT '' AS tf_12, BOOLTBL1.*, BOOLTBL2.*   FROM BOOLTBL1, BOOLTBL2   WHERE BOOLTBL2.f1 <> BOOLTBL1.f1;
SELECT '' AS tf_12, BOOLTBL1.*, BOOLTBL2.*   FROM BOOLTBL1, BOOLTBL2   WHERE boolne(BOOLTBL2.f1,BOOLTBL1.f1);
SELECT '' AS ff_4, BOOLTBL1.*, BOOLTBL2.*   FROM BOOLTBL1, BOOLTBL2   WHERE BOOLTBL2.f1 = BOOLTBL1.f1 and BOOLTBL1.f1 = bool 'false';
SELECT '' AS tf_12_ff_4, BOOLTBL1.*, BOOLTBL2.*   FROM BOOLTBL1, BOOLTBL2   WHERE BOOLTBL2.f1 = BOOLTBL1.f1 or BOOLTBL1.f1 = bool 'true'   ORDER BY BOOLTBL1.f1, BOOLTBL2.f1;
SELECT '' AS "True", f1   FROM BOOLTBL1   WHERE f1 IS TRUE;
SELECT '' AS "Not False", f1   FROM BOOLTBL1   WHERE f1 IS NOT FALSE;
SELECT '' AS "False", f1   FROM BOOLTBL1   WHERE f1 IS FALSE;
SELECT '' AS "Not True", f1   FROM BOOLTBL1   WHERE f1 IS NOT TRUE;
SELECT '' AS "True", f1   FROM BOOLTBL2   WHERE f1 IS TRUE;
SELECT '' AS "Not False", f1   FROM BOOLTBL2   WHERE f1 IS NOT FALSE;
SELECT '' AS "False", f1   FROM BOOLTBL2   WHERE f1 IS FALSE;
SELECT '' AS "Not True", f1   FROM BOOLTBL2   WHERE f1 IS NOT TRUE;
CREATE TABLE BOOLTBL3 (d text, b bool, o int);
INSERT INTO BOOLTBL3 (d, b, o) VALUES ('null', null, 3);
SELECT    d,    b IS TRUE AS istrue,    b IS NOT TRUE AS isnottrue,    b IS FALSE AS isfalse,    b IS NOT FALSE AS isnotfalse,    b IS UNKNOWN AS isunknown,    b IS NOT UNKNOWN AS isnotunknownFROM booltbl3 ORDER BY o;
CREATE TABLE booltbl4(isfalse bool, istrue bool, isnul bool);
INSERT INTO booltbl4 VALUES (false, true, null);
\\pset null '(null)'SELECT istrue AND isnul AND istrue FROM booltbl4;
SELECT istrue AND istrue AND isnul FROM booltbl4;
SELECT isnul AND istrue AND istrue FROM booltbl4;
SELECT isfalse AND isnul AND istrue FROM booltbl4;
SELECT istrue AND isfalse AND isnul FROM booltbl4;
SELECT isnul AND istrue AND isfalse FROM booltbl4;
SELECT isfalse OR isnul OR isfalse FROM booltbl4;
SELECT isfalse OR isfalse OR isnul FROM booltbl4;
SELECT isnul OR isfalse OR isfalse FROM booltbl4;
SELECT isfalse OR isnul OR istrue FROM booltbl4;
SELECT istrue OR isfalse OR isnul FROM booltbl4;
SELECT isnul OR istrue OR isfalse FROM booltbl4;
CREATE TABLE BOX_TBL (f1 box);
SELECT '' AS four, b.*, area(b.f1) as barea   FROM BOX_TBL b;
SELECT '' AS three, b.f1   FROM BOX_TBL b   WHERE b.f1 && box '(2.5,2.5,1.0,1.0)';
SELECT '' AS two, b1.*   FROM BOX_TBL b1   WHERE b1.f1 &< box '(2.0,2.0,2.5,2.5)';
SELECT '' AS two, b1.*   FROM BOX_TBL b1   WHERE b1.f1 &> box '(2.0,2.0,2.5,2.5)';
SELECT '' AS two, b.f1   FROM BOX_TBL b   WHERE b.f1 << box '(3.0,3.0,5.0,5.0)';
SELECT '' AS four, b.f1   FROM BOX_TBL b   WHERE b.f1 <= box '(3.0,3.0,5.0,5.0)';
SELECT '' AS two, b.f1   FROM BOX_TBL b   WHERE b.f1 < box '(3.0,3.0,5.0,5.0)';
SELECT '' AS two, b.f1   FROM BOX_TBL b   WHERE b.f1 = box '(3.0,3.0,5.0,5.0)';
SELECT '' AS two, b.f1   FROM BOX_TBL b				-- zero area   WHERE b.f1 > box '(3.5,3.0,4.5,3.0)';
SELECT '' AS four, b.f1   FROM BOX_TBL b				-- zero area   WHERE b.f1 >= box '(3.5,3.0,4.5,3.0)';
SELECT '' AS two, b.f1   FROM BOX_TBL b   WHERE box '(3.0,3.0,5.0,5.0)' >> b.f1;
SELECT '' AS three, b.f1   FROM BOX_TBL b   WHERE b.f1 <@ box '(0,0,3,3)';
SELECT '' AS three, b.f1   FROM BOX_TBL b   WHERE box '(0,0,3,3)' @> b.f1;
SELECT '' AS one, b.f1   FROM BOX_TBL b   WHERE box '(1,1,3,3)' ~= b.f1;
@@SELECT '' AS four, @@(b1.f1) AS p   FROM BOX_TBL b1;
SELECT '' AS one, b1.*, b2.*   FROM BOX_TBL b1, BOX_TBL b2   WHERE b1.f1 @> b2.f1 and not b1.f1 ~= b2.f1;
CREATE TEMPORARY TABLE box_temp (f1 box);
CREATE INDEX box_spgist ON box_temp USING spgist (f1);
INSERT INTO box_temp	VALUES (NULL),		   ('(0,0)(0,100)'),		   ('(-3,4.3333333333)(40,1)'),		   ('(0,100)(0,infinity)'),		   ('(-infinity,0)(0,infinity)'),		   ('(-infinity,-infinity)(infinity,infinity)');
SET enable_seqscan = false;
SELECT * FROM box_temp WHERE f1 << '(10,20),(30,40)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 << '(10,20),(30,40)';
&EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &< '(10,4.333334),(5,100)';
&&SELECT * FROM box_temp WHERE f1 && '(15,20),(25,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 && '(15,20),(25,30)';
&EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &> '(40,30),(45,50)';
SELECT * FROM box_temp WHERE f1 >> '(30,40),(40,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 >> '(30,40),(40,30)';
SELECT * FROM box_temp WHERE f1 <<| '(10,4.33334),(5,100)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 <<| '(10,4.33334),(5,100)';
&|EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &<| '(10,4.3333334),(5,1)';
|&EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 |&> '(49.99,49.99),(49.99,49.99)';
|SELECT * FROM box_temp WHERE f1 |>> '(37,38),(39,40)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 |>> '(37,38),(39,40)';
@EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 @> '(10,11),(15,15)';
@EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 <@ '(10,15),(30,35)';
~EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 ~= '(20,20),(40,40)';
RESET enable_seqscan;
CREATE TABLE quad_box_tbl (id int, b box);
INSERT INTO quad_box_tblVALUES  (11001, NULL),  (11002, NULL),  (11003, '((-infinity,-infinity),(infinity,infinity))'),  (11004, '((-infinity,100),(-infinity,500))'),  (11005, '((-infinity,-infinity),(700,infinity))');
CREATE INDEX quad_box_tbl_idx ON quad_box_tbl USING spgist(b);
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
CREATE TABLE quad_box_tbl_ord_seq1 ASSELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, idFROM quad_box_tbl;
CREATE TABLE quad_box_tbl_ord_seq2 ASSELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, idFROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
SELECT count(*) FROM quad_box_tbl WHERE b <<  box '((100,200),(300,500))';
&SELECT count(*) FROM quad_box_tbl WHERE b &<  box '((100,200),(300,500))';
&&SELECT count(*) FROM quad_box_tbl WHERE b &&  box '((100,200),(300,500))';
&SELECT count(*) FROM quad_box_tbl WHERE b &>  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b >>  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b >>  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b <<| box '((100,200),(300,500))';
&|SELECT count(*) FROM quad_box_tbl WHERE b &<| box '((100,200),(300,500))';
|&SELECT count(*) FROM quad_box_tbl WHERE b |&> box '((100,200),(300,500))';
|SELECT count(*) FROM quad_box_tbl WHERE b |>> box '((100,200),(300,500))';
@SELECT count(*) FROM quad_box_tbl WHERE b @>  box '((201,301),(202,303))';
@SELECT count(*) FROM quad_box_tbl WHERE b <@  box '((100,200),(300,500))';
~SELECT count(*) FROM quad_box_tbl WHERE b ~=  box '((200,300),(205,305))';
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, idFROM quad_box_tbl;
CREATE TEMP TABLE quad_box_tbl_ord_idx1 ASSELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, idFROM quad_box_tbl;
SELECT *FROM quad_box_tbl_ord_seq1 seq FULL JOIN quad_box_tbl_ord_idx1 idx	ON seq.n = idx.n AND seq.id = idx.id AND		(seq.dist = idx.dist OR seq.dist IS NULL AND idx.dist IS NULL)WHERE seq.id IS NULL OR idx.id IS NULL;
EXPLAIN (COSTS OFF)SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, idFROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
CREATE TEMP TABLE quad_box_tbl_ord_idx2 ASSELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, idFROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
SELECT *FROM quad_box_tbl_ord_seq2 seq FULL JOIN quad_box_tbl_ord_idx2 idx	ON seq.n = idx.n AND seq.id = idx.id AND		(seq.dist = idx.dist OR seq.dist IS NULL AND idx.dist IS NULL)WHERE seq.id IS NULL OR idx.id IS NULL;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
set standard_conforming_strings = on;
~select 'bbbbb' ~ '^([bc])\1*$' as t;
~select 'ccc' ~ '^([bc])\1*$' as t;
~select 'xxx' ~ '^([bc])\1*$' as f;
~select 'bbc' ~ '^([bc])\1*$' as f;
~select 'b' ~ '^([bc])\1*$' as t;
~select 'abc abc abc' ~ '^(\w+)( \1)+$' as t;
~select 'abc abd abc' ~ '^(\w+)( \1)+$' as f;
~select 'abc abc abd' ~ '^(\w+)( \1)+$' as f;
~select 'abc abc abc' ~ '^(.+)( \1)+$' as t;
~select 'abc abd abc' ~ '^(.+)( \1)+$' as f;
~select 'abc abc abd' ~ '^(.+)( \1)+$' as f;
select substring('asd TO foo' from ' TO (([a-z0-9._]+|"([^"]+|"")+")+)');
select substring('a' from '((a))+');
select substring('a' from '((a)+)');
select regexp_match('abc', 'Bd', 'ig'); -- errorselect regexp_matches('ab', 'a(?=b)b*');
~select 'xz' ~ 'x(?=[xy])';
~select 'xy' ~ 'x(?=[xy])';
~select 'xz' ~ 'x(?![xy])';
~select 'xy' ~ 'x(?![xy])';
~select 'x'  ~ 'x(?![xy])';
~select 'xyy' ~ '(?<=[xy])yy+';
~select 'zyy' ~ '(?<=[xy])yy+';
~select 'xyy' ~ '(?<![xy])yy+';
~select 'zyy' ~ '(?<![xy])yy+';
explain (costs off) select * from pg_proc where proname ~ 'abc';
explain (costs off) select * from pg_proc where proname ~ '^abc';
explain (costs off) select * from pg_proc where proname ~ '^abc$';
explain (costs off) select * from pg_proc where proname ~ '^abcd*e';
explain (costs off) select * from pg_proc where proname ~ '^abc+d';
explain (costs off) select * from pg_proc where proname ~ '^(abc)(def)';
explain (costs off) select * from pg_proc where proname ~ '^(abc)$';
explain (costs off) select * from pg_proc where proname ~ '^(abc)?d';
explain (costs off) select * from pg_proc where proname ~ '^abcd(x|(?=\w\w)q)';
~select 'a' ~ '($|^)*';
~select 'a' ~ '(^)+^';
~select 'a' ~ '$($$)+';
~select 'a' ~ '($^)+';
~select 'a' ~ '(^$)*';
~select 'aa bb cc' ~ '(^(?!aa))+';
~select 'aa x' ~ '(^(?!aa)(?!bb)(?!cc))+';
~select 'bb x' ~ '(^(?!aa)(?!bb)(?!cc))+';
~select 'cc x' ~ '(^(?!aa)(?!bb)(?!cc))+';
~select 'dd x' ~ '(^(?!aa)(?!bb)(?!cc))+';
~select 'a' ~ '((((((a)*)*)*)*)*)*';
~select 'a' ~ '((((((a+|)+|)+|)+|)+|)+|)';
~select 'x' ~ 'abcd(\m)+xyz';
~select 'a' ~ '^abcd*(((((^(a c(e?d)a+|)+|)+|)+|)+|a)+|)';
~select 'x' ~ 'a^(^)bcd*xy(((((($a+|)+|)+|)+$|)+|)+|)^$';
~select 'x' ~ 'xyz(\Y\Y)+';
~select 'x' ~ 'x|(?:\M)+';
~select 'x' ~ repeat('x*y*z*', 1000);
~select 'Programmer' ~ '(\w).*?\1' as t;
~select 'a' ~ '$()|^\1';
~select 'a' ~ '.. ()|\1';
~select 'a' ~ '()*\1';
~select 'a' ~ '()+\1';
~select 'xyz' ~ 'x(\w)(?=\1)';  -- no backrefs in LACONsselect 'xyz' ~ 'x(\w)(?=(\1))';
~select 'a' ~ '\x7fffffff';  -- invalid chr codeCREATE TABLE FLOAT4_TBL (f1  float4);
::::::::::::::::::::::::::SELECT 'Infinity'::float4 + 100.0;
::SELECT 'Infinity'::float4 / 'Infinity'::float4;
::SELECT 'nan'::float4 / 'nan'::float4;
::SELECT 'nan'::numeric::float4;
SELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE f.f1 <> '1004.3';
SELECT '' AS one, f.* FROM FLOAT4_TBL f WHERE f.f1 = '1004.3';
SELECT '' AS three, f.* FROM FLOAT4_TBL f WHERE '1004.3' > f.f1;
SELECT '' AS three, f.* FROM FLOAT4_TBL f WHERE  f.f1 < '1004.3';
SELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE '1004.3' >= f.f1;
SELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE  f.f1 <= '1004.3';
SELECT '' AS three, f.f1, f.f1 * '-10' AS x FROM FLOAT4_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS three, f.f1, f.f1 + '-10' AS x FROM FLOAT4_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS three, f.f1, f.f1 / '-10' AS x FROM FLOAT4_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS three, f.f1, f.f1 - '-10' AS x FROM FLOAT4_TBL f   WHERE f.f1 > '0.0';
SELECT '' AS bad, f.f1 / '0.0' from FLOAT4_TBL f;
SELECT '' AS five, f.f1, @f.f1 AS abs_f1 FROM FLOAT4_TBL f;
UPDATE FLOAT4_TBL   SET f1 = FLOAT4_TBL.f1 * '-1'   WHERE FLOAT4_TBL.f1 > '0.0';
::::SELECT '32767.4'::float4::int2;
::::SELECT '32767.6'::float4::int2;
::::SELECT '-32768.4'::float4::int2;
::::SELECT '-32768.6'::float4::int2;
::::SELECT '2147483520'::float4::int4;
::::SELECT '2147483647'::float4::int4;
::::SELECT '-2147483648.5'::float4::int4;
::::SELECT '-2147483900'::float4::int4;
::::SELECT '9223369837831520256'::float4::int8;
::::SELECT '9223372036854775807'::float4::int8;
::::SELECT '-9223372036854775808.5'::float4::int8;
::::SELECT '-9223380000000000000'::float4::int8;
::::::::::::::::::::::::::::::::::create type xfloat4;
create function xfloat4in(cstring) returns xfloat4 immutable strict  language internal as 'int4in';
create function xfloat4out(xfloat4) returns cstring immutable strict  language internal as 'int4out';
create type xfloat4 (input = xfloat4in, output = xfloat4out, like = float4);
create cast (xfloat4 as float4) without function;
create cast (float4 as xfloat4) without function;
create cast (xfloat4 as integer) without function;
create cast (integer as xfloat4) without function;
with testdata(bits) as (values  -- small subnormals  (x'00000001'),  (x'00000002'), (x'00000003'),  (x'00000010'), (x'00000011'), (x'00000100'), (x'00000101'),  (x'00004000'), (x'00004001'), (x'00080000'), (x'00080001'),  -- stress values  (x'0053c4f4'),  -- 7693e-42  (x'006c85c4'),  -- 996622e-44  (x'0041ca76'),  -- 60419369e-46  (x'004b7678'),  -- 6930161142e-48  -- taken from upstream testsuite  (x'00000007'),  (x'00424fe2'),  -- borderline between subnormal and normal  (x'007ffff0'), (x'007ffff1'), (x'007ffffe'), (x'007fffff'))select float4send(flt) as ibits,       flt  from (select bits::integer::xfloat4::float4 as flt          from testdata	offset 0) s;
with testdata(bits) as (values  (x'00000000'),  -- smallest normal values  (x'00800000'), (x'00800001'), (x'00800004'), (x'00800005'),  (x'00800006'),  -- small normal values chosen for short vs. long output  (x'008002f1'), (x'008002f2'), (x'008002f3'),  (x'00800e17'), (x'00800e18'), (x'00800e19'),  -- assorted values (random mantissae)  (x'01000001'), (x'01102843'), (x'01a52c98'),  (x'0219c229'), (x'02e4464d'), (x'037343c1'), (x'03a91b36'),  (x'047ada65'), (x'0496fe87'), (x'0550844f'), (x'05999da3'),  (x'060ea5e2'), (x'06e63c45'), (x'07f1e548'), (x'0fc5282b'),  (x'1f850283'), (x'2874a9d6'),  -- values around 5e-08  (x'3356bf94'), (x'3356bf95'), (x'3356bf96'),  -- around 1e-07  (x'33d6bf94'), (x'33d6bf95'), (x'33d6bf96'),  -- around 3e-07 .. 1e-04  (x'34a10faf'), (x'34a10fb0'), (x'34a10fb1'),  (x'350637bc'), (x'350637bd'), (x'350637be'),  (x'35719786'), (x'35719787'), (x'35719788'),  (x'358637bc'), (x'358637bd'), (x'358637be'),  (x'36a7c5ab'), (x'36a7c5ac'), (x'36a7c5ad'),  (x'3727c5ab'), (x'3727c5ac'), (x'3727c5ad'),  -- format crossover at 1e-04  (x'38d1b714'), (x'38d1b715'), (x'38d1b716'),  (x'38d1b717'), (x'38d1b718'), (x'38d1b719'),  (x'38d1b71a'), (x'38d1b71b'), (x'38d1b71c'),  (x'38d1b71d'),  --  (x'38dffffe'), (x'38dfffff'), (x'38e00000'),  (x'38efffff'), (x'38f00000'), (x'38f00001'),  (x'3a83126e'), (x'3a83126f'), (x'3a831270'),  (x'3c23d709'), (x'3c23d70a'), (x'3c23d70b'),  (x'3dcccccc'), (x'3dcccccd'), (x'3dccccce'),  -- chosen to need 9 digits for 3dcccd70  (x'3dcccd6f'), (x'3dcccd70'), (x'3dcccd71'),  --  (x'3effffff'), (x'3f000000'), (x'3f000001'),  (x'3f333332'), (x'3f333333'), (x'3f333334'),  -- approach 1.0 with increasing numbers of 9s  (x'3f666665'), (x'3f666666'), (x'3f666667'),  (x'3f7d70a3'), (x'3f7d70a4'), (x'3f7d70a5'),  (x'3f7fbe76'), (x'3f7fbe77'), (x'3f7fbe78'),  (x'3f7ff971'), (x'3f7ff972'), (x'3f7ff973'),  (x'3f7fff57'), (x'3f7fff58'), (x'3f7fff59'),  (x'3f7fffee'), (x'3f7fffef'),  -- values very close to 1  (x'3f7ffff0'), (x'3f7ffff1'), (x'3f7ffff2'),  (x'3f7ffff3'), (x'3f7ffff4'), (x'3f7ffff5'),  (x'3f7ffff6'), (x'3f7ffff7'), (x'3f7ffff8'),  (x'3f7ffff9'), (x'3f7ffffa'), (x'3f7ffffb'),  (x'3f7ffffc'), (x'3f7ffffd'), (x'3f7ffffe'),  (x'3f7fffff'),  (x'3f800000'),  (x'3f800001'), (x'3f800002'), (x'3f800003'),  (x'3f800004'), (x'3f800005'), (x'3f800006'),  (x'3f800007'), (x'3f800008'), (x'3f800009'),  -- values 1 to 1.1  (x'3f80000f'), (x'3f800010'), (x'3f800011'),  (x'3f800012'), (x'3f800013'), (x'3f800014'),  (x'3f800017'), (x'3f800018'), (x'3f800019'),  (x'3f80001a'), (x'3f80001b'), (x'3f80001c'),  (x'3f800029'), (x'3f80002a'), (x'3f80002b'),  (x'3f800053'), (x'3f800054'), (x'3f800055'),  (x'3f800346'), (x'3f800347'), (x'3f800348'),  (x'3f8020c4'), (x'3f8020c5'), (x'3f8020c6'),  (x'3f8147ad'), (x'3f8147ae'), (x'3f8147af'),  (x'3f8ccccc'), (x'3f8ccccd'), (x'3f8cccce'),  --  (x'3fc90fdb'), -- pi/2  (x'402df854'), -- e  (x'40490fdb'), -- pi  --  (x'409fffff'), (x'40a00000'), (x'40a00001'),  (x'40afffff'), (x'40b00000'), (x'40b00001'),  (x'411fffff'), (x'41200000'), (x'41200001'),  (x'42c7ffff'), (x'42c80000'), (x'42c80001'),  (x'4479ffff'), (x'447a0000'), (x'447a0001'),  (x'461c3fff'), (x'461c4000'), (x'461c4001'),  (x'47c34fff'), (x'47c35000'), (x'47c35001'),  (x'497423ff'), (x'49742400'), (x'49742401'),  (x'4b18967f'), (x'4b189680'), (x'4b189681'),  (x'4cbebc1f'), (x'4cbebc20'), (x'4cbebc21'),  (x'4e6e6b27'), (x'4e6e6b28'), (x'4e6e6b29'),  (x'501502f8'), (x'501502f9'), (x'501502fa'),  (x'51ba43b6'), (x'51ba43b7'), (x'51ba43b8'),  -- stress values  (x'1f6c1e4a'),  -- 5e-20  (x'59be6cea'),  -- 67e14  (x'5d5ab6c4'),  -- 985e15  (x'2cc4a9bd'),  -- 55895e-16  (x'15ae43fd'),  -- 7038531e-32  (x'2cf757ca'),  -- 702990899e-20  (x'665ba998'),  -- 25933168707e13  (x'743c3324'),  -- 596428896559e20  -- exercise fixed-point memmoves  (x'47f1205a'),  (x'4640e6ae'),  (x'449a5225'),  (x'42f6e9d5'),  (x'414587dd'),  (x'3f9e064b'),  -- these cases come from the upstream's testsuite  -- BoundaryRoundEven  (x'4c000004'),  (x'50061c46'),  (x'510006a8'),  -- ExactValueRoundEven  (x'48951f84'),  (x'45fd1840'),  -- LotsOfTrailingZeros  (x'39800000'),  (x'3b200000'),  (x'3b900000'),  (x'3bd00000'),  -- Regression  (x'63800000'),  (x'4b000000'),  (x'4b800000'),  (x'4c000001'),  (x'4c800b0d'),  (x'00d24584'),  (x'00d90b88'),  (x'45803f34'),  (x'4f9f24f7'),  (x'3a8722c3'),  (x'5c800041'),  (x'15ae43fd'),  (x'5d4cccfb'),  (x'4c800001'),  (x'57800ed8'),  (x'5f000000'),  (x'700000f0'),  (x'5f23e9ac'),  (x'5e9502f9'),  (x'5e8012b1'),  (x'3c000028'),  (x'60cde861'),  (x'03aa2a50'),  (x'43480000'),  (x'4c000000'),  -- LooksLikePow5  (x'5D1502F9'),  (x'5D9502F9'),  (x'5E1502F9'),  -- OutputLength  (x'3f99999a'),  (x'3f9d70a4'),  (x'3f9df3b6'),  (x'3f9e0419'),  (x'3f9e0610'),  (x'3f9e064b'),  (x'3f9e0651'),  (x'03d20cfe')select float4send(flt) as ibits,       flt,       flt::text::float4 as r_flt,       float4send(flt::text::float4) as obits,       float4send(flt::text::float4) = float4send(flt) as correct  from (select bits::integer::xfloat4::float4 as flt          from testdata	offset 0) s;
drop type xfloat4 cascade;
create function binary_coercible(oid, oid) returns bool as $$begin  if $1 = $2 then return true; end if;
  if EXISTS(select 1 from pg_catalog.pg_cast where            castsource = $1 and casttarget = $2 and            castmethod = 'b' and castcontext = 'i')  then return true; end if;
  if $2 = 'pg_catalog.any'::pg_catalog.regtype then return true; end if;
  if $2 = 'pg_catalog.anyarray'::pg_catalog.regtype then    if EXISTS(select 1 from pg_catalog.pg_type where              oid = $1 and typelem != 0 and typlen = -1)    then return true; end if;
  end if;
  if $2 = 'pg_catalog.anyrange'::pg_catalog.regtype then    if (select typtype from pg_catalog.pg_type where oid = $1) = 'r'    then return true; end if;
  end if;
  return false;
end$$ language plpgsql strict stable;
create function explicitly_binary_coercible(oid, oid) returns bool as $$begin  if $1 = $2 then return true; end if;
  if EXISTS(select 1 from pg_catalog.pg_cast where            castsource = $1 and casttarget = $2 and            castmethod = 'b')  then return true; end if;
  if $2 = 'pg_catalog.any'::pg_catalog.regtype then return true; end if;
  if $2 = 'pg_catalog.anyarray'::pg_catalog.regtype then    if EXISTS(select 1 from pg_catalog.pg_type where              oid = $1 and typelem != 0 and typlen = -1)    then return true; end if;
  end if;
  if $2 = 'pg_catalog.anyrange'::pg_catalog.regtype then    if (select typtype from pg_catalog.pg_type where oid = $1) = 'r'    then return true; end if;
  end if;
  return false;
end$$ language plpgsql strict stable;
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE p1.prolang = 0 OR p1.prorettype = 0 OR       p1.pronargs < 0 OR       p1.pronargdefaults < 0 OR       p1.pronargdefaults > p1.pronargs OR       array_lower(p1.proargtypes, 1) != 0 OR       array_upper(p1.proargtypes, 1) != p1.pronargs-1 OR       0::oid = ANY (p1.proargtypes) OR       procost <= 0 OR       CASE WHEN proretset THEN prorows <= 0 ELSE prorows != 0 END OR       prokind NOT IN ('f', 'a', 'w', 'p') OR       provolatile NOT IN ('i', 's', 'v') OR       proparallel NOT IN ('s', 'r', 'u');
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE prosrc IS NULL OR prosrc = '' OR prosrc = '-';
SELECT p1.oid, p1.pronameFROM pg_proc AS p1WHERE proretset AND prokind != 'f';
SELECT p1.oid, p1.pronameFROM pg_proc AS p1WHERE prosecdefORDER BY 1;
SELECT p1.oid, p1.pronameFROM pg_proc AS p1WHERE (pronargdefaults <> 0) != (proargdefaults IS NOT NULL);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE prolang = 13 AND (probin IS NULL OR probin = '' OR probin = '-');
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE prolang != 13 AND probin IS NOT NULL;
SELECT p1.oid, p1.proname, p2.oid, p2.pronameFROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.proname = p2.proname AND    p1.pronargs = p2.pronargs AND    p1.proargtypes = p2.proargtypes;
SELECT p1.oid, p1.proname, p2.oid, p2.pronameFROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid < p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    (p1.prokind != 'a' OR p2.prokind != 'a') AND    (p1.prolang != p2.prolang OR     p1.prokind != p2.prokind OR     p1.prosecdef != p2.prosecdef OR     p1.proleakproof != p2.proleakproof OR     p1.proisstrict != p2.proisstrict OR     p1.proretset != p2.proretset OR     p1.provolatile != p2.provolatile OR     p1.pronargs != p2.pronargs);
SELECT DISTINCT p1.prorettype, p2.prorettypeFROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    p1.prosrc NOT LIKE E'range\\_constructor_' AND    p2.prosrc NOT LIKE E'range\\_constructor_' AND    (p1.prorettype < p2.prorettype)ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[0], p2.proargtypes[0]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    p1.prosrc NOT LIKE E'range\\_constructor_' AND    p2.prosrc NOT LIKE E'range\\_constructor_' AND    (p1.proargtypes[0] < p2.proargtypes[0])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[1], p2.proargtypes[1]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    p1.prosrc NOT LIKE E'range\\_constructor_' AND    p2.prosrc NOT LIKE E'range\\_constructor_' AND    (p1.proargtypes[1] < p2.proargtypes[1])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[2], p2.proargtypes[2]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    (p1.proargtypes[2] < p2.proargtypes[2])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[3], p2.proargtypes[3]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    (p1.proargtypes[3] < p2.proargtypes[3])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[4], p2.proargtypes[4]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    (p1.proargtypes[4] < p2.proargtypes[4])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[5], p2.proargtypes[5]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    (p1.proargtypes[5] < p2.proargtypes[5])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[6], p2.proargtypes[6]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    (p1.proargtypes[6] < p2.proargtypes[6])ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[7], p2.proargtypes[7]FROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid != p2.oid AND    p1.prosrc = p2.prosrc AND    p1.prolang = 12 AND p2.prolang = 12 AND    p1.prokind != 'a' AND p2.prokind != 'a' AND    (p1.proargtypes[7] < p2.proargtypes[7])ORDER BY 1, 2;
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE p1.prorettype = 'internal'::regtype AND NOT    'internal'::regtype = ANY (p1.proargtypes);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE p1.prorettype IN    ('anyelement'::regtype, 'anyarray'::regtype, 'anynonarray'::regtype,     'anyenum'::regtype, 'anyrange'::regtype)  AND NOT    ('anyelement'::regtype = ANY (p1.proargtypes) OR     'anyarray'::regtype = ANY (p1.proargtypes) OR     'anynonarray'::regtype = ANY (p1.proargtypes) OR     'anyenum'::regtype = ANY (p1.proargtypes) OR     'anyrange'::regtype = ANY (p1.proargtypes))ORDER BY 2;
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE 'cstring'::regtype = ANY (p1.proargtypes)    AND NOT EXISTS(SELECT 1 FROM pg_type WHERE typinput = p1.oid)    AND NOT EXISTS(SELECT 1 FROM pg_conversion WHERE conproc = p1.oid)    AND p1.oid != 'shell_in(cstring)'::regprocedureORDER BY 1;
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE  p1.prorettype = 'cstring'::regtype    AND NOT EXISTS(SELECT 1 FROM pg_type WHERE typoutput = p1.oid)    AND NOT EXISTS(SELECT 1 FROM pg_type WHERE typmodout = p1.oid)    AND p1.oid != 'shell_out(opaque)'::regprocedureORDER BY 1;
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE proallargtypes IS NOT NULL AND    array_length(proallargtypes,1) < array_length(proargtypes,1);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE proargmodes IS NOT NULL AND    array_length(proargmodes,1) < array_length(proargtypes,1);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE proargnames IS NOT NULL AND    array_length(proargnames,1) < array_length(proargtypes,1);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE proallargtypes IS NOT NULL AND proargmodes IS NOT NULL AND    array_length(proallargtypes,1) <> array_length(proargmodes,1);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE proallargtypes IS NOT NULL AND proargnames IS NOT NULL AND    array_length(proallargtypes,1) <> array_length(proargnames,1);
SELECT p1.oid, p1.pronameFROM pg_proc as p1WHERE proargmodes IS NOT NULL AND proargnames IS NOT NULL AND    array_length(proargmodes,1) <> array_length(proargnames,1);
SELECT p1.oid, p1.proname, p1.proargtypes, p1.proallargtypes, p1.proargmodesFROM pg_proc as p1WHERE proallargtypes IS NOT NULL AND  ARRAY(SELECT unnest(proargtypes)) <>  ARRAY(SELECT proallargtypes[i]        FROM generate_series(1, array_length(proallargtypes, 1)) g(i)        WHERE proargmodes IS NULL OR proargmodes[i] IN ('i', 'b', 'v'));
SELECT p1.oid, p1.proname, p2.oid, p2.pronameFROM pg_proc AS p1, pg_proc AS p2WHERE p2.oid = p1.prosupport AND    (p2.prorettype != 'internal'::regtype OR p2.proretset OR p2.pronargs != 1     OR p2.proargtypes[0] != 'internal'::regtype);
SELECT p1.oid, p1.pronameFROM pg_proc as p1 LEFT JOIN pg_description as d     ON p1.tableoid = d.classoid and p1.oid = d.objoid and d.objsubid = 0WHERE d.classoid IS NULL AND p1.oid <= 9999;
\\a\tSELECT p1.oid::regprocedureFROM pg_proc p1 JOIN pg_namespace pn     ON pronamespace = pn.oidWHERE nspname = 'pg_catalog' AND proleakproofORDER BY 1;
\\a\tselect proname, oid from pg_catalog.pg_procwhere proname in (  'lo_open',  'lo_close',  'lo_creat',  'lo_create',  'lo_unlink',  'lo_lseek',  'lo_lseek64',  'lo_tell',  'lo_tell64',  'lo_truncate',  'lo_truncate64',  'loread',  'lowrite')and pronamespace = (select oid from pg_catalog.pg_namespace                    where nspname = 'pg_catalog')order by 1;
SELECT p1.oid, p1.pronameFROM pg_proc AS p1WHERE provolatile = 'i' AND proparallel = 'u';
SELECT *FROM pg_cast cWHERE castsource = 0 OR casttarget = 0 OR castcontext NOT IN ('e', 'a', 'i')    OR castmethod NOT IN ('f', 'b' ,'i');
SELECT *FROM pg_cast cWHERE (castmethod = 'f' AND castfunc = 0)   OR (castmethod IN ('b', 'i') AND castfunc <> 0);
SELECT *FROM pg_cast cWHERE castsource = casttarget AND castfunc = 0;
SELECT c.*FROM pg_cast c, pg_proc pWHERE c.castfunc = p.oid AND p.pronargs < 2 AND castsource = casttarget;
SELECT c.*FROM pg_cast c, pg_proc pWHERE c.castfunc = p.oid AND    (p.pronargs < 1 OR p.pronargs > 3     OR NOT (binary_coercible(c.castsource, p.proargtypes[0])             OR (c.castsource = 'character'::regtype AND                 p.proargtypes[0] = 'text'::regtype))     OR NOT binary_coercible(p.prorettype, c.casttarget));
SELECT c.*FROM pg_cast c, pg_proc pWHERE c.castfunc = p.oid AND    ((p.pronargs > 1 AND p.proargtypes[1] != 'int4'::regtype) OR     (p.pronargs > 2 AND p.proargtypes[2] != 'bool'::regtype));
::::SELECT castsource::regtype, casttarget::regtype, castfunc, castcontextFROM pg_cast cWHERE c.castmethod = 'b' AND    NOT EXISTS (SELECT 1 FROM pg_cast k                WHERE k.castmethod = 'b' AND                    k.castsource = c.casttarget AND                    k.casttarget = c.castsource);
SELECT p1.oid, p1.connameFROM pg_conversion as p1WHERE p1.conproc = 0 OR    pg_encoding_to_char(conforencoding) = '' OR    pg_encoding_to_char(contoencoding) = '';
SELECT p.oid, p.proname, c.oid, c.connameFROM pg_proc p, pg_conversion cWHERE p.oid = c.conproc AND    (p.prorettype != 'void'::regtype OR p.proretset OR     p.pronargs != 5 OR     p.proargtypes[0] != 'int4'::regtype OR     p.proargtypes[1] != 'int4'::regtype OR     p.proargtypes[2] != 'cstring'::regtype OR     p.proargtypes[3] != 'internal'::regtype OR     p.proargtypes[4] != 'int4'::regtype);
SELECT p1.oid, p1.connameFROM pg_conversion as p1WHERE condefault AND    convert('ABC'::bytea, pg_encoding_to_char(conforencoding),            pg_encoding_to_char(contoencoding)) != 'ABC';
SELECT p1.oid, p1.oprnameFROM pg_operator as p1WHERE (p1.oprkind != 'b' AND p1.oprkind != 'l' AND p1.oprkind != 'r') OR    p1.oprresult = 0 OR p1.oprcode = 0;
SELECT p1.oid, p1.oprnameFROM pg_operator as p1WHERE (p1.oprleft = 0 and p1.oprkind != 'l') OR    (p1.oprleft != 0 and p1.oprkind = 'l') OR    (p1.oprright = 0 and p1.oprkind != 'r') OR    (p1.oprright != 0 and p1.oprkind = 'r');
SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcodeFROM pg_operator AS p1, pg_operator AS p2WHERE p1.oid != p2.oid AND    p1.oprname = p2.oprname AND    p1.oprkind = p2.oprkind AND    p1.oprleft = p2.oprleft AND    p1.oprright = p2.oprright;
SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcodeFROM pg_operator AS p1, pg_operator AS p2WHERE p1.oprcom = p2.oid AND    (p1.oprkind != 'b' OR     p1.oprleft != p2.oprright OR     p1.oprright != p2.oprleft OR     p1.oprresult != p2.oprresult OR     p1.oid != p2.oprcom);
SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcodeFROM pg_operator AS p1, pg_operator AS p2WHERE p1.oprnegate = p2.oid AND    (p1.oprkind != p2.oprkind OR     p1.oprleft != p2.oprleft OR     p1.oprright != p2.oprright OR     p1.oprresult != 'bool'::regtype OR     p2.oprresult != 'bool'::regtype OR     p1.oid != p2.oprnegate OR     p1.oid = p2.oid);
SELECT DISTINCT o1.oprname AS op1, o2.oprname AS op2FROM pg_operator o1, pg_operator o2WHERE o1.oprcom = o2.oid AND o1.oprname <= o2.oprnameORDER BY 1, 2;
SELECT DISTINCT o1.oprname AS op1, o2.oprname AS op2FROM pg_operator o1, pg_operator o2WHERE o1.oprnegate = o2.oid AND o1.oprname <= o2.oprnameORDER BY 1, 2;
SELECT p1.oid, p1.oprname FROM pg_operator AS p1WHERE (p1.oprcanmerge OR p1.oprcanhash) AND NOT    (p1.oprkind = 'b' AND p1.oprresult = 'bool'::regtype AND p1.oprcom != 0);
SELECT p1.oid, p1.oprname, p2.oid, p2.oprnameFROM pg_operator AS p1, pg_operator AS p2WHERE p1.oprcom = p2.oid AND    (p1.oprcanmerge != p2.oprcanmerge OR     p1.oprcanhash != p2.oprcanhash);
SELECT p1.oid, p1.oprnameFROM pg_operator AS p1WHERE p1.oprcanmerge AND NOT EXISTS  (SELECT 1 FROM pg_amop   WHERE amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree') AND         amopopr = p1.oid AND amopstrategy = 3);
SELECT p1.oid, p1.oprname, p.amopfamilyFROM pg_operator AS p1, pg_amop pWHERE amopopr = p1.oid  AND amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')  AND amopstrategy = 3  AND NOT p1.oprcanmerge;
SELECT p1.oid, p1.oprnameFROM pg_operator AS p1WHERE p1.oprcanhash AND NOT EXISTS  (SELECT 1 FROM pg_amop   WHERE amopmethod = (SELECT oid FROM pg_am WHERE amname = 'hash') AND         amopopr = p1.oid AND amopstrategy = 1);
SELECT p1.oid, p1.oprname, p.amopfamilyFROM pg_operator AS p1, pg_amop pWHERE amopopr = p1.oid  AND amopmethod = (SELECT oid FROM pg_am WHERE amname = 'hash')  AND NOT p1.oprcanhash;
SELECT p1.oid, p1.oprname, p2.oid, p2.pronameFROM pg_operator AS p1, pg_proc AS p2WHERE p1.oprcode = p2.oid AND    p1.oprkind = 'b' AND    (p2.pronargs != 2     OR NOT binary_coercible(p2.prorettype, p1.oprresult)     OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])     OR NOT binary_coercible(p1.oprright, p2.proargtypes[1]));
SELECT p1.oid, p1.oprname, p2.oid, p2.pronameFROM pg_operator AS p1, pg_proc AS p2WHERE p1.oprcode = p2.oid AND    p1.oprkind = 'l' AND    (p2.pronargs != 1     OR NOT binary_coercible(p2.prorettype, p1.oprresult)     OR NOT binary_coercible(p1.oprright, p2.proargtypes[0])     OR p1.oprleft != 0);
SELECT p1.oid, p1.oprname, p2.oid, p2.pronameFROM pg_operator AS p1, pg_proc AS p2WHERE p1.oprcode = p2.oid AND    p1.oprkind = 'r' AND    (p2.pronargs != 1     OR NOT binary_coercible(p2.prorettype, p1.oprresult)     OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])     OR p1.oprright != 0);
SELECT p1.oid, p1.oprname, p2.oid, p2.pronameFROM pg_operator AS p1, pg_proc AS p2WHERE p1.oprcode = p2.oid AND    (p1.oprcanmerge OR p1.oprcanhash) AND    p2.provolatile = 'v';
SELECT p1.oid, p1.oprname, p2.oid, p2.pronameFROM pg_operator AS p1, pg_proc AS p2WHERE p1.oprrest = p2.oid AND    (p1.oprresult != 'bool'::regtype OR     p2.prorettype != 'float8'::regtype OR p2.proretset OR     p2.pronargs != 4 OR     p2.proargtypes[0] != 'internal'::regtype OR     p2.proargtypes[1] != 'oid'::regtype OR     p2.proargtypes[2] != 'internal'::regtype OR     p2.proargtypes[3] != 'int4'::regtype);
SELECT p1.oid, p1.oprname, p2.oid, p2.pronameFROM pg_operator AS p1, pg_proc AS p2WHERE p1.oprjoin = p2.oid AND    (p1.oprkind != 'b' OR p1.oprresult != 'bool'::regtype OR     p2.prorettype != 'float8'::regtype OR p2.proretset OR     p2.pronargs != 5 OR     p2.proargtypes[0] != 'internal'::regtype OR     p2.proargtypes[1] != 'oid'::regtype OR     p2.proargtypes[2] != 'internal'::regtype OR     p2.proargtypes[3] != 'int2'::regtype OR     p2.proargtypes[4] != 'internal'::regtype);
SELECT p1.oid, p1.oprnameFROM pg_operator as p1 LEFT JOIN pg_description as d     ON p1.tableoid = d.classoid and p1.oid = d.objoid and d.objsubid = 0WHERE d.classoid IS NULL AND p1.oid <= 9999;
WITH funcdescs AS (  SELECT p.oid as p_oid, proname, o.oid as o_oid,    pd.description as prodesc,    'implementation of ' || oprname || ' operator' as expecteddesc,    od.description as oprdesc  FROM pg_proc p JOIN pg_operator o ON oprcode = p.oid       LEFT JOIN pg_description pd ON         (pd.objoid = p.oid and pd.classoid = p.tableoid and pd.objsubid = 0)       LEFT JOIN pg_description od ON         (od.objoid = o.oid and od.classoid = o.tableoid and od.objsubid = 0)  WHERE o.oid <= 9999SELECT * FROM funcdescs  WHERE prodesc IS DISTINCT FROM expecteddesc    AND oprdesc NOT LIKE 'deprecated%'    AND prodesc IS DISTINCT FROM oprdesc;
WITH funcdescs AS (  SELECT p.oid as p_oid, proname, o.oid as o_oid,    pd.description as prodesc,    'implementation of ' || oprname || ' operator' as expecteddesc,    od.description as oprdesc  FROM pg_proc p JOIN pg_operator o ON oprcode = p.oid       LEFT JOIN pg_description pd ON         (pd.objoid = p.oid and pd.classoid = p.tableoid and pd.objsubid = 0)       LEFT JOIN pg_description od ON         (od.objoid = o.oid and od.classoid = o.tableoid and od.objsubid = 0)  WHERE o.oid <= 9999SELECT p_oid, proname, prodesc FROM funcdescs  WHERE prodesc IS DISTINCT FROM expecteddesc    AND oprdesc NOT LIKE 'deprecated%'ORDER BY 1;
SELECT o1.oid, o1.oprcode, o2.oid, o2.oprcodeFROM pg_operator AS o1, pg_operator AS o2, pg_proc AS p1, pg_proc AS p2WHERE o1.oprcom = o2.oid AND p1.oid = o1.oprcode AND p2.oid = o2.oprcode AND    (p1.provolatile != p2.provolatile OR     p1.proleakproof != p2.proleakproof);
SELECT o1.oid, o1.oprcode, o2.oid, o2.oprcodeFROM pg_operator AS o1, pg_operator AS o2, pg_proc AS p1, pg_proc AS p2WHERE o1.oprnegate = o2.oid AND p1.oid = o1.oprcode AND p2.oid = o2.oprcode AND    (p1.provolatile != p2.provolatile OR     p1.proleakproof != p2.proleakproof);
SELECT pp.oid::regprocedure as proc, pp.provolatile as vp, pp.proleakproof as lp,       po.oid::regprocedure as opr, po.provolatile as vo, po.proleakproof as loFROM pg_proc pp, pg_proc po, pg_operator o, pg_amproc ap, pg_amop aoWHERE pp.oid = ap.amproc AND po.oid = o.oprcode AND o.oid = ao.amopopr AND    ao.amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree') AND    ao.amopfamily = ap.amprocfamily AND    ao.amoplefttype = ap.amproclefttype AND    ao.amoprighttype = ap.amprocrighttype AND    ap.amprocnum = 1 AND    (pp.provolatile != po.provolatile OR     pp.proleakproof != po.proleakproof)ORDER BY 1;
::SELECT ctid, aggfnoid::oidFROM pg_aggregate as p1WHERE aggfnoid = 0 OR aggtransfn = 0 OR    aggkind NOT IN ('n', 'o', 'h') OR    aggnumdirectargs < 0 OR    (aggkind = 'n' AND aggnumdirectargs > 0) OR    aggfinalmodify NOT IN ('r', 's', 'w') OR    aggmfinalmodify NOT IN ('r', 's', 'w') OR    aggtranstype = 0 OR aggtransspace < 0 OR aggmtransspace < 0;
SELECT a.aggfnoid::oid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggfnoid = p.oid AND    (p.prokind != 'a' OR p.proretset OR p.pronargs < a.aggnumdirectargs);
SELECT oid, pronameFROM pg_proc as pWHERE p.prokind = 'a' AND    NOT EXISTS (SELECT 1 FROM pg_aggregate a WHERE a.aggfnoid = p.oid);
SELECT a.aggfnoid::oid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggfnoid = p.oid AND    a.aggfinalfn = 0 AND p.prorettype != a.aggtranstype;
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptrWHERE a.aggfnoid = p.oid AND    a.aggtransfn = ptr.oid AND    (ptr.proretset     OR NOT (ptr.pronargs =             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)     OR NOT binary_coercible(ptr.prorettype, a.aggtranstype)     OR NOT binary_coercible(a.aggtranstype, ptr.proargtypes[0])     OR (p.pronargs > 0 AND         NOT binary_coercible(p.proargtypes[0], ptr.proargtypes[1]))     OR (p.pronargs > 1 AND         NOT binary_coercible(p.proargtypes[1], ptr.proargtypes[2]))     OR (p.pronargs > 2 AND         NOT binary_coercible(p.proargtypes[2], ptr.proargtypes[3]))     -- we could carry the check further, but 3 args is enough for now     OR (p.pronargs > 3)    );
SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfnWHERE a.aggfnoid = p.oid AND    a.aggfinalfn = pfn.oid AND    (pfn.proretset OR     NOT binary_coercible(pfn.prorettype, p.prorettype) OR     NOT binary_coercible(a.aggtranstype, pfn.proargtypes[0]) OR     CASE WHEN a.aggfinalextra THEN pfn.pronargs != p.pronargs + 1          ELSE pfn.pronargs != a.aggnumdirectargs + 1 END     OR (pfn.pronargs > 1 AND         NOT binary_coercible(p.proargtypes[0], pfn.proargtypes[1]))     OR (pfn.pronargs > 2 AND         NOT binary_coercible(p.proargtypes[1], pfn.proargtypes[2]))     OR (pfn.pronargs > 3 AND         NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))     -- we could carry the check further, but 4 args is enough for now     OR (pfn.pronargs > 4)    );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptrWHERE a.aggfnoid = p.oid AND    a.aggtransfn = ptr.oid AND ptr.proisstrict AND    a.agginitval IS NULL AND    NOT binary_coercible(p.proargtypes[0], a.aggtranstype);
::SELECT ctid, aggfnoid::oidFROM pg_aggregate as p1WHERE aggmtranstype != 0 AND    (aggmtransfn = 0 OR aggminvtransfn = 0);
::SELECT ctid, aggfnoid::oidFROM pg_aggregate as p1WHERE aggmtranstype = 0 AND    (aggmtransfn != 0 OR aggminvtransfn != 0 OR aggmfinalfn != 0 OR     aggmtransspace != 0 OR aggminitval IS NOT NULL);
SELECT a.aggfnoid::oid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggfnoid = p.oid AND    a.aggmtransfn != 0 AND    a.aggmfinalfn = 0 AND p.prorettype != a.aggmtranstype;
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptrWHERE a.aggfnoid = p.oid AND    a.aggmtransfn = ptr.oid AND    (ptr.proretset     OR NOT (ptr.pronargs =             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)     OR NOT binary_coercible(ptr.prorettype, a.aggmtranstype)     OR NOT binary_coercible(a.aggmtranstype, ptr.proargtypes[0])     OR (p.pronargs > 0 AND         NOT binary_coercible(p.proargtypes[0], ptr.proargtypes[1]))     OR (p.pronargs > 1 AND         NOT binary_coercible(p.proargtypes[1], ptr.proargtypes[2]))     OR (p.pronargs > 2 AND         NOT binary_coercible(p.proargtypes[2], ptr.proargtypes[3]))     -- we could carry the check further, but 3 args is enough for now     OR (p.pronargs > 3)    );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptrWHERE a.aggfnoid = p.oid AND    a.aggminvtransfn = ptr.oid AND    (ptr.proretset     OR NOT (ptr.pronargs =             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)     OR NOT binary_coercible(ptr.prorettype, a.aggmtranstype)     OR NOT binary_coercible(a.aggmtranstype, ptr.proargtypes[0])     OR (p.pronargs > 0 AND         NOT binary_coercible(p.proargtypes[0], ptr.proargtypes[1]))     OR (p.pronargs > 1 AND         NOT binary_coercible(p.proargtypes[1], ptr.proargtypes[2]))     OR (p.pronargs > 2 AND         NOT binary_coercible(p.proargtypes[2], ptr.proargtypes[3]))     -- we could carry the check further, but 3 args is enough for now     OR (p.pronargs > 3)    );
SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfnWHERE a.aggfnoid = p.oid AND    a.aggmfinalfn = pfn.oid AND    (pfn.proretset OR     NOT binary_coercible(pfn.prorettype, p.prorettype) OR     NOT binary_coercible(a.aggmtranstype, pfn.proargtypes[0]) OR     CASE WHEN a.aggmfinalextra THEN pfn.pronargs != p.pronargs + 1          ELSE pfn.pronargs != a.aggnumdirectargs + 1 END     OR (pfn.pronargs > 1 AND         NOT binary_coercible(p.proargtypes[0], pfn.proargtypes[1]))     OR (pfn.pronargs > 2 AND         NOT binary_coercible(p.proargtypes[1], pfn.proargtypes[2]))     OR (pfn.pronargs > 3 AND         NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))     -- we could carry the check further, but 4 args is enough for now     OR (pfn.pronargs > 4)    );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptrWHERE a.aggfnoid = p.oid AND    a.aggmtransfn = ptr.oid AND ptr.proisstrict AND    a.aggminitval IS NULL AND    NOT binary_coercible(p.proargtypes[0], a.aggmtranstype);
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname, iptr.oid, iptr.pronameFROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr, pg_proc AS iptrWHERE a.aggfnoid = p.oid AND    a.aggmtransfn = ptr.oid AND    a.aggminvtransfn = iptr.oid AND    ptr.proisstrict != iptr.proisstrict;
SELECT a.aggfnoid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggcombinefn = p.oid AND    (p.pronargs != 2 OR     p.prorettype != p.proargtypes[0] OR     p.prorettype != p.proargtypes[1] OR     NOT binary_coercible(a.aggtranstype, p.proargtypes[0]));
SELECT a.aggfnoid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggcombinefn = p.oid AND    a.aggtranstype = 'internal'::regtype AND p.proisstrict;
SELECT aggfnoid, aggtranstype, aggserialfn, aggdeserialfnFROM pg_aggregateWHERE (aggserialfn != 0 OR aggdeserialfn != 0)  AND (aggtranstype != 'internal'::regtype OR aggcombinefn = 0 OR       aggserialfn = 0 OR aggdeserialfn = 0);
SELECT a.aggfnoid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggserialfn = p.oid AND    (p.prorettype != 'bytea'::regtype OR p.pronargs != 1 OR     p.proargtypes[0] != 'internal'::regtype OR     NOT p.proisstrict);
SELECT a.aggfnoid, p.pronameFROM pg_aggregate as a, pg_proc as pWHERE a.aggdeserialfn = p.oid AND    (p.prorettype != 'internal'::regtype OR p.pronargs != 2 OR     p.proargtypes[0] != 'bytea'::regtype OR     p.proargtypes[1] != 'internal'::regtype OR     NOT p.proisstrict);
SELECT a.aggfnoid, a.aggcombinefn, a.aggserialfn, a.aggdeserialfn,       b.aggfnoid, b.aggcombinefn, b.aggserialfn, b.aggdeserialfnFROM    pg_aggregate a, pg_aggregate bWHERE    a.aggfnoid < b.aggfnoid AND a.aggtransfn = b.aggtransfn AND    (a.aggcombinefn != b.aggcombinefn OR a.aggserialfn != b.aggserialfn     OR a.aggdeserialfn != b.aggdeserialfn);
SELECT DISTINCT proname, oprnameFROM pg_operator AS o, pg_aggregate AS a, pg_proc AS pWHERE a.aggfnoid = p.oid AND a.aggsortop = o.oidORDER BY 1, 2;
SELECT a.aggfnoid::oid, o.oidFROM pg_operator AS o, pg_aggregate AS a, pg_proc AS pWHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND    (oprkind != 'b' OR oprresult != 'boolean'::regtype     OR oprleft != p.proargtypes[0] OR oprright != p.proargtypes[0]);
SELECT a.aggfnoid::oid, o.oidFROM pg_operator AS o, pg_aggregate AS a, pg_proc AS pWHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND    NOT EXISTS(SELECT 1 FROM pg_amop               WHERE amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')                     AND amopopr = o.oid                     AND amoplefttype = o.oprleft                     AND amoprighttype = o.oprright);
SELECT DISTINCT proname, oprname, amopstrategyFROM pg_operator AS o, pg_aggregate AS a, pg_proc AS p,     pg_amop as aoWHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND    amopopr = o.oid AND    amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')ORDER BY 1, 2;
SELECT p1.oid::regprocedure, p2.oid::regprocedureFROM pg_proc AS p1, pg_proc AS p2WHERE p1.oid < p2.oid AND p1.proname = p2.proname AND    p1.prokind = 'a' AND p2.prokind = 'a' AND    array_dims(p1.proargtypes) != array_dims(p2.proargtypes)ORDER BY 1;
SELECT oid, pronameFROM pg_proc AS pWHERE prokind = 'a' AND proargdefaults IS NOT NULL;
SELECT p.oid, pronameFROM pg_proc AS p JOIN pg_aggregate AS a ON a.aggfnoid = p.oidWHERE prokind = 'a' AND provariadic != 0 AND a.aggkind = 'n';
SELECT p1.oidFROM pg_opfamily as p1WHERE p1.opfmethod = 0 OR p1.opfnamespace = 0;
SELECT oid, opfname FROM pg_opfamily fWHERE NOT EXISTS (SELECT 1 FROM pg_opclass WHERE opcfamily = f.oid);
SELECT p1.oidFROM pg_opclass AS p1WHERE p1.opcmethod = 0 OR p1.opcnamespace = 0 OR p1.opcfamily = 0    OR p1.opcintype = 0;
SELECT p1.oid, p2.oidFROM pg_opclass AS p1, pg_opfamily AS p2WHERE p1.opcfamily = p2.oid AND p1.opcmethod != p2.opfmethod;
SELECT p1.oid, p2.oidFROM pg_opclass AS p1, pg_opclass AS p2WHERE p1.oid != p2.oid AND    p1.opcmethod = p2.opcmethod AND p1.opcintype = p2.opcintype AND    p1.opcdefault AND p2.opcdefault;
SELECT p1.oid, p1.amnameFROM pg_am AS p1WHERE p1.amhandler = 0;
SELECT p1.oid, p1.amname, p2.oid, p2.pronameFROM pg_am AS p1, pg_proc AS p2WHERE p2.oid = p1.amhandler AND p1.amtype = 'i' AND    (p2.prorettype != 'index_am_handler'::regtype     OR p2.proretset     OR p2.pronargs != 1     OR p2.proargtypes[0] != 'internal'::regtype);
SELECT p1.oid, p1.amname, p2.oid, p2.pronameFROM pg_am AS p1, pg_proc AS p2WHERE p2.oid = p1.amhandler AND p1.amtype = 's' AND    (p2.prorettype != 'table_am_handler'::regtype     OR p2.proretset     OR p2.pronargs != 1     OR p2.proargtypes[0] != 'internal'::regtype);
SELECT p1.amopfamily, p1.amopstrategyFROM pg_amop as p1WHERE p1.amopfamily = 0 OR p1.amoplefttype = 0 OR p1.amoprighttype = 0    OR p1.amopopr = 0 OR p1.amopmethod = 0 OR p1.amopstrategy < 1;
SELECT p1.amopfamily, p1.amopstrategyFROM pg_amop as p1WHERE NOT ((p1.amoppurpose = 's' AND p1.amopsortfamily = 0) OR           (p1.amoppurpose = 'o' AND p1.amopsortfamily <> 0));
SELECT p1.oid, p2.oidFROM pg_amop AS p1, pg_opfamily AS p2WHERE p1.amopfamily = p2.oid AND p1.amopmethod != p2.opfmethod;
SELECT DISTINCT amopmethod, amopstrategy, oprnameFROM pg_amop p1 LEFT JOIN pg_operator p2 ON amopopr = p2.oidORDER BY 1, 2, 3;
SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.oprnameFROM pg_amop AS p1, pg_operator AS p2WHERE p1.amopopr = p2.oid AND p1.amoppurpose = 's' AND    (p2.oprrest = 0 OR p2.oprjoin = 0);
SELECT p1.opcname, p1.opcfamilyFROM pg_opclass AS p1WHERE NOT EXISTS(SELECT 1 FROM pg_amop AS p2                 WHERE p2.amopfamily = p1.opcfamily                   AND binary_coercible(p1.opcintype, p2.amoplefttype));
SELECT p1.amopfamily, p1.amopstrategy, p1.amopoprFROM pg_amop AS p1WHERE NOT EXISTS(SELECT 1 FROM pg_opclass AS p2                 WHERE p2.opcfamily = p1.amopfamily                   AND binary_coercible(p2.opcintype, p1.amoplefttype));
SELECT p1.amopfamily, p1.amopopr, p2.oprname, p3.prosrcFROM pg_amop AS p1, pg_operator AS p2, pg_proc AS p3WHERE p1.amopopr = p2.oid AND p2.oprcode = p3.oid AND    p1.amoplefttype = p1.amoprighttype AND    p3.provolatile != 'i';
SELECT p1.amopfamily, p1.amopopr, p2.oprname, p3.prosrcFROM pg_amop AS p1, pg_operator AS p2, pg_proc AS p3WHERE p1.amopopr = p2.oid AND p2.oprcode = p3.oid AND    p1.amoplefttype != p1.amoprighttype AND    p3.provolatile = 'v';
SELECT p1.amprocfamily, p1.amprocnumFROM pg_amproc as p1WHERE p1.amprocfamily = 0 OR p1.amproclefttype = 0 OR p1.amprocrighttype = 0    OR p1.amprocnum < 1 OR p1.amproc = 0;
SELECT p1.amprocfamily, p1.amproc, p2.prosrcFROM pg_amproc AS p1, pg_proc AS p2WHERE p1.amproc = p2.oid AND    p1.amproclefttype = p1.amprocrighttype AND    p2.provolatile != 'i';
SELECT p1.amprocfamily, p1.amproc, p2.prosrcFROM pg_amproc AS p1, pg_proc AS p2WHERE p1.amproc = p2.oid AND    p1.amproclefttype != p1.amprocrighttype AND    p2.provolatile = 'v';
SELECT p1.indexrelid, p1.indrelidFROM pg_index as p1WHERE p1.indexrelid = 0 OR p1.indrelid = 0 OR      p1.indnatts <= 0 OR p1.indnatts > 32;
SELECT p1.indexrelid, p1.indrelidFROM pg_index as p1WHERE array_lower(indkey, 1) != 0 OR array_upper(indkey, 1) != indnatts-1 OR    array_lower(indclass, 1) != 0 OR array_upper(indclass, 1) != indnatts-1 OR    array_lower(indcollation, 1) != 0 OR array_upper(indcollation, 1) != indnatts-1 OR    array_lower(indoption, 1) != 0 OR array_upper(indoption, 1) != indnatts-1;
::::::SELECT indexrelid::regclass, indrelid::regclass, attname, atttypid::regtype, opcnameFROM (SELECT indexrelid, indrelid, unnest(indkey) as ikey,             unnest(indclass) as iclass, unnest(indcollation) as icoll      FROM pg_index) ss,      pg_attribute a,      pg_opclass opcWHERE a.attrelid = indrelid AND a.attnum = ikey AND opc.oid = iclass AND      (NOT binary_coercible(atttypid, opcintype) OR icoll != attcollation);
::::::SELECT indexrelid::regclass, indrelid::regclass, attname, atttypid::regtype, opcnameFROM (SELECT indexrelid, indrelid, unnest(indkey) as ikey,             unnest(indclass) as iclass, unnest(indcollation) as icoll      FROM pg_index      WHERE indrelid < 16384) ss,      pg_attribute a,      pg_opclass opcWHERE a.attrelid = indrelid AND a.attnum = ikey AND opc.oid = iclass AND      (opcintype != atttypid OR icoll != attcollation)ORDER BY 1;
SELECT relname, attname, attcollationFROM pg_class c, pg_attribute aWHERE c.oid = attrelid AND c.oid < 16384 AND    c.relkind != 'v' AND  -- we don't care about columns in views    attcollation != 0 AND    attcollation != (SELECT oid FROM pg_collation WHERE collname = 'C');
::::SELECT indexrelid::regclass, indrelid::regclass, iclass, icollFROM (SELECT indexrelid, indrelid,             unnest(indclass) as iclass, unnest(indcollation) as icoll      FROM pg_index      WHERE indrelid < 16384) ssWHERE icoll != 0 AND    icoll != (SELECT oid FROM pg_collation WHERE collname = 'C');
EXPLAIN (COSTS OFF)SELECT ctid, * FROM tidscan WHERE ctid = '(0,1)';
EXPLAIN (COSTS OFF)SELECT ctid, * FROM tidscan WHERE '(0,1)' = ctid;
EXPLAIN (COSTS OFF)SELECT ctid, * FROM tidscan WHERE ctid = '(0,2)' OR '(0,1)' = ctid;
EXPLAIN (COSTS OFF)SELECT ctid, * FROM tidscan WHERE ctid = ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
::SELECT ctid, * FROM tidscan WHERE ctid = ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
EXPLAIN (COSTS OFF)SELECT ctid, * FROM tidscan WHERE ctid != ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
::SELECT ctid, * FROM tidscan WHERE ctid != ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
EXPLAIN (COSTS OFF)SELECT ctid, * FROM tidscanWHERE (id = 3 AND ctid IN ('(0,2)', '(0,3)')) OR (ctid = '(0,1)' AND id = 1);
SELECT ctid, * FROM tidscanWHERE (id = 3 AND ctid IN ('(0,2)', '(0,3)')) OR (ctid = '(0,1)' AND id = 1);
SET enable_hashjoin TO off;  -- otherwise hash join might winEXPLAIN (COSTS OFF)SELECT t1.ctid, t1.*, t2.ctid, t2.*FROM tidscan t1 JOIN tidscan t2 ON t1.ctid = t2.ctid WHERE t1.id = 1;
SELECT t1.ctid, t1.*, t2.ctid, t2.*FROM tidscan t1 JOIN tidscan t2 ON t1.ctid = t2.ctid WHERE t1.id = 1;
EXPLAIN (COSTS OFF)SELECT t1.ctid, t1.*, t2.ctid, t2.*FROM tidscan t1 LEFT JOIN tidscan t2 ON t1.ctid = t2.ctid WHERE t1.id = 1;
SELECT t1.ctid, t1.*, t2.ctid, t2.*FROM tidscan t1 LEFT JOIN tidscan t2 ON t1.ctid = t2.ctid WHERE t1.id = 1;
RESET enable_hashjoin;
BEGIN;
DECLARE c CURSOR FORSELECT ctid, * FROM tidscan WHERE ctid = ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
FETCH ALL FROM c;
FETCH BACKWARD 1 FROM c;
FETCH FIRST FROM c;
ROLLBACK;
BEGIN;
DECLARE c CURSOR FOR SELECT ctid, * FROM tidscan;
FETCH NEXT FROM c; -- skip one rowFETCH NEXT FROM c;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
FETCH NEXT FROM c;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
FETCH NEXT FROM c;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
ROLLBACK;
EXPLAIN (COSTS OFF)SELECT count(*) FROM tenk1 t1 JOIN tenk1 t2 ON t1.ctid = t2.ctid;
SELECT count(*) FROM tenk1 t1 JOIN tenk1 t2 ON t1.ctid = t2.ctid;
SET enable_hashjoin TO off;
EXPLAIN (COSTS OFF)SELECT count(*) FROM tenk1 t1 JOIN tenk1 t2 ON t1.ctid = t2.ctid;
SELECT count(*) FROM tenk1 t1 JOIN tenk1 t2 ON t1.ctid = t2.ctid;
RESET enable_hashjoin;
UPDATE onek   SET unique1 = onek.unique1 + 1;
UPDATE onek   SET unique1 = onek.unique1 - 1;
UPDATE tmp   SET stringu1 = reverse_name(onek.stringu1)   FROM onek   WHERE onek.stringu1 = 'JBAAAA' and	  onek.stringu1 = tmp.stringu1;
UPDATE tmp   SET stringu1 = reverse_name(onek2.stringu1)   FROM onek2   WHERE onek2.stringu1 = 'JCAAAA' and	  onek2.stringu1 = tmp.stringu1;
COPY onek TO '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/onek.data';
DELETE FROM onek;
COPY onek FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/onek.data';
DELETE FROM onek2;
COPY onek2 FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/onek.data';
COPY BINARY stud_emp TO '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/stud_emp.data';
DELETE FROM stud_emp;
COPY BINARY stud_emp FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/stud_emp.data';
SELECT * FROM a_star*;
SELECT *   FROM b_star* x   WHERE x.b = text 'bumble' or x.a < 3;
SELECT class, a   FROM c_star* x   WHERE x.c ~ text 'hi';
SELECT class, b, c   FROM d_star* x   WHERE x.a < 100;
SELECT class, c FROM e_star* x WHERE x.c NOTNULL;
SELECT * FROM f_star* x WHERE x.c ISNULL;
SELECT sum(a) FROM a_star*;
SELECT class, sum(a) FROM a_star* GROUP BY class ORDER BY class;
ALTER TABLE e_star* RENAME COLUMN e TO ee;
ALTER TABLE d_star* RENAME COLUMN d TO dd;
ALTER TABLE c_star* RENAME COLUMN c TO cc;
ALTER TABLE b_star* RENAME COLUMN b TO bb;
ALTER TABLE a_star* RENAME COLUMN a TO aa;
SELECT class, aa   FROM a_star* x   WHERE aa ISNULL;
SELECT class, foo   FROM a_star* x   WHERE x.foo >= 2;
SELECT *   from a_star*   WHERE aa < 1000;
ALTER TABLE f_star ADD COLUMN f int4;
ALTER TABLE e_star* ADD COLUMN e int4;
SELECT * FROM e_star*;
ALTER TABLE a_star* ADD COLUMN a text;
SELECT relname, reltoastrelid <> 0 AS has_toast_table   FROM pg_class   WHERE oid::regclass IN ('a_star', 'c_star')   ORDER BY 1;
SELECT class, aa, a FROM a_star*;
SELECT p.name, name(p.hobbies) FROM ONLY person p;
SELECT p.name, name(p.hobbies) FROM person* p;
SELECT DISTINCT hobbies_r.name, name(hobbies_r.equipment) FROM hobbies_r  ORDER BY 1,2;
SELECT hobbies_r.name, (hobbies_r.equipment).name FROM hobbies_r;
SELECT p.name, name(p.hobbies), name(equipment(p.hobbies)) FROM ONLY person p;
SELECT p.name, name(p.hobbies), name(equipment(p.hobbies)) FROM person* p;
SELECT name(equipment(p.hobbies)), p.name, name(p.hobbies) FROM ONLY person p;
SELECT (p.hobbies).equipment.name, p.name, name(p.hobbies) FROM person* p;
SELECT (p.hobbies).equipment.name, name(p.hobbies), p.name FROM ONLY person p;
SELECT name(equipment(p.hobbies)), name(p.hobbies), p.name FROM person* p;
SELECT name(equipment(hobby_construct(text 'skywalking', text 'mer')));
SELECT name(equipment(hobby_construct_named(text 'skywalking', text 'mer')));
SELECT name(equipment_named(hobby_construct_named(text 'skywalking', text 'mer')));
SELECT name(equipment_named_ambiguous_1a(hobby_construct_named(text 'skywalking', text 'mer')));
SELECT name(equipment_named_ambiguous_1b(hobby_construct_named(text 'skywalking', text 'mer')));
SELECT name(equipment_named_ambiguous_1c(hobby_construct_named(text 'skywalking', text 'mer')));
SELECT name(equipment_named_ambiguous_2a(text 'skywalking'));
SELECT name(equipment_named_ambiguous_2b(text 'skywalking'));
SELECT name, overpaid(emp.*) FROM emp;
SELECT * FROM equipment(ROW('skywalking', 'mer'));
SELECT name(equipment(ROW('skywalking', 'mer')));
SELECT *, name(equipment(h.*)) FROM hobbies_r h;
SELECT *, (equipment(CAST((h.*) AS hobbies_r))).name FROM hobbies_r h;
select;
select distinct from pg_database;
select * from pg_database where nonesuch = pg_database.datname;
select * from pg_database where pg_database.datname = nonesuch;
select distinct on (foobar) * from pg_database;
delete from;
delete from nonesuch;
drop table;
alter table rename;
abort;
end;
create aggregate newavg2 (sfunc = int4pl,			  basetype = int4,			  stype = int4,			  finalfunc = int2um,			  initcond = '0');
create aggregate newcnt1 (sfunc = int4inc,			  stype = int4,			  initcond = '0');
drop index;
drop index 314159;
drop aggregate;
drop aggregate newcnt1;
drop aggregate 314159 (int);
drop aggregate newcnt (nonesuch);
drop aggregate nonesuch (int4);
drop aggregate newcnt (float4);
drop function ();
drop function 314159();
drop function nonesuch();
drop type;
drop type 314159;
drop type nonesuch;
drop operator;
drop operator equals;
drop operator ===;
drop operator int4, int4;
drop operator (int4, int4);
drop operator === ();
drop operator === (int4);
drop operator === (int4, int4);
drop operator = (nonesuch);
drop operator = ( , int4);
drop operator = (nonesuch, int4);
drop operator = (int4, nonesuch);
drop operator = (int4, );
drop rule;
drop rule 314159;
drop rule nonesuch on noplace;
drop tuple rule nonesuch;
drop instance rule nonesuch on noplace;
drop rewrite rule nonesuch;
::select 1::int8/0;
::::select 1::int2/0;
::::select 1::numeric/0;
::select 1/0::numeric;
::select 1::float8/0;
::::select 1::float4/0;
::xxx;
CREATE foo;
CREATE TABLE ;
\CREATE TABLE\gINSERT INTO foo VALUES(123) foo;
INSERT INTO 123VALUES(123);
INSERT INTO fooVALUES(123) 123CREATE TABLE foo  (id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY,	id3 INTEGER NOT NUL,   id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
CREATE TABLE foo(id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY);
CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
CREATETEMPORARYTABLEfoo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,id4 INT4UNIQUENOTNULL,id5 TEXTUNIQUENOTNULL)CREATETEMPORARYTABLEfoo(id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY)CREATETEMPORARYTABLEfoo(idINT4UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,idz INT4 UNIQUE NOT NULL,idv INT4 UNIQUE NOT NULL);
CREATETEMPORARYTABLEfoo(idINT4UNIQUENOTNULLidmINT4UNIQUENOTNULL,idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,idz INT4 UNIQUE NOT NULL,idvINT4UNIQUENOTNULL);
create function infinite_recurse() returns int as'select infinite_recurse()' language sql;
\\set VERBOSITY terseselect infinite_recurse();
CREATE TABLE TIMETZ_TBL (f1 time(2) with time zone);
SELECT f1 + time with time zone '00:01' AS "Illegal" FROM TIMETZ_TBL;
CREATE TABLE INT4_TBL(f1 int4);
SELECT '' AS four, i.* FROM INT4_TBL i WHERE i.f1 <> int2 '0';
SELECT '' AS four, i.* FROM INT4_TBL i WHERE i.f1 <> int4 '0';
SELECT '' AS one, i.* FROM INT4_TBL i WHERE i.f1 = int2 '0';
SELECT '' AS one, i.* FROM INT4_TBL i WHERE i.f1 = int4 '0';
SELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 < int2 '0';
SELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 < int4 '0';
SELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 <= int2 '0';
SELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 <= int4 '0';
SELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 > int2 '0';
SELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 > int4 '0';
SELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 >= int2 '0';
SELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 >= int4 '0';
SELECT '' AS one, i.* FROM INT4_TBL i WHERE (i.f1 % int2 '2') = int2 '1';
SELECT '' AS three, i.* FROM INT4_TBL i WHERE (i.f1 % int4 '2') = int2 '0';
SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL iWHERE abs(f1) < 1073741824;
SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL iWHERE abs(f1) < 1073741824;
SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL iWHERE f1 < 2147483646;
SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL iWHERE f1 < 2147483646;
SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL iWHERE f1 > -2147483647;
SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL iWHERE f1 > -2147483647;
SELECT '' AS five, i.f1, i.f1 / int2 '2' AS x FROM INT4_TBL i;
SELECT '' AS five, i.f1, i.f1 / int4 '2' AS x FROM INT4_TBL i;
SELECT 4-2 AS two;
SELECT int2 '2' * int2 '2' = int2 '16' / int2 '4' AS true;
SELECT int4 '2' * int2 '2' = int2 '16' / int4 '4' AS true;
SELECT int2 '2' * int4 '2' = int4 '16' / int2 '4' AS true;
SELECT int4 '1000' < int4 '999' AS false;
!!!::SELECT (-1::int4<<31)::text;
::SELECT ((-1::int4<<31)+1)::text;
::SELECT (-2147483648)::int4 * (-1)::int4;
::SELECT (-2147483648)::int4 / (-1)::int4;
::SELECT (-2147483648)::int4 % (-1)::int4;
::SELECT (-2147483648)::int4 * (-1)::int2;
::SELECT (-2147483648)::int4 / (-1)::int2;
::SELECT (-2147483648)::int4 % (-1)::int2;
::SELECT x, x::int4 AS int4_valueFROM (VALUES (-2.5::float8),             (-1.5::float8),             (-0.5::float8),             (0.0::float8),             (0.5::float8),             (1.5::float8),             (2.5::float8)) t(x);
::SELECT x, x::int4 AS int4_valueFROM (VALUES (-2.5::numeric),             (-1.5::numeric),             (-0.5::numeric),             (0.0::numeric),             (0.5::numeric),             (1.5::numeric),             (2.5::numeric)) t(x);
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_alter_generic_user1;
DROP ROLE IF EXISTS regress_alter_generic_user2;
DROP ROLE IF EXISTS regress_alter_generic_user3;
RESET client_min_messages;
CREATE USER regress_alter_generic_user3;
CREATE USER regress_alter_generic_user2;
CREATE USER regress_alter_generic_user1 IN ROLE regress_alter_generic_user3;
CREATE SCHEMA alt_nsp1;
CREATE SCHEMA alt_nsp2;
GRANT ALL ON SCHEMA alt_nsp1, alt_nsp2 TO public;
SET search_path = alt_nsp1, public;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql  AS 'SELECT $1 + 1';
CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql  AS 'SELECT $1 - 1';
CREATE AGGREGATE alt_agg1 (  sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 0);
CREATE AGGREGATE alt_agg2 (  sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0);
ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;  -- failed (not aggregate)ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_generic_user3;  -- failed (not aggregate)ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;  -- failed (not aggregate)ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;  -- failed (name conflict)ALTER FUNCTION alt_func1(int) RENAME TO alt_func3;  -- OKALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;  -- OKALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp1;  -- OK, already thereALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;  -- OKALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;   -- failed (name conflict)ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;   -- OKALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;  -- OKALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- OKSET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql  AS 'SELECT $1 + 2';
CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql  AS 'SELECT $1 - 2';
CREATE AGGREGATE alt_agg1 (  sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 100);
CREATE AGGREGATE alt_agg2 (  sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = -100);
ALTER FUNCTION alt_func3(int) RENAME TO alt_func4;	-- failed (not owner)ALTER FUNCTION alt_func1(int) RENAME TO alt_func4;	-- OKALTER FUNCTION alt_func3(int) OWNER TO regress_alter_generic_user2;	-- failed (not owner)ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;	-- failed (no role membership)ALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;      -- failed (not owner)ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;	-- failed (name conflicts)ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;   -- failed (not owner)ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;   -- OKALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER AGGREGATE alt_agg3(int) SET SCHEMA alt_nsp2;  -- failed (not owner)ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- failed (name conflict)RESET SESSION AUTHORIZATION;
SELECT n.nspname, proname, prorettype::regtype, prokind, a.rolname  FROM pg_proc p, pg_namespace n, pg_authid a  WHERE p.pronamespace = n.oid AND p.proowner = a.oid    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')  ORDER BY nspname, proname;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;  -- failed (name conflict)ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;  -- OKALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;  -- OKALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;  -- OKSET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;  -- failed (not owner)ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;  -- OKALTER CONVERSION alt_conv3 OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER CONVERSION alt_conv3 SET SCHEMA alt_nsp2;  -- failed (not owner)ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;  -- failed (name conflict)RESET SESSION AUTHORIZATION;
SELECT n.nspname, c.conname, a.rolname  FROM pg_conversion c, pg_namespace n, pg_authid a  WHERE c.connamespace = n.oid AND c.conowner = a.oid    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')  ORDER BY nspname, conname;
CREATE FOREIGN DATA WRAPPER alt_fdw1;
CREATE FOREIGN DATA WRAPPER alt_fdw2;
CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;  -- failed (name conflict)ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  -- OKALTER SERVER alt_fserv1 RENAME TO alt_fserv2;   -- failed (name conflict)ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   -- OKSELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler;
CREATE LANGUAGE alt_lang2 HANDLER plpgsql_call_handler;
ALTER LANGUAGE alt_lang1 OWNER TO regress_alter_generic_user1;  -- OKALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user2;  -- OKSET SESSION AUTHORIZATION regress_alter_generic_user1;
ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;   -- failed (name conflict)ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;   -- failed (not owner)ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;   -- OKALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user3;  -- failed (not owner)ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user3;  -- OKRESET SESSION AUTHORIZATION;
SELECT lanname, a.rolname  FROM pg_language l, pg_authid a  WHERE l.lanowner = a.oid AND l.lanname like 'alt_lang%'  ORDER BY lanname;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
CREATE OPERATOR @+@ ( leftarg = int4, rightarg = int4, procedure = int4pl );
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user3;  -- OKALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;           -- OKSET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER OPERATOR @-@(int4, int4) OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;   -- failed (not owner)RESET SESSION AUTHORIZATION;
SELECT n.nspname, oprname, a.rolname,    oprleft::regtype, oprright::regtype, oprcode::regproc  FROM pg_operator o, pg_namespace n, pg_authid a  WHERE o.oprnamespace = n.oid AND o.oprowner = a.oid    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')  ORDER BY nspname, oprname;
CREATE OPERATOR FAMILY alt_opf1 USING hash;
CREATE OPERATOR FAMILY alt_opf2 USING hash;
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user1;
CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid;
CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid;
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user1;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;  -- failed (name conflict)ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;  -- OKALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;  -- OKALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- OKALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;  -- failed (name conflict)ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;  -- OKALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;  -- OKALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- OKRESET SESSION AUTHORIZATION;
CREATE OPERATOR FAMILY alt_opf1 USING hash;
CREATE OPERATOR FAMILY alt_opf2 USING hash;
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr;
CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr;
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
SET SESSION AUTHORIZATION regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;	-- failed (not owner)ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;  -- OKALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner)ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;	-- failed (not owner)ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;  -- OKALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner)ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)RESET SESSION AUTHORIZATION;
SELECT nspname, opfname, amname, rolname  FROM pg_opfamily o, pg_am m, pg_namespace n, pg_authid a  WHERE o.opfmethod = m.oid AND o.opfnamespace = n.oid AND o.opfowner = a.oid    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')	AND NOT opfname LIKE 'alt_opc%'  ORDER BY nspname, opfname;
SELECT nspname, opcname, amname, rolname  FROM pg_opclass o, pg_am m, pg_namespace n, pg_authid a  WHERE o.opcmethod = m.oid AND o.opcnamespace = n.oid AND o.opcowner = a.oid    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')  ORDER BY nspname, opcname;
BEGIN TRANSACTION;
CREATE OPERATOR FAMILY alt_opf4 USING btree;
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD  -- int4 vs int2  OPERATOR 1 < (int4, int2) ,  OPERATOR 2 <= (int4, int2) ,  OPERATOR 3 = (int4, int2) ,  OPERATOR 4 >= (int4, int2) ,  OPERATOR 5 > (int4, int2) ,  FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf4 USING btree DROP  -- int4 vs int2  OPERATOR 1 (int4, int2) ,  OPERATOR 2 (int4, int2) ,  OPERATOR 3 (int4, int2) ,  OPERATOR 4 (int4, int2) ,  OPERATOR 5 (int4, int2) ,  FUNCTION 1 (int4, int2) ;
DROP OPERATOR FAMILY alt_opf4 USING btree;
ROLLBACK;
CREATE OPERATOR FAMILY alt_opf4 USING btree;
ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2); -- invalid indexing_methodALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2); -- operator number should be between 1 and 5ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2); -- operator number should be between 1 and 5ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 < ; -- operator without argument typesALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2); -- function number should be between 1 and 5ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2); -- function number should be between 1 and 5ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage; -- Ensure STORAGE is not a part of ALTER OPERATOR FAMILYDROP OPERATOR FAMILY alt_opf4 USING btree;
BEGIN TRANSACTION;
CREATE ROLE regress_alter_generic_user5 NOSUPERUSER;
CREATE OPERATOR FAMILY alt_opf5 USING btree;
SET ROLE regress_alter_generic_user5;
ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
RESET ROLE;
DROP OPERATOR FAMILY alt_opf5 USING btree;
ROLLBACK;
BEGIN TRANSACTION;
CREATE ROLE regress_alter_generic_user6;
CREATE SCHEMA alt_nsp6;
REVOKE ALL ON SCHEMA alt_nsp6 FROM regress_alter_generic_user6;
CREATE OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree;
SET ROLE regress_alter_generic_user6;
ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
ROLLBACK;
CREATE OPERATOR FAMILY alt_opf7 USING btree;
ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < (int4, int2);
ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
DROP OPERATOR FAMILY alt_opf7 USING btree;
CREATE OPERATOR FAMILY alt_opf8 USING btree;
ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < (int4, int4);
DROP OPERATOR FAMILY alt_opf8 USING btree;
CREATE OPERATOR FAMILY alt_opf9 USING gist;
ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
DROP OPERATOR FAMILY alt_opf9 USING gist;
CREATE OPERATOR FAMILY alt_opf10 USING btree;
ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
DROP OPERATOR FAMILY alt_opf10 USING btree;
CREATE OPERATOR FAMILY alt_opf11 USING gist;
ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 (int4, int4);
DROP OPERATOR FAMILY alt_opf11 USING gist;
BEGIN TRANSACTION;
CREATE OPERATOR FAMILY alt_opf12 USING btree;
CREATE FUNCTION fn_opf12  (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
DROP OPERATOR FAMILY alt_opf12 USING btree;
ROLLBACK;
BEGIN TRANSACTION;
CREATE OPERATOR FAMILY alt_opf13 USING hash;
CREATE FUNCTION fn_opf13  (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
DROP OPERATOR FAMILY alt_opf13 USING hash;
ROLLBACK;
BEGIN TRANSACTION;
CREATE OPERATOR FAMILY alt_opf14 USING btree;
CREATE FUNCTION fn_opf14 (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
DROP OPERATOR FAMILY alt_opf14 USING btree;
ROLLBACK;
BEGIN TRANSACTION;
CREATE OPERATOR FAMILY alt_opf15 USING hash;
CREATE FUNCTION fn_opf15 (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;' LANGUAGE SQL;
ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
DROP OPERATOR FAMILY alt_opf15 USING hash;
ROLLBACK;
CREATE OPERATOR FAMILY alt_opf16 USING gist;
ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
DROP OPERATOR FAMILY alt_opf16 USING gist;
CREATE OPERATOR FAMILY alt_opf17 USING btree;
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4); -- operator # appears twice in same statementALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested first-timeALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested again in separate statementALTER OPERATOR FAMILY alt_opf17 USING btree ADD  OPERATOR 1 < (int4, int2) ,  OPERATOR 2 <= (int4, int2) ,  OPERATOR 3 = (int4, int2) ,  OPERATOR 4 >= (int4, int2) ,  OPERATOR 5 > (int4, int2) ,  FUNCTION 1 btint42cmp(int4, int2) ,  FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears twice in same statementALTER OPERATOR FAMILY alt_opf17 USING btree ADD  OPERATOR 1 < (int4, int2) ,  OPERATOR 2 <= (int4, int2) ,  OPERATOR 3 = (int4, int2) ,  OPERATOR 4 >= (int4, int2) ,  OPERATOR 5 > (int4, int2) ,  FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears first timeALTER OPERATOR FAMILY alt_opf17 USING btree ADD  OPERATOR 1 < (int4, int2) ,  OPERATOR 2 <= (int4, int2) ,  OPERATOR 3 = (int4, int2) ,  OPERATOR 4 >= (int4, int2) ,  OPERATOR 5 > (int4, int2) ,  FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 requested again in separate statementDROP OPERATOR FAMILY alt_opf17 USING btree;
CREATE OPERATOR FAMILY alt_opf18 USING btree;
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
ALTER OPERATOR FAMILY alt_opf18 USING btree ADD  OPERATOR 1 < (int4, int2) ,  OPERATOR 2 <= (int4, int2) ,  OPERATOR 3 = (int4, int2) ,  OPERATOR 4 >= (int4, int2) ,  OPERATOR 5 > (int4, int2) ,  FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
DROP OPERATOR FAMILY alt_opf18 USING btree;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_1;
ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;   -- failed (name conflict)ALTER STATISTICS alt_stat1 RENAME TO alt_stat3;   -- failed (name conflict)ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;  -- OKALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;    -- OKSET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_2;
CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_2;
ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;    -- failed (not owner)ALTER STATISTICS alt_stat1 RENAME TO alt_stat4;    -- OKALTER STATISTICS alt_stat3 OWNER TO regress_alter_generic_user2; -- failed (not owner)ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3; -- failed (no role membership)ALTER STATISTICS alt_stat3 SET SCHEMA alt_nsp2;		-- failed (not owner)ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;		-- failed (name conflict)RESET SESSION AUTHORIZATION;
SELECT nspname, stxname, rolname  FROM pg_statistic_ext s, pg_namespace n, pg_authid a WHERE s.stxnamespace = n.oid AND s.stxowner = a.oid   AND n.nspname in ('alt_nsp1', 'alt_nsp2') ORDER BY nspname, stxname;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;  -- failed (name conflict)ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;  -- OKALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;  -- OKALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;  -- OKSET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;  -- failed (not owner)ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;  -- OKALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 SET SCHEMA alt_nsp2;  -- failed (not owner)ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;  -- failed (name conflict)RESET SESSION AUTHORIZATION;
SELECT nspname, dictname, rolname  FROM pg_ts_dict t, pg_namespace n, pg_authid a  WHERE t.dictnamespace = n.oid AND t.dictowner = a.oid    AND n.nspname in ('alt_nsp1', 'alt_nsp2')  ORDER BY nspname, dictname;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;  -- failed (name conflict)ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;  -- OKALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user2;  -- failed (no role membership)ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;  -- OKALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- OKSET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;  -- failed (not owner)ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;  -- OKALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_generic_user2;  -- failed (not owner)ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;  -- failed (no role membership)ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;  -- failed (not owner)ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- failed (name conflict)RESET SESSION AUTHORIZATION;
SELECT nspname, cfgname, rolname  FROM pg_ts_config t, pg_namespace n, pg_authid a  WHERE t.cfgnamespace = n.oid AND t.cfgowner = a.oid    AND n.nspname in ('alt_nsp1', 'alt_nsp2')  ORDER BY nspname, cfgname;
CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2; -- failed (name conflict)ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3; -- OKALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- OKCREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- failed (name conflict)CREATE TEXT SEARCH TEMPLATE tstemp_case ("Init" = init_function);
SELECT nspname, tmplname  FROM pg_ts_template t, pg_namespace n  WHERE t.tmplnamespace = n.oid AND nspname like 'alt_nsp%'  ORDER BY nspname, tmplname;
CREATE TEXT SEARCH PARSER alt_ts_prs1    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
CREATE TEXT SEARCH PARSER alt_ts_prs2    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2; -- failed (name conflict)ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3; -- OKALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- OKCREATE TEXT SEARCH PARSER alt_ts_prs2    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- failed (name conflict)CREATE TEXT SEARCH PARSER tspars_case ("Start" = start_function);
SELECT nspname, prsname  FROM pg_ts_parser t, pg_namespace n  WHERE t.prsnamespace = n.oid AND nspname like 'alt_nsp%'  ORDER BY nspname, prsname;
DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE;
DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
DROP LANGUAGE alt_lang2 CASCADE;
DROP LANGUAGE alt_lang3 CASCADE;
DROP SCHEMA alt_nsp1 CASCADE;
DROP SCHEMA alt_nsp2 CASCADE;
DROP USER regress_alter_generic_user1;
DROP USER regress_alter_generic_user2;
DROP USER regress_alter_generic_user3;
CREATE TABLE num_data (id int4, val numeric(1000,800));
CREATE TABLE num_exp_add (id1 int4, id2 int4, expected numeric(1000,800));
CREATE TABLE num_exp_sub (id1 int4, id2 int4, expected numeric(1000,800));
CREATE TABLE num_exp_div (id1 int4, id2 int4, expected numeric(1000,800));
CREATE TABLE num_exp_mul (id1 int4, id2 int4, expected numeric(1000,800));
CREATE TABLE num_exp_sqrt (id int4, expected numeric(1000,800));
CREATE TABLE num_exp_ln (id int4, expected numeric(1000,800));
CREATE TABLE num_exp_log10 (id int4, expected numeric(1000,800));
CREATE TABLE num_exp_power_10_ln (id int4, expected numeric(1000,800));
CREATE TABLE num_result (id1 int4, id2 int4, result numeric(1000,800));
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
VACUUM ANALYZE num_exp_add;
VACUUM ANALYZE num_exp_sub;
VACUUM ANALYZE num_exp_div;
VACUUM ANALYZE num_exp_mul;
VACUUM ANALYZE num_exp_sqrt;
VACUUM ANALYZE num_exp_ln;
VACUUM ANALYZE num_exp_log10;
VACUUM ANALYZE num_exp_power_10_ln;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val + t2.val    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_add t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val + t2.val, 10)    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 10) as expected    FROM num_result t1, num_exp_add t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 10);
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val - t2.val    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_sub t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val - t2.val, 40)    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 40)    FROM num_result t1, num_exp_sub t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 40);
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val * t2.val    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_mul t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val * t2.val, 30)    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 30) as expected    FROM num_result t1, num_exp_mul t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 30);
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val / t2.val    FROM num_data t1, num_data t2    WHERE t2.val != '0.0';
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_div t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val / t2.val, 80)    FROM num_data t1, num_data t2    WHERE t2.val != '0.0';
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 80) as expected    FROM num_result t1, num_exp_div t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 80);
DELETE FROM num_result;
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_sqrt t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
DELETE FROM num_result;
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_ln t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
DELETE FROM num_result;
::INSERT INTO num_result SELECT id, 0, LOG('10'::numeric, ABS(val))    FROM num_data    WHERE val != '0.0';
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_log10 t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT id, 0, POW(numeric '10', LN(ABS(round(val,1000))))    FROM num_data    WHERE val != '0.0';
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_power_10_ln t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
WITH t(b, p, bc_result) AS (VALUES(0.084738, -20, 2744326694304960114888.7859130502035257),(0.084738, -19, 232548755422013710215.4459407000481464),(0.084738, -18, 19705716436950597776.2364581230406798),(0.084738, -17, 1669822999434319754.3627249884302211),(0.084738, -16, 141497461326065387.3451885900696001),(0.084738, -15, 11990211877848128.7928565907453178),(0.084738, -14, 1016026574105094.7376490817865767),(0.084738, -13, 86096059836517.5178789078924309),(0.084738, -12, 7295607918426.8214300228969888),(0.084738, -11, 618215223791.6519943372802450),(0.084738, -10, 52386321633.6570066961524534),(0.084738, -9, 4439112122.5928274334185666),(0.084738, -8, 376161483.0442710110530225),(0.084738, -7, 31875171.7502054369346110),(0.084738, -6, 2701038.3037689083149651),(0.084738, -5, 228880.5837847697527935),(0.084738, -4, 19394.8829087538193122),(0.084738, -3, 1643.4835879219811409),(0.084738, -2, 139.2655122733328379),(0.084738, -1, 11.8010809790176780),(0.084738, 0, 1),(0.084738, 1, .084738),(0.084738, 2, .007180528644),(0.084738, 3, .0006084636362353),(0.084738, 4, .0000515599916073),(0.084738, 5, .0000043690905688),(0.084738, 6, .0000003702279966),(0.084738, 7, .0000000313723800),(0.084738, 8, .0000000026584327),(0.084738, 9, .0000000002252703),(0.084738, 10, .0000000000190890),(0.084738, 11, .0000000000016176),(0.084738, 12, .0000000000001371),(0.084738, 13, .0000000000000116),(0.084738, 14, .0000000000000010),(0.084738, 15, .0000000000000001),(0.084738, 16, .0000000000000000),(0.084738, 17, .0000000000000000),(0.084738, 18, .0000000000000000),(0.084738, 19, .0000000000000000),(0.084738, 20, .0000000000000000))SELECT b, p, bc_result, b^p AS power, b^p - bc_result AS diff FROM t;
WITH t(b, p, bc_result) AS (VALUES(37.821637, -20, .0000000000000000),(37.821637, -19, .0000000000000000),(37.821637, -18, .0000000000000000),(37.821637, -17, .0000000000000000),(37.821637, -16, .0000000000000000),(37.821637, -15, .0000000000000000),(37.821637, -14, .0000000000000000),(37.821637, -13, .0000000000000000),(37.821637, -12, .0000000000000000),(37.821637, -11, .0000000000000000),(37.821637, -10, .0000000000000002),(37.821637, -9, .0000000000000063),(37.821637, -8, .0000000000002388),(37.821637, -7, .0000000000090327),(37.821637, -6, .0000000003416316),(37.821637, -5, .0000000129210673),(37.821637, -4, .0000004886959182),(37.821637, -3, .0000184832796213),(37.821637, -2, .0006990678924066),(37.821637, -1, .0264398920649574),(37.821637, 0, 1),(37.821637, 1, 37.821637),(37.821637, 2, 1430.476225359769),(37.821637, 3, 54102.9525326873775219),(37.821637, 4, 2046262.2313195326271135),(37.821637, 5, 77392987.3197773940323425),(37.821637, 6, 2927129472.7542235178972258),(37.821637, 7, 110708828370.5116321107718772),(37.821637, 8, 4187189119324.7924539711577286),(37.821637, 9, 158366346921451.9852944363360812),(37.821637, 10, 5989674486279224.5007355092228730),(37.821637, 11, 226539294168214309.7083246628376531),(37.821637, 12, 8568086950266418559.9938312759931069),(37.821637, 13, 324059074417413536066.1494087598581043),(37.821637, 14, 12256444679171401239980.3109258799733927),(37.821637, 15, 463558801566202198479885.2069857662592280),(37.821637, 16, 17532552720991931019508170.1002855156233684),(37.821637, 17, 663109844696719094948877928.0672523682648687),(37.821637, 18, 25079899837245684700124994552.6717306599041850),(37.821637, 19, 948562867640665366544581398598.1275771806665398),(37.821637, 20, 35876200451584291931921101974730.6901038166532866))SELECT b, p, bc_result, b^p AS power, b^p - bc_result AS diff FROM t;
WITH t(b, p, bc_result) AS (VALUES(0.06933247, -20.342987, 379149253615977128356318.39406340),(0.06933247, -19.342987, 26287354251852125772450.59436685),(0.06933247, -18.342987, 1822567200045909954554.65766042),(0.06933247, -17.342987, 126363085720167050546.86216560),(0.06933247, -16.342987, 8761064849800910427.02880469),(0.06933247, -15.342987, 607426265866876128.15466179),(0.06933247, -14.342987, 42114363355427213.14899924),(0.06933247, -13.342987, 2919892833909256.59283660),(0.06933247, -12.342987, 202443382310228.51544515),(0.06933247, -11.342987, 14035899730722.44924025),(0.06933247, -10.342987, 973143597003.32229028),(0.06933247, -9.342987, 67470449244.92493259),(0.06933247, -8.342987, 4677892898.16028054),(0.06933247, -7.342987, 324329869.02491071),(0.06933247, -6.342987, 22486590.914273551),(0.06933247, -5.342987, 1559050.8899661435),(0.06933247, -4.342987, 108092.84905705095),(0.06933247, -3.342987, 7494.3442144625131),(0.06933247, -2.342987, 519.60139541889576),(0.06933247, -1.342987, 36.025248159838727),(0.06933247, 0.342987, .40036522320023350),(0.06933247, 1.342987, .02775830982657349),(0.06933247, 2.342987, .001924552183301612),(0.06933247, 3.342987, .0001334339565121935),(0.06933247, 4.342987, .000009251305786862961),(0.06933247, 5.342987, .0000006414158809285026),(0.06933247, 6.342987, .00000004447094732199898),(0.06933247, 7.342987, .000000003083280621074075),(0.06933247, 8.342987, .0000000002137714611621997),(0.06933247, 9.342987, .00000000001482130341788437),(0.06933247, 10.342987, .000000000001027597574581366),(0.06933247, 11.342987, .00000000000007124587801173530),(0.06933247, 12.342987, .000000000000004939652699872298),(0.06933247, 13.342987, .0000000000000003424783226243151),(0.06933247, 14.342987, .00000000000000002374486802900065),(0.06933247, 15.342987, .000000000000000001646290350274646),(0.06933247, 16.342987, .0000000000000000001141413763217064),(0.06933247, 17.342987, .000000000000000000007913703549583420),(0.06933247, 18.342987, .0000000000000000000005486766139403860),(0.06933247, 19.342987, .00000000000000000000003804110487572339),(0.06933247, 20.342987, .000000000000000000000002637483762562946))SELECT b, p, bc_result, b^p AS power, b^p - bc_result AS diff FROM t;
WITH t(b, p, bc_result) AS (VALUES(27.234987, -20.230957, .000000000000000000000000000009247064512095633),(27.234987, -19.230957, .0000000000000000000000000002518436817750859),(27.234987, -18.230957, .000000000000000000000000006858959399176602),(27.234987, -17.230957, .0000000000000000000000001868036700701026),(27.234987, -16.230957, .000000000000000000000005087595525911532),(27.234987, -15.230957, .0000000000000000000001385605980094587),(27.234987, -14.230957, .000000000000000000003773696085499835),(27.234987, -13.230957, .0000000000000000001027765638305389),(27.234987, -12.230957, .000000000000000002799118379829397),(27.234987, -11.230957, .00000000000000007623395268611469),(27.234987, -10.230957, .000000000000002076230710364949),(27.234987, -9.230957, .00000000000005654611640579014),(27.234987, -8.230957, .000000000001540032745212181),(27.234987, -7.230957, .00000000004194277179542807),(27.234987, -6.230957, .000000001142310844592450),(27.234987, -5.230957, .00000003111082100243440),(27.234987, -4.230957, .0000008473028055606278),(27.234987, -3.230957, .00002307628089450723),(27.234987, -2.230957, .0006284822101702527),(27.234987, -1.230957, .01711670482371810),(27.234987, 0.230957, 2.1451253063142300),(27.234987, 1.230957, 58.422459830839071),(27.234987, 2.230957, 1591.1349340009243),(27.234987, 3.230957, 43334.539242761031),(27.234987, 4.230957, 1180215.6129275865),(27.234987, 5.230957, 32143156.875279851),(27.234987, 6.230957, 875418459.63720737),(27.234987, 7.230957, 23842010367.779367),(27.234987, 8.230957, 649336842420.336290),(27.234987, 9.230957, 17684680461938.907402),(27.234987, 10.230957, 481642042480060.137900),(27.234987, 11.230957, 13117514765597885.614921),(27.234987, 12.230957, 357255344113366461.949871),(27.234987, 13.230957, 9729844652608062117.440722),(27.234987, 14.230957, 264992192625800087863.690528),(27.234987, 15.230957, 7217058921265161257566.469315),(27.234987, 16.230957, 196556505898890690402726.443417),(27.234987, 17.230957, 5353213882921711267539279.451015),(27.234987, 18.230957, 145794710509592328389185797.837767),(27.234987, 19.230957, 3970717045397510438979206144.696206),(27.234987, 20.230957, 108142427112079606637962972621.121293))SELECT b, p, bc_result, b^p AS power, b^p - bc_result AS diff FROM t;
WITH t(b, p, bc_result) AS (VALUES(0.12, -2829.8369, 58463948950011752465280493160293790845494328939320966633018493248607815580903065923369555885857984675501574162389726507612128133630191173383130639968378879506624785786843501848666498440326970769604109017960864573408272864266102690849952650095786874354625921641729880352858506454246180842452983243549491658464046163869265572232996388827878976066830374513768599285647145439771472435206769249126377164951470622827631950210853282324510655982757098065657709137845327135766013147354253426364240746381620690117663724329288646510198895137275207992825719846135857839292915100523542874885080351683587865157015032404901182924720371819942957083390475846809517968191151435281268695782594904484795360890092607679215675240583291240729468370895035823777914792823688291214492607109455017754453939895630226174304357121900605689015734289765672740769194115142607443713769825894380064727556869268488695795705030158832909348803019429370973064732712469794182891757241046263341655894972953512257981661670321890336672832647028099324621932563236459127918144141230217523147304565594514812518826936144181257723061181656522095236928347413997136815409159361412494284201481609684892562646522086577634100783077813105675590737823924220663206479031113753135119759722725207724879578900186075841393115040465401462266086907464970054073340036852442184414587772177753008511913377364966775792477387717262694468450099866775550614257191941835797445874557362115814601886902749237439492398087966544817154173072811937702110580330775581851211123491341435883319798273456296794954514173820352334127081705706502510709179711510240917772628308487366740741280043704807717608366220401933596364641284631036907635403895053036499618723044314773148779735006542501244942039455169872946018271985844759209768927953340447524637670938413827595013338859796135512187473850161303598087634723542727044978083220970836296653305188470017342167913572166172051819741354902582606590658382067039498769674611071582171914886494269818475850690414812481252963932223686078322390396586222238852602472958831686564971334200490182175112490433364675164900946902818404704835106260174052265784055642968397240262737313737007322288203637798365320295080314524864099419556398713380156353062937736280885716820226469419928595465390700629307079710611273715705695938635644841913194091407807776191951797748706106000922803167645881087385311847268311361092838264814899353459146959869764278464187826798546290981492648723002412475976344071283321798061003719251864595518596639432393032991023409676558943539937377229130132816883146259468718344018277257037013406135980469482324577407154032999045733141275895.3432),(1.2, 32908.8896, 58463467728170833376633133695001863276259293590926929026251227859007891876739460057725441400966420577009060860805883032969522911803372870882799865787473726926215148161529632590083389287080925059682489116446754279752928005457087175157581627230586554364417068189211136840990661174760199073702207450133797324318403866058202372178813998850887986769280847189341565507156189065295823921162851958925352114220880236114784962150135485415106748467247897246441194126125699204912883449386043559785865023459356275014504597646990160571664166410683323036984805434677654413174177920726210827006973855410386789516533036723888687725436216478665958434776205940192130053647653715221076841771578099896259902368829351569726536927952661429685419815305418450230567773264738536471211804481206474781470237730069753206249915908804615495060673071058534441654604668770343616386612119048579369195201590008082689834456232255266932976831478404670192731621439902738547169253818323045451045749609624500171633897705543164388470746657118050314064066768449450440405619135824055131398727045420324382226572368236570500391463795989258779677208133531636928003546809249007993065200108076924439703799231711400266122025052209803513232429907231051873161206025860851056337427740362763618748092029386371493898291580557004812947013231371383576580415676519066503391905962989205397824064923920045371823949776899815750413244195402085917098964452866825666226141169411712884994564949174271056284898570445214367063763956186792886147126466387576513166370247576466566827375268334148320298849218878848928271566491769458471357076035396330179659440244425914213309776100351793665960978678576150833311810944729586040624059867137538839913141142139636023129691775489034134511666020819676247950267220131499463010350308195762769192775344260909521732256844149916046793599150786757764962585268686580124987490115873389726527572428003433405659445349155536369077209682951123806333170190998931670309088422483075609203671527331975811507450670132060984691061148836994322505371265263690017938762760088575875666254883673433331627055180154954694693433502522592907190906966067656027637884202418119121728966267936832338377284832958974299187166554160783467156478554899314000348357280306042140481751668215838656488457943830180819301102535170705017482946779698265096226184239631924271857062033454725540956591929965181603262502135610768915716020374362368495244256420143645126927013882334008435586481691725030031204304273292938132599127402133470745819213047706793887965197191137237066440328777206799072470374264316425913530947082957300047105685634407092811630672103242089966046839626911122.7149))SELECT b, p, bc_result, b^p AS power, b^p - bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES(-20.29837, .000000001529431101152222),(-19.29837, .000000004157424770142192),(-18.29837, .00000001130105220586304),(-17.29837, .00000003071944485366452),(-16.29837, .00000008350410872606600),(-15.29837, .0000002269877013517336),(-14.29837, .0000006170165438681061),(-13.29837, .000001677224859055276),(-12.29837, .000004559169856609741),(-11.29837, .00001239310857408049),(-10.29837, .00003368796183504298),(-9.29837, .00009157337449401917),(-8.29837, .0002489222398577673),(-7.29837, .0006766408013046928),(-6.29837, .001839300394580514),(-5.29837, .004999736839665763),(-4.29837, .01359069379834070),(-3.29837, .03694333598818056),(-2.29837, .1004223988993283),(-1.29837, .2729763820983097),(0.29837, 1.3476603299656679),(1.29837, 3.6633205858807959),(2.29837, 9.9579377804197108),(3.29837, 27.068481317440698),(4.29837, 73.579760889182206),(5.29837, 200.01052696742555),(6.29837, 543.68498095607070),(7.29837, 1477.8890041389891),(8.29837, 4017.3188244304487),(9.29837, 10920.204759575742),(10.29837, 29684.194161006717),(11.29837, 80690.005580314652),(12.29837, 219338.17590722828),(13.29837, 596222.97785597218),(14.29837, 1620702.0864156289),(15.29837, 4405525.0308492653),(16.29837, 11975458.636179032),(17.29837, 32552671.598188404),(18.29837, 88487335.673150406),(19.29837, 240533516.60908059),(20.29837, 653837887.33381570))SELECT x, bc_result, exp(x), exp(x)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('1.0e-1', -2.3025850929940457),('1.0e-2', -4.6051701859880914),('1.0e-3', -6.9077552789821371),('1.0e-4', -9.2103403719761827),('1.0e-5', -11.512925464970228),('1.0e-6', -13.815510557964274),('1.0e-7', -16.118095650958320),('1.0e-8', -18.420680743952365),('1.0e-9', -20.723265836946411),('1.0e-10', -23.025850929940457),('1.0e-11', -25.328436022934503),('1.0e-12', -27.631021115928548),('1.0e-13', -29.933606208922594),('1.0e-14', -32.236191301916640),('1.0e-15', -34.5387763949106853),('1.0e-16', -36.84136148790473094),('1.0e-17', -39.143946580898776628),('1.0e-18', -41.4465316738928223123),('1.0e-19', -43.74911676688686799634),('1.0e-20', -46.051701859880913680360),('1.0e-21', -48.3542869528749593643778),('1.0e-22', -50.65687204586900504839581),('1.0e-23', -52.959457138863050732413803),('1.0e-24', -55.2620422318570964164317949),('1.0e-25', -57.56462732485114210044978637),('1.0e-26', -59.867212417845187784467777822),('1.0e-27', -62.1697975108392334684857692765),('1.0e-28', -64.47238260383327915250376073116),('1.0e-29', -66.774967696827324836521752185847),('1.0e-30', -69.0775527898213705205397436405309),('1.0e-31', -71.38013788281541620455773509521529),('1.0e-32', -73.682722975809461888575726549899655),('1.0e-33', -75.9853080688035075725937180045840189),('1.0e-34', -78.28789316179755325661170945926838306),('1.0e-35', -80.590478254791598940629700913952747266),('1.0e-36', -82.8930633477856446246476923686371114736),('1.0e-37', -85.19564844077969030866568382332147568124),('1.0e-38', -87.498233533773735992683675278005839888842),('1.0e-39', -89.8008186267677816767016667326902040964430),('1.0e-40', -92.10340371976182736071965818737456830404406))SELECT x, bc_result, ln(x::numeric), ln(x::numeric)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('1.0e-1', -.10536051565782630),('1.0e-2', -.010050335853501441),('1.0e-3', -.0010005003335835335),('1.0e-4', -.00010000500033335834),('1.0e-5', -.000010000050000333336),('1.0e-6', -.0000010000005000003333),('1.0e-7', -.00000010000000500000033),('1.0e-8', -.000000010000000050000000),('1.0e-9', -.0000000010000000005000000),('1.0e-10', -.00000000010000000000500000),('1.0e-11', -.000000000010000000000050000),('1.0e-12', -.0000000000010000000000005000),('1.0e-13', -.00000000000010000000000000500),('1.0e-14', -.000000000000010000000000000050),('1.0e-15', -.0000000000000010000000000000005),('1.0e-16', -.00000000000000010000000000000001),('1.0e-17', -.000000000000000010000000000000000),('1.0e-18', -.0000000000000000010000000000000000),('1.0e-19', -.00000000000000000010000000000000000),('1.0e-20', -.000000000000000000010000000000000000),('1.0e-21', -.0000000000000000000010000000000000000),('1.0e-22', -.00000000000000000000010000000000000000),('1.0e-23', -.000000000000000000000010000000000000000),('1.0e-24', -.0000000000000000000000010000000000000000),('1.0e-25', -.00000000000000000000000010000000000000000),('1.0e-26', -.000000000000000000000000010000000000000000),('1.0e-27', -.0000000000000000000000000010000000000000000),('1.0e-28', -.00000000000000000000000000010000000000000000),('1.0e-29', -.000000000000000000000000000010000000000000000),('1.0e-30', -.0000000000000000000000000000010000000000000000),('1.0e-31', -.00000000000000000000000000000010000000000000000),('1.0e-32', -.000000000000000000000000000000010000000000000000),('1.0e-33', -.0000000000000000000000000000000010000000000000000),('1.0e-34', -.00000000000000000000000000000000010000000000000000),('1.0e-35', -.000000000000000000000000000000000010000000000000000),('1.0e-36', -.0000000000000000000000000000000000010000000000000000),('1.0e-37', -.00000000000000000000000000000000000010000000000000000),('1.0e-38', -.000000000000000000000000000000000000010000000000000000),('1.0e-39', -.0000000000000000000000000000000000000010000000000000000),('1.0e-40', -.00000000000000000000000000000000000000010000000000000000))SELECT '1-'||x, bc_result, ln(1.0-x::numeric), ln(1.0-x::numeric)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('1.0e-1', .09531017980432486),('1.0e-2', .009950330853168083),('1.0e-3', .0009995003330835332),('1.0e-4', .00009999500033330834),('1.0e-5', .000009999950000333331),('1.0e-6', .0000009999995000003333),('1.0e-7', .00000009999999500000033),('1.0e-8', .000000009999999950000000),('1.0e-9', .0000000009999999995000000),('1.0e-10', .00000000009999999999500000),('1.0e-11', .000000000009999999999950000),('1.0e-12', .0000000000009999999999995000),('1.0e-13', .00000000000009999999999999500),('1.0e-14', .000000000000009999999999999950),('1.0e-15', .0000000000000009999999999999995),('1.0e-16', .00000000000000010000000000000000),('1.0e-17', .000000000000000010000000000000000),('1.0e-18', .0000000000000000010000000000000000),('1.0e-19', .00000000000000000010000000000000000),('1.0e-20', .000000000000000000010000000000000000),('1.0e-21', .0000000000000000000010000000000000000),('1.0e-22', .00000000000000000000010000000000000000),('1.0e-23', .000000000000000000000010000000000000000),('1.0e-24', .0000000000000000000000010000000000000000),('1.0e-25', .00000000000000000000000010000000000000000),('1.0e-26', .000000000000000000000000010000000000000000),('1.0e-27', .0000000000000000000000000010000000000000000),('1.0e-28', .00000000000000000000000000010000000000000000),('1.0e-29', .000000000000000000000000000010000000000000000),('1.0e-30', .0000000000000000000000000000010000000000000000),('1.0e-31', .00000000000000000000000000000010000000000000000),('1.0e-32', .000000000000000000000000000000010000000000000000),('1.0e-33', .0000000000000000000000000000000010000000000000000),('1.0e-34', .00000000000000000000000000000000010000000000000000),('1.0e-35', .000000000000000000000000000000000010000000000000000),('1.0e-36', .0000000000000000000000000000000000010000000000000000),('1.0e-37', .00000000000000000000000000000000000010000000000000000),('1.0e-38', .000000000000000000000000000000000000010000000000000000),('1.0e-39', .0000000000000000000000000000000000000010000000000000000),('1.0e-40', .00000000000000000000000000000000000000010000000000000000))SELECT '1+'||x, bc_result, ln(1.0+x::numeric), ln(1.0+x::numeric)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('1.0e1', 2.3025850929940457),('1.0e2', 4.6051701859880914),('1.0e3', 6.9077552789821371),('1.0e4', 9.2103403719761827),('1.0e5', 11.512925464970228),('1.0e6', 13.815510557964274),('1.0e7', 16.118095650958320),('1.0e8', 18.420680743952365),('1.0e9', 20.723265836946411),('1.0e10', 23.025850929940457),('1.0e11', 25.328436022934503),('1.0e12', 27.631021115928548),('1.0e13', 29.933606208922594),('1.0e14', 32.236191301916640),('1.0e15', 34.538776394910685),('1.0e16', 36.841361487904731),('1.0e17', 39.143946580898777),('1.0e18', 41.446531673892822),('1.0e19', 43.749116766886868),('1.0e20', 46.051701859880914),('1.0e21', 48.354286952874959),('1.0e22', 50.656872045869005),('1.0e23', 52.959457138863051),('1.0e24', 55.262042231857096),('1.0e25', 57.564627324851142),('1.0e26', 59.867212417845188),('1.0e27', 62.169797510839233),('1.0e28', 64.472382603833279),('1.0e29', 66.774967696827325),('1.0e30', 69.077552789821371),('1.0e31', 71.380137882815416),('1.0e32', 73.682722975809462),('1.0e33', 75.985308068803508),('1.0e34', 78.287893161797553),('1.0e35', 80.590478254791599),('1.0e36', 82.893063347785645),('1.0e37', 85.195648440779690),('1.0e38', 87.498233533773736),('1.0e39', 89.800818626767782),('1.0e40', 92.103403719761827))SELECT x, bc_result, ln(x::numeric), ln(x::numeric)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('1.0e100', 230.25850929940457),('1.0e200', 460.51701859880914),('1.0e300', 690.77552789821371),('1.0e400', 921.03403719761827),('1.0e500', 1151.2925464970228),('1.0e600', 1381.5510557964274),('1.0e700', 1611.8095650958320),('1.0e800', 1842.0680743952365),('1.0e900', 2072.3265836946411),('1.0e1000', 2302.5850929940457))SELECT x, bc_result, ln(x::numeric), ln(x::numeric)-bc_result AS diff FROM t;
||WITH t(x) AS (SELECT '1e-'||n FROM generate_series(1, 100) g(n))SELECT x, log(x::numeric) FROM t;
WITH t(x, bc_result) AS (VALUES('9.0e-1', -.04575749056067513),('6.0e-1', -.2218487496163564),('3.0e-1', -.5228787452803376),('9.0e-8', -7.045757490560675),('6.0e-8', -7.221848749616356),('3.0e-8', -7.522878745280338),('9.0e-15', -14.0457574905606751),('6.0e-15', -14.2218487496163564),('3.0e-15', -14.5228787452803376),('9.0e-22', -21.04575749056067512540994),('6.0e-22', -21.22184874961635636749123),('3.0e-22', -21.52287874528033756270497),('9.0e-29', -28.045757490560675125409944193490),('6.0e-29', -28.221848749616356367491233202020),('3.0e-29', -28.522878745280337562704972096745),('9.0e-36', -35.0457574905606751254099441934897693816),('6.0e-36', -35.2218487496163563674912332020203916640),('3.0e-36', -35.5228787452803375627049720967448846908),('9.0e-43', -42.04575749056067512540994419348976938159974227),('6.0e-43', -42.22184874961635636749123320202039166403168125),('3.0e-43', -42.52287874528033756270497209674488469079987114),('9.0e-50', -49.045757490560675125409944193489769381599742271618608),('6.0e-50', -49.221848749616356367491233202020391664031681254347196),('3.0e-50', -49.522878745280337562704972096744884690799871135809304))SELECT x, bc_result, log(x::numeric), log(x::numeric)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('9.0e-1', -1.0000000000000000),('6.0e-1', -.3979400086720376),('3.0e-1', -.1549019599857432),('9.0e-8', -.000000039086505130185422),('6.0e-8', -.000000026057669695925208),('3.0e-8', -.000000013028834652530076),('9.0e-15', -.0000000000000039086503371292840),('6.0e-15', -.0000000000000026057668914195188),('3.0e-15', -.0000000000000013028834457097574),('9.0e-22', -.00000000000000000000039086503371292664),('6.0e-22', -.00000000000000000000026057668914195110),('3.0e-22', -.00000000000000000000013028834457097555),('9.0e-29', -.000000000000000000000000000039086503371292664),('6.0e-29', -.000000000000000000000000000026057668914195110),('3.0e-29', -.000000000000000000000000000013028834457097555),('9.0e-36', -.0000000000000000000000000000000000039086503371292664),('6.0e-36', -.0000000000000000000000000000000000026057668914195110),('3.0e-36', -.0000000000000000000000000000000000013028834457097555))SELECT '1-'||x, bc_result, log(1.0-x::numeric), log(1.0-x::numeric)-bc_result AS diff FROM t;
WITH t(x, bc_result) AS (VALUES('9.0e-1', .2787536009528290),('6.0e-1', .2041199826559248),('3.0e-1', .1139433523068368),('9.0e-8', .000000039086501612400118),('6.0e-8', .000000026057668132465074),('3.0e-8', .000000013028834261665042),('9.0e-15', .0000000000000039086503371292489),('6.0e-15', .0000000000000026057668914195031),('3.0e-15', .0000000000000013028834457097535),('9.0e-22', .00000000000000000000039086503371292664),('6.0e-22', .00000000000000000000026057668914195110),('3.0e-22', .00000000000000000000013028834457097555),('9.0e-29', .000000000000000000000000000039086503371292664),('6.0e-29', .000000000000000000000000000026057668914195110),('3.0e-29', .000000000000000000000000000013028834457097555),('9.0e-36', .0000000000000000000000000000000000039086503371292664),('6.0e-36', .0000000000000000000000000000000000026057668914195110),('3.0e-36', .0000000000000000000000000000000000013028834457097555))SELECT '1+'||x, bc_result, log(1.0+x::numeric), log(1.0+x::numeric)-bc_result AS diff FROM t;
||WITH t(x) AS (SELECT '1e'||n FROM generate_series(1, 100) g(n))SELECT x, log(x::numeric) FROM t;
WITH t(x, bc_result) AS (VALUES('2.0e10', 10.301029995663981),('5.0e10', 10.698970004336019),('8.0e10', 10.903089986991944),('2.0e17', 17.301029995663981),('5.0e17', 17.698970004336019),('8.0e17', 17.903089986991944),('2.0e24', 24.301029995663981),('5.0e24', 24.698970004336019),('8.0e24', 24.903089986991944),('2.0e31', 31.301029995663981),('5.0e31', 31.698970004336019),('8.0e31', 31.903089986991944),('2.0e38', 38.301029995663981),('5.0e38', 38.698970004336019),('8.0e38', 38.903089986991944),('2.0e45', 45.30102999566398),('5.0e45', 45.69897000433602),('8.0e45', 45.90308998699194))SELECT x, bc_result, log(x::numeric), log(x::numeric)-bc_result AS diff FROM t;
create unique index Room_rno on Room using btree (roomno bpchar_ops);
create unique index WSlot_name on WSlot using btree (slotname bpchar_ops);
create unique index PField_name on PField using btree (name text_ops);
create unique index PSlot_name on PSlot using btree (slotname bpchar_ops);
create unique index PLine_name on PLine using btree (slotname bpchar_ops);
create unique index Hub_name on Hub using btree (name bpchar_ops);
create unique index HSlot_name on HSlot using btree (slotname bpchar_ops);
create index HSlot_hubname on HSlot using btree (hubname bpchar_ops);
create unique index System_name on System using btree (name text_ops);
create unique index IFace_name on IFace using btree (slotname bpchar_ops);
create unique index PHone_name on PHone using btree (slotname bpchar_ops);
create function tg_room_au() returns trigger as 'begin    if new.roomno != old.roomno then        update WSlot set roomno = new.roomno where roomno = old.roomno;
    end if;
    return new;
end;
' language plpgsql;
create function tg_room_ad() returns trigger as 'begin    delete from WSlot where roomno = old.roomno;
    return old;
end;
' language plpgsql;
create function tg_wslot_biu() returns trigger as $$begin    if count(*) = 0 from Room where roomno = new.roomno then        raise exception 'Room % does not exist', new.roomno;
    end if;
    return new;
end;
$$ language plpgsql;
create trigger tg_wslot_biu before insert or update    on WSlot for each row execute procedure tg_wslot_biu();
create function tg_pfield_au() returns trigger as 'begin    if new.name != old.name then        update PSlot set pfname = new.name where pfname = old.name;
    end if;
    return new;
end;
' language plpgsql;
create function tg_pfield_ad() returns trigger as 'begin    delete from PSlot where pfname = old.name;
    return old;
end;
' language plpgsql;
create function tg_pslot_biu() returns trigger as $proc$declare    pfrec	record;
    ps          alias for new;
begin    select into pfrec * from PField where name = ps.pfname;
    if not found then        raise exception $$Patchfield "%" does not exist$$, ps.pfname;
    end if;
    return ps;
end;
$$proc$ language plpgsql;
create trigger tg_pslot_biu before insert or update    on PSlot for each row execute procedure tg_pslot_biu();
create function tg_system_au() returns trigger as 'begin    if new.name != old.name then        update IFace set sysname = new.name where sysname = old.name;
    end if;
    return new;
end;
' language plpgsql;
create function tg_iface_biu() returns trigger as $$declare    sname	text;
    sysrec	record;
begin    select into sysrec * from system where name = new.sysname;
    if not found then        raise exception $q$system "%" does not exist$q$, new.sysname;
    end if;
    sname := 'IF.' || new.sysname;
    sname := sname || '.';
    sname := sname || new.ifname;
    if length(sname) > 20 then        raise exception 'IFace slotname "%" too long (20 char max)', sname;
    end if;
    new.slotname := sname;
    return new;
end;
$$ language plpgsql;
create trigger tg_iface_biu before insert or update    on IFace for each row execute procedure tg_iface_biu();
create function tg_hub_a() returns trigger as 'declare    hname	text;
    dummy	integer;
begin    if tg_op = ''INSERT'' then	dummy := tg_hub_adjustslots(new.name, 0, new.nslots);
	return new;
    end if;
    if tg_op = ''UPDATE'' then	if new.name != old.name then	    update HSlot set hubname = new.name where hubname = old.name;
	end if;
	dummy := tg_hub_adjustslots(new.name, old.nslots, new.nslots);
	return new;
    end if;
    if tg_op = ''DELETE'' then	dummy := tg_hub_adjustslots(old.name, old.nslots, 0);
	return old;
    end if;
end;
' language plpgsql;
create trigger tg_hub_a after insert or update or delete    on Hub for each row execute procedure tg_hub_a();
create function tg_hub_adjustslots(hname bpchar,                                   oldnslots integer,                                   newnslots integer)returns integer as 'begin    if newnslots = oldnslots then        return 0;
    end if;
    if newnslots < oldnslots then        delete from HSlot where hubname = hname and slotno > newnslots;
	return 0;
    end if;
    for i in oldnslots + 1 .. newnslots loop        insert into HSlot (slotname, hubname, slotno, slotlink)		values (''HS.dummy'', hname, i, '''');
    end loop;
    return 0;
end' language plpgsql;
COMMENT ON FUNCTION tg_hub_adjustslots_wrong(bpchar, integer, integer) IS 'function with args';
COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS 'function with args';
COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS NULL;
create function tg_hslot_biu() returns trigger as 'declare    sname	text;
    xname	HSlot.slotname%TYPE;
    hubrec	record;
begin    select into hubrec * from Hub where name = new.hubname;
    if not found then        raise exception ''no manual manipulation of HSlot'';
    end if;
    if new.slotno < 1 or new.slotno > hubrec.nslots then        raise exception ''no manual manipulation of HSlot'';
    end if;
    if tg_op = ''UPDATE'' and new.hubname != old.hubname then	if count(*) > 0 from Hub where name = old.hubname then	    raise exception ''no manual manipulation of HSlot'';
	end if;
    end if;
    sname := ''HS.'' || trim(new.hubname);
    sname := sname || ''.'';
    sname := sname || new.slotno::text;
    if length(sname) > 20 then        raise exception ''HSlot slotname "%" too long (20 char max)'', sname;
    end if;
    new.slotname := sname;
    return new;
end;
' language plpgsql;
create trigger tg_hslot_biu before insert or update    on HSlot for each row execute procedure tg_hslot_biu();
create function tg_hslot_bd() returns trigger as 'declare    hubrec	record;
begin    select into hubrec * from Hub where name = old.hubname;
    if not found then        return old;
    end if;
    if old.slotno > hubrec.nslots then        return old;
    end if;
    raise exception ''no manual manipulation of HSlot'';
end;
' language plpgsql;
create function tg_chkslotname() returns trigger as 'begin    if substr(new.slotname, 1, 2) != tg_argv[0] then        raise exception ''slotname must begin with %'', tg_argv[0];
    end if;
    return new;
end;
' language plpgsql;
create trigger tg_chkslotname before insert    on PSlot for each row execute procedure tg_chkslotname('PS');
create trigger tg_chkslotname before insert    on WSlot for each row execute procedure tg_chkslotname('WS');
create trigger tg_chkslotname before insert    on PLine for each row execute procedure tg_chkslotname('PL');
create trigger tg_chkslotname before insert    on IFace for each row execute procedure tg_chkslotname('IF');
create trigger tg_chkslotname before insert    on PHone for each row execute procedure tg_chkslotname('PH');
create function tg_chkslotlink() returns trigger as 'begin    if new.slotlink isnull then        new.slotlink := '''';
    end if;
    return new;
end;
' language plpgsql;
create trigger tg_chkslotlink before insert or update    on PSlot for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update    on WSlot for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update    on IFace for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update    on HSlot for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update    on PHone for each row execute procedure tg_chkslotlink();
create function tg_chkbacklink() returns trigger as 'begin    if new.backlink isnull then        new.backlink := '''';
    end if;
    return new;
end;
' language plpgsql;
create trigger tg_chkbacklink before insert or update    on PSlot for each row execute procedure tg_chkbacklink();
create trigger tg_chkbacklink before insert or update    on WSlot for each row execute procedure tg_chkbacklink();
create trigger tg_chkbacklink before insert or update    on PLine for each row execute procedure tg_chkbacklink();
create function tg_pslot_bu() returns trigger as 'begin    if new.slotname != old.slotname then        delete from PSlot where slotname = old.slotname;
	insert into PSlot (		    slotname,		    pfname,		    slotlink,		    backlink		) values (		    new.slotname,		    new.pfname,		    new.slotlink,		    new.backlink		);
        return null;
    end if;
    return new;
end;
' language plpgsql;
create function tg_wslot_bu() returns trigger as 'begin    if new.slotname != old.slotname then        delete from WSlot where slotname = old.slotname;
	insert into WSlot (		    slotname,		    roomno,		    slotlink,		    backlink		) values (		    new.slotname,		    new.roomno,		    new.slotlink,		    new.backlink		);
        return null;
    end if;
    return new;
end;
' language plpgsql;
create function tg_pline_bu() returns trigger as 'begin    if new.slotname != old.slotname then        delete from PLine where slotname = old.slotname;
	insert into PLine (		    slotname,		    phonenumber,		    comment,		    backlink		) values (		    new.slotname,		    new.phonenumber,		    new.comment,		    new.backlink		);
        return null;
    end if;
    return new;
end;
' language plpgsql;
create function tg_iface_bu() returns trigger as 'begin    if new.slotname != old.slotname then        delete from IFace where slotname = old.slotname;
	insert into IFace (		    slotname,		    sysname,		    ifname,		    slotlink		) values (		    new.slotname,		    new.sysname,		    new.ifname,		    new.slotlink		);
        return null;
    end if;
    return new;
end;
' language plpgsql;
create function tg_hslot_bu() returns trigger as 'begin    if new.slotname != old.slotname or new.hubname != old.hubname then        delete from HSlot where slotname = old.slotname;
	insert into HSlot (		    slotname,		    hubname,		    slotno,		    slotlink		) values (		    new.slotname,		    new.hubname,		    new.slotno,		    new.slotlink		);
        return null;
    end if;
    return new;
end;
' language plpgsql;
create function tg_phone_bu() returns trigger as 'begin    if new.slotname != old.slotname then        delete from PHone where slotname = old.slotname;
	insert into PHone (		    slotname,		    comment,		    slotlink		) values (		    new.slotname,		    new.comment,		    new.slotlink		);
        return null;
    end if;
    return new;
end;
' language plpgsql;
create function tg_backlink_a() returns trigger as 'declare    dummy	integer;
begin    if tg_op = ''INSERT'' then        if new.backlink != '''' then	    dummy := tg_backlink_set(new.backlink, new.slotname);
	end if;
	return new;
    end if;
    if tg_op = ''UPDATE'' then        if new.backlink != old.backlink then	    if old.backlink != '''' then	        dummy := tg_backlink_unset(old.backlink, old.slotname);
	    end if;
	    if new.backlink != '''' then	        dummy := tg_backlink_set(new.backlink, new.slotname);
	    end if;
	else	    if new.slotname != old.slotname and new.backlink != '''' then	        dummy := tg_slotlink_set(new.backlink, new.slotname);
	    end if;
	end if;
	return new;
    end if;
    if tg_op = ''DELETE'' then        if old.backlink != '''' then	    dummy := tg_backlink_unset(old.backlink, old.slotname);
	end if;
	return old;
    end if;
end;
' language plpgsql;
create trigger tg_backlink_a after insert or update or delete    on PSlot for each row execute procedure tg_backlink_a('PS');
create trigger tg_backlink_a after insert or update or delete    on WSlot for each row execute procedure tg_backlink_a('WS');
create trigger tg_backlink_a after insert or update or delete    on PLine for each row execute procedure tg_backlink_a('PL');
create function tg_backlink_set(myname bpchar, blname bpchar)returns integer as 'declare    mytype	char(2);
    link	char(4);
    rec		record;
begin    mytype := substr(myname, 1, 2);
    link := mytype || substr(blname, 1, 2);
    if link = ''PLPL'' then        raise exception		''backlink between two phone lines does not make sense'';
    end if;
    if link in (''PLWS'', ''WSPL'') then        raise exception		''direct link of phone line to wall slot not permitted'';
    end if;
    if mytype = ''PS'' then        select into rec * from PSlot where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.backlink != blname then	    update PSlot set backlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''WS'' then        select into rec * from WSlot where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.backlink != blname then	    update WSlot set backlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''PL'' then        select into rec * from PLine where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.backlink != blname then	    update PLine set backlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    raise exception ''illegal backlink beginning with %'', mytype;
end;
' language plpgsql;
create function tg_backlink_unset(bpchar, bpchar)returns integer as 'declare    myname	alias for $1;
    blname	alias for $2;
    mytype	char(2);
    rec		record;
begin    mytype := substr(myname, 1, 2);
    if mytype = ''PS'' then        select into rec * from PSlot where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.backlink = blname then	    update PSlot set backlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''WS'' then        select into rec * from WSlot where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.backlink = blname then	    update WSlot set backlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''PL'' then        select into rec * from PLine where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.backlink = blname then	    update PLine set backlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
end' language plpgsql;
create function tg_slotlink_a() returns trigger as 'declare    dummy	integer;
begin    if tg_op = ''INSERT'' then        if new.slotlink != '''' then	    dummy := tg_slotlink_set(new.slotlink, new.slotname);
	end if;
	return new;
    end if;
    if tg_op = ''UPDATE'' then        if new.slotlink != old.slotlink then	    if old.slotlink != '''' then	        dummy := tg_slotlink_unset(old.slotlink, old.slotname);
	    end if;
	    if new.slotlink != '''' then	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
	    end if;
	else	    if new.slotname != old.slotname and new.slotlink != '''' then	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
	    end if;
	end if;
	return new;
    end if;
    if tg_op = ''DELETE'' then        if old.slotlink != '''' then	    dummy := tg_slotlink_unset(old.slotlink, old.slotname);
	end if;
	return old;
    end if;
end;
' language plpgsql;
create trigger tg_slotlink_a after insert or update or delete    on PSlot for each row execute procedure tg_slotlink_a('PS');
create trigger tg_slotlink_a after insert or update or delete    on WSlot for each row execute procedure tg_slotlink_a('WS');
create trigger tg_slotlink_a after insert or update or delete    on IFace for each row execute procedure tg_slotlink_a('IF');
create trigger tg_slotlink_a after insert or update or delete    on HSlot for each row execute procedure tg_slotlink_a('HS');
create trigger tg_slotlink_a after insert or update or delete    on PHone for each row execute procedure tg_slotlink_a('PH');
create function tg_slotlink_set(bpchar, bpchar)returns integer as 'declare    myname	alias for $1;
    blname	alias for $2;
    mytype	char(2);
    link	char(4);
    rec		record;
begin    mytype := substr(myname, 1, 2);
    link := mytype || substr(blname, 1, 2);
    if link = ''PHPH'' then        raise exception		''slotlink between two phones does not make sense'';
    end if;
    if link in (''PHHS'', ''HSPH'') then        raise exception		''link of phone to hub does not make sense'';
    end if;
    if link in (''PHIF'', ''IFPH'') then        raise exception		''link of phone to hub does not make sense'';
    end if;
    if link in (''PSWS'', ''WSPS'') then        raise exception		''slotlink from patchslot to wallslot not permitted'';
    end if;
    if mytype = ''PS'' then        select into rec * from PSlot where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.slotlink != blname then	    update PSlot set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''WS'' then        select into rec * from WSlot where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.slotlink != blname then	    update WSlot set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''IF'' then        select into rec * from IFace where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.slotlink != blname then	    update IFace set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''HS'' then        select into rec * from HSlot where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.slotlink != blname then	    update HSlot set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''PH'' then        select into rec * from PHone where slotname = myname;
	if not found then	    raise exception ''% does not exist'', myname;
	end if;
	if rec.slotlink != blname then	    update PHone set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    raise exception ''illegal slotlink beginning with %'', mytype;
end;
' language plpgsql;
create function tg_slotlink_unset(bpchar, bpchar)returns integer as 'declare    myname	alias for $1;
    blname	alias for $2;
    mytype	char(2);
    rec		record;
begin    mytype := substr(myname, 1, 2);
    if mytype = ''PS'' then        select into rec * from PSlot where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.slotlink = blname then	    update PSlot set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''WS'' then        select into rec * from WSlot where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.slotlink = blname then	    update WSlot set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''IF'' then        select into rec * from IFace where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.slotlink = blname then	    update IFace set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''HS'' then        select into rec * from HSlot where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.slotlink = blname then	    update HSlot set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''PH'' then        select into rec * from PHone where slotname = myname;
	if not found then	    return 0;
	end if;
	if rec.slotlink = blname then	    update PHone set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
end;
' language plpgsql;
create function pslot_backlink_view(bpchar)returns text as '<<outer>>declare    rec		record;
    bltype	char(2);
    retval	text;
begin    select into rec * from PSlot where slotname = $1;
    if not found then        return '''';
    end if;
    if rec.backlink = '''' then        return ''-'';
    end if;
    bltype := substr(rec.backlink, 1, 2);
    if bltype = ''PL'' then        declare	    rec		record;
	begin	    select into rec * from PLine where slotname = "outer".rec.backlink;
	    retval := ''Phone line '' || trim(rec.phonenumber);
	    if rec.comment != '''' then	        retval := retval || '' ('';
		retval := retval || rec.comment;
		retval := retval || '')'';
	    end if;
	    return retval;
	end;
    end if;
    if bltype = ''WS'' then        select into rec * from WSlot where slotname = rec.backlink;
	retval := trim(rec.slotname) || '' in room '';
	retval := retval || trim(rec.roomno);
	retval := retval || '' -> '';
	return retval || wslot_slotlink_view(rec.slotname);
    end if;
    return rec.backlink;
end;
' language plpgsql;
create function pslot_slotlink_view(bpchar)returns text as 'declare    psrec	record;
    sltype	char(2);
    retval	text;
begin    select into psrec * from PSlot where slotname = $1;
    if not found then        return '''';
    end if;
    if psrec.slotlink = '''' then        return ''-'';
    end if;
    sltype := substr(psrec.slotlink, 1, 2);
    if sltype = ''PS'' then	retval := trim(psrec.slotlink) || '' -> '';
	return retval || pslot_backlink_view(psrec.slotlink);
    end if;
    if sltype = ''HS'' then        retval := comment from Hub H, HSlot HS			where HS.slotname = psrec.slotlink			  and H.name = HS.hubname;
        retval := retval || '' slot '';
	retval := retval || slotno::text from HSlot			where slotname = psrec.slotlink;
	return retval;
    end if;
    return psrec.slotlink;
end;
' language plpgsql;
create function wslot_slotlink_view(bpchar)returns text as 'declare    rec		record;
    sltype	char(2);
    retval	text;
begin    select into rec * from WSlot where slotname = $1;
    if not found then        return '''';
    end if;
    if rec.slotlink = '''' then        return ''-'';
    end if;
    sltype := substr(rec.slotlink, 1, 2);
    if sltype = ''PH'' then        select into rec * from PHone where slotname = rec.slotlink;
	retval := ''Phone '' || trim(rec.slotname);
	if rec.comment != '''' then	    retval := retval || '' ('';
	    retval := retval || rec.comment;
	    retval := retval || '')'';
	end if;
	return retval;
    end if;
    if sltype = ''IF'' then	declare	    syrow	System%RowType;
	    ifrow	IFace%ROWTYPE;
        begin	    select into ifrow * from IFace where slotname = rec.slotlink;
	    select into syrow * from System where name = ifrow.sysname;
	    retval := syrow.name || '' IF '';
	    retval := retval || ifrow.ifname;
	    if syrow.comment != '''' then	        retval := retval || '' ('';
		retval := retval || syrow.comment;
		retval := retval || '')'';
	    end if;
	    return retval;
	end;
    end if;
    return rec.slotlink;
end;
' language plpgsql;
create view Pfield_v1 as select PF.pfname, PF.slotname,	pslot_backlink_view(PF.slotname) as backside,	pslot_slotlink_view(PF.slotname) as patch    from PSlot PF;
~select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
~select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
~select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
~select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
~select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
~select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
delete from HSlot;
CREATE FUNCTION recursion_test(int,int) RETURNS text AS 'DECLARE rslt text;
BEGIN    IF $1 <= 0 THEN        rslt = CAST($2 AS TEXT);
    ELSE        rslt = CAST($1 AS TEXT) || '','' || recursion_test($1 - 1, $2);
    END IF;
    RETURN rslt;
END;' LANGUAGE plpgsql;
create function test_found()  returns boolean as '  declare  begin  insert into found_test_tbl values (1);
  if FOUND then     insert into found_test_tbl values (2);
  end if;
  if FOUND then    insert into found_test_tbl values (3);
  end if;
  delete from found_test_tbl where a = 9999; -- matches no rows  if not FOUND then    insert into found_test_tbl values (4);
  end if;
  for i in 1 .. 10 loop    -- no need to do anything  end loop;
  if FOUND then    insert into found_test_tbl values (5);
  end if;
  -- never executes the loop  for i in 2 .. 1 loop    -- no need to do anything  end loop;
  if not FOUND then    insert into found_test_tbl values (6);
  end if;
  return true;
  end;' language plpgsql;
create function test_table_func_rec() returns setof found_test_tbl as 'DECLARE	rec RECORD;
BEGIN	FOR rec IN select * from found_test_tbl LOOP		RETURN NEXT rec;
	END LOOP;
	RETURN;
END;' language plpgsql;
select * from test_table_func_rec();
create function test_table_func_row() returns setof found_test_tbl as 'DECLARE	row found_test_tbl%ROWTYPE;
BEGIN	FOR row IN select * from found_test_tbl LOOP		RETURN NEXT row;
	END LOOP;
	RETURN;
END;' language plpgsql;
select * from test_table_func_row();
create function test_ret_set_scalar(int,int) returns setof int as 'DECLARE	i int;
BEGIN	FOR i IN $1 .. $2 LOOP		RETURN NEXT i + 1;
	END LOOP;
	RETURN;
END;' language plpgsql;
create function test_ret_set_rec_dyn(int) returns setof record as 'DECLARE	retval RECORD;
BEGIN	IF $1 > 10 THEN		SELECT INTO retval 5, 10, 15;
		RETURN NEXT retval;
		RETURN NEXT retval;
	ELSE		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
		RETURN NEXT retval;
		RETURN NEXT retval;
	END IF;
	RETURN;
END;' language plpgsql;
SELECT * FROM test_ret_set_rec_dyn(1500) AS (a int, b int, c int);
SELECT * FROM test_ret_set_rec_dyn(5) AS (a int, b numeric, c text);
create function test_ret_rec_dyn(int) returns record as 'DECLARE	retval RECORD;
BEGIN	IF $1 > 10 THEN		SELECT INTO retval 5, 10, 15;
		RETURN retval;
	ELSE		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
		RETURN retval;
	END IF;
END;' language plpgsql;
SELECT * FROM test_ret_rec_dyn(1500) AS (a int, b int, c int);
SELECT * FROM test_ret_rec_dyn(5) AS (a int, b numeric, c text);
create function f1(in i int, out j int) returns int as $$begin  return i+1;
end$$ language plpgsql;
create function f1(in i int, out j int) as $$begin  j := i+1;
  return;
end$$ language plpgsql;
create or replace function f1(inout i int) as $$begin  i := i+1;
end$$ language plpgsql;
drop function f1(int);
create function f1(in i int, out j int) returns setof int as $$begin  j := i+1;
  return next;
  j := i+2;
  return next;
  return;
end$$ language plpgsql;
drop function f1(int);
create function f1(in i int, out j int, out k text) as $$begin  j := i;
  j := j+1;
  k := 'foo';
end$$ language plpgsql;
drop function f1(int);
create function f1(in i int, out j int, out k text) returns setof record as $$begin  j := i+1;
  k := 'foo';
  return next;
  j := j+1;
  k := 'foot';
  return next;
end$$ language plpgsql;
drop function f1(int);
create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$begin  j := i;
  k := array[j,j];
  return;
end$$ language plpgsql;
::select * from duplic('foo'::text);
drop function duplic(anyelement);
create function perform_simple_func(int) returns boolean as 'BEGIN	IF $1 < 20 THEN		INSERT INTO perform_test VALUES ($1, $1 + 10);
		RETURN TRUE;
	ELSE		RETURN FALSE;
	END IF;
END;' language plpgsql;
create function perform_test_func() returns void as 'BEGIN	IF FOUND then		INSERT INTO perform_test VALUES (100, 100);
	END IF;
	PERFORM perform_simple_func(5);
	IF FOUND then		INSERT INTO perform_test VALUES (100, 100);
	END IF;
	PERFORM perform_simple_func(50);
	IF FOUND then		INSERT INTO perform_test VALUES (100, 100);
	END IF;
	RETURN;
END;' language plpgsql;
create temp table users(login text, id serial);
create function sp_id_user(a_login text) returns int as $$declare x int;
begin  select into x id from users where login = a_login;
  if found then return x; end if;
  return 0;
end$$ language plpgsql stable;
create function sp_add_user(a_login text) returns int as $$declare my_id_user int;
begin  my_id_user = sp_id_user( a_login );
  IF  my_id_user > 0 THEN    RETURN -1;  -- error code for existing user  END IF;
  my_id_user = sp_id_user( a_login );
  IF  my_id_user = 0 THEN    RETURN -2;  -- error code for insertion failure  END IF;
  RETURN my_id_user;
end$$ language plpgsql;
drop function sp_add_user(text);
drop function sp_id_user(text);
copy rc_test from stdin;
5	1050	100500	1000\.create function return_unnamed_refcursor() returns refcursor as $$declare    rc refcursor;
begin    open rc for select a from rc_test;
    return rc;
end$$ language plpgsql;
create function use_refcursor(rc refcursor) returns int as $$declare    rc refcursor;
    x record;
begin    rc := return_unnamed_refcursor();
    fetch next from rc into x;
    return x.a;
end$$ language plpgsql;
create function return_refcursor(rc refcursor) returns refcursor as $$begin    open rc for select a from rc_test;
    return rc;
end$$ language plpgsql;
create function refcursor_test1(refcursor) returns refcursor as $$begin    perform return_refcursor($1);
    return $1;
end$$ language plpgsql;
begin;
fetch next in test1;
fetch all from test2;
commit;
fetch next from test1;
create function refcursor_test2(int, int) returns boolean as $$declare    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
    nonsense record;
begin    open c1($1, $2);
    fetch c1 into nonsense;
    close c1;
    if found then        return true;
    else        return false;
    end if;
end$$ language plpgsql;
create function namedparmcursor_test1(int, int) returns boolean as $$declare    c1 cursor (param1 int, param12 int) for select * from rc_test where a > param1 and b > param12;
    nonsense record;
begin    open c1(param12 := $2, param1 := $1);
    fetch c1 into nonsense;
    close c1;
    if found then        return true;
    else        return false;
    end if;
end$$ language plpgsql;
create function namedparmcursor_test2(int, int) returns boolean as $$declare    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
    nonsense record;
begin    open c1(param1 := $1, $2);
    fetch c1 into nonsense;
    close c1;
    if found then        return true;
    else        return false;
    end if;
end$$ language plpgsql;
create function namedparmcursor_test3() returns void as $$declare    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
begin    open c1(param2 := 20, 21);
end$$ language plpgsql;
create function namedparmcursor_test4() returns void as $$declare    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
begin    open c1(20, param1 := 21);
end$$ language plpgsql;
create function namedparmcursor_test5() returns void as $$declare  c1 cursor (p1 int, p2 int) for    select * from tenk1 where thousand = p1 and tenthous = p2;
begin  open c1 (p2 := 77, p2 := 42);
end$$ language plpgsql;
create function namedparmcursor_test6() returns void as $$declare  c1 cursor (p1 int, p2 int) for    select * from tenk1 where thousand = p1 and tenthous = p2;
begin  open c1 (p2 := 77);
end$$ language plpgsql;
create function namedparmcursor_test7() returns void as $$declare  c1 cursor (p1 int, p2 int) for    select * from tenk1 where thousand = p1 and tenthous = p2;
begin  open c1 (p2 := 77, p1 := 42/0);
end $$ language plpgsql;
create function namedparmcursor_test8() returns int4 as $$declare  c1 cursor (p1 int, p2 int) for    select count(*) from tenk1 where thousand = p1 and tenthous = p2;
  n int4;
begin  open c1 (77 -- test  , 42);
  fetch c1 into n;
  return n;
end $$ language plpgsql;
create function namedparmcursor_test9(p1 int) returns int4 as $$declare  c1 cursor (p1 int, p2 int, debug int) for    select count(*) from tenk1 where thousand = p1 and tenthous = p2      and four = debug;
  p2 int4 := 1006;
  n int4;
begin  open c1 (p1 := p1, p2 := p2, debug := 2);
  fetch c1 into n;
  return n;
end $$ language plpgsql;
create function raise_test1(int) returns int as $$begin    raise notice 'This message has too many parameters!', $1;
    return $1;
end;
$$ language plpgsql;
create function raise_test2(int) returns int as $$begin    raise notice 'This message has too few parameters: %, %, %', $1, $1;
    return $1;
end;
$$ language plpgsql;
create function raise_test3(int) returns int as $$begin    raise notice 'This message has no parameters (despite having %% signs in it)!';
    return $1;
end;
$$ language plpgsql;
CREATE FUNCTION reraise_test() RETURNS void AS $$BEGIN   BEGIN       RAISE syntax_error;
   EXCEPTION       WHEN syntax_error THEN           BEGIN               raise notice 'exception % thrown in inner block, reraising', sqlerrm;
               RAISE;
           EXCEPTION               WHEN OTHERS THEN                   raise notice 'RIGHT - exception % caught in inner block', sqlerrm;
           END;
   END;
EXCEPTION   WHEN OTHERS THEN       raise notice 'WRONG - exception % caught in outer block', sqlerrm;
END;
$$ LANGUAGE plpgsql;
create function bad_sql1() returns int as $$declare a int;
begin    a := 5;
    Johnny Yuma;
    a := 10;
    return a;
end$$ language plpgsql;
create function bad_sql2() returns int as $$declare r record;
begin    for r in select I fought the law, the law won LOOP        raise notice 'in loop';
    end loop;
    return 5;
end;$$ language plpgsql;
create function missing_return_expr() returns int as $$begin    return ;
end;$$ language plpgsql;
create function void_return_expr() returns void as $$begin    return 5;
end;$$ language plpgsql;
create function void_return_expr() returns void as $$begin    perform 2+2;
end;$$ language plpgsql;
create function missing_return_expr() returns int as $$begin    perform 2+2;
end;$$ language plpgsql;
drop function void_return_expr();
drop function missing_return_expr();
create type eitype as (i integer, y integer);
create or replace function execute_into_test(varchar) returns record as $$declare    _r record;
_    _rt eifoo%rowtype;
_    _v eitype;
    i int;
    j int;
    k int;
begin    execute 'insert into '||$1||' values(10,15)';
    execute 'select (row).* from (select row(10,1)::eifoo) s' into _r;
    raise notice '% %', _r.i, _r.y;
    execute 'select * from '||$1||' limit 1' into _rt;
    raise notice '% %', _rt.i, _rt.y;
    execute 'select *, 20 from '||$1||' limit 1' into i, j, k;
    raise notice '% % %', i, j, k;
    execute 'select 1,2' into _v;
    return _v;
end; $$ language plpgsql;
drop table eifoo cascade;
drop type eitype cascade;
create function excpt_test1() returns void as $$begin    raise notice '% %', sqlstate, sqlerrm;
end; $$ language plpgsql;
create function excpt_test2() returns void as $$begin    begin        begin            raise notice '% %', sqlstate, sqlerrm;
        end;
    end;
end; $$ language plpgsql;
create function excpt_test3() returns void as $$begin    begin        raise exception 'user exception';
    exception when others then	    raise notice 'caught exception % %', sqlstate, sqlerrm;
	    begin	        raise notice '% %', sqlstate, sqlerrm;
	        perform 10/0;
        exception            when substring_error then                -- this exception handler shouldn't be invoked                raise notice 'unexpected exception: % %', sqlstate, sqlerrm;
	        when division_by_zero then	            raise notice 'caught exception % %', sqlstate, sqlerrm;
	    end;
	    raise notice '% %', sqlstate, sqlerrm;
    end;
end; $$ language plpgsql;
create function excpt_test4() returns text as $$begin	begin perform 1/0;
	exception when others then return sqlerrm; end;
end; $$ language plpgsql;
drop function excpt_test1();
drop function excpt_test2();
drop function excpt_test3();
drop function excpt_test4();
create function raise_exprs() returns void as $$declare    a integer[] = '{10,20,30}';
    c varchar = 'xyz';
    i integer;
begin    i := 2;
    raise notice '%; %; %; %; %; %', a, a[i], c, (select c || 'abc'), row(10,'aaa',NULL,30), NULL;
end;$$ language plpgsql;
drop function raise_exprs();
create function multi_datum_use(p1 int) returns bool as $$declare  x int;
  y int;
begin  select into x,y unique1/p1, unique1/$1 from tenk1 group by unique1/p1;
  return x = y;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should work  insert into foo values(5,6) returning * into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should fail due to implicit strict  insert into foo values(7,8),(9,10) returning * into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should work  execute 'insert into foo values(5,6) returning *' into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- this should work since EXECUTE isn't as picky  execute 'insert into foo values(7,8),(9,10) returning *' into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should work  select * from foo where f1 = 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should fail, no rows  select * from foo where f1 = 0 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should fail, too many rows  select * from foo where f1 > 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should work  execute 'select * from foo where f1 = 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should fail, no rows  execute 'select * from foo where f1 = 0' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- should fail, too many rows  execute 'select * from foo where f1 > 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
drop function stricttest();
set plpgsql.print_strict_params to true;
create or replace function stricttest() returns void as $$declarex record;
p1 int := 2;
p3 text := 'foo';
begin  -- no rows  select * from foo where f1 = p1 and f1::text = p3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declarex record;
p1 int := 2;
p3 text := 'foo';
begin  -- too many rows  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- too many rows, no params  select * from foo where f1 > 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- no rows  execute 'select * from foo where f1 = $1 or f1::text = $2' using 0, 'foo' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- too many rows  execute 'select * from foo where f1 > $1' using 1 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$declare x record;
begin  -- too many rows, no parameters  execute 'select * from foo where f1 > 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
create or replace function stricttest() returns void as $$#print_strict_params offdeclarex record;
p1 int := 2;
p3 text := 'foo';
begin  -- too many rows  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
reset plpgsql.print_strict_params;
create or replace function stricttest() returns void as $$#print_strict_params ondeclarex record;
p1 int := 2;
p3 text := 'foo';
begin  -- too many rows  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
set plpgsql.extra_warnings to 'all';
set plpgsql.extra_warnings to 'none';
set plpgsql.extra_errors to 'all';
set plpgsql.extra_errors to 'none';
set plpgsql.extra_warnings to 'shadowed_variables';
create or replace function shadowtest(in1 int)	returns table (out1 int) as $$declarein1 int;
out1 int;
beginend$$ language plpgsql;
set plpgsql.extra_warnings to 'shadowed_variables';
create or replace function shadowtest(in1 int)	returns table (out1 int) as $$declarein1 int;
out1 int;
beginend$$ language plpgsql;
drop function shadowtest(int);
create or replace function shadowtest()	returns void as $$declaref1 int;
begin	declare	f1 int;
	begin	end;
end$$ language plpgsql;
drop function shadowtest();
create or replace function shadowtest(in1 int)	returns void as $$declarein1 int;
begin	declare	in1 int;
	begin	end;
end$$ language plpgsql;
drop function shadowtest(int);
create or replace function shadowtest()	returns void as $$declaref1 int;
c1 cursor (f1 int) for select 1;
beginend$$ language plpgsql;
drop function shadowtest();
set plpgsql.extra_errors to 'shadowed_variables';
create or replace function shadowtest(f1 int)	returns boolean as $$declare f1 int; begin return 1; end $$ language plpgsql;
reset plpgsql.extra_errors;
reset plpgsql.extra_warnings;
create or replace function shadowtest(f1 int)	returns boolean as $$declare f1 int; begin return 1; end $$ language plpgsql;
set plpgsql.extra_warnings to 'too_many_rows';
do $$declare x int;
begin  select v from generate_series(1,2) g(v) into x;
end;
$$;
set plpgsql.extra_errors to 'too_many_rows';
do $$declare x int;
begin  select v from generate_series(1,2) g(v) into x;
end;
$$;
reset plpgsql.extra_errors;
reset plpgsql.extra_warnings;
set plpgsql.extra_warnings to 'strict_multi_assignment';
do $$declare  x int;
  y int;
begin  select 1 into x, y;
  select 1,2 into x, y;
  select 1,2,3 into x, y;
end$$;
set plpgsql.extra_errors to 'strict_multi_assignment';
do $$declare  x int;
  y int;
begin  select 1 into x, y;
  select 1,2 into x, y;
  select 1,2,3 into x, y;
end$$;
alter table test_01 drop column a;
do $$declare  x int;
  y int;
begin  select * from test_01 into x, y; -- should be ok  raise notice 'ok';
  select * from test_01 into x;    -- should to failend;
$$;
do $$declare  t test_01;
begin  select 1, 2 into t;  -- should be ok  raise notice 'ok';
  select 1, 2, 3 into t; -- should fail;
end;
$$;
do $$declare  t test_01;
begin  select 1 into t; -- should fail;
end;
$$;
reset plpgsql.extra_errors;
reset plpgsql.extra_warnings;
create function sc_test() returns setof integer as $$declare  c scroll cursor for select f1 from int4_tbl;
  x integer;
begin  open c;
  fetch last from c into x;
  while found loop    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
select * from sc_test();
create or replace function sc_test() returns setof integer as $$declare  c no scroll cursor for select f1 from int4_tbl;
  x integer;
begin  open c;
  fetch last from c into x;
  while found loop    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
select * from sc_test();  -- fails because of NO SCROLL specificationcreate or replace function sc_test() returns setof integer as $$declare  c refcursor;
  x integer;
begin  open c scroll for select f1 from int4_tbl;
  fetch last from c into x;
  while found loop    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
select * from sc_test();
create or replace function sc_test() returns setof integer as $$declare  c refcursor;
  x integer;
begin  open c scroll for execute 'select f1 from int4_tbl';
  fetch last from c into x;
  while found loop    return next x;
    fetch relative -2 from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
select * from sc_test();
create or replace function sc_test() returns setof integer as $$declare  c refcursor;
  x integer;
begin  open c scroll for execute 'select f1 from int4_tbl';
  fetch last from c into x;
  while found loop    return next x;
    move backward 2 from c;
    fetch relative -1 from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
select * from sc_test();
create or replace function sc_test() returns setof integer as $$declare  c cursor for select * from generate_series(1, 10);
  x integer;
begin  open c;
  loop      move relative 2 in c;
      if not found then          exit;
      end if;
      fetch next from c into x;
      if found then          return next x;
      end if;
  end loop;
  close c;
end;
$$ language plpgsql;
select * from sc_test();
create or replace function sc_test() returns setof integer as $$declare  c cursor for select * from generate_series(1, 10);
  x integer;
begin  open c;
  move forward all in c;
  fetch backward from c into x;
  if found then    return next x;
  end if;
  close c;
end;
$$ language plpgsql;
select * from sc_test();
drop function sc_test();
create function pl_qual_names (param1 int) returns void as $$<<outerblock>>declare  param1 int := 1;
begin  <<innerblock>>  declare    param1 int := 2;
  begin    raise notice 'param1 = %', param1;
    raise notice 'pl_qual_names.param1 = %', pl_qual_names.param1;
    raise notice 'outerblock.param1 = %', outerblock.param1;
    raise notice 'innerblock.param1 = %', innerblock.param1;
  end;
end;
$$ language plpgsql;
drop function pl_qual_names(int);
create function ret_query1(out int, out int) returns setof record as $$begin    $1 := -1;
$    $2 := -2;
    return next;
    return query select x + 1, x * 10 from generate_series(0, 10) s (x);
    return next;
end;
$$ language plpgsql;
select * from ret_query1();
create type record_type as (x text, y int, z boolean);
create or replace function ret_query2(lim int) returns setof record_type as $$begin    return query select md5(s.x::text), s.x, s.x > 0                 from generate_series(-8, lim) s (x) where s.x % 2 = 0;
end;
$$ language plpgsql;
create function exc_using(int, text) returns int as $$declare i int;
begin  for i in execute 'select * from generate_series(1,$1)' using $1+1 loop    raise notice '%', i;
  end loop;
  execute 'select $2 + $2*3 + length($1)' into i using $2,$1;
  return i;
end$$ language plpgsql;
drop function exc_using(int, text);
create or replace function exc_using(int) returns void as $$declare  c refcursor;
  i int;
begin  open c for execute 'select * from generate_series(1,$1)' using $1+1;
  loop    fetch c into i;
    exit when not found;
    raise notice '%', i;
  end loop;
  close c;
  return;
end;
$$ language plpgsql;
drop function exc_using(int);
create or replace function forc01() returns void as $$declare  c cursor(r1 integer, r2 integer)       for select * from generate_series(r1,r2) i;
  c2 cursor       for select * from generate_series(41,43) i;
begin  for r in c(5,7) loop    raise notice '% from %', r.i, c;
  end loop;
  -- again, to test if cursor was closed properly  for r in c(9,10) loop    raise notice '% from %', r.i, c;
  end loop;
  -- and test a parameterless cursor  for r in c2 loop    raise notice '% from %', r.i, c2;
  end loop;
  -- and try it with a hand-assigned name  raise notice 'after loop, c2 = %', c2;
  c2 := 'special_name';
  for r in c2 loop    raise notice '% from %', r.i, c2;
  end loop;
  raise notice 'after loop, c2 = %', c2;
  -- and try it with a generated name  -- (which we can't show in the output because it's variable)  c2 := null;
  for r in c2 loop    raise notice '%', r.i;
  end loop;
  raise notice 'after loop, c2 = %', c2;
  return;
end;
$$ language plpgsql;
create or replace function forc01() returns void as $$declare  c cursor for select * from forc_test;
begin  for r in c loop    raise notice '%, %', r.i, r.j;
    update forc_test set i = i * 100, j = r.j * 2 where current of c;
  end loop;
end;
$$ language plpgsql;
create or replace function forc01() returns void as $$declare  c refcursor := 'fooled_ya';
  r record;
begin  open c for select * from forc_test;
  loop    fetch c into r;
    exit when not found;
    raise notice '%, %', r.i, r.j;
    update forc_test set i = i * 100, j = r.j * 2 where current of c;
  end loop;
end;
$$ language plpgsql;
drop function forc01();
create or replace function forc_bad() returns void as $$declare  c refcursor;
begin  for r in c loop    raise notice '%', r.i;
  end loop;
end;
$$ language plpgsql;
create or replace function return_dquery()returns setof int as $$begin  return query execute 'select * from (values(10),(20)) f';
  return query execute 'select * from (values($1),($2)) f' using 40,50;
end;
$$ language plpgsql;
select * from return_dquery();
drop function return_dquery();
create or replace function returnqueryf()returns setof tabwithcols as $$begin  return query select * from tabwithcols;
  return query execute 'select * from tabwithcols';
end;
$$ language plpgsql;
select * from returnqueryf();
alter table tabwithcols drop column b;
select * from returnqueryf();
alter table tabwithcols drop column d;
select * from returnqueryf();
select * from returnqueryf();
drop function returnqueryf();
create type compostype as (x int, y varchar);
create or replace function compos() returns compostype as $$declare  v compostype;
begin  v := (1, 'hello');
  return v;
end;
$$ language plpgsql;
create or replace function compos() returns compostype as $$declare  v record;
begin  v := (1, 'hello'::varchar);
  return v;
end;
$$ language plpgsql;
create or replace function compos() returns compostype as $$begin  return (1, 'hello'::varchar);
end;
$$ language plpgsql;
create or replace function compos() returns compostype as $$begin  return (1, 'hello');
end;
$$ language plpgsql;
create or replace function compos() returns compostype as $$begin  return (1, 'hello')::compostype;
end;
$$ language plpgsql;
drop function compos();
create or replace function composrec() returns record as $$declare  v record;
begin  v := (1, 'hello');
  return v;
end;
$$ language plpgsql;
create or replace function composrec() returns record as $$begin  return (1, 'hello');
end;
$$ language plpgsql;
drop function composrec();
create or replace function compos() returns setof compostype as $$begin  for i in 1..3  loop    return next (1, 'hello'::varchar);
  end loop;
  return next null::compostype;
  return next (2, 'goodbye')::compostype;
end;
$$ language plpgsql;
select * from compos();
drop function compos();
create or replace function compos() returns compostype as $$begin  return 1 + 1;
end;
$$ language plpgsql;
create or replace function compos() returns compostype as $$declare x int := 42;
begin  return x;
end;
$$ language plpgsql;
select * from compos();
drop function compos();
create or replace function compos() returns int as $$declare  v compostype;
begin  v := (1, 'hello');
  return v;
end;
$$ language plpgsql;
create or replace function compos() returns int as $$begin  return (1, 'hello')::compostype;
end;
$$ language plpgsql;
drop function compos();
drop type compostype;
create or replace function raise_test() returns void as $$begin  raise notice '% % %', 1, 2, 3     using errcode = '55001', detail = 'some detail info', hint = 'some hint';
  raise '% % %', 1, 2, 3     using errcode = 'division_by_zero', detail = 'some detail info';
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise 'check me'     using errcode = 'division_by_zero', detail = 'some detail info';
  exception    when others then      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise 'check me'     using errcode = '1234F', detail = 'some detail info';
  exception    when others then      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise 'check me'     using errcode = '1234F', detail = 'some detail info';
  exception    when sqlstate '1234F' then      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise division_by_zero using detail = 'some detail info';
  exception    when others then      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise division_by_zero;
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise sqlstate '1234F';
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise division_by_zero using message = 'custom' || ' message';
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise notice 'some message' using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise division_by_zero using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise;
end;
$$ language plpgsql;
create function zero_divide() returns int as $$declare v int := 0;
begin  return 10 / v;
end;
$$ language plpgsql;
create or replace function raise_test() returns void as $$begin  raise exception 'custom exception'     using detail = 'some detail of custom exception',           hint = 'some hint related to custom exception';
end;
$$ language plpgsql;
create function stacked_diagnostics_test() returns void as $$declare _sqlstate text;
_        _message text;
_        _context text;
begin  perform zero_divide();
exception when others then  get stacked diagnostics        _sqlstate = returned_sqlstate,        _message = message_text,        _context = pg_exception_context;
  raise notice 'sqlstate: %, message: %, context: [%]',    _sqlstate, _message, replace(_context, E'\n', ' <- ');
end;
$$ language plpgsql;
create or replace function stacked_diagnostics_test() returns void as $$declare _detail text;
_        _hint text;
_        _message text;
begin  perform raise_test();
exception when others then  get stacked diagnostics        _message = message_text,        _detail = pg_exception_detail,        _hint = pg_exception_hint;
  raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
end;
$$ language plpgsql;
create or replace function stacked_diagnostics_test() returns void as $$declare _detail text;
_        _hint text;
_        _message text;
begin  get stacked diagnostics        _message = message_text,        _detail = pg_exception_detail,        _hint = pg_exception_hint;
  raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
end;
$$ language plpgsql;
drop function zero_divide();
drop function stacked_diagnostics_test();
create or replace function raise_test() returns void as $$begin  perform 1/0;
exception  when sqlstate '22012' then    raise notice using message = sqlstate;
    raise sqlstate '22012' using message = 'substitute message';
end;
$$ language plpgsql;
drop function raise_test();
create or replace function stacked_diagnostics_test() returns void as $$declare _column_name text;
_        _constraint_name text;
_        _datatype_name text;
_        _table_name text;
_        _schema_name text;
begin  raise exception using    column = '>>some column name<<',    constraint = '>>some constraint name<<',    datatype = '>>some datatype name<<',    table = '>>some table name<<',    schema = '>>some schema name<<';
exception when others then  get stacked diagnostics        _column_name = column_name,        _constraint_name = constraint_name,        _datatype_name = pg_datatype_name,        _table_name = table_name,        _schema_name = schema_name;
  raise notice 'column %, constraint %, type %, table %, schema %',    _column_name, _constraint_name, _datatype_name, _table_name, _schema_name;
end;
$$ language plpgsql;
drop function stacked_diagnostics_test();
create or replace function vari(variadic int[])returns void as $$begin  for i in array_lower($1,1)..array_upper($1,1) loop    raise notice '%', $1[i];
  end loop; end;
$$ language plpgsql;
select vari(variadic array[5,6,7]);
drop function vari(int[]);
create or replace function pleast(variadic numeric[])returns numeric as $$declare aux numeric = $1[array_lower($1,1)];
begin  for i in array_lower($1,1)+1..array_upper($1,1) loop    if $1[i] < aux then aux := $1[i]; end if;
  end loop;
  return aux;
end;
$$ language plpgsql immutable strict;
create or replace function pleast(numeric)returns numeric as $$begin  raise notice 'non-variadic function called';
  return $1;
end;
$$ language plpgsql immutable strict;
drop function pleast(numeric[]);
drop function pleast(numeric);
create function tftest(int) returns table(a int, b int) as $$begin  return query select $1, $1+i from generate_series(1,5) g(i);
end;
$$ language plpgsql immutable strict;
create or replace function tftest(a1 int) returns table(a int, b int) as $$begin  a := a1; b := a1 + 1;
  return next;
  a := a1 * 10; b := a1 * 10 + 1;
  return next;
end;
$$ language plpgsql immutable strict;
drop function tftest(int);
create or replace function rttest()returns setof int as $$declare rc int;
  rca int[];
begin  return query values(10),(20);
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query select * from (values(10),(20)) f(a) where false;
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query execute 'values(10),(20)';
  -- just for fun, let's use array elements as targets  get diagnostics rca[1] = row_count;
  raise notice '% %', found, rca[1];
  return query execute 'select * from (values(10),(20)) f(a) where false';
  get diagnostics rca[2] = row_count;
  raise notice '% %', found, rca[2];
end;
$$ language plpgsql;
select * from rttest();
drop function rttest();
CREATE FUNCTION leaker_1(fail BOOL) RETURNS INTEGER AS $$DECLARE  v_var INTEGER;
BEGIN  BEGIN    v_var := (leaker_2(fail)).error_code;
  EXCEPTION    WHEN others THEN RETURN 0;
  END;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION leaker_2(fail BOOL, OUT error_code INTEGER, OUT new_id INTEGER)  RETURNS RECORD AS $$BEGIN  IF fail THEN    RAISE EXCEPTION 'fail ...';
  END IF;
  error_code := 1;
  new_id := 1;
  RETURN;
END;
$$ LANGUAGE plpgsql;
DROP FUNCTION leaker_1(bool);
DROP FUNCTION leaker_2(bool);
CREATE FUNCTION nonsimple_expr_test() RETURNS text[] AS $$DECLARE  arr text[];
  lr text;
  i integer;
BEGIN  arr := array[array['foo','bar'], array['baz', 'quux']];
  lr := 'fool';
  i := 1;
  -- use sub-SELECTs to make expressions non-simple  arr[(SELECT i)][(SELECT i+1)] := (SELECT lr);
  RETURN arr;
END;
$$ LANGUAGE plpgsql;
DROP FUNCTION nonsimple_expr_test();
CREATE FUNCTION nonsimple_expr_test() RETURNS integer AS $$declare   i integer NOT NULL := 0;
begin  begin    i := (SELECT NULL::integer);  -- should throw error  exception    WHEN OTHERS THEN      i := (SELECT 1::integer);
  end;
  return i;
end;
$$ LANGUAGE plpgsql;
DROP FUNCTION nonsimple_expr_test();
create function recurse(float8) returns float8 as$$begin  if ($1 > 0) then    return sql_recurse($1 - 1);
  else    return $1;
  end if;
end;
$$ language plpgsql;
create function sql_recurse(float8) returns float8 as$$ select recurse($1) limit 1; $$ language sql;
create function error1(text) returns text language sql as$$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
create function error2(p_name_table text) returns text language plpgsql as $$begin  return error1(p_name_table);
end$$;
BEGIN;
create table public.stuffs (stuff text);
SAVEPOINT a;
ROLLBACK TO a;
rollback;
drop function error2(p_name_table text);
drop function error1(text);
create function sql_to_date(integer) returns date as $$select $1::text::date$$ language sql immutable strict;
create cast (integer as date) with function sql_to_date(integer) as assignment;
create function cast_invoker(integer) returns date as $$begin  return $1;
end$$ language plpgsql;
select cast_invoker(20150718);  -- second call crashed in pre-release 9.5begin;
savepoint s1;
select cast_invoker(-1); -- failsrollback to savepoint s1;
commit;
drop function cast_invoker(integer);
drop function sql_to_date(integer) cascade;
begin;
do $$ declare x text[]; begin x := '{1.23, 4.56}'::numeric[]; end $$;
do $$ declare x text[]; begin x := '{1.23, 4.56}'::numeric[]; end $$;
end;
create function fail() returns int language plpgsql as $$begin  return 1/0;
end$$;
drop function fail();
set standard_conforming_strings = off;
create or replace function strtest() returns text as $$begin  raise notice 'foo\\bar\041baz';
  return 'foo\\bar\041baz';
end$$ language plpgsql;
create or replace function strtest() returns text as $$begin  raise notice E'foo\\bar\041baz';
  return E'foo\\bar\041baz';
end$$ language plpgsql;
set standard_conforming_strings = on;
create or replace function strtest() returns text as $$begin  raise notice 'foo\\bar\041baz\';
  return 'foo\\bar\041baz\';
end$$ language plpgsql;
create or replace function strtest() returns text as $$begin  raise notice E'foo\\bar\041baz';
  return E'foo\\bar\041baz';
end$$ language plpgsql;
drop function strtest();
DO $$DECLARE r record;
BEGIN    FOR r IN SELECT rtrim(roomno) AS roomno, comment FROM Room ORDER BY roomno    LOOP        RAISE NOTICE '%, %', r.roomno, r.comment;
    END LOOP;
END$$;
DO LANGUAGE plpgsql $$begin return 1; end$$;
DO $$DECLARE r record;
BEGIN    FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno    LOOP        RAISE NOTICE '%, %', r.roomno, r.comment;
    END LOOP;
END$$;
do $outer$begin  for i in 1..10 loop   begin    execute $ex$      do $$      declare x int = 0;
      begin        x := 1 / x;
      end;
      $$;
$    $ex$;
  exception when division_by_zero then    raise notice 'caught division by zero';
  end;
  end loop;
end;
$$outer$;
create function scope_test() returns int as $$declare x int := 42;
begin  declare y int := x + 1;
          x int := x + 2;
  begin    return x * 100 + y;
  end;
end;
$$ language plpgsql;
drop function scope_test();
set plpgsql.variable_conflict = error;
create function conflict_test() returns setof int8_tbl as $$declare r record;
  q1 bigint := 42;
begin  for r in select q1,q2 from int8_tbl loop    return next r;
  end loop;
end;
$$ language plpgsql;
select * from conflict_test();
create or replace function conflict_test() returns setof int8_tbl as $$#variable_conflict use_variabledeclare r record;
  q1 bigint := 42;
begin  for r in select q1,q2 from int8_tbl loop    return next r;
  end loop;
end;
$$ language plpgsql;
select * from conflict_test();
create or replace function conflict_test() returns setof int8_tbl as $$#variable_conflict use_columndeclare r record;
  q1 bigint := 42;
begin  for r in select q1,q2 from int8_tbl loop    return next r;
  end loop;
end;
$$ language plpgsql;
select * from conflict_test();
drop function conflict_test();
create function unreserved_test() returns int as $$declare  forward int := 21;
begin  forward := forward * 2;
  return forward;
end$$ language plpgsql;
create or replace function unreserved_test() returns int as $$declare  return int := 42;
begin  return := return + 1;
  return return;
end$$ language plpgsql;
create or replace function unreserved_test() returns int as $$declare  comment int := 21;
begin  comment := comment * 2;
  comment on function unreserved_test() is 'this is a test';
  return comment;
end$$ language plpgsql;
::drop function unreserved_test();
create function foreach_test(anyarray)returns void as $$declare x int;
begin  foreach x in array $1  loop    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
select foreach_test(ARRAY[[1,2],[3,4]]);
create or replace function foreach_test(anyarray)returns void as $$declare x int;
begin  foreach x slice 1 in array $1  loop    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
select foreach_test(ARRAY[[1,2],[3,4]]);
create or replace function foreach_test(anyarray)returns void as $$declare x int[];
begin  foreach x slice 1 in array $1  loop    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
select foreach_test(ARRAY[[1,2],[3,4]]);
create or replace function foreach_test(anyarray)returns void as $$declare x int[];
begin  foreach x slice 2 in array $1  loop    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
select foreach_test(ARRAY[[1,2],[3,4]]);
select foreach_test(ARRAY[[[1,2]],[[3,4]]]);
create type xy_tuple AS (x int, y int);
create or replace function foreach_test(anyarray)returns void as $$declare r record;
begin  foreach r in array $1  loop    raise notice '%', r;
  end loop;
  end;
$$ language plpgsql;
::select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
create or replace function foreach_test(anyarray)returns void as $$declare x int; y int;
begin  foreach x, y in array $1  loop    raise notice 'x = %, y = %', x, y;
  end loop;
  end;
$$ language plpgsql;
::select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
create or replace function foreach_test(anyarray)returns void as $$declare x xy_tuple[];
begin  foreach x slice 1 in array $1  loop    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
::select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
drop function foreach_test(anyarray);
drop type xy_tuple;
create temp table rtype (id int, ar text[]);
create function arrayassign1() returns text[] language plpgsql as $$declare r record;
begin  r := row(12, '{foo,bar,baz}')::rtype;
  r.ar[2] := 'replace';
  return r.ar;
end$$;
select arrayassign1(); -- try again to exercise internal cachingcreate domain orderedarray as int[2]  constraint sorted check (value[1] < value[2]);
::::select '{2,1}'::orderedarray;  -- failcreate function testoa(x1 int, x2 int, x3 int) returns orderedarraylanguage plpgsql as $$declare res orderedarray;
begin  res := array[x1, x2];
  res[2] := x3;
  return res;
end$$;
select testoa(1,2,3); -- try again to exercise internal cachingselect testoa(2,1,3); -- fail at initial assignselect testoa(1,2,1); -- fail at updatedrop function arrayassign1();
drop function testoa(x1 int, x2 int, x3 int);
create function returns_rw_array(int) returns int[]language plpgsql as $$  declare r int[];
  begin r := array[$1, $1]; return r; end;
$$ stable;
create function consumes_rw_array(int[]) returns intlanguage plpgsql as $$  begin return $1[1]; end;
$$ stable;
explain (verbose, costs off)select i, a from  (select returns_rw_array(1) as a offset 0) ss,  lateral consumes_rw_array(a) i;
select i, a from  (select returns_rw_array(1) as a offset 0) ss,  lateral consumes_rw_array(a) i;
explain (verbose, costs off)select consumes_rw_array(a), a from returns_rw_array(1) a;
explain (verbose, costs off)select consumes_rw_array(a), a from  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
select consumes_rw_array(a), a from  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
do $$declare a int[] := array[1,2];
begin  a := a || 3;
  raise notice 'a = %', a;
end$$;
create function inner_func(int)returns int as $$declare _context text;
begin  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  -- lets do it again, just for fun..  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  raise notice 'lets make sure we didnt break anything';
  return 2 * $1;
end;
$$ language plpgsql;
create or replace function outer_func(int)returns int as $$declare  myresult int;
begin  raise notice 'calling down into inner_func()';
  myresult := inner_func($1);
  raise notice 'inner_func() done';
  return myresult;
end;
$$ language plpgsql;
create or replace function outer_outer_func(int)returns int as $$declare  myresult int;
begin  raise notice 'calling down into outer_func()';
  myresult := outer_func($1);
  raise notice 'outer_func() done';
  return myresult;
end;
$$ language plpgsql;
drop function outer_outer_func(int);
drop function outer_func(int);
drop function inner_func(int);
create function inner_func(int)returns int as $$declare  _context text;
  sx int := 5;
begin  begin    perform sx / 0;
  exception    when division_by_zero then      get diagnostics _context = pg_context;
      raise notice '***%***', _context;
  end;
  -- lets do it again, just for fun..  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  raise notice 'lets make sure we didnt break anything';
  return 2 * $1;
end;
$$ language plpgsql;
create or replace function outer_func(int)returns int as $$declare  myresult int;
begin  raise notice 'calling down into inner_func()';
  myresult := inner_func($1);
  raise notice 'inner_func() done';
  return myresult;
end;
$$ language plpgsql;
create or replace function outer_outer_func(int)returns int as $$declare  myresult int;
begin  raise notice 'calling down into outer_func()';
  myresult := outer_func($1);
  raise notice 'outer_func() done';
  return myresult;
end;
$$ language plpgsql;
drop function outer_outer_func(int);
drop function outer_func(int);
drop function inner_func(int);
do $$begin  assert 1=1;  -- should succeedend;
$$;
do $$begin  assert 1=0;  -- should failend;
$$;
do $$begin  assert NULL;  -- should failend;
$$;
set plpgsql.check_asserts = off;
do $$begin  assert 1=0;  -- won't be testedend;
$$;
reset plpgsql.check_asserts;
do $$declare var text := 'some value';
begin  assert 1=0, format('assertion failed, var = "%s"', var);
end;
$$;
do $$begin  assert 1=0, 'unhandled assertion';
exception when others then  null; -- do nothingend;
$$;
create function plpgsql_domain_check(val int) returns boolean as $$begin return val > 0; end$$ language plpgsql immutable;
create domain plpgsql_domain as integer check(plpgsql_domain_check(value));
do $$declare v_test plpgsql_domain;
begin  v_test := 1;
end;
$$;
do $$declare v_test plpgsql_domain := 1;
begin  v_test := 0;  -- failend;
$$;
create function plpgsql_arr_domain_check(val int[]) returns boolean as $$begin return val[1] > 0; end$$ language plpgsql immutable;
create domain plpgsql_arr_domain as int[] check(plpgsql_arr_domain_check(value));
do $$declare v_test plpgsql_arr_domain;
begin  v_test := array[1];
  v_test := v_test || 2;
end;
$$;
do $$declare v_test plpgsql_arr_domain := array[1];
begin  v_test := 0 || v_test;  -- failend;
$$;
CREATE FUNCTION transition_table_base_ins_func()  RETURNS trigger  LANGUAGE plpgsqlAS $$DECLARE  t text;
  l text;
BEGIN  t = '';
  FOR l IN EXECUTE           $q$             EXPLAIN (TIMING off, COSTS off, VERBOSE on)             SELECT * FROM newtable           $q$ LOOP    t = t || l || E'\n';
  END LOOP;
  RAISE INFO '%', t;
  RETURN new;
END;
$$;
CREATE TRIGGER transition_table_base_ins_trig  AFTER INSERT ON transition_table_base  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable  FOR EACH STATEMENT  EXECUTE PROCEDURE transition_table_base_ins_func();
CREATE TRIGGER transition_table_base_ins_trig  AFTER INSERT ON transition_table_base  REFERENCING NEW TABLE AS newtable  FOR EACH STATEMENT  EXECUTE PROCEDURE transition_table_base_ins_func();
CREATE OR REPLACE FUNCTION transition_table_base_upd_func()  RETURNS trigger  LANGUAGE plpgsqlAS $$DECLARE  t text;
  l text;
BEGIN  t = '';
  FOR l IN EXECUTE           $q$             EXPLAIN (TIMING off, COSTS off, VERBOSE on)             SELECT * FROM oldtable ot FULL JOIN newtable nt USING (id)           $q$ LOOP    t = t || l || E'\n';
  END LOOP;
  RAISE INFO '%', t;
  RETURN new;
END;
$$;
CREATE TRIGGER transition_table_base_upd_trig  AFTER UPDATE ON transition_table_base  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable  FOR EACH STATEMENT  EXECUTE PROCEDURE transition_table_base_upd_func();
||UPDATE transition_table_base  SET val = '*' || val || '*'  WHERE id BETWEEN 2 AND 3;
CREATE TABLE transition_table_level1      level1_no serial NOT NULL ,      level1_node_name varchar(255),       PRIMARY KEY (level1_no)) WITHOUT OIDS;
CREATE TABLE transition_table_level2      level2_no serial NOT NULL ,      parent_no int NOT NULL,      level1_node_name varchar(255),       PRIMARY KEY (level2_no)) WITHOUT OIDS;
CREATE TABLE transition_table_status      level int NOT NULL,      node_no int NOT NULL,      status int,       PRIMARY KEY (level, node_no)) WITHOUT OIDS;
CREATE FUNCTION transition_table_level1_ri_parent_del_func()  RETURNS TRIGGER  LANGUAGE plpgsqlAS $$  DECLARE n bigint;
  BEGIN    PERFORM FROM p JOIN transition_table_level2 c ON c.parent_no = p.level1_no;
    IF FOUND THEN      RAISE EXCEPTION 'RI error';
    END IF;
    RETURN NULL;
  END;
$$;
CREATE TRIGGER transition_table_level1_ri_parent_del_trigger  AFTER DELETE ON transition_table_level1  REFERENCING OLD TABLE AS p  FOR EACH STATEMENT EXECUTE PROCEDURE    transition_table_level1_ri_parent_del_func();
CREATE FUNCTION transition_table_level1_ri_parent_upd_func()  RETURNS TRIGGER  LANGUAGE plpgsqlAS $$  DECLARE    x int;
  BEGIN    WITH p AS (SELECT level1_no, sum(delta) cnt                 FROM (SELECT level1_no, 1 AS delta FROM i                       UNION ALL                       SELECT level1_no, -1 AS delta FROM d) w                 GROUP BY level1_no                 HAVING sum(delta) < 0)    SELECT level1_no      FROM p JOIN transition_table_level2 c ON c.parent_no = p.level1_no      INTO x;
    IF FOUND THEN      RAISE EXCEPTION 'RI error';
    END IF;
    RETURN NULL;
  END;
$$;
CREATE TRIGGER transition_table_level1_ri_parent_upd_trigger  AFTER UPDATE ON transition_table_level1  REFERENCING OLD TABLE AS d NEW TABLE AS i  FOR EACH STATEMENT EXECUTE PROCEDURE    transition_table_level1_ri_parent_upd_func();
CREATE FUNCTION transition_table_level2_ri_child_insupd_func()  RETURNS TRIGGER  LANGUAGE plpgsqlAS $$  BEGIN    PERFORM FROM i      LEFT JOIN transition_table_level1 p        ON p.level1_no IS NOT NULL AND p.level1_no = i.parent_no      WHERE p.level1_no IS NULL;
    IF FOUND THEN      RAISE EXCEPTION 'RI error';
    END IF;
    RETURN NULL;
  END;
$$;
CREATE TRIGGER transition_table_level2_ri_child_ins_trigger  AFTER INSERT ON transition_table_level2  REFERENCING NEW TABLE AS i  FOR EACH STATEMENT EXECUTE PROCEDURE    transition_table_level2_ri_child_insupd_func();
CREATE TRIGGER transition_table_level2_ri_child_upd_trigger  AFTER UPDATE ON transition_table_level2  REFERENCING NEW TABLE AS i  FOR EACH STATEMENT EXECUTE PROCEDURE    transition_table_level2_ri_child_insupd_func();
ANALYZE transition_table_level1;
ANALYZE transition_table_level2;
ANALYZE transition_table_status;
ANALYZE transition_table_level1;
CREATE FUNCTION transition_table_level2_bad_usage_func()  RETURNS TRIGGER  LANGUAGE plpgsqlAS $$  BEGIN    INSERT INTO dx VALUES (1000000, 1000000, 'x');
    RETURN NULL;
  END;
$$;
CREATE TRIGGER transition_table_level2_bad_usage_trigger  AFTER DELETE ON transition_table_level2  REFERENCING OLD TABLE AS dx  FOR EACH STATEMENT EXECUTE PROCEDURE    transition_table_level2_bad_usage_func();
DELETE FROM transition_table_level2  WHERE level2_no BETWEEN 301 AND 305;
DROP TRIGGER transition_table_level2_bad_usage_trigger  ON transition_table_level2;
DELETE FROM transition_table_level1  WHERE level1_no = 25;
DELETE FROM transition_table_level1  WHERE level1_no BETWEEN 201 AND 1000;
DELETE FROM transition_table_level1  WHERE level1_no BETWEEN 100000000 AND 100000010;
DELETE FROM transition_table_level2  WHERE level2_no BETWEEN 211 AND 220;
CREATE TABLE alter_table_under_transition_tables  id int PRIMARY KEY,  name text);
CREATE FUNCTION alter_table_under_transition_tables_upd_func()  RETURNS TRIGGER  LANGUAGE plpgsqlAS $$BEGIN  RAISE WARNING 'old table = %, new table = %',                  (SELECT string_agg(id || '=' || name, ',') FROM d),                  (SELECT string_agg(id || '=' || name, ',') FROM i);
  RAISE NOTICE 'one = %', (SELECT 1 FROM alter_table_under_transition_tables LIMIT 1);
  RETURN NULL;
END;
$$;
CREATE TRIGGER alter_table_under_transition_tables_upd_trigger  AFTER TRUNCATE OR UPDATE ON alter_table_under_transition_tables  REFERENCING OLD TABLE AS d NEW TABLE AS i  FOR EACH STATEMENT EXECUTE PROCEDURE    alter_table_under_transition_tables_upd_func();
CREATE TRIGGER alter_table_under_transition_tables_upd_trigger  AFTER UPDATE ON alter_table_under_transition_tables  REFERENCING OLD TABLE AS d NEW TABLE AS i  FOR EACH STATEMENT EXECUTE PROCEDURE    alter_table_under_transition_tables_upd_func();
||UPDATE alter_table_under_transition_tables  SET name = name || name;
ALTER TABLE alter_table_under_transition_tables  ALTER COLUMN name TYPE int USING name::integer;
::UPDATE alter_table_under_transition_tables  SET name = (name::text || name::text)::integer;
ALTER TABLE alter_table_under_transition_tables  DROP column name;
CREATE OR REPLACE FUNCTION multi_test_trig() RETURNS triggerLANGUAGE plpgsql AS $$BEGIN    RAISE NOTICE 'count = %', (SELECT COUNT(*) FROM new_test);
    RAISE NOTICE 'count union = %',      (SELECT COUNT(*)       FROM (SELECT * FROM new_test UNION ALL SELECT * FROM new_test) ss);
    RETURN NULL;
END$$;
CREATE TRIGGER my_trigger AFTER UPDATE ON multi_test  REFERENCING NEW TABLE AS new_test OLD TABLE as old_test  FOR EACH STATEMENT EXECUTE PROCEDURE multi_test_trig();
DROP FUNCTION multi_test_trig();
CREATE TABLE partitioned_table (a int, b text) PARTITION BY LIST (a);
CREATE TABLE pt_part1 PARTITION OF partitioned_table FOR VALUES IN (1);
CREATE TABLE pt_part2 PARTITION OF partitioned_table FOR VALUES IN (2);
CREATE OR REPLACE FUNCTION get_from_partitioned_table(partitioned_table.a%type)RETURNS partitioned_table AS $$DECLARE    a_val partitioned_table.a%TYPE;
    result partitioned_table%ROWTYPE;
BEGIN    a_val := $1;
    SELECT * INTO result FROM partitioned_table WHERE a = a_val;
    RETURN result;
END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION list_partitioned_table()RETURNS SETOF partitioned_table.a%TYPE AS $$DECLARE    row partitioned_table%ROWTYPE;
    a_val partitioned_table.a%TYPE;
BEGIN    FOR row IN SELECT * FROM partitioned_table ORDER BY a LOOP        a_val := row.a;
        RETURN NEXT a_val;
    END LOOP;
    RETURN;
END; $$ LANGUAGE plpgsql;
SELECT * FROM list_partitioned_table() AS t;
CREATE FUNCTION fx(x WSlot) RETURNS void AS $$BEGIN  GET DIAGNOSTICS x = ROW_COUNT;
  RETURN;
END; $$ LANGUAGE plpgsql;
CREATE TABLE mchash (a int, b text, c jsonb)  PARTITION BY HASH (a part_test_int4_ops, b part_test_text_ops);
CREATE TABLE mchash1  PARTITION OF mchash FOR VALUES WITH (MODULUS 4, REMAINDER 0);
SELECT satisfies_hash_partition(0, 4, 0, NULL);
::SELECT satisfies_hash_partition('tenk1'::regclass, 4, 0, NULL);
::SELECT satisfies_hash_partition('mchash1'::regclass, 4, 0, NULL);
::SELECT satisfies_hash_partition('mchash'::regclass, 0, 0, NULL);
::SELECT satisfies_hash_partition('mchash'::regclass, 1, -1, NULL);
::SELECT satisfies_hash_partition('mchash'::regclass, 1, 1, NULL);
::SELECT satisfies_hash_partition('mchash'::regclass, NULL, 0, NULL);
::SELECT satisfies_hash_partition('mchash'::regclass, 4, NULL, NULL);
::SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, NULL::int, NULL::text, NULL::json);
::SELECT satisfies_hash_partition('mchash'::regclass, 3, 1, NULL::int);
::SELECT satisfies_hash_partition('mchash'::regclass, 2, 1, NULL::int, NULL::int);
::::SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, 0, ''::text);
::::SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, 2, ''::text);
::SELECT satisfies_hash_partition('mchash'::regclass, 2, 1,								variadic array[1,2]::int[]);
CREATE TABLE mcinthash (a int, b int, c jsonb)  PARTITION BY HASH (a part_test_int4_ops, b part_test_int4_ops);
::SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,								variadic array[0, 0]);
::SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,								variadic array[0, 1]);
::SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,								variadic array[]::int[]);
::SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,								variadic array[now(), now()]);
create table text_hashp (a text) partition by hash (a);
create table text_hashp0 partition of text_hashp for values with (modulus 2, remainder 0);
create table text_hashp1 partition of text_hashp for values with (modulus 2, remainder 1);
::::select satisfies_hash_partition('text_hashp'::regclass, 2, 0, 'xxx'::text) OR	   satisfies_hash_partition('text_hashp'::regclass, 2, 1, 'xxx'::text) AS satisfies;
CREATE TABLE ttable1 OF nothing;
CREATE TYPE person_type AS (id int, name text);
CREATE TABLE persons OF person_type;
CREATE TABLE IF NOT EXISTS persons OF person_type;
CREATE FUNCTION get_all_persons() RETURNS SETOF person_typeLANGUAGE SQLAS $$    SELECT * FROM persons;
$$;
SELECT * FROM get_all_persons();
ALTER TABLE persons DROP COLUMN name;
ALTER TABLE persons ALTER COLUMN name TYPE varchar;
ALTER TABLE persons INHERIT stuff;
CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL); -- errorCREATE TABLE persons2 OF person_type (    id WITH OPTIONS PRIMARY KEY,    UNIQUE (name));
CREATE TABLE persons3 OF person_type (    PRIMARY KEY (id),    name WITH OPTIONS DEFAULT '');
CREATE TABLE persons4 OF person_type (    name WITH OPTIONS NOT NULL,    name WITH OPTIONS DEFAULT ''  -- error, specified more than once);
DROP TYPE person_type RESTRICT;
DROP TYPE person_type CASCADE;
CREATE TABLE persons5 OF stuff; -- only CREATE TYPE AS types may be usedDROP TABLE stuff;
CREATE TYPE person_type AS (id int, name text);
CREATE TABLE persons OF person_type;
CREATE FUNCTION namelen(person_type) RETURNS int LANGUAGE SQL AS $$ SELECT length($1.name) $$;
CREATE TABLE persons2 OF person_type (    id WITH OPTIONS PRIMARY KEY,    UNIQUE (name));
CREATE TABLE persons3 OF person_type (    PRIMARY KEY (id),    name NOT NULL DEFAULT '');
CREATE USER regress_dep_user;
CREATE USER regress_dep_user2;
CREATE USER regress_dep_user3;
CREATE GROUP regress_dep_group;
CREATE TABLE deptest (f1 serial primary key, f2 text);
GRANT SELECT ON TABLE deptest TO GROUP regress_dep_group;
GRANT ALL ON TABLE deptest TO regress_dep_user, regress_dep_user2;
DROP USER regress_dep_user;
DROP GROUP regress_dep_group;
REVOKE SELECT ON deptest FROM GROUP regress_dep_group;
DROP GROUP regress_dep_group;
REVOKE SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES ON deptest FROM regress_dep_user;
DROP USER regress_dep_user;
REVOKE TRIGGER ON deptest FROM regress_dep_user;
DROP USER regress_dep_user;
REVOKE ALL ON deptest FROM regress_dep_user2;
DROP USER regress_dep_user2;
\\set VERBOSITY terseALTER TABLE deptest OWNER TO regress_dep_user3;
DROP USER regress_dep_user3;
\\set VERBOSITY defaultDROP TABLE deptest;
DROP USER regress_dep_user3;
CREATE USER regress_dep_user0;
CREATE USER regress_dep_user1;
CREATE USER regress_dep_user2;
SET SESSION AUTHORIZATION regress_dep_user0;
DROP OWNED BY regress_dep_user1;
DROP OWNED BY regress_dep_user0, regress_dep_user2;
REASSIGN OWNED BY regress_dep_user0 TO regress_dep_user1;
REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user0;
DROP OWNED BY regress_dep_user0;
GRANT ALL ON deptest1 TO regress_dep_user1 WITH GRANT OPTION;
SET SESSION AUTHORIZATION regress_dep_user1;
CREATE TABLE deptest (a serial primary key, b text);
GRANT ALL ON deptest1 TO regress_dep_user2;
RESET SESSION AUTHORIZATION;
\\z deptest1DROP OWNED BY regress_dep_user1;
\\z deptest1GRANT ALL ON deptest1 TO regress_dep_user1;
GRANT CREATE ON DATABASE regression TO regress_dep_user1;
SET SESSION AUTHORIZATION regress_dep_user1;
CREATE SCHEMA deptest;
CREATE TABLE deptest (a serial primary key, b text);
ALTER DEFAULT PRIVILEGES FOR ROLE regress_dep_user1 IN SCHEMA deptest  GRANT ALL ON TABLES TO regress_dep_user2;
CREATE FUNCTION deptest_func() RETURNS void LANGUAGE plpgsql  AS $$ BEGIN END; $$;
CREATE TYPE deptest_enum AS ENUM ('red');
CREATE TYPE deptest_range AS RANGE (SUBTYPE = int4);
CREATE SEQUENCE ss1;
ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
CREATE TYPE deptest_t AS (a int);
SELECT typowner = relownerFROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
RESET SESSION AUTHORIZATION;
REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user2;
SELECT typowner = relownerFROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
DROP USER regress_dep_user1;
DROP OWNED BY regress_dep_user1;
DROP USER regress_dep_user1;
DROP USER regress_dep_user2;
DROP OWNED BY regress_dep_user2, regress_dep_user0;
DROP USER regress_dep_user2;
DROP USER regress_dep_user0;
GRANT SELECT ON pg_proc TO CURRENT_USER;
GRANT SELECT (prosrc) ON pg_proc TO CURRENT_USER;
GRANT SELECT (rolname, rolsuper) ON pg_authid TO CURRENT_USER;
CREATE TABLE b (bb TEXT) INHERITS (a);
CREATE TABLE c (cc TEXT) INHERITS (a);
CREATE TABLE d (dd TEXT) INHERITS (b,c,a);
SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
DELETE FROM ONLY c WHERE aa='new';
SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
DELETE FROM a;
SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
CREATE TEMP TABLE z (b TEXT, PRIMARY KEY(aa, b)) inherits (a);
INSERT INTO z VALUES (NULL, 'text'); -- should failcreate table some_tab (a int, b int);
create table some_tab_child () inherits (some_tab);
explain (verbose, costs off)update some_tab set a = a + 1 where false;
explain (verbose, costs off)update some_tab set a = a + 1 where false returning b, a;
update some_tab set a = a + 1 where false returning b, a;
table some_tab;
drop table some_tab cascade;
create temp table foo2(f3 int) inherits (foo);
create temp table bar2(f3 int) inherits (bar);
::::select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
update bar set f2 = f2 + 100from  ( select f1 from foo union all select f1+3 from foo ) sswhere bar.f1 = ss.f1;
::::select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
create table some_tab_child () inherits (some_tab);
create table parted_tab (a int, b char) partition by list (a);
create table parted_tab_part1 partition of parted_tab for values in (1);
create table parted_tab_part2 partition of parted_tab for values in (2);
create table parted_tab_part3 partition of parted_tab for values in (3);
update parted_tab set b = 'b'from  (select a from some_tab union all select a+1 from some_tab) ss (a)where parted_tab.a = ss.a;
::::select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;
truncate parted_tab;
update parted_tab set b = 'b'from  (select 0 from parted_tab union all select 1 from parted_tab) ss (a)where parted_tab.a = ss.a;
::::select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;
explain update parted_tab set a = 2 where false;
create table mlparted_tab (a int, b char, c text) partition by list (a);
create table mlparted_tab_part1 partition of mlparted_tab for values in (1);
create table mlparted_tab_part2 partition of mlparted_tab for values in (2) partition by list (b);
create table mlparted_tab_part3 partition of mlparted_tab for values in (3);
create table mlparted_tab_part2a partition of mlparted_tab_part2 for values in ('a');
create table mlparted_tab_part2b partition of mlparted_tab_part2 for values in ('b');
update mlparted_tab mlp set c = 'xxx'from  (select a from some_tab union all select a+1 from some_tab) ss (a)where (mlp.a = ss.a and mlp.b = 'b') or mlp.a = 3;
::::select tableoid::regclass::text as relname, mlparted_tab.* from mlparted_tab order by 1,2;
drop table some_tab cascade;
/* Test multiple inheritance of column defaults */CREATE TABLE firstparent (tomorrow date default now()::date + 1);
CREATE TABLE secondparent (tomorrow date default  now() :: date  +  1);
CREATE TABLE jointchild () INHERITS (firstparent, secondparent);  -- okCREATE TABLE thirdparent (tomorrow date default now()::date - 1);
CREATE TABLE otherchild () INHERITS (firstparent, thirdparent);  -- not okCREATE TABLE otherchild (tomorrow date default now())  INHERITS (firstparent, thirdparent);  -- ok, child resolves ambiguous defaultDROP TABLE firstparent, secondparent, jointchild, thirdparent, otherchild;
alter table a alter column aa type integer using bit_length(aa);
create temp table childtab(f4 int) inherits(parent1, parent2);
alter table parent1 alter column f1 type bigint;  -- fail, conflict w/parent2alter table parent1 alter column f2 type bigint;  -- okcreate table p1(ff1 int);
alter table p1 add constraint p1chk check (ff1 > 0) no inherit;
alter table p1 add constraint p2chk check (ff1 > 10);
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.connoinherit from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname = 'p1' order by 1,2;
create table c1 () inherits (p1);
create table c2 (constraint p2chk check (ff1 > 10) no inherit) inherits (p1);	--failsdrop table p1 cascade;
create table derived () inherits (base);
create table more_derived (like derived, b int) inherits (derived);
::select NULL::derived::base;
explain (verbose on, costs off) select row(i, b)::more_derived::derived::base from more_derived;
explain (verbose on, costs off) select (1, 2)::more_derived::derived::base;
create function p2text(p2) returns text as 'select $1.f1' language sql;
create table c1(f3 int) inherits(p1,p2);
select p2text(c1.*) from c1;
drop function p2text(p2);
alter table ac add constraint ac_check check (aa is not null);
CREATE TABLE bc (bb TEXT) INHERITS (ac);
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
insert into ac (aa) values (NULL);
insert into bc (aa) values (NULL);
alter table bc drop constraint ac_check;  -- fail, disallowedalter table ac drop constraint ac_check;
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
alter table ac add check (aa is not null);
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
insert into ac (aa) values (NULL);
insert into bc (aa) values (NULL);
alter table bc drop constraint ac_aa_check;  -- fail, disallowedalter table ac drop constraint ac_aa_check;
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
alter table ac add constraint ac_check check (aa is not null);
alter table bc no inherit ac;
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
alter table bc drop constraint ac_check;
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
alter table ac drop constraint ac_check;
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
create table ac (a int constraint check_a check (a <> 0));
create table bc (a int constraint check_a check (a <> 0), b int constraint check_b check (b <> 0)) inherits (ac);
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
create table ac (a int constraint check_a check (a <> 0));
create table bc (b int constraint check_b check (b <> 0));
create table cc (c int constraint check_c check (c <> 0)) inherits (ac, bc);
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
alter table cc no inherit bc;
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
create table c1(f3 int) inherits(p1,p2);
alter table p2 add constraint cc check (f2>0);  -- failalter table p2 add check (f2>0);  -- check it without a name, toodelete from c1;
alter table p2 add check (f2>0);
insert into c1 values(1,-1,2);  -- failcreate table c2(f3 int) inherits(p1,p2);
create table c3 (f4 int) inherits(c1,c2);
drop table p1 cascade;
drop table p2 cascade;
create table cc1 (f2 text, f3 int) inherits (pp1);
create table cc2(f4 float) inherits(pp1,cc1);
drop table pp1 cascade;
CREATE TABLE inhts (d int) INHERITS (inht1, inhs1);
ALTER TABLE inht1 RENAME b TO bb;                -- to be failedALTER TABLE inhts RENAME aa TO aaa;      -- to be failedALTER TABLE inhts RENAME d TO dd;
CREATE TABLE inht2 (x int) INHERITS (inht1);
CREATE TABLE inht3 (y int) INHERITS (inht1);
CREATE TABLE inht4 (z int) INHERITS (inht2, inht3);
CREATE TABLE inhts (d int) INHERITS (inht2, inhs1);
ALTER TABLE inht1 RENAME b TO bb;                -- to be failedWITH RECURSIVE r AS (  SELECT 'inht1'::regclass AS inhrelidUNION ALL  SELECT c.inhrelid FROM pg_inherits c, r WHERE r.inhrelid = c.inhparentSELECT a.attrelid::regclass, a.attname, a.attinhcount, e.expected  FROM (SELECT inhrelid, count(*) AS expected FROM pg_inherits        WHERE inhparent IN (SELECT inhrelid FROM r) GROUP BY inhrelid) e  JOIN pg_attribute a ON e.inhrelid = a.attrelid WHERE NOT attislocal  ORDER BY a.attrelid::regclass::name, a.attnum;
DROP TABLE inht1, inhs1 CASCADE;
CREATE TABLE test_constraints (id int, val1 varchar, val2 int, UNIQUE(val1, val2));
CREATE TABLE test_constraints_inh () INHERITS (test_constraints);
ALTER TABLE ONLY test_constraints DROP CONSTRAINT test_constraints_val1_val2_key;
CREATE TABLE test_ex_constraints (    c circle,    EXCLUDE USING gist (c WITH &&));
CREATE TABLE test_ex_constraints_inh () INHERITS (test_ex_constraints);
ALTER TABLE test_ex_constraints DROP CONSTRAINT test_ex_constraints_c_excl;
CREATE TABLE test_foreign_constraints_inh () INHERITS (test_foreign_constraints);
ALTER TABLE test_foreign_constraints DROP CONSTRAINT test_foreign_constraints_id1_fkey;
create table inh_fk_2_child () inherits (inh_fk_2);
delete from inh_fk_1 where a = 1;
select * from inh_fk_2 order by 1, 2;
drop table inh_fk_1, inh_fk_2, inh_fk_2_child;
create table p1_c1() inherits(p1);
alter table p1 add constraint inh_check_constraint1 check (f1 > 0);
alter table p1_c1 add constraint inh_check_constraint1 check (f1 > 0);
alter table p1_c1 add constraint inh_check_constraint2 check (f1 < 10);
alter table p1 add constraint inh_check_constraint2 check (f1 < 10);
::::select conrelid::regclass::text as relname, conname, conislocal, coninhcountfrom pg_constraint where conname like 'inh\_check\_constraint%'order by 1, 2;
drop table p1 cascade;
create table invalid_check_con_child() inherits(invalid_check_con);
alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0) not valid;
alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0); -- failalter table invalid_check_con_child drop constraint inh_check_constraint;
alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0);
alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0) not valid;
insert into invalid_check_con values(0); -- failinsert into invalid_check_con_child values(0); -- failselect conrelid::regclass::text as relname, conname,       convalidated, conislocal, coninhcount, connoinheritfrom pg_constraint where conname like 'inh\_check\_constraint%'order by 1, 2;
create temp table patest0 (id, x) as  select x, x from generate_series(0,1000) x;
create temp table patest1() inherits (patest0);
create temp table patest2() inherits (patest0);
analyze patest0;
analyze patest1;
analyze patest2;
explain (costs off)select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
explain (costs off)select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
drop table patest0 cascade;
create table matest0 (id serial primary key, name text);
create table matest1 (id integer primary key) inherits (matest0);
create table matest2 (id integer primary key) inherits (matest0);
create table matest3 (id integer primary key) inherits (matest0);
set enable_indexscan = off;  -- force use of seqscan/sort, so no mergeexplain (verbose, costs off) select * from matest0 order by 1-id;
explain (verbose, costs off) select min(1-id) from matest0;
reset enable_indexscan;
set enable_seqscan = off;  -- plan with fewest seqscans should be mergeset enable_parallel_append = off; -- Don't let parallel-append interfereexplain (verbose, costs off) select * from matest0 order by 1-id;
explain (verbose, costs off) select min(1-id) from matest0;
reset enable_seqscan;
reset enable_parallel_append;
drop table matest0 cascade;
create table matest1 () inherits(matest0);
set enable_nestloop = off;  -- we want a plan with two MergeAppendsexplain (costs off)select t1.* from matest0 t1, matest0 t2where t1.b = t2.b and t2.c = t2.dorder by t1.b limit 10;
reset enable_nestloop;
drop table matest0 cascade;
set enable_seqscan = off;
set enable_indexscan = on;
set enable_bitmapscan = off;
explain (costs off)SELECT thousand, tenthous FROM tenk1UNION ALLSELECT thousand, thousand FROM tenk1ORDER BY thousand, tenthous;
explain (costs off)SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1UNION ALLSELECT 42, 42, hundred FROM tenk1ORDER BY thousand, tenthous;
explain (costs off)SELECT thousand, tenthous FROM tenk1UNION ALLSELECT thousand, random()::integer FROM tenk1ORDER BY thousand, tenthous;
explain (costs off)SELECT min(x) FROM  (SELECT unique1 AS x FROM tenk1 a   UNION ALL   SELECT unique2 AS x FROM tenk1 b) s;
explain (costs off)SELECT min(y) FROM  (SELECT unique1 AS x, unique1 AS y FROM tenk1 a   UNION ALL   SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
explain (costs off)SELECT x, y FROM  (SELECT thousand AS x, tenthous AS y FROM tenk1 a   UNION ALL   SELECT unique2 AS x, unique2 AS y FROM tenk1 b) sORDER BY x, y;
explain (costs off)SELECT    ARRAY(SELECT f.i FROM (        (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)        UNION ALL        (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)    ) f(i)    ORDER BY f.i LIMIT 10)FROM generate_series(1, 3) g(i);
SELECT    ARRAY(SELECT f.i FROM (        (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)        UNION ALL        (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)    ) f(i)    ORDER BY f.i LIMIT 10)FROM generate_series(1, 3) g(i);
reset enable_seqscan;
reset enable_indexscan;
reset enable_bitmapscan;
create table cnullchild (check (f1 = 1 or f1 = null)) inherits(cnullparent);
insert into cnullchild values(null);
drop table cnullparent cascade;
create temp table inh_temp_child () inherits (inh_perm_parent); -- okcreate table inh_perm_child () inherits (inh_temp_parent); -- errorcreate temp table inh_temp_child_2 () inherits (inh_temp_parent); -- okinsert into inh_perm_parent values (1);
::::drop table inh_perm_parent cascade;
drop table inh_temp_parent cascade;
create table list_parted (	a	varchar) partition by list (a);
create table part_ab_cd partition of list_parted for values in ('ab', 'cd');
create table part_ef_gh partition of list_parted for values in ('ef', 'gh');
create table part_null_xy partition of list_parted for values in (null, 'xy');
explain (costs off) select * from list_parted;
explain (costs off) select * from list_parted where a is null;
explain (costs off) select * from list_parted where a is not null;
explain (costs off) select * from list_parted where a in ('ab', 'cd', 'ef');
explain (costs off) select * from list_parted where a = 'ab' or a in (null, 'cd');
explain (costs off) select * from list_parted where a = 'ab';
create table range_list_parted (	a	int,	b	char(2)) partition by range (a);
create table part_1_10 partition of range_list_parted for values from (1) to (10) partition by list (b);
create table part_1_10_ab partition of part_1_10 for values in ('ab');
create table part_1_10_cd partition of part_1_10 for values in ('cd');
create table part_10_20 partition of range_list_parted for values from (10) to (20) partition by list (b);
create table part_10_20_ab partition of part_10_20 for values in ('ab');
create table part_10_20_cd partition of part_10_20 for values in ('cd');
create table part_21_30 partition of range_list_parted for values from (21) to (30) partition by list (b);
create table part_21_30_ab partition of part_21_30 for values in ('ab');
create table part_21_30_cd partition of part_21_30 for values in ('cd');
create table part_40_inf partition of range_list_parted for values from (40) to (maxvalue) partition by list (b);
create table part_40_inf_ab partition of part_40_inf for values in ('ab');
create table part_40_inf_cd partition of part_40_inf for values in ('cd');
create table part_40_inf_null partition of part_40_inf for values in (null);
explain (costs off) select * from range_list_parted;
explain (costs off) select * from range_list_parted where a = 5;
explain (costs off) select * from range_list_parted where b = 'ab';
explain (costs off) select * from range_list_parted where a between 3 and 23 and b in ('ab');
/* Should select no rows because range partition key cannot be null */explain (costs off) select * from range_list_parted where a is null;
/* Should only select rows from the null-accepting partition */explain (costs off) select * from range_list_parted where b is null;
explain (costs off) select * from range_list_parted where a is not null and a < 67;
explain (costs off) select * from range_list_parted where a >= 30;
create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
create table mcrparted_def partition of mcrparted default;
create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
create table mcrparted1 partition of mcrparted for values from (1, 1, 1) to (10, 5, 10);
create table mcrparted2 partition of mcrparted for values from (10, 5, 10) to (10, 10, 10);
create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
create table mcrparted4 partition of mcrparted for values from (20, 10, 10) to (20, 20, 20);
create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
explain (costs off) select * from mcrparted where a = 0;	-- scans mcrparted0, mcrparted_defexplain (costs off) select * from mcrparted where a = 10 and abs(b) < 5;	-- scans mcrparted1, mcrparted_defexplain (costs off) select * from mcrparted where a = 10 and abs(b) = 5;	-- scans mcrparted1, mcrparted2, mcrparted_defexplain (costs off) select * from mcrparted where abs(b) = 5;	-- scans all partitionsexplain (costs off) select * from mcrparted where a > -1;	-- scans all partitionsexplain (costs off) select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;	-- scans mcrparted4explain (costs off) select * from mcrparted where a = 20 and c > 20; -- scans mcrparted3, mcrparte4, mcrparte5, mcrparted_defcreate table parted_minmax (a int, b varchar(16)) partition by range (a);
create table parted_minmax1 partition of parted_minmax for values from (1) to (10);
explain (costs off) select min(a), max(a) from parted_minmax where b = '12345';
explain (costs off) select * from mcrparted order by a, abs(b), c;
explain (costs off) select * from mcrparted order by a, abs(b), c;
explain (costs off) select * from mcrparted order by a desc, abs(b) desc, c desc;
create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue) partition by list (a);
create table mcrparted5a partition of mcrparted5 for values in(20);
create table mcrparted5_def partition of mcrparted5 default;
explain (costs off) select * from mcrparted order by a, abs(b), c;
explain (costs off) select a, abs(b) from mcrparted order by a, abs(b), c;
explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c;
create table mclparted (a int) partition by list(a);
create table mclparted1 partition of mclparted for values in(1);
create table mclparted2 partition of mclparted for values in(2);
create index on mclparted (a);
explain (costs off) select * from mclparted order by a;
create table mclparted3_5 partition of mclparted for values in(3,5);
create table mclparted4 partition of mclparted for values in(4);
explain (costs off) select * from mclparted order by a;
create index on mcrparted1 (a, abs(b), c);
create index on mcrparted2 (a, abs(b), c);
create index on mcrparted3 (a, abs(b), c);
create index on mcrparted4 (a, abs(b), c);
explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c limit 1;
set enable_bitmapscan = 0;
explain (costs off) select * from mcrparted where a = 10 order by a, abs(b), c;
reset enable_bitmapscan;
create table bool_lp (b bool) partition by list(b);
create table bool_lp_true partition of bool_lp for values in(true);
create table bool_lp_false partition of bool_lp for values in(false);
create index on bool_lp (b);
explain (costs off) select * from bool_lp order by b;
create table bool_rp (b bool, a int) partition by range(b,a);
create table bool_rp_false_1k partition of bool_rp for values from (false,0) to (false,1000);
create table bool_rp_true_1k partition of bool_rp for values from (true,0) to (true,1000);
create table bool_rp_false_2k partition of bool_rp for values from (false,1000) to (false,2000);
create table bool_rp_true_2k partition of bool_rp for values from (true,1000) to (true,2000);
create index on bool_rp (b,a);
explain (costs off) select * from bool_rp where b = true order by b,a;
explain (costs off) select * from bool_rp where b = false order by b,a;
explain (costs off) select * from bool_rp where b = true order by a;
explain (costs off) select * from bool_rp where b = false order by a;
create table range_parted (a int, b int, c int) partition by range(a, b);
create table range_parted1 partition of range_parted for values from (0,0) to (10,10);
create table range_parted2 partition of range_parted for values from (10,10) to (20,20);
create index on range_parted (a,b,c);
explain (costs off) select * from range_parted order by a,b,c;
explain (costs off) select * from range_parted order by a desc,b desc,c desc;
create table permtest_parent (a int, b text, c text) partition by list (a);
create table permtest_child (b text, c text, a int) partition by list (b);
alter table permtest_child attach partition permtest_grandchild for values in ('a');
alter table permtest_parent attach partition permtest_child for values in (1);
create index on permtest_parent (left(c, 3));
insert into permtest_parent  select 1, 'a', left(md5(i::text), 5) from generate_series(0, 100) i;
analyze permtest_parent;
create role regress_no_child_access;
revoke all on permtest_grandchild from regress_no_child_access;
grant select on permtest_parent to regress_no_child_access;
set session authorization regress_no_child_access;
explain (costs off)  select * from permtest_parent p1 inner join permtest_parent p2  on p1.a = p2.a and p1.c ~ 'a1$';
explain (costs off)  select * from permtest_parent p1 inner join permtest_parent p2  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
reset session authorization;
revoke all on permtest_parent from regress_no_child_access;
grant select(a,c) on permtest_parent to regress_no_child_access;
set session authorization regress_no_child_access;
explain (costs off)  select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2  on p1.a = p2.a and p1.c ~ 'a1$';
explain (costs off)  select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
reset session authorization;
revoke all on permtest_parent from regress_no_child_access;
drop role regress_no_child_access;
SELECT 'first line'' - next line'	' - third line'	AS "Three lines to one";
SELECT 'first line'' - next line' /* this comment is not allowed here */' - third line'	AS "Illegal comment within continuation";
SET standard_conforming_strings TO on;
&SELECT U&'d\0061t\+000061' AS U&"d\0061t\+000061";
&SELECT U&'d!0061t\+000061' UESCAPE '!' AS U&"d*0061t\+000061" UESCAPE '*';
&SELECT U&' \' UESCAPE '!' AS "tricky";
&SELECT 'tricky' AS U&"\" UESCAPE '!';
&SELECT U&'wrong: \061';
&SELECT U&'wrong: \+0061';
&SELECT U&'wrong: +0061' UESCAPE '+';
SET standard_conforming_strings TO off;
&SELECT U&'d\0061t\+000061' AS U&"d\0061t\+000061";
&SELECT U&'d!0061t\+000061' UESCAPE '!' AS U&"d*0061t\+000061" UESCAPE '*';
&SELECT U&' \' UESCAPE '!' AS "tricky";
&SELECT 'tricky' AS U&"\" UESCAPE '!';
&SELECT U&'wrong: \061';
&SELECT U&'wrong: \+0061';
&SELECT U&'wrong: +0061' UESCAPE '+';
RESET standard_conforming_strings;
SET bytea_output TO hex;
SELECT E'\\xDeAdBeEf'::bytea;
SELECT E'\\x De Ad Be Ef '::bytea;
SELECT E'\\xDeAdBeE'::bytea;
SELECT E'\\xDeAdBeEx'::bytea;
SELECT E'\\xDe00BeEf'::bytea;
SELECT E'DeAdBeEf'::bytea;
SELECT E'De\\000dBeEf'::bytea;
SELECT E'De\123dBeEf'::bytea;
SELECT E'De\\123dBeEf'::bytea;
SELECT E'De\\678dBeEf'::bytea;
SET bytea_output TO escape;
SELECT E'\\xDeAdBeEf'::bytea;
SELECT E'\\x De Ad Be Ef '::bytea;
SELECT E'\\xDe00BeEf'::bytea;
SELECT E'DeAdBeEf'::bytea;
SELECT E'De\\000dBeEf'::bytea;
SELECT E'De\\123dBeEf'::bytea;
SELECT CAST(name 'namefield' AS text) AS "text(name)";
SELECT CAST(name 'namefield' AS char(10)) AS "char(name)";
SELECT CAST(name 'namefield' AS varchar) AS "varchar(name)";
SELECT TRIM(BOTH FROM '  bunch o blanks  ') = 'bunch o blanks' AS "bunch o blanks";
SELECT TRIM(LEADING FROM '  bunch o blanks  ') = 'bunch o blanks  ' AS "bunch o blanks  ";
SELECT TRIM(TRAILING FROM '  bunch o blanks  ') = '  bunch o blanks' AS "  bunch o blanks";
SELECT TRIM(BOTH 'x' FROM 'xxxxxsome Xsxxxxx') = 'some Xs' AS "some Xs";
SELECT SUBSTRING('1234567890' FROM 3) = '34567890' AS "34567890";
SELECT SUBSTRING('1234567890' FROM 4 FOR 3) = '456' AS "456";
SELECT SUBSTRING('abcdefg' FROM 'a#"(b_d)#"%' FOR '#') AS "bcd";
SELECT SUBSTRING('abcdefg' FROM '#"(b_d)#"%' FOR '#') IS NULL AS "True";
SELECT SUBSTRING('abcdefg' FROM '%' FOR NULL) IS NULL AS "True";
SELECT SUBSTRING(NULL FROM '%' FOR '#') IS NULL AS "True";
SELECT SUBSTRING('abcdefg' FROM NULL FOR '#') IS NULL AS "True";
SELECT SUBSTRING('abcdefg' FROM 'a#"%#"g' FOR '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' FROM 'a*#"%#"g*' FOR '#') AS "abcdefg";
SELECT SUBSTRING('abcdefg' FROM 'a|b#"%#"g' FOR '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' FROM 'a#"%#"x|g' FOR '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' FROM 'a#"%|ab#"g' FOR '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' FROM 'a*#"%#"g*#"x' FOR '#') AS "error";
SELECT SUBSTRING('abcdefg' FROM 'a#"%g' FOR '#') AS "bcdefg";
SELECT SUBSTRING('abcdefg' FROM 'a%g' FOR '#') AS "abcdefg";
SELECT SUBSTRING('abcdefg' FROM 'c.e') AS "cde";
SELECT SUBSTRING('abcdefg' FROM 'b(.*)f') AS "cde";
SELECT 'abcdefg' SIMILAR TO '_bcd%' AS true;
SELECT 'abcdefg' SIMILAR TO 'bcd%' AS false;
SELECT 'abcdefg' SIMILAR TO '_bcd#%' ESCAPE '#' AS false;
SELECT 'abcd%' SIMILAR TO '_bcd#%' ESCAPE '#' AS true;
SELECT 'abcdefg' SIMILAR TO '_bcd\%' AS false;
SELECT 'abcd\efg' SIMILAR TO '_bcd\%' ESCAPE '' AS true;
SELECT 'abcdefg' SIMILAR TO '_bcd%' ESCAPE NULL AS null;
SELECT 'abcdefg' SIMILAR TO '_bcd#%' ESCAPE '##' AS error;
SELECT regexp_replace('AAA   BBB   CCC   ', E'\\s+', ' ', 'g');
\\pset null '\\N'SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque)$re$);
$$SELECT regexp_matches('foObARbEqUEbAz', $re$(bar)(beque)$re$, 'i');
$$SELECT regexp_matches('foobarbequebazilbarfbonk', $re$(b[^b]+)(b[^b]+)$re$, 'g');
$$SELECT regexp_matches('foobarbequebaz', $re$(bar)(.*)(beque)$re$);
$$SELECT regexp_matches('foobarbequebaz', $re$(bar)(.+)(beque)$re$);
$$SELECT regexp_matches('foobarbequebaz', $re$(bar)(.+)?(beque)$re$);
$$$SELECT regexp_matches('foobarbequebaz', $re$barbeque$re$);
||SELECT regexp_matches('foo' || chr(10) || 'bar' || chr(10) || 'bequq' || chr(10) || 'baz', '^', 'mg');
||SELECT regexp_matches('foo' || chr(10) || 'bar' || chr(10) || 'bequq' || chr(10) || 'baz', '$', 'mg');
||SELECT regexp_matches('1' || chr(10) || '2' || chr(10) || '3' || chr(10) || '4' || chr(10), '^.?', 'mg');
||SELECT regexp_matches(chr(10) || '1' || chr(10) || '2' || chr(10) || '3' || chr(10) || '4' || chr(10), '.?$', 'mg');
||SELECT regexp_matches(chr(10) || '1' || chr(10) || '2' || chr(10) || '3' || chr(10) || '4', '.?$', 'mg');
$$SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque)$re$, 'gz');
$$$$SELECT regexp_matches('foobarbequebaz', $re$(barbeque$re$);
$$SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque){2,1}$re$);
$$\SELECT foo, length(foo) FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', $re$\s+$re$) AS foo;
$$\SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s+$re$);
$$\SELECT foo, length(foo) FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', $re$\s*$re$) AS foo;
$$\SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s*$re$);
\\pset null ''SELECT POSITION('4' IN '1234567890') = '4' AS "4";
SELECT POSITION('5' IN '1234567890') = '5' AS "5";
SELECT OVERLAY('abcdef' PLACING '45' FROM 4) AS "abc45f";
SELECT OVERLAY('yabadoo' PLACING 'daba' FROM 5) AS "yabadaba";
SELECT OVERLAY('yabadoo' PLACING 'daba' FROM 5 FOR 0) AS "yabadabadoo";
SELECT OVERLAY('babosa' PLACING 'ubb' FROM 2 FOR 4) AS "bubba";
SELECT 'hawkeye' LIKE 'h%' ESCAPE '#' AS "true";
SELECT 'hawkeye' NOT LIKE 'h%' ESCAPE '#' AS "false";
SELECT 'indio' LIKE 'ind_o' ESCAPE '$' AS "true";
SELECT 'indio' NOT LIKE 'ind_o' ESCAPE '$' AS "false";
SELECT 'h%' LIKE 'h#%' ESCAPE '#' AS "true";
SELECT 'h%' NOT LIKE 'h#%' ESCAPE '#' AS "false";
SELECT 'h%wkeye' LIKE 'h#%' ESCAPE '#' AS "false";
SELECT 'h%wkeye' NOT LIKE 'h#%' ESCAPE '#' AS "true";
SELECT 'h%wkeye' LIKE 'h#%%' ESCAPE '#' AS "true";
SELECT 'h%wkeye' NOT LIKE 'h#%%' ESCAPE '#' AS "false";
SELECT 'h%awkeye' LIKE 'h#%a%k%e' ESCAPE '#' AS "true";
SELECT 'h%awkeye' NOT LIKE 'h#%a%k%e' ESCAPE '#' AS "false";
SELECT 'indio' LIKE '_ndio' ESCAPE '$' AS "true";
SELECT 'indio' NOT LIKE '_ndio' ESCAPE '$' AS "false";
SELECT 'i_dio' LIKE 'i$_d_o' ESCAPE '$' AS "true";
SELECT 'i_dio' NOT LIKE 'i$_d_o' ESCAPE '$' AS "false";
SELECT 'i_dio' LIKE 'i$_nd_o' ESCAPE '$' AS "false";
SELECT 'i_dio' NOT LIKE 'i$_nd_o' ESCAPE '$' AS "true";
SELECT 'i_dio' LIKE 'i$_d%o' ESCAPE '$' AS "true";
SELECT 'i_dio' NOT LIKE 'i$_d%o' ESCAPE '$' AS "false";
SELECT 'maca' LIKE 'm%aca' ESCAPE '%' AS "true";
SELECT 'maca' NOT LIKE 'm%aca' ESCAPE '%' AS "false";
SELECT 'ma%a' LIKE 'm%a%%a' ESCAPE '%' AS "true";
SELECT 'ma%a' NOT LIKE 'm%a%%a' ESCAPE '%' AS "false";
SELECT 'bear' LIKE 'b_ear' ESCAPE '_' AS "true";
SELECT 'bear' NOT LIKE 'b_ear' ESCAPE '_' AS "false";
SELECT 'be_r' LIKE 'b_e__r' ESCAPE '_' AS "true";
SELECT 'be_r' NOT LIKE 'b_e__r' ESCAPE '_' AS "false";
SELECT 'be_r' LIKE '__e__r' ESCAPE '_' AS "false";
SELECT 'be_r' NOT LIKE '__e__r' ESCAPE '_' AS "true";
SELECT 'hawkeye' ILIKE 'h%' AS "true";
SELECT 'hawkeye' NOT ILIKE 'h%' AS "false";
SELECT 'hawkeye' ILIKE 'H%' AS "true";
SELECT 'hawkeye' NOT ILIKE 'H%' AS "false";
SELECT 'hawkeye' ILIKE 'H%Eye' AS "true";
SELECT 'hawkeye' NOT ILIKE 'H%Eye' AS "false";
SELECT 'Hawkeye' ILIKE 'h%' AS "true";
SELECT 'Hawkeye' NOT ILIKE 'h%' AS "false";
CREATE TABLE byteatest (a bytea PRIMARY KEY, b int);
DROP TABLE texttest, byteatest;
||SELECT 'unknown' || ' and unknown' AS "Concat unknown types";
SELECT text 'text' || ' and unknown' AS "Concat text to unknown type";
SELECT char(20) 'characters' || ' and text' AS "Concat char to unknown type";
SELECT text 'text' || char(20) ' and characters' AS "Concat text to char";
SELECT text 'text' || varchar ' and varchar' AS "Concat text to varchar";
alter table toasttest alter column f1 set storage external;
TRUNCATE TABLE toasttest;
TRUNCATE TABLE toasttest;
ALTER TABLE toasttest set (toast_tuple_target = 4080);
CREATE TABLE toasttest(f1 bytea);
alter table toasttest alter column f1 set storage external;
::SELECT length(c), c::text FROM toasttest;
SELECT replace('abcdef', 'de', '45') AS "abc45f";
SELECT replace('yabadabadoo', 'ba', '123') AS "ya123da123doo";
SELECT replace('yabadoo', 'bad', '') AS "yaoo";
::select to_hex(256::bigint*256::bigint*256::bigint*256::bigint - 1) AS "ffffffff";
::::::::::::::SET bytea_output TO hex;
set escape_string_warning = off;
set standard_conforming_strings = off;
show escape_string_warning;
show standard_conforming_strings;
set escape_string_warning = on;
set standard_conforming_strings = on;
show escape_string_warning;
show standard_conforming_strings;
set standard_conforming_strings = off;
select 'a\\bcd' as f1, 'a\\b\'cd' as f2, 'a\\b\'''cd' as f3, 'abcd\\'   as f4, 'ab\\\'cd' as f5, '\\\\' as f6;
set escape_string_warning = off;
set standard_conforming_strings = on;
set standard_conforming_strings = off;
select 'a\\bcd' as f1, 'a\\b\'cd' as f2, 'a\\b\'''cd' as f3, 'abcd\\'   as f4, 'ab\\\'cd' as f5, '\\\\' as f6;
SET bytea_output TO escape;
SELECT trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea);
SELECT btrim(E'\\000trim\\000'::bytea, E'\\000'::bytea);
::SELECT btrim(''::bytea, E'\\000'::bytea);
SELECT btrim(E'\\000trim\\000'::bytea, ''::bytea);
SELECT encode(overlay(E'Th\\000omas'::bytea placing E'Th\\001omas'::bytea from 2),'escape');
SELECT encode(overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 8),'escape');
SELECT encode(overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 5 for 3),'escape');
||select case pg_is_in_recovery() when false then	'These tests are intended only for execution on a standby server that is reading ' ||	'WAL from a server upon which the regression database is already created and into ' ||	'which src/test/regress/sql/hs_primary_setup.sql has been run'else	'Tests are running on a standby server during recovery'end;
(SELECT 2) UNION SELECT 2;
((SELECT 2)) UNION SELECT 2;
SELECT ((SELECT 2) UNION SELECT 2);
SELECT (((SELECT 2)) UNION SELECT 2);
INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
SELECT '' AS three, f1, f2  FROM SUBSELECT_TBL  WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL                         WHERE f3 IS NOT NULL);
SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"  FROM SUBSELECT_TBL upper  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1);
SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"  FROM SUBSELECT_TBL upper  WHERE f1 IN    (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3);
SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"  FROM SUBSELECT_TBL upper  WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL               WHERE f2 = CAST(f3 AS integer));
SELECT '' AS five, f1 AS "Correlated Field"  FROM SUBSELECT_TBL  WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL                     WHERE f3 IS NOT NULL);
SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"  FROM SUBSELECT_TBL ss  WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL                   WHERE f1 != ss.f1 AND f1 < 2147483647);
explain (verbose, costs off) select '42' union all select '43';
explain (verbose, costs off) select '42' union all select 43;
explain (verbose, costs off)select 1 = all (select (select 1));
select 1 = all (select (select 1));
explain (costs off)select * from int4_tbl o where exists  (select 1 from int4_tbl i where i.f1=o.f1 limit null);
explain (costs off)select * from int4_tbl o where not exists  (select 1 from int4_tbl i where i.f1=o.f1 limit 1);
explain (costs off)select * from int4_tbl o where exists  (select 1 from int4_tbl i where i.f1=o.f1 limit 0);
select count(distinct ss.ten) from  (select ten from tenk1 a   where unique1 IN (select hundred from tenk1 b)) ss;
select count(distinct ss.ten) from  (select ten from tenk1 a   where unique1 IN (select distinct hundred from tenk1 b)) ss;
SELECT * FROM foo WHERE id IN    (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s);
CREATE VIEW orders_view ASSELECT *,(SELECT CASE   WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved' END) AS "Approved",(SELECT CASE WHEN ord.ordercanceled THEN 'Canceled' ELSE  (SELECT CASE		WHEN ord.po_ref=1		THEN		 (SELECT CASE				WHEN ord.approver_ref=1				THEN '---'				ELSE 'Approved'			END)		ELSE 'PO'	END)END) AS "Status",(CASE WHEN ord.ordercanceled THEN 'Canceled' ELSE  (CASE		WHEN ord.po_ref=1		THEN		 (CASE				WHEN ord.approver_ref=1				THEN '---'				ELSE 'Approved'			END)		ELSE 'PO'	END)END) AS "Status_OK"FROM orderstest ord;
DROP TABLE orderstest cascade;
create temp table parts (    partnum     text,    cost        float8);
create temp table shipped (    ttype       char(2),    ordnum      int4,    partnum     text,    value       float8);
create rule shipped_view_insert as on insert to shipped_view do instead    insert into shipped values('wt', new.ordnum, new.partnum, new.value);
create rule shipped_view_update as on update to shipped_view do instead    update shipped set partnum = new.partnum, value = new.value        where ttype = new.ttype and ordnum = new.ordnum;
update shipped_view set value = 11    from int4_tbl a join int4_tbl b      on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1))    where ordnum = a.f1;
select f1, ss1 as relabel from    (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1     from int4_tbl a) ss;
select * from (  select max(unique1) from tenk1 as a  where exists (select 1 from tenk1 as b where b.thousand = a.unique2)) ss;
select * from (  select min(unique1) from tenk1 as a  where not exists (select 1 from tenk1 as b where b.unique2 = 10000)) ss;
create temp table float_table (float_col float8);
select  ( select min(tb.id) from tb    where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_idfrom tc;
create temp table t1 (f1 numeric(14,0), f2 varchar(30));
select * from  (select distinct f1, f2, (select f2 from t1 x where x.f1 = up.f1) as fs   from t1 up) ssgroup by f1,f2,fs;
select (select (a.*)::text) from view_a a;
begin;  --  this shouldn't delete anything, but be safedelete from roadwhere exists (  select 1  from    int4_tbl cross join    ( select f1, array(select q1 from int8_tbl) as arr      from text_tbl ) ss  where road.name = ss.f1 );
rollback;
select  (select sq1) as qq1from  (select exists(select 1 from int4_tbl where f1 = q2) as sq1, 42 as dummy   from int8_tbl) sq0  join  int4_tbl i4 on dummy = i4.f1;
create temp table upsert(key int4 primary key, val text);
insert into upsert values(1, 'val') on conflict (key) do update set val = 'not seen';
insert into upsert values(1, 'val') on conflict (key) do update set val = 'seen with subselect ' || (select f1 from int4_tbl where f1 != 0 limit 1)::text;
with aa as (select 'int4_tbl' u from int4_tbl limit 1)insert into upsert values (1, 'x'), (999, 'y')on conflict (key) do update set val = (select u from aa)returning *;
create temp table outer_7597 (f1 int4, f2 int4);
insert into outer_7597 values (0, null);
insert into outer_7597 values (1, null);
create temp table inner_7597(c1 int8, c2 int8);
insert into inner_7597 values(0, null);
insert into outer_text values ('a', null);
insert into outer_text values ('b', null);
insert into inner_text values ('a', null);
explain (verbose, costs off)select 'foo'::text in (select 'bar'::name union all select 'bar'::name);
::select 'foo'::text in (select 'bar'::name union all select 'bar'::name);
::select '1'::text in (select '1'::name union all select '1'::name);
select a.thousand from tenk1 a, tenk1 bwhere a.thousand = b.thousand  and exists ( select 1 from tenk1 c where b.hundred = c.hundred                   and not exists ( select 1 from tenk1 d                                    where a.thousand = d.thousand ) );
explain (verbose, costs off)  select x, x from    (select (select now()) as x from (values(1),(2)) v(y)) ss;
explain (verbose, costs off)  select x, x from    (select (select random()) as x from (values(1),(2)) v(y)) ss;
explain (verbose, costs off)  select x, x from    (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
explain (verbose, costs off)  select x, x from    (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
insert into notinouter values (null), (1);
create temp table nocolumns();
select val.x  from generate_series(1,10) as s(i),  lateral (    values ((select s.i + 1)), (s.i + 101)  ) as val(x)where s.i < 10 and (select val.x) < 110;
explain (verbose, costs off)select * from int4_tbl where  (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in  (select ten from tenk1 b);
select * from int4_tbl where  (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in  (select ten from tenk1 b);
explain (verbose, costs off)select * from int4_tbl o where (f1, f1) in  (select f1, generate_series(1,50) / 10 g from int4_tbl i group by f1);
select (select q from         (select 1,2,3 where f1 > 0          union all          select 4,5,6.0 where f1 <= 0         ) q )from int4_tbl;
create temp sequence ts1;
create function tattle(x int, y int) returns boolvolatile language plpgsql as $$begin  raise notice 'x = %, y = %', x, y;
  return x > y;
end$$;
explain (verbose, costs off)select * from  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss  where tattle(x, 8);
alter function tattle(x int, y int) stable;
explain (verbose, costs off)select * from  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss  where tattle(x, 8);
explain (verbose, costs off)select * from  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss  where tattle(x, u);
drop function tattle(x int, y int);
create function explain_sq_limit() returns setof text language plpgsql as$$declare ln text;
begin    for ln in        explain (analyze, summary off, timing off, costs off)        select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3    loop        ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
        -- this case might occur if force_parallel_mode is on:        ln := regexp_replace(ln, 'Worker 0:  Sort Method',  'Sort Method');
        return next ln;
    end loop;
end;
$$;
select * from explain_sq_limit();
select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3;
drop function explain_sq_limit();
begin;
declare c1 scroll cursor for select * from generate_series(1,4) i  where i <> all (values (2),(3));
move forward all in c1;
fetch backward all in c1;
commit;
explain (verbose, costs off)with x as (select * from (select f1 from subselect_tbl) ss)select * from x where f1 = 1;
explain (verbose, costs off)with x as materialized (select * from (select f1 from subselect_tbl) ss)select * from x where f1 = 1;
explain (verbose, costs off)with x as (select * from (select f1, now() from subselect_tbl) ss)select * from x where f1 = 1;
explain (verbose, costs off)with x as (select * from (select f1, random() from subselect_tbl) ss)select * from x where f1 = 1;
explain (verbose, costs off)with x as (select * from (select f1 from subselect_tbl for update) ss)select * from x where f1 = 1;
explain (verbose, costs off)with x as (select * from (select f1, now() as n from subselect_tbl) ss)select * from x, x x2 where x.n = x2.n;
explain (verbose, costs off)with x as not materialized (select * from (select f1, now() as n from subselect_tbl) ss)select * from x, x x2 where x.n = x2.n;
explain (verbose, costs off)with recursive x(a) as  ((values ('a'), ('b'))   union all   (with z as not materialized (select * from x)    select z.a || z1.a as a from z cross join z as z1    where length(z.a || z1.a) < 5))select * from x;
with recursive x(a) as  ((values ('a'), ('b'))   union all   (with z as not materialized (select * from x)    select z.a || z1.a as a from z cross join z as z1    where length(z.a || z1.a) < 5))select * from x;
explain (verbose, costs off)with recursive x(a) as  ((values ('a'), ('b'))   union all   (with z as not materialized (select * from x)    select z.a || z.a as a from z    where length(z.a || z.a) < 5))select * from x;
with recursive x(a) as  ((values ('a'), ('b'))   union all   (with z as not materialized (select * from x)    select z.a || z.a as a from z    where length(z.a || z.a) < 5))select * from x;
explain (verbose, costs off)with x as (select * from int4_tbl)select * from (with y as (select * from x) select * from y) ss;
explain (verbose, costs off)with x as materialized (select * from int4_tbl)select * from (with y as (select * from x) select * from y) ss;
explain (verbose, costs off)with x as (select 1 as y)select * from (with x as (select 2 as y) select * from x) ss;
explain (verbose, costs off)with x as (select * from subselect_tbl)select * from x for update;
CREATE USER regress_conversion_user WITH NOCREATEDB NOCREATEROLE;
SET SESSION AUTHORIZATION regress_conversion_user;
CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE DEFAULT CONVERSION public.mydef FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
COMMENT ON CONVERSION myconv_bad IS 'foo';
COMMENT ON CONVERSION myconv IS 'bar';
COMMENT ON CONVERSION myconv IS NULL;
DROP CONVERSION myconv;
DROP CONVERSION mydef;
RESET SESSION AUTHORIZATION;
DROP USER regress_conversion_user;
CREATE TABLE OID_TBL(f1 oid);
SELECT '' AS one, o.* FROM OID_TBL o WHERE o.f1 = 1234;
SELECT '' AS five, o.* FROM OID_TBL o WHERE o.f1 <> '1234';
SELECT '' AS three, o.* FROM OID_TBL o WHERE o.f1 <= '1234';
SELECT '' AS two, o.* FROM OID_TBL o WHERE o.f1 < '1234';
SELECT '' AS four, o.* FROM OID_TBL o WHERE o.f1 >= '1234';
SELECT '' AS three, o.* FROM OID_TBL o WHERE o.f1 > '1234';
CREATE UNLOGGED SEQUENCE sequence_testx;
CREATE SEQUENCE sequence_testx INCREMENT BY 0;
CREATE SEQUENCE sequence_testx INCREMENT BY -1 MINVALUE 20;
CREATE SEQUENCE sequence_testx INCREMENT BY 1 MAXVALUE -20;
CREATE SEQUENCE sequence_testx INCREMENT BY -1 START 10;
CREATE SEQUENCE sequence_testx INCREMENT BY 1 START -10;
CREATE SEQUENCE sequence_testx CACHE 0;
CREATE SEQUENCE sequence_testx OWNED BY nobody;  -- nonsense wordCREATE SEQUENCE sequence_testx OWNED BY pg_class_oid_index.oid;  -- not a tableCREATE SEQUENCE sequence_testx OWNED BY pg_class.relname;  -- not same schemaCREATE TABLE sequence_test_table (a int);
CREATE SEQUENCE sequence_testx OWNED BY sequence_test_table.b;  -- wrong columnDROP TABLE sequence_test_table;
CREATE SEQUENCE sequence_test5 AS integer;
CREATE SEQUENCE sequence_test6 AS smallint;
CREATE SEQUENCE sequence_test7 AS bigint;
CREATE SEQUENCE sequence_test8 AS integer MAXVALUE 100000;
CREATE SEQUENCE sequence_test9 AS integer INCREMENT BY -1;
CREATE SEQUENCE sequence_test10 AS integer MINVALUE -100000 START 1;
CREATE SEQUENCE sequence_test11 AS smallint;
CREATE SEQUENCE sequence_test12 AS smallint INCREMENT -1;
CREATE SEQUENCE sequence_test13 AS smallint MINVALUE -32768;
CREATE SEQUENCE sequence_test14 AS smallint MAXVALUE 32767 INCREMENT -1;
CREATE SEQUENCE sequence_testx AS text;
CREATE SEQUENCE sequence_testx AS nosuchtype;
CREATE SEQUENCE sequence_testx AS smallint MAXVALUE 100000;
CREATE SEQUENCE sequence_testx AS smallint MINVALUE -100000;
ALTER SEQUENCE sequence_test5 AS smallint;  -- success, max will be adjustedALTER SEQUENCE sequence_test8 AS smallint;  -- fail, max has to be adjustedALTER SEQUENCE sequence_test8 AS smallint MAXVALUE 20000;  -- ok nowALTER SEQUENCE sequence_test9 AS smallint;  -- success, min will be adjustedALTER SEQUENCE sequence_test10 AS smallint;  -- fail, min has to be adjustedALTER SEQUENCE sequence_test10 AS smallint MINVALUE -20000;  -- ok nowALTER SEQUENCE sequence_test11 AS int;  -- max will be adjustedALTER SEQUENCE sequence_test12 AS int;  -- min will be adjustedALTER SEQUENCE sequence_test13 AS int;  -- min and max will be adjustedALTER SEQUENCE sequence_test14 AS int;  -- min and max will be adjustedCREATE TABLE serialTest1 (f1 text, f2 serial);
INSERT INTO serialTest1 VALUES ('wrong', NULL);
CREATE TABLE serialTest2 (f1 text, f2 serial, f3 smallserial, f4 serial2,  f5 bigserial, f6 serial8);
CREATE SEQUENCE sequence_test;
CREATE SEQUENCE IF NOT EXISTS sequence_test;
::SELECT nextval('sequence_test'::text);
::::SELECT currval('sequence_test'::text);
::::SELECT setval('sequence_test'::text, 32);
::::SELECT setval('sequence_test'::text, 99, false);
::::::SELECT nextval('sequence_test'::text);
::::SELECT nextval('sequence_test'::text);
DISCARD SEQUENCES;
::DROP SEQUENCE sequence_test;
CREATE SEQUENCE foo_seq;
DROP SEQUENCE foo_seq_new;
CREATE TEMP SEQUENCE myseq2;
CREATE TEMP SEQUENCE myseq3;
CREATE TEMP TABLE t1 (  f1 serial,  f2 int DEFAULT nextval('myseq2'),  f3 int DEFAULT nextval('myseq3'::text));
DROP SEQUENCE t1_f1_seq;
DROP SEQUENCE myseq2;
DROP SEQUENCE myseq3;
DROP SEQUENCE t1_f1_seq;
DROP SEQUENCE myseq2;
ALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 24  INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
ALTER SEQUENCE serialTest1 CYCLE;  -- error, not a sequenceCREATE SEQUENCE sequence_test2 START WITH 32;
CREATE SEQUENCE sequence_test4 INCREMENT BY -1;
ALTER SEQUENCE sequence_test2 RESTART;
ALTER SEQUENCE sequence_test2 RESTART WITH 0;  -- errorALTER SEQUENCE sequence_test4 RESTART WITH 40;  -- errorALTER SEQUENCE sequence_test2 RESTART WITH 24  INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
SELECT nextval('sequence_test2');  -- cycledALTER SEQUENCE sequence_test2 RESTART WITH 24  NO CYCLE;
SELECT nextval('sequence_test2');  -- errorALTER SEQUENCE sequence_test2 RESTART WITH -24 START WITH -24  INCREMENT BY -4 MINVALUE -36 MAXVALUE -5 CYCLE;
SELECT nextval('sequence_test2');  -- cycledALTER SEQUENCE sequence_test2 RESTART WITH -24  NO CYCLE;
SELECT nextval('sequence_test2');  -- errorALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 32 START WITH 32  INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
SELECT setval('sequence_test2', -100);  -- errorSELECT setval('sequence_test2', 100);  -- errorSELECT setval('sequence_test2', 5);
CREATE SEQUENCE sequence_test3;  -- not read from, to test is_calledSELECT * FROM information_schema.sequences  WHERE sequence_name ~ ANY(ARRAY['sequence_test', 'serialtest'])  ORDER BY sequence_name ASC;
SELECT schemaname, sequencename, start_value, min_value, max_value, increment_by, cycle, cache_size, last_valueFROM pg_sequencesWHERE sequencename ~ ANY(ARRAY['sequence_test', 'serialtest'])  ORDER BY sequencename ASC;
::COMMENT ON SEQUENCE asdf IS 'won''t work';
COMMENT ON SEQUENCE sequence_test2 IS 'will work';
COMMENT ON SEQUENCE sequence_test2 IS NULL;
CREATE SEQUENCE seq;
DISCARD SEQUENCES;
CREATE SEQUENCE seq2;
DROP SEQUENCE seq2;
CREATE TEMPORARY SEQUENCE sequence_test_temp1;
START TRANSACTION READ ONLY;
SELECT nextval('sequence_test_temp1');  -- okSELECT nextval('sequence_test2');  -- errorROLLBACK;
START TRANSACTION READ ONLY;
SELECT setval('sequence_test_temp1', 1);  -- okSELECT setval('sequence_test2', 1);  -- errorROLLBACK;
CREATE USER regress_seq_user;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT SELECT ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT UPDATE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT USAGE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT SELECT ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT UPDATE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT USAGE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT SELECT ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT UPDATE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT USAGE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE seq3;
REVOKE ALL ON seq3 FROM regress_seq_user;
SAVEPOINT save;
ROLLBACK TO save;
GRANT UPDATE ON seq3 TO regress_seq_user;
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
ALTER SEQUENCE sequence_test2 START WITH 1;
ROLLBACK;
DROP TABLE serialTest1, serialTest2;
SELECT * FROM information_schema.sequences WHERE sequence_name IN  ('sequence_test2', 'serialtest2_f2_seq', 'serialtest2_f3_seq',   'serialtest2_f4_seq', 'serialtest2_f5_seq', 'serialtest2_f6_seq')  ORDER BY sequence_name ASC;
DROP USER regress_seq_user;
DROP SEQUENCE seq;
CREATE SEQUENCE test_seq1 CACHE 10;
DROP SEQUENCE test_seq1;
SELECT *   INTO TABLE sitmp1   FROM onek   WHERE onek.unique1 < 2;
SELECT *   INTO TABLE sitmp1   FROM onek2   WHERE onek2.unique1 < 2;
CREATE SCHEMA selinto_schema;
CREATE USER regress_selinto_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user	  REVOKE INSERT ON TABLES FROM regress_selinto_user;
GRANT ALL ON SCHEMA selinto_schema TO public;
SET SESSION AUTHORIZATION regress_selinto_user;
SELECT * INTO TABLE selinto_schema.tmp1	  FROM pg_class WHERE relname like '%a%';	-- ErrorSELECT oid AS clsoid, relname, relnatts + 10 AS x	  INTO selinto_schema.tmp2	  FROM pg_class WHERE relname like '%b%';	-- ErrorCREATE TABLE selinto_schema.tmp3 (a,b,c)	   AS SELECT oid,relname,relacl FROM pg_class	   WHERE relname like '%c%';	-- ErrorRESET SESSION AUTHORIZATION;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user	  GRANT INSERT ON TABLES TO regress_selinto_user;
SET SESSION AUTHORIZATION regress_selinto_user;
SELECT * INTO TABLE selinto_schema.tmp1	  FROM pg_class WHERE relname like '%a%';	-- OKSELECT oid AS clsoid, relname, relnatts + 10 AS x	  INTO selinto_schema.tmp2	  FROM pg_class WHERE relname like '%b%';	-- OKCREATE TABLE selinto_schema.tmp3 (a,b,c)	   AS SELECT oid,relname,relacl FROM pg_class	   WHERE relname like '%c%';	-- OKRESET SESSION AUTHORIZATION;
DROP SCHEMA selinto_schema CASCADE;
DROP USER regress_selinto_user;
CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base; -- ErrorCREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base WITH NO DATA; -- ErrorCREATE TABLE ctas_nodata (ii, jj) AS SELECT i, j FROM ctas_base; -- OKCREATE TABLE ctas_nodata_2 (ii, jj) AS SELECT i, j FROM ctas_base WITH NO DATA; -- OKCREATE TABLE ctas_nodata_3 (ii) AS SELECT i, j FROM ctas_base; -- OKCREATE TABLE ctas_nodata_4 (ii) AS SELECT i, j FROM ctas_base WITH NO DATA; -- OKSELECT * FROM ctas_nodata;
CREATE FUNCTION make_table() RETURNS VOIDAS $$  CREATE TABLE created_table AS SELECT * FROM int8_tbl;
$$ LANGUAGE SQL;
DO $$BEGIN	EXECUTE 'EXPLAIN ANALYZE SELECT * INTO TABLE easi FROM int8_tbl';
	EXECUTE 'EXPLAIN ANALYZE CREATE TABLE easi2 AS SELECT * FROM int8_tbl WITH NO DATA';
END$$;
DROP TABLE easi, easi2;
DECLARE foo CURSOR FOR SELECT 1 INTO b;
COPY (SELECT 1 INTO frak UNION SELECT 2) TO 'blob';
SELECT * FROM (SELECT 1 INTO f) bar;
CREATE VIEW foo AS SELECT 1 INTO b;
INSERT INTO b SELECT 1 INTO f;
CREATE TABLE PG_LSN_TBL (f1 pg_lsn);
::::SELECT '0/16AE7F8'::pg_lsn != '0/16AE7F7';
::SELECT '0/16AE7F8' > pg_lsn '0/16AE7F7';
::SELECT '0/16AE7F7'::pg_lsn - '0/16AE7F8'::pg_lsn;
::SELECT '0/16AE7F8'::pg_lsn - '0/16AE7F7'::pg_lsn;
EXPLAIN (COSTS OFF)SELECT DISTINCT (i || '/' || j)::pg_lsn f  FROM generate_series(1, 10) i,       generate_series(1, 10) j,       generate_series(1, 5) k  WHERE i <= 10 AND j > 0 AND j <= 10  ORDER BY f;
||SELECT DISTINCT (i || '/' || j)::pg_lsn f  FROM generate_series(1, 10) i,       generate_series(1, 10) j,       generate_series(1, 5) k  WHERE i <= 10 AND j > 0 AND j <= 10  ORDER BY f;
CREATE OPERATOR === (        PROCEDURE = int8eq,        LEFTARG = bigint,        RIGHTARG = bigint,        COMMUTATOR = ===);
CREATE OPERATOR !== (        PROCEDURE = int8ne,        LEFTARG = bigint,        RIGHTARG = bigint,        NEGATOR = ===,        COMMUTATOR = !==);
DROP OPERATOR !==(bigint, bigint);
SELECT  ctid, oprcomFROM    pg_catalog.pg_operator fkWHERE   oprcom != 0 AND        NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprcom);
SELECT  ctid, oprnegateFROM    pg_catalog.pg_operator fkWHERE   oprnegate != 0 AND        NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprnegate);
DROP OPERATOR ===(bigint, bigint);
CREATE OPERATOR <| (        PROCEDURE = int8lt,        LEFTARG = bigint,        RIGHTARG = bigint);
CREATE OPERATOR |> (        PROCEDURE = int8gt,        LEFTARG = bigint,        RIGHTARG = bigint,        NEGATOR = <|,        COMMUTATOR = <|);
DROP OPERATOR |>(bigint, bigint);
SELECT  ctid, oprcomFROM    pg_catalog.pg_operator fkWHERE   oprcom != 0 AND        NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprcom);
SELECT  ctid, oprnegateFROM    pg_catalog.pg_operator fkWHERE   oprnegate != 0 AND        NOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprnegate);
DROP OPERATOR <|(bigint, bigint);
select prop,       pg_indexam_has_property(a.oid, prop) as "AM",       pg_index_has_property('onek_hundred'::regclass, prop) as "Index",       pg_index_column_has_property('onek_hundred'::regclass, 1, prop) as "Column"  from pg_am a,       unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',                    'orderable', 'distance_orderable', 'returnable',                    'search_array', 'search_nulls',                    'clusterable', 'index_scan', 'bitmap_scan',                    'backward_scan',                    'can_order', 'can_unique', 'can_multi_col',                    'can_exclude', 'can_include',                    'bogus']::text[])         with ordinality as u(prop,ord) where a.amname = 'btree' order by ord;
select prop,       pg_indexam_has_property(a.oid, prop) as "AM",       pg_index_has_property('gcircleind'::regclass, prop) as "Index",       pg_index_column_has_property('gcircleind'::regclass, 1, prop) as "Column"  from pg_am a,       unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',                    'orderable', 'distance_orderable', 'returnable',                    'search_array', 'search_nulls',                    'clusterable', 'index_scan', 'bitmap_scan',                    'backward_scan',                    'can_order', 'can_unique', 'can_multi_col',                    'can_exclude', 'can_include',                    'bogus']::text[])         with ordinality as u(prop,ord) where a.amname = 'gist' order by ord;
::::::::::::::::select prop,       pg_index_column_has_property('onek_hundred'::regclass, 1, prop) as btree,       pg_index_column_has_property('hash_i4_index'::regclass, 1, prop) as hash,       pg_index_column_has_property('gcircleind'::regclass, 1, prop) as gist,       pg_index_column_has_property('sp_radix_ind'::regclass, 1, prop) as spgist_radix,       pg_index_column_has_property('sp_quad_ind'::regclass, 1, prop) as spgist_quad,       pg_index_column_has_property('botharrayidx'::regclass, 1, prop) as gin,       pg_index_column_has_property('brinidx'::regclass, 1, prop) as brin  from unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',                    'orderable', 'distance_orderable', 'returnable',                    'search_array', 'search_nulls',                    'bogus']::text[])         with ordinality as u(prop,ord) order by ord;
::::::::::::::select prop,       pg_index_has_property('onek_hundred'::regclass, prop) as btree,       pg_index_has_property('hash_i4_index'::regclass, prop) as hash,       pg_index_has_property('gcircleind'::regclass, prop) as gist,       pg_index_has_property('sp_radix_ind'::regclass, prop) as spgist,       pg_index_has_property('botharrayidx'::regclass, prop) as gin,       pg_index_has_property('brinidx'::regclass, prop) as brin  from unnest(array['clusterable', 'index_scan', 'bitmap_scan',                    'backward_scan',                    'bogus']::text[])         with ordinality as u(prop,ord) order by ord;
select amname, prop, pg_indexam_has_property(a.oid, prop) as p  from pg_am a,       unnest(array['can_order', 'can_unique', 'can_multi_col',                    'can_exclude', 'can_include', 'bogus']::text[])         with ordinality as u(prop,ord) where amtype = 'i' order by amname, ord;
CREATE INDEX fooindex ON foo (f1 desc, f2 asc, f3 nulls first, f4 nulls last);
select col, prop, pg_index_column_has_property(o, col, prop)  from (values ('fooindex'::regclass)) v1(o),       (values (1,'orderable'),(2,'asc'),(3,'desc'),               (4,'nulls_first'),(5,'nulls_last'),               (6, 'bogus')) v2(idx,prop),       generate_series(1,4) col order by col, idx;
CREATE INDEX foocover ON foo (f1) INCLUDE (f2,f3);
select col, prop, pg_index_column_has_property(o, col, prop)  from (values ('foocover'::regclass)) v1(o),       (values (1,'orderable'),(2,'asc'),(3,'desc'),               (4,'nulls_first'),(5,'nulls_last'),               (6,'distance_orderable'),(7,'returnable'),               (8, 'bogus')) v2(idx,prop),       generate_series(1,3) col order by col, idx;
CREATE TABLE reloptions_test(i INT) WITH (FiLLFaCToR=30,	autovacuum_enabled = false, autovacuum_analyze_scale_factor = 0.2);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=2);
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=110);
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor = -10.0);
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor = 110.0);
CREATE TABLE reloptions_test2(i INT) WITH (not_existing_option=2);
CREATE TABLE reloptions_test2(i INT) WITH (not_existing_namespace.fillfactor=2);
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=-30.1);
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor='string');
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=true);
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_enabled=12);
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_enabled=30.5);
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_enabled='string');
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor='string');
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor=true);
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=30, fillfactor=40);
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor);
ALTER TABLE reloptions_test SET (fillfactor=31,	autovacuum_analyze_scale_factor = 0.3);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
ALTER TABLE reloptions_test SET (autovacuum_enabled, fillfactor=32);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
ALTER TABLE reloptions_test RESET (fillfactor);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
ALTER TABLE reloptions_test RESET (autovacuum_enabled,	autovacuum_analyze_scale_factor);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass AND       reloptions IS NULL;
ALTER TABLE reloptions_test RESET (fillfactor=12);
CREATE TABLE reloptions_test(i INT NOT NULL, j text)	WITH (vacuum_truncate=false,	toast.vacuum_truncate=false,	autovacuum_enabled=false);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
INSERT INTO reloptions_test VALUES (1, NULL), (NULL, NULL);
VACUUM reloptions_test;
::SELECT reloptions FROM pg_class WHERE oid =	(SELECT reltoastrelid FROM pg_class	WHERE oid = 'reloptions_test'::regclass);
ALTER TABLE reloptions_test RESET (vacuum_truncate);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
INSERT INTO reloptions_test VALUES (1, NULL), (NULL, NULL);
VACUUM reloptions_test;
CREATE TABLE reloptions_test (s VARCHAR)	WITH (toast.autovacuum_vacuum_cost_delay = 23);
::SELECT reltoastrelid as toast_oid	FROM pg_class WHERE oid = 'reloptions_test'::regclass \gsetSELECT reloptions FROM pg_class WHERE oid = :toast_oid;
ALTER TABLE reloptions_test SET (toast.autovacuum_vacuum_cost_delay = 24);
:ALTER TABLE reloptions_test RESET (toast.autovacuum_vacuum_cost_delay);
:CREATE TABLE reloptions_test2 (i int) WITH (toast.not_existing_option = 42);
CREATE TABLE reloptions_test (s VARCHAR) WITH	(toast.autovacuum_vacuum_cost_delay = 23,	autovacuum_vacuum_cost_delay = 24, fillfactor = 40);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test'::regclass;
::SELECT reloptions FROM pg_class WHERE oid = (	SELECT reltoastrelid FROM pg_class WHERE oid = 'reloptions_test'::regclass);
CREATE INDEX reloptions_test_idx ON reloptions_test (s) WITH (fillfactor=30);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test_idx'::regclass;
CREATE INDEX reloptions_test_idx ON reloptions_test (s)	WITH (not_existing_option=2);
CREATE INDEX reloptions_test_idx ON reloptions_test (s)	WITH (not_existing_ns.fillfactor=2);
CREATE INDEX reloptions_test_idx2 ON reloptions_test (s) WITH (fillfactor=1);
CREATE INDEX reloptions_test_idx2 ON reloptions_test (s) WITH (fillfactor=130);
ALTER INDEX reloptions_test_idx SET (fillfactor=40);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test_idx'::regclass;
ALTER INDEX reloptions_test_idx3 SET (fillfactor=40);
::SELECT reloptions FROM pg_class WHERE oid = 'reloptions_test_idx3'::regclass;
BEGIN;
SAVEPOINT s1;
ROLLBACK TO s1;
COMMIT;
BEGIN;
DECLARE c CURSOR FOR SELECT ctid,cmin,* FROM combocidtest;
DELETE FROM combocidtest;
FETCH ALL FROM c;
ROLLBACK;
BEGIN;
SAVEPOINT s1;
SELECT ctid,cmin,* FROM combocidtest FOR UPDATE;
ROLLBACK TO s1;
COMMIT;
BEGIN;
SELECT * FROM testcase WHERE testcase.id = 1 FOR UPDATE;
SAVEPOINT subxact;
ROLLBACK TO SAVEPOINT subxact;
SELECT * FROM testcase WHERE id = 1 FOR UPDATE;
ROLLBACK;
SHOW track_counts;  -- must be onSET enable_seqscan TO on;
SET enable_indexscan TO on;
SET enable_indexonlyscan TO off;
CREATE TABLE prevstats ASSELECT t.seq_scan, t.seq_tup_read, t.idx_scan, t.idx_tup_fetch,       (b.heap_blks_read + b.heap_blks_hit) AS heap_blks,       (b.idx_blks_read + b.idx_blks_hit) AS idx_blks,       pg_stat_get_snapshot_timestamp() as snap_ts  FROM pg_catalog.pg_stat_user_tables AS t,       pg_catalog.pg_statio_user_tables AS b WHERE t.relname='tenk2' AND b.relname='tenk2';
create function wait_for_stats() returns void as $$declare  start_time timestamptz := clock_timestamp();
  updated1 bool;
  updated2 bool;
  updated3 bool;
  updated4 bool;
begin  -- we don't want to wait forever; loop will exit after 30 seconds  for i in 1 .. 300 loop    -- With parallel query, the seqscan and indexscan on tenk2 might be done    -- in parallel worker processes, which will send their stats counters    -- asynchronously to what our own session does.  So we must check for    -- those counts to be registered separately from the update counts.    -- check to see if seqscan has been sensed    SELECT (st.seq_scan >= pr.seq_scan + 1) INTO updated1      FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr     WHERE st.relname='tenk2' AND cl.relname='tenk2';
    -- check to see if indexscan has been sensed    SELECT (st.idx_scan >= pr.idx_scan + 1) INTO updated2      FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr     WHERE st.relname='tenk2' AND cl.relname='tenk2';
    -- check to see if all updates have been sensed    SELECT (n_tup_ins > 0) INTO updated3      FROM pg_stat_user_tables WHERE relname='trunc_stats_test4';
    -- We must also check explicitly that pg_stat_get_snapshot_timestamp has    -- advanced, because that comes from the global stats file which might    -- be older than the per-DB stats file we got the other values from.    SELECT (pr.snap_ts < pg_stat_get_snapshot_timestamp()) INTO updated4      FROM prevstats AS pr;
    exit when updated1 and updated2 and updated3 and updated4;
    -- wait a little    perform pg_sleep_for('100 milliseconds');
    -- reset stats snapshot so we can test again    perform pg_stat_clear_snapshot();
  end loop;
  -- report time waited in postmaster log (where it won't change test output)  raise log 'wait_for_stats delayed % seconds',    extract(epoch from clock_timestamp() - start_time);
end$$ language plpgsql;
CREATE TABLE trunc_stats_test(id serial);
CREATE TABLE trunc_stats_test1(id serial, stuff text);
CREATE TABLE trunc_stats_test2(id serial);
CREATE TABLE trunc_stats_test3(id serial, stuff text);
CREATE TABLE trunc_stats_test4(id serial);
TRUNCATE trunc_stats_test;
DELETE FROM trunc_stats_test1 WHERE id = 3;
BEGIN;
TRUNCATE trunc_stats_test1;
COMMIT;
BEGIN;
SAVEPOINT p1;
TRUNCATE trunc_stats_test2;
RELEASE SAVEPOINT p1;
COMMIT;
BEGIN;
SAVEPOINT p1;
TRUNCATE trunc_stats_test3;
ROLLBACK TO SAVEPOINT p1;
COMMIT;
BEGIN;
TRUNCATE trunc_stats_test4;
ROLLBACK;
SET enable_bitmapscan TO off;
RESET enable_bitmapscan;
\\c -SELECT wait_for_stats();
SELECT st.seq_scan >= pr.seq_scan + 1,       st.seq_tup_read >= pr.seq_tup_read + cl.reltuples,       st.idx_scan >= pr.idx_scan + 1,       st.idx_tup_fetch >= pr.idx_tup_fetch + 1  FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr WHERE st.relname='tenk2' AND cl.relname='tenk2';
SELECT st.heap_blks_read + st.heap_blks_hit >= pr.heap_blks + cl.relpages,       st.idx_blks_read + st.idx_blks_hit >= pr.idx_blks + 1  FROM pg_statio_user_tables AS st, pg_class AS cl, prevstats AS pr WHERE st.relname='tenk2' AND cl.relname='tenk2';
SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newerFROM prevstats AS pr;
DROP TABLE trunc_stats_test, trunc_stats_test1, trunc_stats_test2, trunc_stats_test3, trunc_stats_test4;
SET DATESTYLE = 'ISO';
SET IntervalStyle to postgres;
SELECT INTERVAL '01:00' AS "One hour";
SELECT INTERVAL '+02:00' AS "Two hours";
SELECT INTERVAL '-08:00' AS "Eight hours";
SELECT INTERVAL '-1 +02:03' AS "22 hours ago...";
SELECT INTERVAL '-1 days +02:03' AS "22 hours ago...";
SELECT INTERVAL '1.5 weeks' AS "Ten days twelve hours";
SELECT INTERVAL '1.5 months' AS "One month 15 days";
SELECT INTERVAL '10 years -11 month -12 days +13:14' AS "9 years...";
CREATE TABLE INTERVAL_TBL (f1 interval);
SELECT '' AS nine, * FROM INTERVAL_TBL   WHERE INTERVAL_TBL.f1 <> interval '@ 10 days';
SELECT '' AS three, * FROM INTERVAL_TBL   WHERE INTERVAL_TBL.f1 <= interval '@ 5 hours';
SELECT '' AS three, * FROM INTERVAL_TBL   WHERE INTERVAL_TBL.f1 < interval '@ 1 day';
SELECT '' AS one, * FROM INTERVAL_TBL   WHERE INTERVAL_TBL.f1 = interval '@ 34 years';
SELECT '' AS five, * FROM INTERVAL_TBL   WHERE INTERVAL_TBL.f1 >= interval '@ 1 month';
SELECT '' AS nine, * FROM INTERVAL_TBL   WHERE INTERVAL_TBL.f1 > interval '@ 3 seconds ago';
SELECT '' AS fortyfive, r1.*, r2.*   FROM INTERVAL_TBL r1, INTERVAL_TBL r2   WHERE r1.f1 > r2.f1   ORDER BY r1.f1, r2.f1;
CREATE TEMP TABLE INTERVAL_TBL_OF (f1 interval);
select extract(epoch from '256 microseconds'::interval * (2^55)::float8);
SELECT r1.*, r2.*   FROM INTERVAL_TBL_OF r1, INTERVAL_TBL_OF r2   WHERE r1.f1 > r2.f1   ORDER BY r1.f1, r2.f1;
CREATE INDEX ON INTERVAL_TBL_OF USING btree (f1);
SET enable_seqscan TO false;
EXPLAIN (COSTS OFF)SELECT f1 FROM INTERVAL_TBL_OF r1 ORDER BY f1;
RESET enable_seqscan;
CREATE TABLE INTERVAL_MULDIV_TBL (span interval);
COPY INTERVAL_MULDIV_TBL FROM STDIN;
41 mon 12 days 360:00-41 mon -12 days +360:00-12 days9 mon -27 days 12:34:56-3 years 482 days 76:54:32.1894 mon14 mon999 mon 999 days\.SELECT span * 0.3 AS productFROM INTERVAL_MULDIV_TBL;
SELECT span * 8.2 AS productFROM INTERVAL_MULDIV_TBL;
SELECT span / 10 AS quotientFROM INTERVAL_MULDIV_TBL;
SELECT span / 100 AS quotientFROM INTERVAL_MULDIV_TBL;
SET DATESTYLE = 'postgres';
SET IntervalStyle to postgres_verbose;
::::SELECT justify_hours(interval '6 months 3 days 52 hours 3 minutes 2 seconds') as "6 mons 5 days 4 hours 3 mins 2 seconds";
SELECT justify_days(interval '6 months 36 days 5 hours 4 minutes 3 seconds') as "7 mons 6 days 5 hours 4 mins 3 seconds";
SELECT justify_interval(interval '1 month -1 hour') as "1 month -1 hour";
SET DATESTYLE = 'ISO';
SET IntervalStyle TO postgres;
::::::::::SELECT '1 second 2 seconds'::interval;              -- errorSELECT '10 milliseconds 20 milliseconds'::interval; -- errorSELECT '5.5 seconds 3 milliseconds'::interval;      -- errorSELECT '1:20:05 5 microseconds'::interval;          -- errorSELECT '1 day 1 day'::interval;                     -- errorSELECT interval '1-2';  -- SQL year-month literalSELECT interval '999' second;  -- oversize leading field is okSELECT interval '999' minute;
SELECT interval '999' hour;
SELECT interval '999' day;
SELECT interval '999' month;
SELECT interval '1' year;
SELECT interval '2' month;
SELECT interval '3' day;
SELECT interval '4' hour;
SELECT interval '5' minute;
SELECT interval '6' second;
SELECT interval '1' year to month;
SELECT interval '1-2' year to month;
SELECT interval '1 2' day to hour;
SELECT interval '1 2:03' day to hour;
SELECT interval '1 2:03:04' day to hour;
SELECT interval '1 2' day to minute;
SELECT interval '1 2:03' day to minute;
SELECT interval '1 2:03:04' day to minute;
SELECT interval '1 2' day to second;
SELECT interval '1 2:03' day to second;
SELECT interval '1 2:03:04' day to second;
SELECT interval '1 2' hour to minute;
SELECT interval '1 2:03' hour to minute;
SELECT interval '1 2:03:04' hour to minute;
SELECT interval '1 2' hour to second;
SELECT interval '1 2:03' hour to second;
SELECT interval '1 2:03:04' hour to second;
SELECT interval '1 2' minute to second;
SELECT interval '1 2:03' minute to second;
SELECT interval '1 2:03:04' minute to second;
SELECT interval '1 +2:03' minute to second;
SELECT interval '1 +2:03:04' minute to second;
SELECT interval '1 -2:03' minute to second;
SELECT interval '1 -2:03:04' minute to second;
SELECT interval '123 11' day to hour; -- okSELECT interval '123 11' day; -- not okSELECT interval '123 11'; -- not ok, too ambiguousSELECT interval '123 2:03 -2:04'; -- not ok, redundant hh:mm fieldsSELECT interval(0) '1 day 01:23:45.6789';
SELECT interval(2) '1 day 01:23:45.6789';
SELECT interval '12:34.5678' minute to second(2);  -- per SQL specSELECT interval '1.234' second;
SELECT interval '1.234' second(2);
SELECT interval '1 2.345' day to second(2);
SELECT interval '1 2:03' day to second(2);
SELECT interval '1 2:03.4567' day to second(2);
SELECT interval '1 2:03:04.5678' day to second(2);
SELECT interval '1 2.345' hour to second(2);
SELECT interval '1 2:03.45678' hour to second(2);
SELECT interval '1 2:03:04.5678' hour to second(2);
SELECT interval '1 2.3456' minute to second(2);
SELECT interval '1 2:03.5678' minute to second(2);
SELECT interval '1 2:03:04.5678' minute to second(2);
::SELECT f1, f1::INTERVAL DAY TO MINUTE AS "minutes",  (f1 + INTERVAL '1 month')::INTERVAL MONTH::INTERVAL YEAR AS "years"  FROM interval_tbl;
SET IntervalStyle TO sql_standard;
SELECT  interval '0'                       AS "zero",        interval '1-2' year to month       AS "year-month",        interval '1 2:03:04' day to second AS "day-time",        - interval '1-2'                   AS "negative year-month",        - interval '1 2:03:04'             AS "negative day-time";
SET IntervalStyle TO postgres;
SELECT  interval '+1 -1:00:00',        interval '-1 +1:00:00',        interval '+1-2 -3 +4:05:06.789',        interval '-1-2 +3 -4:05:06.789';
SET IntervalStyle TO sql_standard;
SELECT  interval '1 day -1 hours',        interval '-1 days +1 hours',        interval '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds',        - interval '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds';
SET IntervalStyle to iso_8601;
select  interval '0'                                AS "zero",        interval '1-2'                              AS "a year 2 months",        interval '1 2:03:04'                        AS "a bit over a day",        interval '2:03:04.45679'                    AS "a bit over 2 hours",        (interval '1-2' + interval '3 4:05:06.7')   AS "all fields",        (interval '1-2' - interval '3 4:05:06.7')   AS "mixed sign",        (- interval '1-2' + interval '3 4:05:06.7') AS "negative";
SET IntervalStyle to sql_standard;
select  interval 'P0Y'                    AS "zero",        interval 'P1Y2M'                  AS "a year 2 months",        interval 'P1W'                    AS "a week",        interval 'P1DT2H3M4S'             AS "a bit over a day",        interval 'P1Y2M3DT4H5M6.7S'       AS "all fields",        interval 'P-1Y-2M-3DT-4H-5M-6.7S' AS "negative",        interval 'PT-0.1S'                AS "fractional second";
SET IntervalStyle to postgres;
select  interval 'P00021015T103020'       AS "ISO8601 Basic Format",        interval 'P0002-10-15T10:30:20'   AS "ISO8601 Extended Format";
select  interval 'P0002'                  AS "year only",        interval 'P0002-10'               AS "year month",        interval 'P0002-10-15'            AS "year month day",        interval 'P0002T1S'               AS "year only plus time",        interval 'P0002-10T1S'            AS "year month plus time",        interval 'P0002-10-15T1S'         AS "year month day plus time",        interval 'PT10'                   AS "hour only",        interval 'PT10:30'                AS "hour minute";
SET IntervalStyle to postgres_verbose;
select interval '-10 mons -3 days +03:55:06.70';
select interval '1 year 2 mons 3 days 04:05:06.699999';
select interval '0:0:0.7', interval '@ 0.70 secs', interval '0.7 seconds';
::select '30 days'::interval = '1 month'::interval as t;
:::::::::::::::::::::::::select make_interval(years := 'inf'::float::int);
:::select make_interval(months := 'NaN'::float::int);
:::SET extra_float_digits = 0;
CREATE TABLE POINT_TBL(f1 point);
INSERT INTO POINT_TBL(f1) VALUES ('(1e-300,-1e-300)');	-- To underflowINSERT INTO POINT_TBL(f1) VALUES ('(1e+300,Inf)');		-- To overflowINSERT INTO POINT_TBL(f1) VALUES (' ( Nan , NaN ) ');
INSERT INTO POINT_TBL(f1) VALUES ('(10.0, 1e+500)');	-- Out of rangeSELECT '' AS six, * FROM POINT_TBL;
SELECT '' AS three, p.* FROM POINT_TBL p WHERE p.f1 << '(0.0, 0.0)';
SELECT '' AS three, p.* FROM POINT_TBL p WHERE '(0.0,0.0)' >> p.f1;
SELECT '' AS one, p.* FROM POINT_TBL p WHERE '(0.0,0.0)' >^ p.f1;
SELECT '' AS one, p.* FROM POINT_TBL p WHERE p.f1 <^ '(0.0, 0.0)';
SELECT '' AS one, p.* FROM POINT_TBL p WHERE p.f1 ~= '(5.1, 34.5)';
SELECT '' AS three, p.* FROM POINT_TBL p   WHERE p.f1 <@ box '(0,0,100,100)';
SELECT '' AS three, p.* FROM POINT_TBL p   WHERE box '(0,0,100,100)' @> p.f1;
SELECT '' AS three, p.* FROM POINT_TBL p   WHERE not p.f1 <@ box '(0,0,100,100)';
SELECT '' AS two, p.* FROM POINT_TBL p   WHERE p.f1 <@ path '[(0,0),(-10,0),(-10,10)]';
SELECT '' AS three, p.* FROM POINT_TBL p   WHERE not box '(0,0,100,100)' @> p.f1;
SELECT '' AS six, p.f1, p.f1 <-> point '(0,0)' AS dist   FROM POINT_TBL p   ORDER BY dist;
SELECT '' AS thirtysix, p1.f1 AS point1, p2.f1 AS point2, p1.f1 <-> p2.f1 AS dist   FROM POINT_TBL p1, POINT_TBL p2   ORDER BY dist, p1.f1[0], p2.f1[0];
SELECT '' AS thirty, p1.f1 AS point1, p2.f1 AS point2   FROM POINT_TBL p1, POINT_TBL p2   WHERE (p1.f1 <-> p2.f1) > 3;
SELECT '' AS fifteen, p1.f1 AS point1, p2.f1 AS point2, (p1.f1 <-> p2.f1) AS distance   FROM POINT_TBL p1, POINT_TBL p2   WHERE (p1.f1 <-> p2.f1) > 3 and p1.f1 << p2.f1   ORDER BY distance, p1.f1[0], p2.f1[0];
SELECT '' AS three, p1.f1 AS point1, p2.f1 AS point2, (p1.f1 <-> p2.f1) AS distance   FROM POINT_TBL p1, POINT_TBL p2   WHERE (p1.f1 <-> p2.f1) > 3 and p1.f1 << p2.f1 and p1.f1 >^ p2.f1   ORDER BY distance;
CREATE TEMP TABLE point_gist_tbl(f1 point);
CREATE INDEX point_gist_tbl_index ON point_gist_tbl USING gist (f1);
SET enable_seqscan TO true;
SET enable_indexscan TO false;
SET enable_bitmapscan TO false;
~::SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000009,0.0000009)'::point;
@::SELECT COUNT(*) FROM point_gist_tbl WHERE f1 <@ '(0.0000009,0.0000009),(0.0000009,0.0000009)'::box;
~::SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000018,0.0000018)'::point;
SET enable_seqscan TO false;
SET enable_indexscan TO true;
SET enable_bitmapscan TO true;
~::SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000009,0.0000009)'::point;
@::SELECT COUNT(*) FROM point_gist_tbl WHERE f1 <@ '(0.0000009,0.0000009),(0.0000009,0.0000009)'::box;
~::SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000018,0.0000018)'::point;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE, ftest2 int );
INSERT INTO FKTABLE VALUES (NULL, 1);
DELETE FROM PKTABLE WHERE ptest1=1;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, CONSTRAINT constrname FOREIGN KEY(ftest1, ftest2)                       REFERENCES PKTABLE MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
INSERT INTO FKTABLE VALUES (NULL, 2, 4);
INSERT INTO FKTABLE VALUES (1, NULL, 4);
DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
UPDATE FKTABLE SET ftest1 = NULL WHERE ftest1 = 1;
ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
DROP TABLE PKTABLE CASCADE;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
CREATE TABLE FKTABLE ( ftest1 int DEFAULT -1, ftest2 int DEFAULT -2, ftest3 int, CONSTRAINT constrname2 FOREIGN KEY(ftest1, ftest2)                       REFERENCES PKTABLE MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
INSERT INTO FKTABLE VALUES (NULL, 2, 4);
INSERT INTO FKTABLE VALUES (1, NULL, 4);
DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
DROP TABLE PKTABLE CASCADE;
INSERT INTO FKTABLE VALUES (NULL, 1);
DELETE FROM PKTABLE WHERE ptest1=1;
DELETE FROM PKTABLE WHERE ptest1=5;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, PRIMARY KEY(ptest1, ptest2) );
INSERT INTO FKTABLE VALUES (1, NULL);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) REFERENCES PKTABLE MATCH FULL;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE);
INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
DELETE FROM PKTABLE where ptest1=2;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, UNIQUE(ptest1, ptest2, ptest3) );
CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE (ptest1, ptest2, ptest3));
INSERT INTO PKTABLE VALUES (1, 3, NULL, 'test2');
INSERT INTO PKTABLE VALUES (2, NULL, 4, 'test3');
DELETE FROM PKTABLE WHERE ptest1 = 2;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE			ON DELETE CASCADE ON UPDATE CASCADE);
INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
DELETE FROM PKTABLE where ptest1=1 and ptest2=5 and ptest3=3;
DELETE FROM PKTABLE where ptest1=2;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE			ON DELETE SET DEFAULT ON UPDATE SET NULL);
INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
DELETE FROM PKTABLE where ptest2=5;
CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int DEFAULT -1, ftest3 int DEFAULT -2, ftest4 int, CONSTRAINT constrname3			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE			ON DELETE SET NULL ON UPDATE SET DEFAULT);
INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
CREATE TABLE FKTABLE_FAIL2 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest1) REFERENCES PKTABLE(ptest2));
CREATE TABLE PKTABLE (ptest1 int, ptest2 int, UNIQUE(ptest1, ptest2));
CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1));
CREATE TABLE FKTABLE (ftest1 int8 REFERENCES pktable);
INSERT INTO FKTABLE VALUES(42);		-- should succeedINSERT INTO FKTABLE VALUES(43);		-- should failUPDATE FKTABLE SET ftest1 = ftest1;	-- should succeedUPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should failDROP TABLE FKTABLE;
INSERT INTO FKTABLE VALUES(42);		-- should succeedINSERT INTO FKTABLE VALUES(43);		-- should failUPDATE FKTABLE SET ftest1 = ftest1;	-- should succeedUPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should failDROP TABLE FKTABLE;
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, PRIMARY KEY(ptest1, ptest2));
CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable);
CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable);
CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2));
CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1));
CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest2, ptest1));
CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,ptest4) REFERENCES pktable(ptest1, ptest2));
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,ptest4) REFERENCES pktable);
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,ptest4) REFERENCES pktable(ptest2, ptest1));
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,ptest3) REFERENCES pktable(ptest1, ptest2));
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,ptest3) REFERENCES pktable);
create table pktable (ptest1 int, primary key(base1), unique(base1, ptest1)) inherits (pktable_base);
delete from pktable where base1>2;
delete from pktable where base1>3;
delete from pktable;
create table fktable (ftest1 int, ftest2 int, foreign key(ftest1, ftest2) references pktable(base1, ptest1));
delete from pktable where base1>2;
delete from pktable where base1>3;
create table pktable(ptest1 int, ptest2 int, primary key(base1, ptest1), foreign key(base2, ptest2) references                                             pktable(base1, ptest1)) inherits (pktable_base);
delete from pktable where base1=2;
delete from pktable where base2=2;
delete from pktable where base1=2;
create table pktable(ptest1 inet, primary key(base1, ptest1)) inherits (pktable_base);
create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1));
create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable);
create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1));
create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
create table pktable(ptest1 inet, ptest2 inet[], primary key(base1, ptest1), foreign key(base2, ptest2) references                                             pktable(base1, ptest1)) inherits (pktable_base);
create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(base2, ptest2) references                                             pktable(ptest1, base1)) inherits (pktable_base);
create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references                                             pktable(base1, ptest1)) inherits (pktable_base);
create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references                                             pktable(base1, ptest1)) inherits (pktable_base);
CREATE TABLE pktable (	id		INT4 PRIMARY KEY,	other	INT4);
CREATE TABLE fktable (	id		INT4 PRIMARY KEY,	fk		INT4 REFERENCES pktable DEFERRABLE);
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
INSERT INTO pktable VALUES (15, 0); -- make the FK insert validCOMMIT;
DROP TABLE fktable, pktable;
CREATE TABLE pktable (	id		INT4 PRIMARY KEY,	other	INT4);
CREATE TABLE fktable (	id		INT4 PRIMARY KEY,	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED);
BEGIN;
INSERT INTO pktable VALUES (200, 500); -- make the FK insert validCOMMIT;
BEGIN;
SET CONSTRAINTS ALL IMMEDIATE;
COMMIT;
DROP TABLE fktable, pktable;
CREATE TABLE pktable (	id		INT4 PRIMARY KEY,	other	INT4);
CREATE TABLE fktable (	id		INT4 PRIMARY KEY,	fk		INT4 REFERENCES pktable DEFERRABLE);
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
SET CONSTRAINTS ALL IMMEDIATE;
INSERT INTO pktable VALUES (2000, 3); -- too lateCOMMIT;
DROP TABLE fktable, pktable;
CREATE TABLE pktable (	id		INT4 PRIMARY KEY,	other	INT4);
CREATE TABLE fktable (	id		INT4 PRIMARY KEY,	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED);
BEGIN;
COMMIT;
DROP TABLE pktable, fktable;
CREATE TEMP TABLE pktable (        id1     INT4 PRIMARY KEY,        id2     VARCHAR(4) UNIQUE,        id3     REAL UNIQUE,        UNIQUE(id1, id2, id3));
CREATE TEMP TABLE fktable (        x1      INT4 REFERENCES pktable(id1),        x2      VARCHAR(4) REFERENCES pktable(id2),        x3      REAL REFERENCES pktable(id3),        x4      TEXT,        x5      INT2);
ALTER TABLE fktable ADD CONSTRAINT fk_2_3FOREIGN KEY (x2) REFERENCES pktable(id3);
ALTER TABLE fktable ADD CONSTRAINT fk_2_1FOREIGN KEY (x2) REFERENCES pktable(id1);
ALTER TABLE fktable ADD CONSTRAINT fk_3_1FOREIGN KEY (x3) REFERENCES pktable(id1);
ALTER TABLE fktable ADD CONSTRAINT fk_1_2FOREIGN KEY (x1) REFERENCES pktable(id2);
ALTER TABLE fktable ADD CONSTRAINT fk_1_3FOREIGN KEY (x1) REFERENCES pktable(id3);
ALTER TABLE fktable ADD CONSTRAINT fk_4_2FOREIGN KEY (x4) REFERENCES pktable(id2);
ALTER TABLE fktable ADD CONSTRAINT fk_5_1FOREIGN KEY (x5) REFERENCES pktable(id1);
ALTER TABLE fktable ADD CONSTRAINT fk_123_123FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id1,id2,id3);
ALTER TABLE fktable ADD CONSTRAINT fk_213_213FOREIGN KEY (x2,x1,x3) REFERENCES pktable(id2,id1,id3);
ALTER TABLE fktable ADD CONSTRAINT fk_253_213FOREIGN KEY (x2,x5,x3) REFERENCES pktable(id2,id1,id3);
ALTER TABLE fktable ADD CONSTRAINT fk_123_231FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
ALTER TABLE fktable ADD CONSTRAINT fk_241_132FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
DROP TABLE pktable, fktable;
CREATE TEMP TABLE fktable (    id int primary key,    fk int references pktable deferrable initially deferred);
BEGIN;
COMMIT;
BEGIN;
SAVEPOINT savept1;
COMMIT;
BEGIN;
SAVEPOINT savept1;
RELEASE SAVEPOINT savept1;
COMMIT;
BEGIN;
SAVEPOINT savept1;
ROLLBACK TO savept1;
COMMIT;
ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
BEGIN;
COMMIT;
BEGIN;
COMMIT;
ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
CREATE TEMP TABLE tasks (  id INT PRIMARY KEY,  owner INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,  worker INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,  checked_by INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL);
INSERT INTO tasks VALUES (1,1,NULL,NULL);
INSERT INTO tasks VALUES (2,2,2,NULL);
DELETE FROM users WHERE id = 4;
BEGIN;
DELETE FROM users WHERE id = 2;
COMMIT;
create temp table selfref (    a int primary key,    b int,    foreign key (b) references selfref (a)        on update cascade on delete cascade);
begin;
commit;
create temp table defc (f1 int default 0                        references defp on delete set default);
delete from defp where f1 = 2;
delete from defp where f1 = 0; -- failalter table defc alter column f1 set default 1;
delete from defp where f1 = 0;
delete from defp where f1 = 1; -- failcreate temp table pp (f1 int primary key);
create temp table cc (f1 int references pp on update no action on delete no action);
update pp set f1=f1+1; -- faildelete from pp where f1 = 13; -- faildrop table pp, cc;
create temp table cc (f1 int references pp on update restrict on delete restrict);
update pp set f1=f1+1; -- faildelete from pp where f1 = 13; -- faildrop table pp, cc;
create rule r1 as on delete to t1 do delete from t2 where t2.b = old.a;
explain (costs off) delete from t1 where a = 1;
delete from t1 where a = 1;
create table pktable2 (a int, b int, c int, d int, e int, primary key (d, e));
create table fktable2 (d int, e int, foreign key (d, e) references pktable2);
delete from pktable2;
drop table pktable2, fktable2;
create table pktable2 (a int, b int, primary key (a, b));
create table fktable2 (  a int,  b int,  very_very_long_column_name_to_exceed_63_characters int,  foreign key (very_very_long_column_name_to_exceed_63_characters) references pktable1,  foreign key (a, very_very_long_column_name_to_exceed_63_characters) references pktable2,  foreign key (a, very_very_long_column_name_to_exceed_63_characters) references pktable2);
::select conname from pg_constraint where conrelid = 'fktable2'::regclass order by conname;
drop table pktable1, pktable2, fktable2;
create table fktable2(f1 int references pktable2 deferrable initially deferred);
begin;
savepoint x;
delete from fktable2;
rollback to x;
commit;
begin;
savepoint x;
delete from fktable2;
rollback to x;
commit; -- failbegin;
alter table fktable2 drop constraint fktable2_f1_fkey;
commit;
begin;
delete from pktable2 where f1 = 1;
alter table fktable2 drop constraint fktable2_f1_fkey;
commit;
drop table pktable2, fktable2;
create table pktable2 (a float8, b float8, primary key (a, b));
create table fktable2 (x float8, y float8, foreign key (x, y) references pktable2 (a, b) on update cascade);
drop table pktable2, fktable2;
CREATE TABLE fk_notpartitioned_pk (fdrop1 int, a int, fdrop2 int, b int,  PRIMARY KEY (a, b));
ALTER TABLE fk_notpartitioned_pk DROP COLUMN fdrop1, DROP COLUMN fdrop2;
CREATE TABLE fk_partitioned_fk (b int, fdrop1 int, a int) PARTITION BY RANGE (a, b);
ALTER TABLE fk_partitioned_fk DROP COLUMN fdrop1;
ALTER TABLE fk_partitioned_fk_1 DROP COLUMN fdrop1, DROP COLUMN fdrop2, DROP COLUMN fdrop3;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_1 FOR VALUES FROM (0,0) TO (1000,1000);
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk;
ALTER TABLE fk_partitioned_fk_2 DROP COLUMN fdrop1, DROP COLUMN fdrop2;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES FROM (1000,1000) TO (2000,2000);
CREATE TABLE fk_partitioned_fk_3 (fdrop1 int, fdrop2 int, fdrop3 int, fdrop4 int, b int, a int)  PARTITION BY HASH (a);
ALTER TABLE fk_partitioned_fk_3 DROP COLUMN fdrop1, DROP COLUMN fdrop2,	DROP COLUMN fdrop3, DROP COLUMN fdrop4;
CREATE TABLE fk_partitioned_fk_3_0 PARTITION OF fk_partitioned_fk_3 FOR VALUES WITH (MODULUS 5, REMAINDER 0);
CREATE TABLE fk_partitioned_fk_3_1 PARTITION OF fk_partitioned_fk_3 FOR VALUES WITH (MODULUS 5, REMAINDER 1);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3  FOR VALUES FROM (2000,2000) TO (3000,3000);
ALTER TABLE ONLY fk_partitioned_fk ADD FOREIGN KEY (a, b)  REFERENCES fk_notpartitioned_pk;
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)  REFERENCES fk_notpartitioned_pk NOT VALID;
ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
CREATE TABLE fk_notpartitioned_pk (a INT, PRIMARY KEY(a), CHECK (a > 0));
CREATE TABLE fk_partitioned_fk (a INT REFERENCES fk_notpartitioned_pk(a) PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
ALTER TABLE fk_notpartitioned_pk ALTER COLUMN a TYPE bigint;
DELETE FROM fk_notpartitioned_pk WHERE a = 1;
DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
CREATE TABLE fk_notpartitioned_pk (a int, b int, primary key (a, b));
CREATE TABLE fk_partitioned_fk (a int default 2501, b int default 142857) PARTITION BY LIST (a);
CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES IN (NULL,500,501,502);
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)  REFERENCES fk_notpartitioned_pk MATCH SIMPLE  ON DELETE SET NULL ON UPDATE SET NULL;
CREATE TABLE fk_partitioned_fk_2 PARTITION OF fk_partitioned_fk FOR VALUES IN (1500,1502);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3 FOR VALUES IN (2500,2501,2502,2503);
INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, NULL);
INSERT INTO fk_partitioned_fk (a,b) VALUES (NULL, NULL);
CREATE TABLE fk_partitioned_fk_full (x int, y int) PARTITION BY RANGE (x);
CREATE TABLE fk_partitioned_fk_full_1 PARTITION OF fk_partitioned_fk_full DEFAULT;
INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);
ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;  -- failsTRUNCATE fk_partitioned_fk_full;
ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;
INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);  -- failsDROP TABLE fk_partitioned_fk_full;
::::DELETE FROM fk_notpartitioned_pk;
ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)  REFERENCES fk_notpartitioned_pk  ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)  REFERENCES fk_notpartitioned_pk  ON DELETE CASCADE ON UPDATE CASCADE;
DELETE FROM fk_notpartitioned_pk WHERE b = 142857;
CREATE TABLE fk_partitioned_fk_2 PARTITION OF fk_partitioned_fk FOR VALUES IN (1500,1502);
ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_2;
BEGIN;
ROLLBACK;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
CREATE TABLE fk_partitioned_fk_2 (b int, c text, a int,	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk ON UPDATE CASCADE ON DELETE CASCADE);
ALTER TABLE fk_partitioned_fk_2 DROP COLUMN c;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
CREATE TABLE fk_partitioned_fk_4 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE) PARTITION BY RANGE (b, a);
CREATE TABLE fk_partitioned_fk_4_1 PARTITION OF fk_partitioned_fk_4 FOR VALUES FROM (1,1) TO (100,100);
CREATE TABLE fk_partitioned_fk_4_2 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE SET NULL);
ALTER TABLE fk_partitioned_fk_4 ATTACH PARTITION fk_partitioned_fk_4_2 FOR VALUES FROM (100,100) TO (1000,1000);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_4;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
CREATE TABLE fk_partitioned_fk_5 (a int, b int,	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE,	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) MATCH FULL ON UPDATE CASCADE ON DELETE CASCADE)  PARTITION BY RANGE (a);
CREATE TABLE fk_partitioned_fk_5_1 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_5;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
ALTER TABLE fk_partitioned_fk_5 DETACH PARTITION fk_partitioned_fk_5_1;
ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
CREATE TABLE fk_partitioned_fk_2 (a int, b int) PARTITION BY RANGE (b);
CREATE TABLE fk_partitioned_fk_2_1 PARTITION OF fk_partitioned_fk_2 FOR VALUES FROM (0) TO (1000);
CREATE TABLE fk_partitioned_fk_2_2 PARTITION OF fk_partitioned_fk_2 FOR VALUES FROM (1000) TO (2000);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2  FOR VALUES IN (1600);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2  FOR VALUES IN (1600);
create role regress_other_partitioned_fk_owner;
grant references on fk_notpartitioned_pk to regress_other_partitioned_fk_owner;
set role regress_other_partitioned_fk_owner;
create table other_partitioned_fk(a int, b int) partition by list (a);
create table other_partitioned_fk_1 partition of other_partitioned_fk  for values in (2048);
alter table other_partitioned_fk add foreign key (a, b)  references fk_notpartitioned_pk(a, b);
reset role;
set role regress_other_partitioned_fk_owner;
alter table other_partitioned_fk add foreign key (a, b)  references fk_notpartitioned_pk(a, b);
reset role;
revoke all on fk_notpartitioned_pk from regress_other_partitioned_fk_owner;
drop role regress_other_partitioned_fk_owner;
create schema fkpart0  create table pkey (a int primary key)  create table fk_part (a int) partition by list (a)  create table fk_part_1 partition of fk_part      (foreign key (a) references fkpart0.pkey) for values in (1)  create table fk_part_23 partition of fk_part      (foreign key (a) references fkpart0.pkey) for values in (2, 3)      partition by list (a)  create table fk_part_23_2 partition of fk_part_23 for values in (2);
alter table fkpart0.fk_part add foreign key (a) references fkpart0.pkey;
alter table fkpart0.fk_part_1 drop constraint fk_part_1_a_fkey;
alter table fkpart0.fk_part_23 drop constraint fk_part_23_a_fkey;
alter table fkpart0.fk_part_23_2 drop constraint fk_part_23_a_fkey;
create table fkpart0.fk_part_4 partition of fkpart0.fk_part for values in (4);
alter table fkpart0.fk_part_4 drop constraint fk_part_a_fkey;
create table fkpart0.fk_part_56 partition of fkpart0.fk_part    for values in (5,6) partition by list (a);
create table fkpart0.fk_part_56_5 partition of fkpart0.fk_part_56    for values in (5);
alter table fkpart0.fk_part_56 drop constraint fk_part_a_fkey;
alter table fkpart0.fk_part_56_5 drop constraint fk_part_a_fkey;
create schema fkpart1  create table pkey (a int primary key)  create table fk_part (a int) partition by list (a)  create table fk_part_1 partition of fk_part for values in (1) partition by list (a)  create table fk_part_1_1 partition of fk_part_1 for values in (1);
alter table fkpart1.fk_part add foreign key (a) references fkpart1.pkey;
insert into fkpart1.fk_part values (1);		-- should failinsert into fkpart1.pkey values (1);
insert into fkpart1.fk_part values (1);
delete from fkpart1.pkey where a = 1;		-- should failalter table fkpart1.fk_part detach partition fkpart1.fk_part_1;
create table fkpart1.fk_part_1_2 partition of fkpart1.fk_part_1 for values in (2);
insert into fkpart1.fk_part_1 values (2);	-- should faildelete from fkpart1.pkey where a = 1;
create schema fkpart2  create table pkey (a int primary key)  create table fk_part (a int, constraint fkey foreign key (a) references fkpart2.pkey) partition by list (a)  create table fk_part_1 partition of fkpart2.fk_part for values in (1) partition by list (a)  create table fk_part_1_1 (a int, constraint my_fkey foreign key (a) references fkpart2.pkey);
alter table fkpart2.fk_part_1 attach partition fkpart2.fk_part_1_1 for values in (1);
alter table fkpart2.fk_part_1 drop constraint fkey;	-- should failalter table fkpart2.fk_part_1_1 drop constraint my_fkey;	-- should failalter table fkpart2.fk_part detach partition fkpart2.fk_part_1;
alter table fkpart2.fk_part_1 drop constraint fkey;	-- okalter table fkpart2.fk_part_1_1 drop constraint my_fkey;	-- doesn't existcreate schema fkpart3  create table pkey (a int primary key)  create table fk_part (a int, constraint fkey foreign key (a) references fkpart3.pkey deferrable initially immediate) partition by list (a)  create table fk_part_1 partition of fkpart3.fk_part for values in (1) partition by list (a)  create table fk_part_1_1 partition of fkpart3.fk_part_1 for values in (1)  create table fk_part_2 partition of fkpart3.fk_part for values in (2);
begin;
set constraints fkpart3.fkey deferred;
insert into fkpart3.fk_part values (1);
insert into fkpart3.pkey values (1);
commit;
begin;
set constraints fkpart3.fkey deferred;
delete from fkpart3.pkey;
delete from fkpart3.fk_part;
commit;
drop schema fkpart0, fkpart1, fkpart2, fkpart3 cascade;
CREATE SCHEMA fkpart3;
SET search_path TO fkpart3;
CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY RANGE (a);
CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (0) TO (1000);
ALTER TABLE pk2 DROP COLUMN b;
ALTER TABLE pk2 ALTER a SET NOT NULL;
ALTER TABLE pk ATTACH PARTITION pk2 FOR VALUES FROM (1000) TO (2000);
CREATE TABLE fk (a int) PARTITION BY RANGE (a);
CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (0) TO (750);
ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk;
ALTER TABLE fk2 DROP COLUMN b;
ALTER TABLE fk ATTACH PARTITION fk2 FOR VALUES FROM (750) TO (3500);
CREATE TABLE pk3 PARTITION OF pk FOR VALUES FROM (2000) TO (3000);
CREATE TABLE pk4 (LIKE pk);
ALTER TABLE pk ATTACH PARTITION pk4 FOR VALUES FROM (3000) TO (4000);
CREATE TABLE pk5 (c int, b int, a int NOT NULL) PARTITION BY RANGE (a);
ALTER TABLE pk5 DROP COLUMN b, DROP COLUMN c;
CREATE TABLE pk51 PARTITION OF pk5 FOR VALUES FROM (4000) TO (4500);
CREATE TABLE pk52 PARTITION OF pk5 FOR VALUES FROM (4500) TO (5000);
ALTER TABLE pk ATTACH PARTITION pk5 FOR VALUES FROM (4000) TO (5000);
CREATE TABLE fk3 PARTITION OF fk FOR VALUES FROM (3500) TO (5000);
DELETE FROM pk WHERE a = 1;
DELETE FROM pk WHERE a = 1000;
DELETE FROM pk WHERE a = 2000;
DELETE FROM pk WHERE a = 3000;
DELETE FROM pk WHERE a = 4000;
DELETE FROM pk WHERE a = 4500;
DELETE FROM fk;
DELETE FROM pk WHERE a = 2;
DELETE FROM pk WHERE a = 1002;
DELETE FROM pk WHERE a = 2002;
DELETE FROM pk WHERE a = 3002;
DELETE FROM pk WHERE a = 4002;
DELETE FROM pk WHERE a = 4502;
CREATE SCHEMA fkpart4;
SET search_path TO fkpart4;
CREATE TABLE droppk (a int PRIMARY KEY) PARTITION BY RANGE (a);
CREATE TABLE droppk1 PARTITION OF droppk FOR VALUES FROM (0) TO (1000);
CREATE TABLE droppk_d PARTITION OF droppk DEFAULT;
CREATE TABLE droppk2 PARTITION OF droppk FOR VALUES FROM (1000) TO (2000)  PARTITION BY RANGE (a);
CREATE TABLE droppk21 PARTITION OF droppk2 FOR VALUES FROM (1000) TO (1400);
CREATE TABLE droppk2_d PARTITION OF droppk2 DEFAULT;
ALTER TABLE droppk DETACH PARTITION droppk_d;
ALTER TABLE droppk2 DETACH PARTITION droppk2_d;
ALTER TABLE droppk DETACH PARTITION droppk1;
ALTER TABLE droppk DETACH PARTITION droppk2;
ALTER TABLE droppk2 DETACH PARTITION droppk21;
DELETE FROM dropfk;
ALTER TABLE droppk2 DETACH PARTITION droppk21;
CREATE SCHEMA fkpart5;
SET search_path TO fkpart5;
CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY LIST (a);
CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1) PARTITION BY LIST (a);
CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES IN (1);
CREATE TABLE fk (a int) PARTITION BY LIST (a);
CREATE TABLE fk1 PARTITION OF fk FOR VALUES IN (1) PARTITION BY LIST (a);
CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES IN (1);
ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk;
CREATE TABLE pk2 PARTITION OF pk FOR VALUES IN (2);
CREATE TABLE pk3 (a int NOT NULL) PARTITION BY LIST (a);
CREATE TABLE pk31 PARTITION OF pk3 FOR VALUES IN (31);
ALTER TABLE pk32 DROP COLUMN b;
ALTER TABLE pk3 ATTACH PARTITION pk32 FOR VALUES IN (32);
ALTER TABLE pk ATTACH PARTITION pk3 FOR VALUES IN (31, 32);
CREATE TABLE fk2 PARTITION OF fk FOR VALUES IN (2);
ALTER TABLE fk3 DROP COLUMN b;
ALTER TABLE fk ATTACH PARTITION fk3 FOR VALUES IN (3);
::::SELECT pg_describe_object('pg_constraint'::regclass, oid, 0), confrelid::regclass,       CASE WHEN conparentid <> 0 THEN pg_describe_object('pg_constraint'::regclass, conparentid, 0) ELSE 'TOP' ENDFROM pg_catalog.pg_constraintWHERE conrelid IN (SELECT relid FROM pg_partition_tree('fk'))ORDER BY conrelid::regclass::text, conname;
CREATE TABLE fk4 (LIKE fk);
ALTER TABLE fk ATTACH PARTITION fk4 FOR VALUES IN (50);
CREATE SCHEMA fkpart9;
SET search_path TO fkpart9;
CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY LIST (a);
CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1, 2) PARTITION BY LIST (a);
CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES IN (1);
CREATE TABLE pk3 PARTITION OF pk FOR VALUES IN (3);
CREATE TABLE fk (a int REFERENCES pk DEFERRABLE INITIALLY IMMEDIATE);
INSERT INTO fk VALUES (1);		-- should failBEGIN;
SET CONSTRAINTS fk_a_fkey DEFERRED;
COMMIT;							-- should failBEGIN;
SET CONSTRAINTS fk_a_fkey DEFERRED;
COMMIT;							-- OKBEGIN;
SET CONSTRAINTS fk_a_fkey DEFERRED;
DELETE FROM pk WHERE a = 1;
DELETE FROM fk WHERE a = 1;
COMMIT;							-- OKDROP SCHEMA fkpart9 CASCADE;
CREATE SCHEMA fkpart6;
SET search_path TO fkpart6;
CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY RANGE (a);
CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES FROM (1) TO (50);
CREATE TABLE pk12 PARTITION OF pk1 FOR VALUES FROM (50) TO (100);
CREATE TABLE fk (a int) PARTITION BY RANGE (a);
CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE CASCADE ON DELETE CASCADE;
CREATE TABLE fk_d PARTITION OF fk DEFAULT;
::DELETE FROM pk WHERE a = 20;
::TRUNCATE TABLE pk;
CREATE TABLE fk (a int) PARTITION BY RANGE (a);
CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE SET NULL ON DELETE SET NULL;
CREATE TABLE fk_d PARTITION OF fk DEFAULT;
DELETE FROM pk WHERE a = 50;
::TRUNCATE TABLE pk;
CREATE TABLE fk (id int, a int DEFAULT 50) PARTITION BY RANGE (a);
CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE SET DEFAULT ON DELETE SET DEFAULT;
CREATE TABLE fk_d PARTITION OF fk DEFAULT;
DELETE FROM pk WHERE a = 20 RETURNING *;
UPDATE pk SET a = 90 WHERE a = 30 RETURNING *;
::TRUNCATE TABLE pk;
CREATE TABLE fk (a int DEFAULT 50) PARTITION BY RANGE (a);
CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE RESTRICT ON DELETE RESTRICT;
CREATE TABLE fk_d PARTITION OF fk DEFAULT;
DELETE FROM pk WHERE a = 20;
::CREATE SCHEMA fkpart7  CREATE TABLE pkpart (a int) PARTITION BY LIST (a)  CREATE TABLE pkpart1 PARTITION OF pkpart FOR VALUES IN (1);
ALTER TABLE fkpart7.pkpart1 ADD PRIMARY KEY (a);
ALTER TABLE fkpart7.pkpart ADD PRIMARY KEY (a);
CREATE TABLE fkpart7.fk (a int REFERENCES fkpart7.pkpart);
DROP SCHEMA fkpart7 CASCADE;
CREATE SCHEMA fkpart8  CREATE TABLE tbl1(f1 int PRIMARY KEY)  CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED) PARTITION BY RANGE(f1)  CREATE TABLE tbl2_p1 PARTITION OF tbl2 FOR VALUES FROM (minvalue) TO (maxvalue);
INSERT INTO fkpart8.tbl1 VALUES(1);
BEGIN;
INSERT INTO fkpart8.tbl2 VALUES(1);
ALTER TABLE fkpart8.tbl2 DROP CONSTRAINT tbl2_f1_fkey;
COMMIT;
DROP SCHEMA fkpart8 CASCADE;
CREATE TABLE onek (	unique1		int4,	unique2		int4,	two			int4,	four		int4,	ten			int4,	twenty		int4,	hundred		int4,	thousand	int4,	twothousand	int4,	fivethous	int4,	tenthous	int4,	odd			int4,	even		int4,	stringu1	name,	stringu2	name,	string4		name);
CREATE TABLE tenk1 (	unique1		int4,	unique2		int4,	two			int4,	four		int4,	ten			int4,	twenty		int4,	hundred		int4,	thousand	int4,	twothousand	int4,	fivethous	int4,	tenthous	int4,	odd			int4,	even		int4,	stringu1	name,	stringu2	name,	string4		name);
CREATE TABLE tenk2 (	unique1 	int4,	unique2 	int4,	two 	 	int4,	four 		int4,	ten			int4,	twenty 		int4,	hundred 	int4,	thousand 	int4,	twothousand int4,	fivethous 	int4,	tenthous	int4,	odd			int4,	even		int4,	stringu1	name,	stringu2	name,	string4		name);
CREATE TABLE person (	name 		text,	age			int4,	location 	point);
CREATE TABLE emp (	salary 		int4,	manager 	name) INHERITS (person);
CREATE TABLE student (	gpa 		float8) INHERITS (person);
CREATE TABLE stud_emp (	percent 	int4) INHERITS (emp, student);
CREATE TABLE city (	name		name,	location 	box,	budget 		city_budget);
CREATE TABLE dept (	dname		name,	mgrname 	text);
CREATE TABLE slow_emp4000 (	home_base	 box);
CREATE TABLE fast_emp4000 (	home_base	 box);
CREATE TABLE road (	name		text,	thepath 	path);
CREATE TABLE ihighway () INHERITS (road);
CREATE TABLE shighway (	surface		text) INHERITS (road);
CREATE TABLE real_city (	pop			int4,	cname		text,	outline 	path);
CREATE TABLE a_star (	class		char,	a 			int4);
CREATE TABLE b_star (	b 			text) INHERITS (a_star);
CREATE TABLE c_star (	c 			name) INHERITS (a_star);
CREATE TABLE d_star (	d 			float8) INHERITS (b_star, c_star);
CREATE TABLE e_star (	e 			int2) INHERITS (c_star);
CREATE TABLE f_star (	f 			polygon) INHERITS (e_star);
CREATE TABLE aggtest (	a 			int2,	b			float4);
CREATE TABLE hash_i4_heap (	seqno 		int4,	random 		int4);
CREATE TABLE hash_name_heap (	seqno 		int4,	random 		name);
CREATE TABLE hash_txt_heap (	seqno 		int4,	random 		text);
CREATE TABLE hash_f8_heap (	seqno		int4,	random 		float8);
CREATE TABLE bt_i4_heap (	seqno 		int4,	random 		int4);
CREATE TABLE bt_name_heap (	seqno 		name,	random 		int4);
CREATE TABLE bt_txt_heap (	seqno 		text,	random 		int4);
CREATE TABLE bt_f8_heap (	seqno 		float8,	random 		int4);
CREATE TABLE array_op_test (	seqno		int4,	i			int4[],	t			text[]);
CREATE TABLE array_index_op_test (	seqno		int4,	i			int4[],	t			text[]);
CREATE TABLE testjsonb (       j jsonb);
CREATE TABLE unknowntab (	u unknown    -- fail);
CREATE TYPE unknown_comptype AS (	u unknown    -- fail);
CREATE TABLE IF NOT EXISTS test_tsvector(	t text,	a tsvector);
CREATE TABLE tas_case WITH ("Fillfactor" = 10) AS SELECT 1 a;
CREATE UNLOGGED TABLE unlogged1 (a int primary key);			-- OKCREATE TEMPORARY TABLE unlogged2 (a int primary key);			-- OKREINDEX INDEX unlogged1_pkey;
CREATE UNLOGGED TABLE public.unlogged2 (a int primary key);		-- also OKCREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);	-- not OKCREATE TABLE pg_temp.implicitly_temp (a int primary key);		-- OKCREATE TEMP TABLE explicitly_temp (a int primary key);			-- also OKCREATE TEMP TABLE pg_temp.doubly_temp (a int primary key);		-- also OKCREATE TEMP TABLE public.temp_to_perm (a int primary key);		-- not OKDROP TABLE unlogged1, public.unlogged2;
PREPARE select1 AS SELECT 1 as a;
CREATE TABLE as_select1 AS EXECUTE select1;
CREATE TABLE as_select1 AS EXECUTE select1;
CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
DEALLOCATE select1;
\\set ECHO noneSELECT 'CREATE TABLE extra_wide_table(firstc text, '|| array_to_string(array_agg('c'||i||' bool'),',')||', lastc text);'FROM generate_series(1, 1100) g(i)\gexec\set ECHO allINSERT INTO extra_wide_table(firstc, lastc) VALUES('first col', 'last col');
CREATE TABLE withoid() WITH OIDS;
CREATE TABLE withoid() WITH (oids);
CREATE TABLE withoid() WITH (oids = true);
CREATE TEMP TABLE withoutoid() WITHOUT OIDS; DROP TABLE withoutoid;
CREATE TEMP TABLE withoutoid() WITH (oids = false); DROP TABLE withoutoid;
CREATE TABLE default_expr_column (id int DEFAULT (id));
CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
CREATE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
CREATE TABLE default_expr_non_column (a int DEFAULT (avg(non_existent)));
CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
CREATE TABLE default_expr_agg (a int DEFAULT (generate_series(1,3)));
CREATE TABLE partitioned (	a int) INHERITS (some_table) PARTITION BY LIST (a);
CREATE TABLE partitioned (	a1 int,	a2 int) PARTITION BY LIST (a1, a2);	-- failCREATE TABLE partitioned (	a int,	EXCLUDE USING gist (a WITH &&)) PARTITION BY RANGE (a);
CREATE FUNCTION retset (a int) RETURNS SETOF int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
CREATE TABLE partitioned (	a int) PARTITION BY RANGE (retset(a));
DROP FUNCTION retset(int);
CREATE TABLE partitioned (	a int) PARTITION BY RANGE ((avg(a)));
CREATE TABLE partitioned (	a int,	b int) PARTITION BY RANGE ((avg(a) OVER (PARTITION BY b)));
CREATE TABLE partitioned (	a int) PARTITION BY LIST ((a LIKE (SELECT 1)));
CREATE TABLE partitioned (	a int) PARTITION BY RANGE (('a'));
CREATE FUNCTION const_func () RETURNS int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
CREATE TABLE partitioned (	a int) PARTITION BY RANGE (const_func());
DROP FUNCTION const_func();
CREATE TABLE partitioned (    a int) PARTITION BY MAGIC (a);
CREATE TABLE partitioned (	a int) PARTITION BY RANGE (b);
CREATE TABLE partitioned (	a int) PARTITION BY RANGE (xmin);
CREATE FUNCTION immut_func (a int) RETURNS int AS $$ SELECT a + random()::int; $$ LANGUAGE SQL;
CREATE TABLE partitioned (	a int) PARTITION BY RANGE (immut_func(a));
DROP FUNCTION immut_func(int);
CREATE TABLE partitioned (	a	int) PARTITION BY RANGE ((partitioned));
CREATE TABLE partitioned (	a point) PARTITION BY LIST (a);
CREATE TABLE partitioned (	a point) PARTITION BY LIST (a point_ops);
CREATE TABLE partitioned (	a point) PARTITION BY RANGE (a);
CREATE TABLE partitioned (	a point) PARTITION BY RANGE (a point_ops);
CREATE TABLE partitioned (	a int,	CONSTRAINT check_a CHECK (a > 0) NO INHERIT) PARTITION BY RANGE (a);
CREATE FUNCTION plusone(a int) RETURNS INT AS $$ SELECT a+1; $$ LANGUAGE SQL;
CREATE TABLE partitioned (	a int,	b int,	c text,	d text) PARTITION BY RANGE (a oid_ops, plusone(b), c collate "default", d collate "C");
DROP FUNCTION plusone(int);
CREATE TABLE partitioned2 (	a int,	b text) PARTITION BY RANGE ((a+1), substr(b, 1, 5));
CREATE TABLE fail () INHERITS (partitioned2);
CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
DROP TABLE partitioned, partitioned2;
create domain intdom1 as int;
create table partitioned (	a intdom1,	b text) partition by range (a);
alter table partitioned drop column a;  -- faildrop domain intdom1;  -- fail, requires cascadedrop domain intdom1 cascade;
table partitioned;  -- gonecreate domain intdom1 as int;
create table partitioned (	a intdom1,	b text) partition by range (plusone(a));
alter table partitioned drop column a;  -- faildrop domain intdom1;  -- fail, requires cascadedrop domain intdom1 cascade;
table partitioned;  -- goneCREATE TABLE list_parted (	a int) PARTITION BY LIST (a);
CREATE TABLE part_p1 PARTITION OF list_parted FOR VALUES IN ('1');
CREATE TABLE part_p2 PARTITION OF list_parted FOR VALUES IN (2);
CREATE TABLE part_p3 PARTITION OF list_parted FOR VALUES IN ((2+1));
CREATE TABLE part_null PARTITION OF list_parted FOR VALUES IN (null);
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename);
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename));
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1));
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6));
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2);
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
CREATE TABLE part_default PARTITION OF list_parted DEFAULT;
CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
CREATE TABLE bools (	a bool) PARTITION BY LIST (a);
CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
CREATE TABLE moneyp (	a money) PARTITION BY LIST (a);
CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
CREATE TABLE moneyp_11 PARTITION OF moneyp FOR VALUES IN ('11');
CREATE TABLE moneyp_12 PARTITION OF moneyp FOR VALUES IN (to_char(12, '99')::int);
CREATE TABLE bigintp (	a bigint) PARTITION BY LIST (a);
CREATE TABLE bigintp_10 PARTITION OF bigintp FOR VALUES IN (10);
CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
CREATE TABLE range_parted (	a date) PARTITION BY RANGE (a);
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (somename) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (somename.somename) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (a) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (max(a)) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (max(somename)) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM ((select 1)) TO ('2019-01-01');
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted  FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z');
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1);
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue);
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
CREATE TABLE hash_parted (	a int) PARTITION BY HASH (a);
CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 0);
CREATE TABLE hpart_2 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 50, REMAINDER 1);
CREATE TABLE hpart_3 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 200, REMAINDER 2);
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3);
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3);
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z');
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT;
CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a');
CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1);
CREATE TEMP TABLE temp_parted (	a int) PARTITION BY LIST (a);
CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a');
CREATE TABLE list_parted2 (	a varchar) PARTITION BY LIST (a);
CREATE TABLE part_null_z PARTITION OF list_parted2 FOR VALUES IN (null, 'z');
CREATE TABLE part_ab PARTITION OF list_parted2 FOR VALUES IN ('a', 'b');
CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
CREATE TABLE range_parted2 (	a int) PARTITION BY RANGE (a);
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
CREATE TABLE part0 PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (1);
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2);
CREATE TABLE part1 PARTITION OF range_parted2 FOR VALUES FROM (1) TO (10);
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue);
CREATE TABLE part2 PARTITION OF range_parted2 FOR VALUES FROM (20) TO (30);
CREATE TABLE part3 PARTITION OF range_parted2 FOR VALUES FROM (30) TO (40);
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT;
CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
CREATE TABLE range_parted3 (	a int,	b int) PARTITION BY RANGE (a, (b+1));
CREATE TABLE part00 PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, maxvalue);
CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1);
CREATE TABLE part10 PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, 1);
CREATE TABLE part11 PARTITION OF range_parted3 FOR VALUES FROM (1, 1) TO (1, 10);
CREATE TABLE part12 PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, maxvalue);
CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20);
CREATE TABLE range3_default PARTITION OF range_parted3 DEFAULT;
CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue);
CREATE TABLE hash_parted2 (	a varchar) PARTITION BY HASH (a);
CREATE TABLE h2part_1 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE h2part_2 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 0);
CREATE TABLE h2part_3 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 4);
CREATE TABLE h2part_4 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 5);
CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1);
CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8);
CREATE TABLE parted (	a text,	b int NOT NULL DEFAULT 0,	CONSTRAINT check_a CHECK (length(a) > 0)) PARTITION BY LIST (a);
CREATE TABLE part_a PARTITION OF parted FOR VALUES IN ('a');
::SELECT attname, attislocal, attinhcount FROM pg_attribute  WHERE attrelid = 'part_a'::regclass and attnum > 0  ORDER BY attnum;
CREATE TABLE part_b PARTITION OF parted (	b NOT NULL,	b DEFAULT 1,	b CHECK (b >= 0),	CONSTRAINT check_a CHECK (length(a) > 0)) FOR VALUES IN ('b');
CREATE TABLE part_b PARTITION OF parted (	b NOT NULL DEFAULT 1,	CONSTRAINT check_a CHECK (length(a) > 0),	CONSTRAINT check_b CHECK (b >= 0)) FOR VALUES IN ('b');
::SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY conislocal, coninhcount;
ALTER TABLE parted ADD CONSTRAINT check_b CHECK (b >= 0);
::SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
ALTER TABLE part_b DROP CONSTRAINT check_a;
ALTER TABLE part_b DROP CONSTRAINT check_b;
ALTER TABLE parted DROP CONSTRAINT check_a, DROP CONSTRAINT check_b;
::SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
CREATE TABLE part_c PARTITION OF parted (b WITH OPTIONS NOT NULL DEFAULT 0) FOR VALUES IN ('c') PARTITION BY RANGE ((b));
CREATE TABLE part_c_1_10 PARTITION OF part_c FOR VALUES FROM (1) TO (10);
create table parted_notnull_inh_test (a int default 1, b int not null default 0) partition by list (a);
create table parted_notnull_inh_test1 partition of parted_notnull_inh_test (a not null, b default 1) for values in (1);
insert into parted_notnull_inh_test (b) values (null);
create table parted_collate_must_match (a text collate "C", b text collate "C")  partition by range (a);
create table parted_collate_must_match1 partition of parted_collate_must_match  (a collate "POSIX") for values from ('a') to ('m');
create table parted_collate_must_match2 partition of parted_collate_must_match  (b collate "POSIX") for values from ('m') to ('z');
create table test_part_coll_posix (a text) partition by range (a collate "POSIX");
create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g');
create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "POSIX") to ('g');
create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m');
create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s');
create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "POSIX") to ('s');
create table test_part_coll_cast2 partition of test_part_coll_posix for values from (name 's') to ('z');
CREATE TABLE range_parted4 (a int, b int, c int) PARTITION BY RANGE (abs(a), abs(b), c);
CREATE TABLE unbounded_range_part PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE);
CREATE TABLE range_parted4_1 PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
CREATE FUNCTION my_int4_sort(int4,int4) RETURNS int LANGUAGE sql  AS $$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $$;
CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS  OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),  OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),  OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
CREATE TABLE partkey_t (a int4) PARTITION BY RANGE (a test_int4_ops);
CREATE TABLE partkey_t_1 PARTITION OF partkey_t FOR VALUES FROM (0) TO (1000);
DROP TABLE parted, list_parted, range_parted, list_parted2, range_parted2, range_parted3;
DROP TABLE partkey_t, hash_parted, hash_parted2;
DROP OPERATOR CLASS test_int4_ops USING btree;
DROP FUNCTION my_int4_sort(int4,int4);
CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a);
COMMENT ON TABLE parted_col_comment IS 'Am partitioned table';
COMMENT ON COLUMN parted_col_comment.a IS 'Partition key';
::CREATE TABLE arrlp (a int[]) PARTITION BY LIST (a);
CREATE TABLE arrlp12 PARTITION OF arrlp FOR VALUES IN ('{1}', '{2}');
create table boolspart (a bool) partition by list (a);
create table boolspart_t partition of boolspart for values in (true);
create table boolspart_f partition of boolspart for values in (false);
create table perm_parted (a int) partition by list (a);
create temporary table temp_parted (a int) partition by list (a);
create table perm_part partition of temp_parted default; -- errorcreate temp table temp_part partition of perm_parted default; -- errorcreate temp table temp_part partition of temp_parted default; -- okdrop table perm_parted cascade;
drop table temp_parted cascade;
create table tab_part_create (a int) partition by list (a);
create or replace function func_part_create() returns trigger  language plpgsql as $$  begin    execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';
    return null;
  end $$;
create trigger trig_part_create before insert on tab_part_create  for each statement execute procedure func_part_create();
drop function func_part_create();
create table volatile_partbound_test (partkey timestamp) partition by range (partkey);
create table volatile_partbound_test1 partition of volatile_partbound_test for values from (minvalue) to (current_timestamp);
create table volatile_partbound_test2 partition of volatile_partbound_test for values from (current_timestamp) to (maxvalue);
::create table defcheck (a int, b int) partition by list (b);
alter table defcheck_def drop c;
alter table defcheck attach partition defcheck_def default;
alter table defcheck_def add check (b <= 0 and b is not null);
create table defcheck_1 partition of defcheck for values in (1, null);
create table defcheck_0 partition of defcheck for values in (0);
create table part_column_drop (  useless_1 int,  id int,  useless_2 int,  d int,  b int,  useless_3 int) partition by range (id);
alter table part_column_drop drop column useless_1;
alter table part_column_drop drop column useless_2;
alter table part_column_drop drop column useless_3;
create table part_column_drop_1_10 partition of  part_column_drop for values from (1) to (10);
create table test1 (id serial, t text);
create table test2 (id serial, t text);
create view v_test1as select 'v_'||t from test1;
copy test1 to stdout;
copy v_test1 to stdout;
copy (select t from test1 where id=1) to stdout;
copy (select t from test1 where id=3 for update) to stdout;
copy (select t into temp test3 from test1 where id=3) to stdout;
copy (select * from test1) from stdin;
copy (select * from test1) (t,id) to stdout;
copy (select * from test1 join test2 using (id)) to stdout;
copy (select t from test1 where id = 1 UNION select * from v_test1 ORDER BY 1) to stdout;
copy (select * from (select t from test1 where id = 1 UNION select * from v_test1 ORDER BY 1) t1) to stdout;
copy (select t from test1 where id = 1) to stdout csv header force quote t;
\\copy test1 to stdout\copy v_test1 to stdout\copy (select "id",'id','id""'||t,(id + 1)*id,t,"test1"."t" from test1 where id=3) to stdoutdrop table test2;
copy (select 1) to stdout\; select 1/0;	-- row, then errorselect 1/0\; copy (select 1) to stdout; -- error onlycopy (select 1) to stdout\; copy (select 2) to stdout\; select 0\; select 3; -- 1 2 3create table test3 (c int);
\select 0\; copy test3 from stdin\; copy test3 from stdin\; select 1; -- 1\.\.select * from test3;
CREATE TABLE TIME_TBL (f1 time(2));
SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL;
PREPARE prepstmt AS SELECT * FROM pcachetest;
EXECUTE prepstmt;
PREPARE prepstmt2(bigint) AS SELECT * FROM pcachetest WHERE q1 = $1;
EXECUTE prepstmt2(123);
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
ALTER TABLE pcachetest DROP COLUMN q3;
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
PREPARE vprep AS SELECT * FROM pcacheview;
EXECUTE vprep;
EXECUTE vprep;
create function cache_test(int) returns int as $$declare total int;
begin	create temp table t1(f1 int);
$	select sum(f1) into total from t1;
	return total;
end$$ language plpgsql;
create function cache_test_2() returns int as $$begin	return f1 from v1;
end$$ language plpgsql;
create schema s1  create table abc (f1 int);
create schema s2  create table abc (f1 int);
insert into s1.abc values(123);
insert into s2.abc values(456);
set search_path = s1;
prepare p1 as select f1 from abc;
execute p1;
set search_path = s2;
execute p1;
alter table s1.abc add column f2 float8;   -- force replanexecute p1;
drop schema s1 cascade;
drop schema s2 cascade;
reset search_path;
create temp sequence seq;
prepare p2 as select nextval('seq');
execute p2;
drop sequence seq;
create temp sequence seq;
execute p2;
create function cachebug() returns void as $$declare r int;
begin  drop table if exists temptable cascade;
  for r in select * from vv loop    raise notice '%', r;
  end loop;
end$$ language plpgsql;
create table pc_list_parted (a int) partition by list(a);
create table pc_list_part_null partition of pc_list_parted for values in (null);
create table pc_list_part_1 partition of pc_list_parted for values in (1);
create table pc_list_part_def partition of pc_list_parted default;
prepare pstmt_def_insert (int) as insert into pc_list_part_def values($1);
execute pstmt_def_insert(null);
execute pstmt_def_insert(1);
create table pc_list_part_2 partition of pc_list_parted for values in (2);
execute pstmt_def_insert(2);
alter table pc_list_parted detach partition pc_list_part_null;
execute pstmt_def_insert(null);
execute pstmt_def_insert(1);
drop table pc_list_parted, pc_list_part_null;
deallocate pstmt_def_insert;
insert into test_mode select 1 from generate_series(1,1000) union all select 2;
create index on test_mode (a);
analyze test_mode;
prepare test_mode_pp (int) as select count(*) from test_mode where a = $1;
explain (costs off) execute test_mode_pp(2);
set plan_cache_mode to force_generic_plan;
explain (costs off) execute test_mode_pp(2);
set plan_cache_mode to auto;
execute test_mode_pp(1); -- 1xexecute test_mode_pp(1); -- 2xexecute test_mode_pp(1); -- 3xexecute test_mode_pp(1); -- 4xexecute test_mode_pp(1); -- 5xexplain (costs off) execute test_mode_pp(2);
set plan_cache_mode to force_custom_plan;
explain (costs off) execute test_mode_pp(2);
CREATE TABLE gtest0 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (55) STORED);
CREATE TABLE gtest1 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
SELECT table_name, column_name, column_default, is_nullable, is_generated, generation_expression FROM information_schema.columns WHERE table_name LIKE 'gtest_' ORDER BY 1, 2;
SELECT table_name, column_name, dependent_column FROM information_schema.column_column_usage ORDER BY 1, 2, 3;
CREATE TABLE gtest_err_1 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED GENERATED ALWAYS AS (a * 3) STORED);
CREATE TABLE gtest_err_2a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (b * 2) STORED);
CREATE TABLE gtest_err_2b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED, c int GENERATED ALWAYS AS (b * 3) STORED);
CREATE TABLE gtest_err_3 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (c * 2) STORED);
CREATE TABLE gtest_err_4 (a int PRIMARY KEY, b double precision GENERATED ALWAYS AS (random()) STORED);
CREATE TABLE gtest_err_5a (a int PRIMARY KEY, b int DEFAULT 5 GENERATED ALWAYS AS (a * 2) STORED);
CREATE TABLE gtest_err_5b (a int PRIMARY KEY, b int GENERATED ALWAYS AS identity GENERATED ALWAYS AS (a * 2) STORED);
CREATE TABLE gtest_err_6a (a int PRIMARY KEY, b bool GENERATED ALWAYS AS (xmin <> 37) STORED);
CREATE TABLE gtest_err_7a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (avg(a)) STORED);
CREATE TABLE gtest_err_7b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (row_number() OVER (ORDER BY a)) STORED);
CREATE TABLE gtest_err_7c (a int PRIMARY KEY, b int GENERATED ALWAYS AS ((SELECT a)) STORED);
CREATE TABLE gtest_err_7d (a int PRIMARY KEY, b int GENERATED ALWAYS AS (generate_series(1, a)) STORED);
CREATE TABLE gtest_err_8 (a int PRIMARY KEY, b int GENERATED BY DEFAULT AS (a * 2) STORED);
INSERT INTO gtest1 VALUES (2, DEFAULT);
INSERT INTO gtest1 VALUES (3, 33);  -- errorSELECT * FROM gtest1 ORDER BY a;
UPDATE gtest1 SET b = DEFAULT WHERE a = 1;
UPDATE gtest1 SET b = 11 WHERE a = 1;  -- errorSELECT * FROM gtest1 ORDER BY a;
DELETE FROM gtest1 WHERE a = 2000000000;
SELECT * FROM gtestx, gtest1 WHERE gtestx.y = gtest1.a;
DELETE FROM gtest1 WHERE b = 2;
INSERT INTO gtest1v VALUES (4, 8);  -- failsDROP VIEW gtest1v;
CREATE TABLE gtest1_1 () INHERITS (gtest1);
CREATE TABLE gtest1_2 () INHERITS (gtest1, gtesty);  -- errorDROP TABLE gtesty;
CREATE TABLE gtest3 (a int, b int GENERATED ALWAYS AS (a * 3) STORED);
INSERT INTO gtest3 (a) VALUES (1), (2), (3), (NULL);
CREATE TABLE gtest3a (a text, b text GENERATED ALWAYS AS (a || '+' || a) STORED);
INSERT INTO gtest3a (a) VALUES ('a'), ('b'), ('c'), (NULL);
TRUNCATE gtest1;
COPY gtest1 TO stdout;
COPY gtest1 (a, b) TO stdout;
COPY gtest1 FROM stdin;
\\.COPY gtest1 (a, b) FROM stdin;
TRUNCATE gtest3;
COPY gtest3 TO stdout;
COPY gtest3 (a, b) TO stdout;
COPY gtest3 FROM stdin;
\\.COPY gtest3 (a, b) FROM stdin;
CREATE TABLE gtest2 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (NULL) STORED);
CREATE TYPE double_int as (a int, b int);
CREATE TABLE gtest4 (    a int,    b double_int GENERATED ALWAYS AS ((a * 2, a * 3)) STORED);
DROP TYPE double_int;
CREATE TABLE gtest_tableoid (  a int PRIMARY KEY,  b bool GENERATED ALWAYS AS (tableoid <> 0) STORED);
CREATE TABLE gtest10 (a int PRIMARY KEY, b int, c int GENERATED ALWAYS AS (b * 2) STORED);
ALTER TABLE gtest10 DROP COLUMN b;
CREATE TABLE gtest10a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
ALTER TABLE gtest10a DROP COLUMN b;
CREATE USER regress_user11;
CREATE TABLE gtest11s (a int PRIMARY KEY, b int, c int GENERATED ALWAYS AS (b * 2) STORED);
GRANT SELECT (a, c) ON gtest11s TO regress_user11;
CREATE FUNCTION gf1(a int) RETURNS int AS $$ SELECT a * 3 $$ IMMUTABLE LANGUAGE SQL;
REVOKE ALL ON FUNCTION gf1(int) FROM PUBLIC;
CREATE TABLE gtest12s (a int PRIMARY KEY, b int, c int GENERATED ALWAYS AS (gf1(b)) STORED);
GRANT SELECT (a, c) ON gtest12s TO regress_user11;
SET ROLE regress_user11;
SELECT a, b FROM gtest11s;  -- not allowedSELECT a, c FROM gtest11s;  -- allowedSELECT gf1(10);  -- not allowedSELECT a, c FROM gtest12s;  -- allowedRESET ROLE;
DROP TABLE gtest11s, gtest12s;
DROP FUNCTION gf1(int);
DROP USER regress_user11;
CREATE TABLE gtest20 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED CHECK (b < 50));
INSERT INTO gtest20 (a) VALUES (10);  -- okINSERT INTO gtest20 (a) VALUES (30);  -- violates constraintCREATE TABLE gtest20a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
ALTER TABLE gtest20a ADD CHECK (b < 50);  -- fails on existing rowCREATE TABLE gtest20b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED);
ALTER TABLE gtest20b ADD CONSTRAINT chk CHECK (b < 50) NOT VALID;
ALTER TABLE gtest20b VALIDATE CONSTRAINT chk;  -- fails on existing rowCREATE TABLE gtest21a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (nullif(a, 0)) STORED NOT NULL);
INSERT INTO gtest21a (a) VALUES (1);  -- okINSERT INTO gtest21a (a) VALUES (0);  -- violates constraintCREATE TABLE gtest21b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (nullif(a, 0)) STORED);
ALTER TABLE gtest21b ALTER COLUMN b SET NOT NULL;
INSERT INTO gtest21b (a) VALUES (1);  -- okINSERT INTO gtest21b (a) VALUES (0);  -- violates constraintALTER TABLE gtest21b ALTER COLUMN b DROP NOT NULL;
INSERT INTO gtest21b (a) VALUES (0);  -- ok nowCREATE TABLE gtest22a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a / 2) STORED UNIQUE);
CREATE TABLE gtest22b (a int, b int GENERATED ALWAYS AS (a / 2) STORED, PRIMARY KEY (a, b));
CREATE TABLE gtest22c (a int, b int GENERATED ALWAYS AS (a * 2) STORED);
SET enable_seqscan TO off;
SET enable_bitmapscan TO off;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b = 4;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b * 3 = 6;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE a = 1 AND b > 0;
RESET enable_seqscan;
RESET enable_bitmapscan;
CREATE TABLE gtest23x (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x) ON UPDATE CASCADE);  -- errorCREATE TABLE gtest23x (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x) ON DELETE SET NULL);  -- errorCREATE TABLE gtest23b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x));
INSERT INTO gtest23b VALUES (1);  -- okINSERT INTO gtest23b VALUES (5);  -- errorDROP TABLE gtest23b;
CREATE TABLE gtest23p (x int, y int GENERATED ALWAYS AS (x * 2) STORED, PRIMARY KEY (y));
INSERT INTO gtest23q VALUES (1, 2);  -- okINSERT INTO gtest23q VALUES (2, 5);  -- errorCREATE DOMAIN gtestdomain1 AS int CHECK (VALUE < 10);
CREATE TABLE gtest24 (a int PRIMARY KEY, b gtestdomain1 GENERATED ALWAYS AS (a * 2) STORED);
INSERT INTO gtest24 (a) VALUES (4);  -- okINSERT INTO gtest24 (a) VALUES (6);  -- errorCREATE TYPE gtest_type AS (f1 integer, f2 text, f3 bigint);
CREATE TABLE gtest28 OF gtest_type (f1 WITH OPTIONS GENERATED ALWAYS AS (f2 *2) STORED);
DROP TYPE gtest_type CASCADE;
CREATE TABLE gtest_parent (f1 date NOT NULL, f2 text, f3 bigint) PARTITION BY RANGE (f1);
CREATE TABLE gtest_child PARTITION OF gtest_parent (    f3 WITH OPTIONS GENERATED ALWAYS AS (f2 * 2) STORED) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01'); -- errorDROP TABLE gtest_parent;
CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE (f1);
CREATE TABLE gtest_child PARTITION OF gtest_parent FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE (f3);
CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE ((f3 * 3));
ALTER TABLE gtest25 ADD COLUMN b int GENERATED ALWAYS AS (a * 3) STORED;
ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (b * 4) STORED;  -- errorALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (z * 4) STORED;  -- errorCREATE TABLE gtest27 (    a int,    b int GENERATED ALWAYS AS (a * 2) STORED);
ALTER TABLE gtest27 ALTER COLUMN a TYPE text;  -- errorALTER TABLE gtest27 ALTER COLUMN b TYPE numeric;
ALTER TABLE gtest27 ALTER COLUMN b TYPE boolean USING b <> 0;  -- errorALTER TABLE gtest27 ALTER COLUMN b DROP DEFAULT;  -- errorCREATE TABLE gtest26 (    a int PRIMARY KEY,    b int GENERATED ALWAYS AS (a * 2) STORED);
CREATE FUNCTION gtest_trigger_func() RETURNS trigger  LANGUAGE plpgsqlAS $$BEGIN  IF tg_op IN ('DELETE', 'UPDATE') THEN    RAISE INFO '%: %: old = %', TG_NAME, TG_WHEN, OLD;
  END IF;
  IF tg_op IN ('INSERT', 'UPDATE') THEN    RAISE INFO '%: %: new = %', TG_NAME, TG_WHEN, NEW;
  END IF;
  IF tg_op = 'DELETE' THEN    RETURN OLD;
  ELSE    RETURN NEW;
  END IF;
END$$;
CREATE TRIGGER gtest1 BEFORE DELETE OR UPDATE ON gtest26  FOR EACH ROW  WHEN (OLD.b < 0)  -- ok  EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2a BEFORE INSERT OR UPDATE ON gtest26  FOR EACH ROW  WHEN (NEW.b < 0)  -- error  EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2b BEFORE INSERT OR UPDATE ON gtest26  FOR EACH ROW  WHEN (NEW.* IS NOT NULL)  -- error  EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2 BEFORE INSERT ON gtest26  FOR EACH ROW  WHEN (NEW.a < 0)  EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest3 AFTER DELETE OR UPDATE ON gtest26  FOR EACH ROW  WHEN (OLD.b < 0)  -- ok  EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest4 AFTER INSERT OR UPDATE ON gtest26  FOR EACH ROW  WHEN (NEW.b < 0)  -- ok  EXECUTE PROCEDURE gtest_trigger_func();
DELETE FROM gtest26 WHERE a = -6;
DROP TRIGGER gtest1 ON gtest26;
DROP TRIGGER gtest2 ON gtest26;
DROP TRIGGER gtest3 ON gtest26;
CREATE FUNCTION gtest_trigger_func3() RETURNS trigger  LANGUAGE plpgsqlAS $$BEGIN  RAISE NOTICE 'OK';
  RETURN NEW;
END$$;
DROP TRIGGER gtest11 ON gtest26;
TRUNCATE gtest26;
CREATE FUNCTION gtest_trigger_func4() RETURNS trigger  LANGUAGE plpgsqlAS $$BEGIN  NEW.a = 10;
  NEW.b = 300;
  RETURN NEW;
END;
$$;
CREATE TABLE gtest28a (  a int,  b int,  c int,  x int GENERATED ALWAYS AS (b * 2) STORED);
ALTER TABLE gtest28a DROP COLUMN a;
CREATE TABLE gtest28b (LIKE gtest28a INCLUDING GENERATED);
CREATE SCHEMA lock_schema1;
SET search_path = lock_schema1;
CREATE ROLE regress_rol_lock1;
ALTER ROLE regress_rol_lock1 SET search_path = lock_schema1;
GRANT USAGE ON SCHEMA lock_schema1 TO regress_rol_lock1;
BEGIN TRANSACTION;
LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE;
LOCK lock_tbl1 IN ROW SHARE MODE;
LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN SHARE MODE;
LOCK lock_tbl1 IN SHARE ROW EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ROW SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE ROW EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE NOWAIT;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view1 IN EXCLUSIVE MODE;
select relname from pg_locks l, pg_class c where l.relation = c.oid and relname like '%lock_%' and mode = 'ExclusiveLock' order by relname;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view2 IN EXCLUSIVE MODE;
select relname from pg_locks l, pg_class c where l.relation = c.oid and relname like '%lock_%' and mode = 'ExclusiveLock' order by relname;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view3 IN EXCLUSIVE MODE;
select relname from pg_locks l, pg_class c where l.relation = c.oid and relname like '%lock_%' and mode = 'ExclusiveLock' order by relname;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view4 IN EXCLUSIVE MODE;
select relname from pg_locks l, pg_class c where l.relation = c.oid and relname like '%lock_%' and mode = 'ExclusiveLock' order by relname;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view5 IN EXCLUSIVE MODE;
select relname from pg_locks l, pg_class c where l.relation = c.oid and relname like '%lock_%' and mode = 'ExclusiveLock' order by relname;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view6 IN EXCLUSIVE MODE;
select relname from pg_locks l, pg_class c where l.relation = c.oid and relname like '%lock_%' and mode = 'ExclusiveLock' order by relname;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view2 IN EXCLUSIVE MODE;
ROLLBACK;
BEGIN TRANSACTION;
LOCK TABLE lock_view7 IN EXCLUSIVE MODE;
ROLLBACK;
CREATE TABLE lock_tbl2 (b BIGINT) INHERITS (lock_tbl1);
CREATE TABLE lock_tbl3 () INHERITS (lock_tbl2);
BEGIN TRANSACTION;
LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
ROLLBACK;
GRANT UPDATE ON TABLE lock_tbl1 TO regress_rol_lock1;
SET ROLE regress_rol_lock1;
BEGIN;
LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
ROLLBACK;
BEGIN;
LOCK TABLE ONLY lock_tbl1;
ROLLBACK;
RESET ROLE;
DROP VIEW lock_view3 CASCADE;
DROP SCHEMA lock_schema1 CASCADE;
DROP ROLE regress_rol_lock1;
RESET search_path;
::SELECT date(now())::text = current_date::text;
::::SELECT now()::timetz::text = current_time::text;
::SELECT now()::timetz(4)::text = current_time(4)::text;
::::SELECT now()::time::text = localtime::text;
::SELECT now()::time(3)::text = localtime(3)::text;
::SELECT length(current_timestamp::text) >= length(current_timestamp(0)::text);
::::SELECT now()::timestamp::text = localtimestamp::text;
SET search_path = 'notme';
SET search_path = 'pg_catalog';
RESET search_path;
explain (costs off)select count(*) from date_tbl  where f1 between '1997-01-01' and '1998-01-01';
explain (costs off)select count(*) from date_tbl  where f1 not between '1997-01-01' and '1998-01-01';
explain (costs off)select count(*) from date_tbl  where f1 between symmetric '1997-01-01' and '1998-01-01';
select count(*) from date_tbl  where f1 between symmetric '1997-01-01' and '1998-01-01';
explain (costs off)select count(*) from date_tbl  where f1 not between symmetric '1997-01-01' and '1998-01-01';
select count(*) from date_tbl  where f1 not between symmetric '1997-01-01' and '1998-01-01';
SET extra_float_digits = 0;
::::::::::::SELECT E'''1 \\''2'''::tsvector;
SELECT E'''1 \\''2''3'::tsvector;
SELECT E'''1 \\''2'' 3'::tsvector;
SELECT E'''1 \\''2'' '' 3'' 4 '::tsvector;
SELECT $$'\\as' ab\c ab\\c AB\\\c ab\\\\c$$::tsvector;
SELECT tsvectorin(tsvectorout($$'\\as' ab\c ab\\c AB\\\c ab\\\\c$$::tsvector));
::||SELECT 'a:3A b:2a'::tsvector || 'ba:1234 a:1B';
::::::::::SELECT E'''1 \\''2'''::tsquery;
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::SELECT E'1&(''2''&('' 4''&(\\|5 | ''6 \\'' !|&'')))'::tsquery;
SELECT $$'\\as'$$::tsquery;
::::::::::::::::SELECT 'a' < 'b & c'::tsquery as "true";
::SELECT 'a' > 'b & c'::tsquery as "false";
::SELECT 'a | f' < 'b & c'::tsquery as "false";
::SELECT 'a | ff' < 'b & c'::tsquery as "false";
::SELECT 'a | f | g' < 'b & c'::tsquery as "false";
::::::::&&SELECT 'foo & bar'::tsquery && 'asd';
::||SELECT 'foo & bar'::tsquery || 'asd & fg';
::||!!SELECT 'foo & bar'::tsquery || !!'asd & fg'::tsquery;
::&&SELECT 'foo & bar'::tsquery && 'asd | fg';
SELECT 'a' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b | d'::tsquery;
SELECT 'a & g' <-> 'b <-> d'::tsquery;
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca' as "true";
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:B' as "true";
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:A' as "true";
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:C' as "false";
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:CB' as "true";
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*C' as "false";
::@@SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*CB' as "true";
::@@SELECT 'a b:89  ca:23A,64b cb:80c d:34c'::tsvector @@ 'd:AC & c:*C' as "true";
::@@SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*C' as "true";
::@@SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*B' as "true";
::@@SELECT 'supernova'::tsvector @@ 'super'::tsquery AS "false";
::@@SELECT 'supeanova supernova'::tsvector @@ 'super'::tsquery AS "false";
::@@SELECT 'supeznova supernova'::tsvector @@ 'super'::tsquery AS "false";
::@@SELECT 'supernova'::tsvector @@ 'super:*'::tsquery AS "true";
::@@SELECT 'supeanova supernova'::tsvector @@ 'super:*'::tsquery AS "true";
::@@SELECT 'supeznova supernova'::tsvector @@ 'super:*'::tsquery AS "true";
@@SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 2' AS "true";
@@SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 2' AS "false";
@@SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 3' AS "false";
@@SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 3' AS "true";
@@SELECT to_tsvector('simple', '1 2 1 2') @@ '1 <3> 2' AS "true";
@@SELECT to_tsvector('simple', '1 2 11 3') @@ '1 <-> 3' AS "false";
@@SELECT to_tsvector('simple', '1 2 11 3') @@ '1:* <-> 3' AS "true";
@@SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> 2 <-> 3' AS "true";
@@SELECT to_tsvector('simple', '1 2 3 4') @@ '(1 <-> 2) <-> 3' AS "true";
@@SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> (2 <-> 3)' AS "true";
@@SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <2> (2 <-> 3)' AS "false";
@@SELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '(1 <-> 2) <-> 3' AS "true";
@@SELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '1 <-> 2 <-> 3' AS "true";
@@SELECT strip(to_tsvector('simple', '1 2 3 4')) @@ '1 <-> 2 <-> 3' AS "false";
@@select to_tsvector('simple', 'q x q y') @@ 'q <-> (x & y)' AS "false";
@@select to_tsvector('simple', 'q x') @@ 'q <-> (x | y <-> z)' AS "true";
@@select to_tsvector('simple', 'q y') @@ 'q <-> (x | y <-> z)' AS "false";
@@select to_tsvector('simple', 'q y z') @@ 'q <-> (x | y <-> z)' AS "true";
@@select to_tsvector('simple', 'q y x') @@ 'q <-> (x | y <-> z)' AS "false";
@@select to_tsvector('simple', 'q x y') @@ 'q <-> (x | y <-> z)' AS "true";
@@select to_tsvector('simple', 'q x') @@ '(x | y <-> z) <-> q' AS "false";
@@select to_tsvector('simple', 'x q') @@ '(x | y <-> z) <-> q' AS "true";
@@select to_tsvector('simple', 'x y q') @@ '(x | y <-> z) <-> q' AS "false";
@@select to_tsvector('simple', 'x y z') @@ '(x | y <-> z) <-> q' AS "false";
@@select to_tsvector('simple', 'x y z q') @@ '(x | y <-> z) <-> q' AS "true";
@@select to_tsvector('simple', 'y z q') @@ '(x | y <-> z) <-> q' AS "true";
@@select to_tsvector('simple', 'y y q') @@ '(x | y <-> z) <-> q' AS "false";
@@select to_tsvector('simple', 'y y q') @@ '(!x | y <-> z) <-> q' AS "true";
@@select to_tsvector('simple', 'x y q') @@ '(!x | y <-> z) <-> q' AS "true";
@@select to_tsvector('simple', 'y y q') @@ '(x | y <-> !z) <-> q' AS "true";
@@select to_tsvector('simple', 'x q') @@ '(x | y <-> !z) <-> q' AS "true";
@@select to_tsvector('simple', 'x q') @@ '(!x | y <-> z) <-> q' AS "false";
@@select to_tsvector('simple', 'z q') @@ '(!x | y <-> z) <-> q' AS "true";
@@select to_tsvector('simple', 'x y q y') @@ '!x <-> y' AS "true";
@@select to_tsvector('simple', 'x y q y') @@ '!foo' AS "true";
@@select to_tsvector('simple', '') @@ '!foo' AS "true";
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::@@SELECT 'a:1 b:2'::tsvector @@ 'a <-> b'::tsquery AS "true";
::@@SELECT 'a:1 b:2'::tsvector @@ 'a <0> b'::tsquery AS "false";
::@@SELECT 'a:1 b:2'::tsvector @@ 'a <1> b'::tsquery AS "true";
::@@SELECT 'a:1 b:2'::tsvector @@ 'a <2> b'::tsquery AS "false";
::@@SELECT 'a:1 b:3'::tsvector @@ 'a <-> b'::tsquery AS "false";
::@@SELECT 'a:1 b:3'::tsvector @@ 'a <0> b'::tsquery AS "false";
::@@SELECT 'a:1 b:3'::tsvector @@ 'a <1> b'::tsquery AS "false";
::@@SELECT 'a:1 b:3'::tsvector @@ 'a <2> b'::tsquery AS "true";
::@@SELECT 'a:1 b:3'::tsvector @@ 'a <3> b'::tsquery AS "false";
::@@SELECT 'a:1 b:3'::tsvector @@ 'a <0> a:*'::tsquery AS "true";
::::::::::::::::::::::::::::::SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel', NULL]);
::::::::::::::SELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship', NULL]);
::::::::::::::SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', ARRAY['a', 'zxc', NULL]);
::::::begin isolation level repeatable read;
set parallel_setup_cost=0;
set parallel_tuple_cost=0;
set min_parallel_table_scan_size=0;
set max_parallel_workers_per_gather=4;
explain (costs off) create table parallel_write as    select length(stringu1) from tenk1 group by length(stringu1);
explain (costs off) select length(stringu1) into parallel_write    from tenk1 group by length(stringu1);
select length(stringu1) into parallel_write    from tenk1 group by length(stringu1);
explain (costs off) create materialized view parallel_mat_view as    select length(stringu1) from tenk1 group by length(stringu1);
create materialized view parallel_mat_view as    select length(stringu1) from tenk1 group by length(stringu1);
drop materialized view parallel_mat_view;
prepare prep_stmt as select length(stringu1) from tenk1 group by length(stringu1);
explain (costs off) create table parallel_write as execute prep_stmt;
create table parallel_write as execute prep_stmt;
rollback;
CREATE TEMPORARY TABLE empsalary (    depname varchar,    empno bigint,    salary int,    enroll_date date);
SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;
SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1GROUP BY four, ten ORDER BY four, ten;
SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);
SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;
SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();
SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);
SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;
SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;
SELECT last_value(ten) OVER (PARTITION BY four), ten, four FROM	(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s	ORDER BY four, ten;
SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four	FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;
SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsumFROM tenk1 GROUP BY ten, two;
::SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +  sum(hundred) OVER (PARTITION BY four ORDER BY ten))::varchar AS cntsum  FROM tenk1 WHERE unique2 < 10;
SELECT * FROM(  SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,    count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum    FROM tenk1)subWHERE total <> fourcount + twosum;
SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsumFROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);
SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)FROM tenk1 s WHERE unique2 < 10;
SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
select ten,  sum(unique1) + sum(unique2) as res,  rank() over (order by sum(unique1) + sum(unique2)) as rankfrom tenk1group by ten order by ten;
explain (costs off)select first_value(max(x)) over (), y  from (select unique1 as x, ten+four as y from tenk1) ss  group by y;
SELECT sum(unique1) over (w range between current row and unbounded following),	unique1, fourFROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);
SELECT sum(unique1) over (w range between unbounded preceding and current row exclude current row),	unique1, fourFROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);
SELECT sum(unique1) over (w range between unbounded preceding and current row exclude group),	unique1, fourFROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);
SELECT sum(unique1) over (w range between unbounded preceding and current row exclude ties),	unique1, fourFROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);
SELECT first_value(unique1) over w,	nth_value(unique1, 2) over w AS nth_2,	last_value(unique1) over w, unique1, fourFROM tenk1 WHERE unique1 < 10WINDOW w AS (order by four range between current row and unbounded following);
::::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four desc range between 2::int8 preceding and 1::int2 preceding),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding exclude no others),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding exclude current row),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding exclude group),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 1::int2 preceding exclude ties),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 6::int2 following exclude ties),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (order by four range between 2::int8 preceding and 6::int2 following exclude group),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (partition by four order by unique1 range between 5::int8 preceding and 6::int2 following),	unique1, fourFROM tenk1 WHERE unique1 < 10;
::SELECT sum(unique1) over (partition by four order by unique1 range between 5::int8 preceding and 6::int2 following	exclude current row),unique1, fourFROM tenk1 WHERE unique1 < 10;
::select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following),	salary, enroll_date from empsalary;
::select sum(salary) over (order by enroll_date desc range between '1 year'::interval preceding and '1 year'::interval following),	salary, enroll_date from empsalary;
::select sum(salary) over (order by enroll_date desc range between '1 year'::interval following and '1 year'::interval following),	salary, enroll_date from empsalary;
::select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following	exclude current row), salary, enroll_date from empsalary;
::select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following	exclude group), salary, enroll_date from empsalary;
::select sum(salary) over (order by enroll_date range between '1 year'::interval preceding and '1 year'::interval following	exclude ties), salary, enroll_date from empsalary;
::select first_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude ties),	last_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following),	salary, enroll_date from empsalary;
::select first_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude ties),	last_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude ties),	salary, enroll_date from empsalary;
::select first_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude group),	last_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude group),	salary, enroll_date from empsalary;
::select first_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude current row),	last_value(salary) over(order by enroll_date range between unbounded preceding and '1 year'::interval following	exclude current row),	salary, enroll_date from empsalary;
select x, y,       first_value(y) over w,       last_value(y) over wfrom  (select x, x as y from generate_series(1,5) as x   union all select null, 42   union all select null, 43) sswindow w as  (order by x asc nulls first range between 2 preceding and 2 following);
select x, y,       first_value(y) over w,       last_value(y) over wfrom  (select x, x as y from generate_series(1,5) as x   union all select null, 42   union all select null, 43) sswindow w as  (order by x asc nulls last range between 2 preceding and 2 following);
select x, y,       first_value(y) over w,       last_value(y) over wfrom  (select x, x as y from generate_series(1,5) as x   union all select null, 42   union all select null, 43) sswindow w as  (order by x desc nulls first range between 2 preceding and 2 following);
select x, y,       first_value(y) over w,       last_value(y) over wfrom  (select x, x as y from generate_series(1,5) as x   union all select null, 42   union all select null, 43) sswindow w as  (order by x desc nulls last range between 2 preceding and 2 following);
::select x, last_value(x) over (order by x::smallint range between current row and 2147450884 following)from generate_series(32764, 32766) x;
::select x, last_value(x) over (order by x::smallint desc range between current row and 2147450885 following)from generate_series(-32766, -32764) x;
create temp table numerics(    id int,    f_float4 float4,    f_float8 float8,    f_numeric numeric);
insert into numerics values(0, '-infinity', '-infinity', '-1000'),  -- numeric type lacks infinities(1, -3, -3, -3),(2, -1, -1, -1),(3, 0, 0, 0),(4, 1.1, 1.1, 1.1),(5, 1.12, 1.12, 1.12),(6, 2, 2, 2),(7, 100, 100, 100),(8, 'infinity', 'infinity', '1000'),(9, 'NaN', 'NaN', 'NaN');
select id, f_float4, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float4 range between             1 preceding and 1 following);
select id, f_float4, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float4 range between             1 preceding and 1.1::float4 following);
select id, f_float4, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float4 range between             'inf' preceding and 'inf' following);
select id, f_float4, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float4 range between             1.1 preceding and 'NaN' following);  -- error, NaN disallowedselect id, f_float8, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float8 range between             1 preceding and 1 following);
select id, f_float8, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float8 range between             1 preceding and 1.1::float8 following);
select id, f_float8, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float8 range between             'inf' preceding and 'inf' following);
select id, f_float8, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_float8 range between             1.1 preceding and 'NaN' following);  -- error, NaN disallowedselect id, f_numeric, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_numeric range between             1 preceding and 1 following);
select id, f_numeric, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_numeric range between             1 preceding and 1.1::numeric following);
select id, f_numeric, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_numeric range between             1 preceding and 1.1::float8 following);  -- currently unsupportedselect id, f_numeric, first_value(id) over w, last_value(id) over wfrom numericswindow w as (order by f_numeric range between             1.1 preceding and 'NaN' following);  -- error, NaN disallowedcreate temp table datetimes(    id int,    f_time time,    f_timetz timetz,    f_interval interval,    f_timestamptz timestamptz,    f_timestamp timestamp);
select id, f_time, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_time range between             '70 min'::interval preceding and '2 hours'::interval following);
select id, f_time, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_time desc range between             '70 min' preceding and '2 hours' following);
select id, f_timetz, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_timetz range between             '70 min'::interval preceding and '2 hours'::interval following);
select id, f_timetz, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_timetz desc range between             '70 min' preceding and '2 hours' following);
select id, f_interval, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_interval range between             '1 year'::interval preceding and '1 year'::interval following);
select id, f_interval, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_interval desc range between             '1 year' preceding and '1 year' following);
select id, f_timestamptz, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_timestamptz range between             '1 year'::interval preceding and '1 year'::interval following);
select id, f_timestamptz, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_timestamptz desc range between             '1 year' preceding and '1 year' following);
select id, f_timestamp, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_timestamp range between             '1 year'::interval preceding and '1 year'::interval following);
select id, f_timestamp, first_value(id) over w, last_value(id) over wfrom datetimeswindow w as (order by f_timestamp desc range between             '1 year' preceding and '1 year' following);
select sum(salary) over (order by enroll_date, salary range between '1 year'::interval preceding and '2 years'::interval following	exclude ties), salary, enroll_date from empsalary;
::select sum(salary) over (range between '1 year'::interval preceding and '2 years'::interval following	exclude ties), salary, enroll_date from empsalary;
::select sum(salary) over (order by depname range between '1 year'::interval preceding and '2 years'::interval following	exclude ties), salary, enroll_date from empsalary;
::select max(enroll_date) over (order by salary range between '1 year'::interval preceding and '2 years'::interval following	exclude ties), salary, enroll_date from empsalary;
::select max(enroll_date) over (order by enroll_date range between '1 year'::interval preceding and '-2 years'::interval following	exclude ties), salary, enroll_date from empsalary;
WITH cte (x) AS (        SELECT * FROM generate_series(1, 35, 2)SELECT x, (sum(x) over w)FROM cteWINDOW w AS (ORDER BY x rows between 1 preceding and 1 following);
WITH cte (x) AS (        SELECT * FROM generate_series(1, 35, 2)SELECT x, (sum(x) over w)FROM cteWINDOW w AS (ORDER BY x range between 1 preceding and 1 following);
WITH cte (x) AS (        SELECT * FROM generate_series(1, 35, 2)SELECT x, (sum(x) over w)FROM cteWINDOW w AS (ORDER BY x groups between 1 preceding and 1 following);
WITH cte (x) AS (        select 1 union all select 1 union all select 1 union all        SELECT * FROM generate_series(5, 49, 2)SELECT x, (sum(x) over w)FROM cteWINDOW w AS (ORDER BY x rows between 1 preceding and 1 following);
WITH cte (x) AS (        select 1 union all select 1 union all select 1 union all        SELECT * FROM generate_series(5, 49, 2)SELECT x, (sum(x) over w)FROM cteWINDOW w AS (ORDER BY x range between 1 preceding and 1 following);
WITH cte (x) AS (        select 1 union all select 1 union all select 1 union all        SELECT * FROM generate_series(5, 49, 2)SELECT x, (sum(x) over w)FROM cteWINDOW w AS (ORDER BY x groups between 1 preceding and 1 following);
SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 UNION ALL SELECT * FROM tenk2)s LIMIT 0;
create temp table t1 (f1 int, f2 int8);
select f1, sum(f1) over (partition by f1                         range between 1 preceding and 1 following)from t1 where f1 = f2;  -- error, must have order byexplain (costs off)select f1, sum(f1) over (partition by f1 order by f2                         range between 1 preceding and 1 following)from t1 where f1 = f2;
select f1, sum(f1) over (partition by f1                         groups between 1 preceding and 1 following)from t1 where f1 = f2;  -- error, must have order byexplain (costs off)select f1, sum(f1) over (partition by f1 order by f2                         groups between 1 preceding and 1 following)from t1 where f1 = f2;
SELECT * FROM empsalary INNER JOIN tenk1 ON row_number() OVER (ORDER BY salary) < 10;
SELECT * FROM rank() OVER (ORDER BY random());
DELETE FROM empsalary WHERE (rank() OVER (ORDER BY random())) > 10;
DELETE FROM empsalary RETURNING rank() OVER (ORDER BY random());
SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM tenk1;
SELECT sum(salary), row_number() OVER (ORDER BY depname), sum(    sum(salary) FILTER (WHERE enroll_date > '2007-01-01')) FILTER (WHERE depname <> 'sales') OVER (ORDER BY depname DESC) AS "filtered_sum",    depnameFROM empsalary GROUP BY depname;
EXPLAIN (COSTS OFF)SELECT * FROM  (SELECT depname,          sum(salary) OVER (PARTITION BY depname) depsalary,          min(salary) OVER (PARTITION BY depname || 'A', depname) depminsalary   FROM empsalary) empWHERE depname = 'sales';
EXPLAIN (COSTS OFF)SELECT * FROM  (SELECT depname,          sum(salary) OVER (PARTITION BY enroll_date) enroll_salary,          min(salary) OVER (PARTITION BY depname) depminsalary   FROM empsalary) empWHERE depname = 'sales';
EXPLAIN (COSTS OFF)SELECT * FROM  (SELECT depname,          sum(salary) OVER (PARTITION BY depname order by empno) depsalary,          min(salary) OVER (PARTITION BY depname, empno order by enroll_date) depminsalary   FROM empsalary) empWHERE depname = 'sales';
EXPLAIN (COSTS OFF)SELECT  lead(1) OVER (PARTITION BY depname ORDER BY salary, enroll_date),  lag(1) OVER (PARTITION BY depname ORDER BY salary,enroll_date,empno)FROM empsalary;
CREATE FUNCTION nth_value_def(val anyelement, n integer = 1) RETURNS anyelement  LANGUAGE internal WINDOW IMMUTABLE STRICT AS 'window_nth_value';
::SELECT nth_value_def(n := 2, val := ten) OVER (PARTITION BY four), ten, four  FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
SELECT nth_value_def(ten) OVER (PARTITION BY four), ten, four  FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
CREATE FUNCTION logging_sfunc_nonstrict(text, anyelement) RETURNS text AS$$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION logging_msfunc_nonstrict(text, anyelement) RETURNS text AS$$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION logging_minvfunc_nonstrict(text, anyelement) RETURNS text AS$$ SELECT $1 || '-' || quote_nullable($2) $$LANGUAGE SQL IMMUTABLE;
CREATE AGGREGATE logging_agg_nonstrict (anyelement)	stype = text,	sfunc = logging_sfunc_nonstrict,	mstype = text,	msfunc = logging_msfunc_nonstrict,	minvfunc = logging_minvfunc_nonstrict);
CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement)	stype = text,	sfunc = logging_sfunc_nonstrict,	mstype = text,	msfunc = logging_msfunc_nonstrict,	minvfunc = logging_minvfunc_nonstrict,	initcond = 'I',	minitcond = 'MI');
CREATE FUNCTION logging_sfunc_strict(text, anyelement) RETURNS text AS$$ SELECT $1 || '*' || quote_nullable($2) $$LANGUAGE SQL STRICT IMMUTABLE;
CREATE FUNCTION logging_msfunc_strict(text, anyelement) RETURNS text AS$$ SELECT $1 || '+' || quote_nullable($2) $$LANGUAGE SQL STRICT IMMUTABLE;
CREATE FUNCTION logging_minvfunc_strict(text, anyelement) RETURNS text AS$$ SELECT $1 || '-' || quote_nullable($2) $$LANGUAGE SQL STRICT IMMUTABLE;
CREATE AGGREGATE logging_agg_strict (text)	stype = text,	sfunc = logging_sfunc_strict,	mstype = text,	msfunc = logging_msfunc_strict,	minvfunc = logging_minvfunc_strict);
CREATE AGGREGATE logging_agg_strict_initcond (anyelement)	stype = text,	sfunc = logging_sfunc_strict,	mstype = text,	msfunc = logging_msfunc_strict,	minvfunc = logging_minvfunc_strict,	initcond = 'I',	minitcond = 'MI');
::SELECT	p::text || ',' || i::text || ':' || COALESCE(v::text, 'NULL') AS row,	logging_agg_nonstrict(v) over wnd as nstrict,	logging_agg_nonstrict_initcond(v) over wnd as nstrict_init,	logging_agg_strict(v::text) over wnd as strict,	logging_agg_strict_initcond(v) over wnd as strict_initFROM (VALUES	(1, 1, NULL),	(1, 2, 'a'),	(1, 3, 'b'),	(1, 4, NULL),	(1, 5, NULL),	(1, 6, 'c'),	(2, 1, NULL),	(2, 2, 'x'),	(3, 1, 'z')) AS t(p, i, v)WINDOW wnd AS (PARTITION BY P ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)ORDER BY p, i;
::SELECT	p::text || ',' || i::text || ':' ||		CASE WHEN f THEN COALESCE(v::text, 'NULL') ELSE '-' END as row,	logging_agg_nonstrict(v) filter(where f) over wnd as nstrict_filt,	logging_agg_nonstrict_initcond(v) filter(where f) over wnd as nstrict_init_filt,	logging_agg_strict(v::text) filter(where f) over wnd as strict_filt,	logging_agg_strict_initcond(v) filter(where f) over wnd as strict_init_filtFROM (VALUES	(1, 1, true,  NULL),	(1, 2, false, 'a'),	(1, 3, true,  'b'),	(1, 4, false, NULL),	(1, 5, false, NULL),	(1, 6, false, 'c'),	(2, 1, false, NULL),	(2, 2, true,  'x'),	(3, 1, true,  'z')) AS t(p, i, f, v)WINDOW wnd AS (PARTITION BY p ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)ORDER BY p, i;
::SELECT	i::text || ':' || COALESCE(v::text, 'NULL') as row,	logging_agg_strict(v::text)		over wnd as inverse,	logging_agg_strict(v::text || CASE WHEN random() < 0 then '?' ELSE '' END)		over wnd as noinverseFROM (VALUES	(1, 'a'),	(2, 'b'),	(3, 'c')) AS t(i, v)WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)ORDER BY i;
::SELECT	i::text || ':' || COALESCE(v::text, 'NULL') as row,	logging_agg_strict(v::text) filter(where true)		over wnd as inverse,	logging_agg_strict(v::text) filter(where random() >= 0)		over wnd as noinverseFROM (VALUES	(1, 'a'),	(2, 'b'),	(3, 'c')) AS t(i, v)WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)ORDER BY i;
::SELECT	logging_agg_strict(v::text) OVER wndFROM (VALUES	(1, 'a'),	(2, 'b'),	(3, 'c')) AS t(i, v)WINDOW wnd AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)ORDER BY i;
CREATE FUNCTION sum_int_randrestart_minvfunc(int4, int4) RETURNS int4 AS$$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$LANGUAGE SQL STRICT;
CREATE AGGREGATE sum_int_randomrestart (int4)	stype = int4,	sfunc = int4pl,	mstype = int4,	msfunc = int4pl,	minvfunc = sum_int_randrestart_minvfunc);
WITHvs AS (	SELECT i, (random() * 100)::int4 AS v	FROM generate_series(1, 100) AS i),sum_following AS (	SELECT i, SUM(v) OVER		(ORDER BY i DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s	FROM vsSELECT DISTINCT	sum_following.s = sum_int_randomrestart(v) OVER fwd AS eq1,	-sum_following.s = sum_int_randomrestart(-v) OVER fwd AS eq2,	100*3+(vs.i-1)*3 = length(logging_agg_nonstrict(''::text) OVER fwd) AS eq3FROM vsJOIN sum_following ON sum_following.i = vs.iWINDOW fwd AS (	ORDER BY vs.i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING);
::SELECT i,AVG(v::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,AVG(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,AVG(v::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,AVG(v::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1.5),(2,2.5),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,AVG(v::interval) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,'1 sec'),(2,'2 sec'),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::money) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,'1.10'),(2,'2.20'),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::interval) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,'1 sec'),(2,'2 sec'),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1.1),(2,2.2),(3,NULL),(4,NULL)) t(i,v);
::SELECT SUM(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1.01),(2,2),(3,3)) v(i,n);
SELECT i,COUNT(v) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
SELECT i,COUNT(*) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT VAR_POP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_POP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_POP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_POP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_SAMP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_SAMP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_SAMP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VAR_SAMP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VARIANCE(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VARIANCE(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VARIANCE(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT VARIANCE(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT STDDEV_POP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_POP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_POP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_POP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_SAMP(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_SAMP(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_SAMP(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV_SAMP(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(1,NULL),(2,600),(3,470),(4,170),(5,430),(6,300)) r(i,n);
::SELECT STDDEV(n::bigint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT STDDEV(n::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT STDDEV(n::smallint) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT STDDEV(n::numeric) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)  FROM (VALUES(0,NULL),(1,600),(2,470),(3,170),(4,430),(5,300)) r(i,n);
::SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);
::SELECT i,SUM(v::int) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)  FROM (VALUES(1,1),(2,2),(3,3),(4,4)) t(i,v);
SELECT a, b,       SUM(b) OVER(ORDER BY A ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)FROM (VALUES(1,1::numeric),(2,2),(3,'NaN'),(4,3),(5,4)) t(a,b);
::SELECT to_char(SUM(n::float8) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING),'999999999999999999999D9')  FROM (VALUES(1,1e20),(2,1)) n(i,n);
SELECT i, b, bool_and(b) OVER w, bool_or(b) OVER w  FROM (VALUES (1,true), (2,true), (3,false), (4,false), (5,true)) v(i,b)  WINDOW w AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING);
SELECT array_agg(i) OVER w  FROM generate_series(1,5) iWINDOW w AS (ORDER BY i ROWS BETWEEN (('foo' < 'foobar')::integer) PRECEDING AND CURRENT ROW);
CREATE FUNCTION pg_temp.f(group_size BIGINT) RETURNS SETOF integer[]AS $$    SELECT array_agg(s) OVER w      FROM generate_series(1,5) s    WINDOW w AS (ORDER BY s ROWS BETWEEN CURRENT ROW AND GROUP_SIZE FOLLOWING)$$ LANGUAGE SQL STABLE;
EXPLAIN (costs off) SELECT * FROM pg_temp.f(2);
SELECT * FROM pg_temp.f(2);
SELECT 1 AS two UNION ALL SELECT 2;
SELECT 1 AS two UNION ALL SELECT 1;
SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;
::SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;
::SELECT 1.0::float8 AS two UNION ALL SELECT 1 ORDER BY 1;
::SELECT 1.1::float8 AS two UNION SELECT 2 UNION SELECT 2.0::float8 ORDER BY 1;
SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;
SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;
SELECT f1 AS five FROM FLOAT8_TBLUNIONSELECT f1 FROM FLOAT8_TBLORDER BY 1;
SELECT f1 AS ten FROM FLOAT8_TBLUNION ALLSELECT f1 FROM FLOAT8_TBL;
SELECT f1 AS nine FROM FLOAT8_TBLUNIONSELECT f1 FROM INT4_TBLORDER BY 1;
SELECT f1 AS ten FROM FLOAT8_TBLUNION ALLSELECT f1 FROM INT4_TBL;
SELECT f1 AS five FROM FLOAT8_TBL  WHERE f1 BETWEEN -1e6 AND 1e6UNIONSELECT f1 FROM INT4_TBL  WHERE f1 BETWEEN 0 AND 1000000ORDER BY 1;
SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBLUNIONSELECT f1 FROM CHAR_TBLORDER BY 1;
SELECT f1 AS three FROM VARCHAR_TBLUNIONSELECT CAST(f1 AS varchar) FROM CHAR_TBLORDER BY 1;
SELECT f1 AS eight FROM VARCHAR_TBLUNION ALLSELECT f1 FROM CHAR_TBL;
SELECT f1 AS five FROM TEXT_TBLUNIONSELECT f1 FROM VARCHAR_TBLUNIONSELECT TRIM(TRAILING FROM f1) FROM CHAR_TBLORDER BY 1;
SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;
SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;
SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;
SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;
(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;
(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;
(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;
(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;
set enable_hashagg to on;
explain (costs off)select count(*) from  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
explain (costs off)select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
set enable_hashagg to off;
explain (costs off)select count(*) from  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
explain (costs off)select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
reset enable_hashagg;
SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;
SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;
(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;
SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));
(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tblORDER BY q2,q1;
SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;
select union select;
select intersect select;
select except select;
set enable_hashagg = true;
set enable_sort = false;
explain (costs off)select from generate_series(1,5) union select from generate_series(1,3);
explain (costs off)select from generate_series(1,5) intersect select from generate_series(1,3);
select from generate_series(1,5) union select from generate_series(1,3);
select from generate_series(1,5) union all select from generate_series(1,3);
select from generate_series(1,5) intersect select from generate_series(1,3);
select from generate_series(1,5) intersect all select from generate_series(1,3);
select from generate_series(1,5) except select from generate_series(1,3);
select from generate_series(1,5) except all select from generate_series(1,3);
set enable_hashagg = false;
set enable_sort = true;
explain (costs off)select from generate_series(1,5) union select from generate_series(1,3);
explain (costs off)select from generate_series(1,5) intersect select from generate_series(1,3);
select from generate_series(1,5) union select from generate_series(1,3);
select from generate_series(1,5) union all select from generate_series(1,3);
select from generate_series(1,5) intersect select from generate_series(1,3);
select from generate_series(1,5) intersect all select from generate_series(1,3);
select from generate_series(1,5) except select from generate_series(1,3);
select from generate_series(1,5) except all select from generate_series(1,3);
reset enable_hashagg;
reset enable_sort;
SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) aUNIONSELECT b.f1 FROM (SELECT f1 FROM varchar_tbl) bORDER BY 1;
::SELECT '3.4'::numeric UNION SELECT 'foo';
||set enable_seqscan = off;
set enable_indexscan = on;
set enable_bitmapscan = off;
explain (costs off) SELECT * FROM (SELECT a || b AS ab FROM t1  UNION ALL  SELECT * FROM t2) t WHERE ab = 'ab';
explain (costs off) SELECT * FROM (SELECT a || b AS ab FROM t1  UNION  SELECT * FROM t2) t WHERE ab = 'ab';
ALTER TABLE t1c INHERIT t1;
CREATE TEMP TABLE t2c (primary key (ab)) INHERITS (t2);
||set enable_seqscan = on;
set enable_indexonlyscan = off;
explain (costs off)  SELECT * FROM  (SELECT a || b AS ab FROM t1   UNION ALL   SELECT ab FROM t2) t  ORDER BY 1 LIMIT 8;
||  SELECT * FROM  (SELECT a || b AS ab FROM t1   UNION ALL   SELECT ab FROM t2) t  ORDER BY 1 LIMIT 8;
reset enable_seqscan;
reset enable_indexscan;
reset enable_bitmapscan;
create table events_child () inherits (events);
explain (costs off)select event_id from (select event_id from events       union all       select event_id from other_events) ss order by event_id;
drop table events_child, events, other_events;
reset enable_indexonlyscan;
explain (costs off) SELECT * FROM  (SELECT 1 AS t, * FROM tenk1 a   UNION ALL   SELECT 2 AS t, * FROM tenk1 b) c WHERE t = 2;
explain (costs off)SELECT * FROM  (SELECT 1 AS t, 2 AS x   UNION   SELECT 2 AS t, 4 AS x) ssWHERE x < 4ORDER BY x;
SELECT * FROM  (SELECT 1 AS t, 2 AS x   UNION   SELECT 2 AS t, 4 AS x) ssWHERE x < 4ORDER BY x;
explain (costs off)SELECT * FROM  (SELECT 1 AS t, generate_series(1,10) AS x   UNION   SELECT 2 AS t, 4 AS x) ssWHERE x < 4ORDER BY x;
SELECT * FROM  (SELECT 1 AS t, generate_series(1,10) AS x   UNION   SELECT 2 AS t, 4 AS x) ssWHERE x < 4ORDER BY x;
explain (costs off)SELECT * FROM  (SELECT 1 AS t, (random()*3)::int AS x   UNION   SELECT 2 AS t, 4 AS x) ssWHERE x > 3ORDER BY x;
::SELECT * FROM  (SELECT 1 AS t, (random()*3)::int AS x   UNION   SELECT 2 AS t, 4 AS x) ssWHERE x > 3ORDER BY x;
explain (costs off)select distinct q1 from  (select distinct * from int8_tbl i81   union all   select distinct * from int8_tbl i82) sswhere q2 = q2;
select distinct q1 from  (select distinct * from int8_tbl i81   union all   select distinct * from int8_tbl i82) sswhere q2 = q2;
explain (costs off)select distinct q1 from  (select distinct * from int8_tbl i81   union all   select distinct * from int8_tbl i82) sswhere -q1 = q2;
select distinct q1 from  (select distinct * from int8_tbl i81   union all   select distinct * from int8_tbl i82) sswhere -q1 = q2;
create function expensivefunc(int) returns intlanguage plpgsql immutable strict cost 10000as $$begin return $1; end$$;
analyze t3;
explain (costs off)select * from  (select * from t3 a union all select * from t3 b) ss  join int4_tbl on f1 = expensivefunc(x);
select * from  (select * from t3 a union all select * from t3 b) ss  join int4_tbl on f1 = expensivefunc(x);
drop function expensivefunc(int);
explain (costs off)select * from  (select *, 0 as x from int8_tbl a   union all   select *, 1 as x from int8_tbl b) sswhere (x = 0) or (q1 >= q2 and q1 <= q2);
select * from  (select *, 0 as x from int8_tbl a   union all   select *, 1 as x from int8_tbl b) sswhere (x = 0) or (q1 >= q2 and q1 <= q2);
CREATE TABLE PATH_TBL (f1 path);
INSERT INTO PATH_TBL VALUES ('((10,20))');	-- Only one pointINSERT INTO PATH_TBL VALUES ('[ 11,12,13,14 ]');
SELECT num_nonnulls(NULL);
SELECT num_nonnulls(NULL::text);
SELECT num_nonnulls(NULL::text, NULL::int);
SELECT num_nonnulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL);
SELECT num_nonnulls(VARIADIC '{1,2,NULL,3}'::int[]);
SELECT num_nonnulls(VARIADIC '{"1","2","3","4"}'::text[]);
SELECT num_nonnulls(VARIADIC ARRAY(SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) i));
SELECT num_nulls(NULL);
SELECT num_nulls(NULL::text);
SELECT num_nulls(NULL::text, NULL::int);
SELECT num_nulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL);
SELECT num_nulls(VARIADIC '{1,2,NULL,3}'::int[]);
SELECT num_nulls(VARIADIC '{"1","2","3","4"}'::text[]);
SELECT num_nulls(VARIADIC ARRAY(SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) i));
SELECT num_nonnulls(VARIADIC NULL::text[]);
SELECT num_nonnulls(VARIADIC '{}'::int[]);
SELECT num_nulls(VARIADIC NULL::text[]);
SELECT num_nulls(VARIADIC '{}'::int[]);
CREATE FUNCTION my_int_eq(int, int) RETURNS bool  LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE  AS $$int4eq$$;
EXPLAIN (COSTS OFF)SELECT * FROM tenk1 a JOIN tenk1 b ON a.unique1 = b.unique1WHERE my_int_eq(a.unique2, 42);
ALTER FUNCTION my_int_eq(int, int) SUPPORT test_support_func;
EXPLAIN (COSTS OFF)SELECT * FROM tenk1 a JOIN tenk1 b ON a.unique1 = b.unique1WHERE my_int_eq(a.unique2, 42);
CREATE FUNCTION my_gen_series(int, int) RETURNS SETOF integer  LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE  AS $$generate_series_int4$$  SUPPORT test_support_func;
EXPLAIN (COSTS OFF)SELECT * FROM tenk1 a JOIN my_gen_series(1,1000) g ON a.unique1 = g;
EXPLAIN (COSTS OFF)SELECT * FROM tenk1 a JOIN my_gen_series(1,10) g ON a.unique1 = g;
CREATE TABLE indtoasttest(descr text, cnt int DEFAULT 0, f1 text, f2 text);
INSERT INTO indtoasttest(descr, f1, f2) VALUES('one-compressed,one-null', NULL, repeat('1234567890',1000));
INSERT INTO indtoasttest(descr, f1, f2) VALUES('one-toasted,one-null', NULL, repeat('1234567890',50000));
::SELECT descr, substring(make_tuple_indirect(indtoasttest)::text, 1, 200) FROM indtoasttest;
UPDATE indtoasttest SET cnt = cnt +1 RETURNING substring(indtoasttest::text, 1, 200);
UPDATE indtoasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(indtoasttest::text, 1, 200);
||UPDATE indtoasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(indtoasttest::text, 1, 200);
||UPDATE indtoasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(indtoasttest::text, 1, 200);
::SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
VACUUM FREEZE indtoasttest;
::SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
CREATE FUNCTION update_using_indirect()        RETURNS trigger        LANGUAGE plpgsql AS $$BEGIN    NEW := make_tuple_indirect(NEW);
    RETURN NEW;
END$$;
CREATE TRIGGER indtoasttest_update_indirect        BEFORE INSERT OR UPDATE        ON indtoasttest        FOR EACH ROW        EXECUTE PROCEDURE update_using_indirect();
UPDATE indtoasttest SET cnt = cnt +1 RETURNING substring(indtoasttest::text, 1, 200);
UPDATE indtoasttest SET cnt = cnt +1, f1 = f1 RETURNING substring(indtoasttest::text, 1, 200);
||UPDATE indtoasttest SET cnt = cnt +1, f1 = f1||'' RETURNING substring(indtoasttest::text, 1, 200);
||UPDATE indtoasttest SET cnt = cnt +1, f1 = '-'||f1||'-' RETURNING substring(indtoasttest::text, 1, 200);
INSERT INTO indtoasttest(descr, f1, f2) VALUES('one-toasted,one-null, via indirect', repeat('1234567890',30000), NULL);
::SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
VACUUM FREEZE indtoasttest;
::SELECT substring(indtoasttest::text, 1, 200) FROM indtoasttest;
DROP FUNCTION update_using_indirect();
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
::SELECT COUNT(*) FROM pg_enum WHERE enumtypid = 'rainbow'::regtype;
::::CREATE TYPE planets AS ENUM ( 'venus', 'earth', 'mars' );
SELECT enumlabel, enumsortorderFROM pg_enumWHERE enumtypid = 'planets'::regtypeORDER BY 2;
ALTER TYPE planets ADD VALUE 'uranus';
SELECT enumlabel, enumsortorderFROM pg_enumWHERE enumtypid = 'planets'::regtypeORDER BY 2;
ALTER TYPE planets ADD VALUE 'mercury' BEFORE 'venus';
ALTER TYPE planets ADD VALUE 'saturn' BEFORE 'uranus';
ALTER TYPE planets ADD VALUE 'jupiter' AFTER 'mars';
ALTER TYPE planets ADD VALUE 'neptune' AFTER 'uranus';
SELECT enumlabel, enumsortorderFROM pg_enumWHERE enumtypid = 'planets'::regtypeORDER BY 2;
SELECT enumlabel, enumsortorderFROM pg_enumWHERE enumtypid = 'planets'::regtypeORDER BY enumlabel::planets;
ALTER TYPE planets ADD VALUE  'plutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutopluto';
ALTER TYPE planets ADD VALUE 'pluto' AFTER 'zeus';
ALTER TYPE planets ADD VALUE 'mercury';
ALTER TYPE planets ADD VALUE IF NOT EXISTS 'mercury';
SELECT enum_last(NULL::planets);
ALTER TYPE planets ADD VALUE IF NOT EXISTS 'pluto';
SELECT enum_last(NULL::planets);
create type insenum as enum ('L1', 'L2');
alter type insenum add value 'i1' before 'L2';
alter type insenum add value 'i2' before 'L2';
alter type insenum add value 'i3' before 'L2';
alter type insenum add value 'i4' before 'L2';
alter type insenum add value 'i5' before 'L2';
alter type insenum add value 'i6' before 'L2';
alter type insenum add value 'i7' before 'L2';
alter type insenum add value 'i8' before 'L2';
alter type insenum add value 'i9' before 'L2';
alter type insenum add value 'i10' before 'L2';
alter type insenum add value 'i11' before 'L2';
alter type insenum add value 'i12' before 'L2';
alter type insenum add value 'i13' before 'L2';
alter type insenum add value 'i14' before 'L2';
alter type insenum add value 'i15' before 'L2';
alter type insenum add value 'i16' before 'L2';
alter type insenum add value 'i17' before 'L2';
alter type insenum add value 'i18' before 'L2';
alter type insenum add value 'i19' before 'L2';
alter type insenum add value 'i20' before 'L2';
alter type insenum add value 'i21' before 'L2';
alter type insenum add value 'i22' before 'L2';
alter type insenum add value 'i23' before 'L2';
alter type insenum add value 'i24' before 'L2';
alter type insenum add value 'i25' before 'L2';
alter type insenum add value 'i26' before 'L2';
alter type insenum add value 'i27' before 'L2';
alter type insenum add value 'i28' before 'L2';
alter type insenum add value 'i29' before 'L2';
alter type insenum add value 'i30' before 'L2';
SELECT enumlabel,       case when enumsortorder > 20 then null else enumsortorder end as soFROM pg_enumWHERE enumtypid = 'insenum'::regtypeORDER BY enumsortorder;
CREATE TABLE enumtest (col rainbow);
COPY enumtest FROM stdin;
bluepurple\.SELECT * FROM enumtest;
SELECT * FROM enumtest WHERE col <> 'orange' ORDER BY col;
::::SELECT 'red'::rainbow::text || 'hithere';
::SELECT 'red'::text::rainbow = 'red'::rainbow;
SET enable_seqscan = off;
SET enable_bitmapscan = off;
CREATE UNIQUE INDEX enumtest_btree ON enumtest USING btree (col);
SELECT * FROM enumtest WHERE col <> 'orange' ORDER BY col;
CREATE INDEX enumtest_hash ON enumtest USING hash (col);
RESET enable_seqscan;
RESET enable_bitmapscan;
CREATE DOMAIN rgb AS rainbow CHECK (VALUE IN ('red', 'green', 'blue'));
::::::::SELECT 'purple'::rainbow::rgb;
DROP DOMAIN rgb;
::SELECT '{red,green,blue}'::rainbow[];
::SELECT ('{red,green,blue}'::rainbow[])[2];
::SELECT 'red' = ANY ('{red,green,blue}'::rainbow[]);
::SELECT 'yellow' = ANY ('{red,green,blue}'::rainbow[]);
SELECT 'red' = ALL ('{red,green,blue}'::rainbow[]);
SELECT 'red' = ALL ('{red,red}'::rainbow[]);
SELECT enum_first(NULL::rainbow);
::SELECT enum_range(NULL::rainbow);
::::SELECT enum_range(NULL, 'green'::rainbow);
::SELECT enum_range('orange'::rainbow, NULL);
SELECT enum_range(NULL::rainbow, NULL);
CREATE FUNCTION echo_me(anyenum) RETURNS text AS $$BEGINRETURN $1::text || 'omg';
END$$ LANGUAGE plpgsql;
::CREATE FUNCTION echo_me(rainbow) RETURNS text AS $$BEGINRETURN $1::text || 'wtf';
END$$ LANGUAGE plpgsql;
::DROP FUNCTION echo_me(anyenum);
DROP FUNCTION echo_me(rainbow);
CREATE TABLE enumtest_parent (id rainbow PRIMARY KEY);
CREATE TABLE enumtest_child (parent rainbow REFERENCES enumtest_parent);
INSERT INTO enumtest_child VALUES ('blue');  -- failDELETE FROM enumtest_parent;  -- failCREATE TYPE bogus AS ENUM('good', 'bad', 'ugly');
CREATE TABLE enumtest_bogus_child(parent bogus REFERENCES enumtest_parent);
DROP TYPE bogus;
ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
SELECT enumlabel, enumsortorderFROM pg_enumWHERE enumtypid = 'rainbow'::regtypeORDER BY 2;
ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
ALTER TYPE rainbow RENAME VALUE 'blue' TO 'green';
CREATE TYPE bogus AS ENUM('good');
BEGIN;
ALTER TYPE bogus ADD VALUE 'new';
SAVEPOINT x;
::SELECT 'new'::bogus;  -- unsafeROLLBACK TO x;
SELECT enum_first(null::bogus);  -- safeSELECT enum_last(null::bogus);  -- unsafeROLLBACK TO x;
SELECT enum_range(null::bogus);  -- unsafeROLLBACK TO x;
COMMIT;
::SELECT 'new'::bogus;  -- now safeSELECT enumlabel, enumsortorderFROM pg_enumWHERE enumtypid = 'bogus'::regtypeORDER BY 2;
BEGIN;
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogon ADD VALUE 'bad';
::ROLLBACK;
BEGIN;
ALTER TYPE bogus RENAME VALUE 'good' to 'bad';
::ROLLBACK;
DROP TYPE bogus;
BEGIN;
CREATE TYPE bogus AS ENUM('good','bad','ugly');
ALTER TYPE bogus RENAME TO bogon;
select enum_range(null::bogon);
ROLLBACK;
BEGIN;
CREATE TYPE bogus AS ENUM('good');
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogon ADD VALUE 'bad';
ALTER TYPE bogon ADD VALUE 'ugly';
select enum_range(null::bogon);  -- failsROLLBACK;
DROP TYPE rainbow;
SELECT * FROM pg_enum WHERE NOT EXISTS  (SELECT 1 FROM pg_type WHERE pg_type.oid = enumtypid);
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_priv_group1;
DROP ROLE IF EXISTS regress_priv_group2;
DROP ROLE IF EXISTS regress_priv_user1;
DROP ROLE IF EXISTS regress_priv_user2;
DROP ROLE IF EXISTS regress_priv_user3;
DROP ROLE IF EXISTS regress_priv_user4;
DROP ROLE IF EXISTS regress_priv_user5;
DROP ROLE IF EXISTS regress_priv_user6;
RESET client_min_messages;
CREATE USER regress_priv_user1;
CREATE USER regress_priv_user2;
CREATE USER regress_priv_user3;
CREATE USER regress_priv_user4;
CREATE USER regress_priv_user5;
CREATE USER regress_priv_user5;	-- duplicateCREATE GROUP regress_priv_group1;
CREATE GROUP regress_priv_group2 WITH USER regress_priv_user1, regress_priv_user2;
ALTER GROUP regress_priv_group1 ADD USER regress_priv_user4;
ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;	-- duplicateALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
GRANT regress_priv_group2 TO regress_priv_user4 WITH ADMIN OPTION;
SET SESSION AUTHORIZATION regress_priv_user1;
DELETE FROM atest1;
TRUNCATE atest1;
BEGIN;
LOCK atest1 IN ACCESS EXCLUSIVE MODE;
COMMIT;
REVOKE ALL ON atest1 FROM PUBLIC;
GRANT ALL ON atest1 TO regress_priv_user2;
GRANT SELECT ON atest1 TO regress_priv_user3, regress_priv_user4;
GRANT SELECT ON atest2 TO regress_priv_user2;
GRANT UPDATE ON atest2 TO regress_priv_user3;
GRANT INSERT ON atest2 TO regress_priv_user4;
GRANT TRUNCATE ON atest2 TO regress_priv_user5;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT * FROM atest1; -- okSELECT * FROM atest2; -- okINSERT INTO atest1 VALUES (2, 'two'); -- okINSERT INTO atest2 VALUES ('foo', true); -- failINSERT INTO atest1 SELECT 1, b FROM atest1; -- okUPDATE atest1 SET a = 1 WHERE a = 2; -- okUPDATE atest2 SET col2 = NOT col2; -- failSELECT * FROM atest1 FOR UPDATE; -- okSELECT * FROM atest2 FOR UPDATE; -- failDELETE FROM atest2; -- failTRUNCATE atest2; -- failBEGIN;
LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- failCOMMIT;
COPY atest2 FROM stdin; -- failGRANT ALL ON atest1 TO PUBLIC; -- failSELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
SET SESSION AUTHORIZATION regress_priv_user3;
SELECT * FROM atest1; -- okSELECT * FROM atest2; -- failINSERT INTO atest1 VALUES (2, 'two'); -- failINSERT INTO atest2 VALUES ('foo', true); -- failINSERT INTO atest1 SELECT 1, b FROM atest1; -- failUPDATE atest1 SET a = 1 WHERE a = 2; -- failUPDATE atest2 SET col2 = NULL; -- okUPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5; -- okSELECT * FROM atest1 FOR UPDATE; -- failSELECT * FROM atest2 FOR UPDATE; -- failDELETE FROM atest2; -- failTRUNCATE atest2; -- failBEGIN;
LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- okCOMMIT;
COPY atest2 FROM stdin; -- failSELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
SET SESSION AUTHORIZATION regress_priv_user4;
COPY atest2 FROM stdin; -- okbar	true\.SELECT * FROM atest1; -- okSET SESSION AUTHORIZATION regress_priv_user1;
CREATE INDEX ON atest12 (a);
CREATE INDEX ON atest12 (abs(a));
VACUUM ANALYZE atest12;
CREATE FUNCTION leak(integer,integer) RETURNS boolean  AS $$begin return $1 < $2; end$$  LANGUAGE plpgsql immutable;
CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,                     restrict = scalarltsel);
CREATE VIEW atest12v AS  SELECT * FROM atest12 WHERE b <<< 5;
CREATE VIEW atest12sbv WITH (security_barrier=true) AS  SELECT * FROM atest12 WHERE b <<< 5;
GRANT SELECT ON atest12v TO PUBLIC;
GRANT SELECT ON atest12sbv TO PUBLIC;
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y  WHERE x.a = y.b and abs(y.a) <<< 5;
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
SET SESSION AUTHORIZATION regress_priv_user2;
CREATE FUNCTION leak2(integer,integer) RETURNS boolean  AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$  LANGUAGE plpgsql immutable;
CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,                     restrict = scalargtsel);
EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y  WHERE x.a = y.b and abs(y.a) <<< 5;
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y  WHERE x.a = y.b and abs(y.a) <<< 5;
SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT (a, b) ON atest12 TO PUBLIC;
SET SESSION AUTHORIZATION regress_priv_user2;
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y  WHERE x.a = y.b and abs(y.a) <<< 5;
DROP FUNCTION leak2(integer, integer) CASCADE;
SET SESSION AUTHORIZATION regress_priv_user3;
GRANT DELETE ON atest3 TO GROUP regress_priv_group2;
SET SESSION AUTHORIZATION regress_priv_user1;
SELECT * FROM atest3; -- failDELETE FROM atest3; -- okSET SESSION AUTHORIZATION regress_priv_user3;
CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok/* The next *should* fail, but it's not implemented that way yet. */CREATE VIEW atestv2 AS SELECT * FROM atest2;
CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok/* Empty view is a corner case that failed in 9.2. */CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- okSELECT * FROM atestv1; -- okSELECT * FROM atestv2; -- failGRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
GRANT SELECT ON atestv2 TO regress_priv_user2;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT * FROM atestv1; -- okSELECT * FROM atestv2; -- failSELECT * FROM atestv3; -- okSELECT * FROM atestv0; -- failselect * from  ((select a.q1 as x from int8_tbl a offset 0)   union all   (select b.q2 as x from int8_tbl b offset 0)) sswhere false;
set constraint_exclusion = on;
select * from  ((select a.q1 as x, random() from int8_tbl a where q1 > 0)   union all   (select b.q2 as x, random() from int8_tbl b where q2 > 0)) sswhere x < 0;
reset constraint_exclusion;
CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested viewSELECT * FROM atestv4; -- okGRANT SELECT ON atestv4 TO regress_priv_user2;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT * FROM atestv3; -- failSELECT * FROM atestv4; -- ok (even though regress_priv_user2 cannot access underlying atestv3)SELECT * FROM atest2; -- okSELECT * FROM atestv2; -- fail (even though regress_priv_user2 can access underlying atest2)SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regress_priv_user4;
GRANT ALL (one) ON atest5 TO regress_priv_user3;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT * FROM atest5; -- failSELECT one FROM atest5; -- okCOPY atest5 (one) TO stdout; -- okSELECT two FROM atest5; -- failCOPY atest5 (two) TO stdout; -- failSELECT atest5 FROM atest5; -- failCOPY atest5 (one,two) TO stdout; -- failSELECT 1 FROM atest5; -- okSELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- okSELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- failSELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- failSELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- failSELECT 1 FROM atest5 WHERE two = 2; -- failSELECT * FROM atest1, atest5; -- failSELECT atest1.* FROM atest1, atest5; -- okSELECT atest1.*,atest5.one FROM atest1, atest5; -- okSELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- failSELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- okSELECT one, two FROM atest5; -- failSET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT (one,two) ON atest6 TO regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail stillSET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT (two) ON atest5 TO regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok nowINSERT INTO atest5 (two) VALUES (3); -- okCOPY atest5 FROM stdin; -- failCOPY atest5 (two) FROM stdin; -- ok\.INSERT INTO atest5 (three) VALUES (4); -- failINSERT INTO atest5 VALUES (5,5,5); -- failUPDATE atest5 SET three = 10; -- okUPDATE atest5 SET one = 8; -- failUPDATE atest5 SET three = 5, one = 2; -- failINSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10;
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.three;
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.one;
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.one;
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.three;
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set one = 8; -- fails (due to UPDATE)INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UPDATE set three = 10; -- fails (due to INSERT)INSERT INTO atest5(four) VALUES (4); -- failSET SESSION AUTHORIZATION regress_priv_user1;
GRANT INSERT (four) ON atest5 TO regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- fails (due to SELECT)INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- fails (due to SELECT)INSERT INTO atest5(four) VALUES (4); -- okSET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT (four) ON atest5 TO regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- okINSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- okSET SESSION AUTHORIZATION regress_priv_user1;
REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
GRANT SELECT (one,two,blue) ON atest6 TO regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT one FROM atest5; -- failUPDATE atest5 SET one = 1; -- failSELECT atest6 FROM atest6; -- okCOPY atest6 TO stdout; -- okSET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), primary key (c1, c2));
GRANT SELECT (c1) ON t1 TO regress_priv_user2;
GRANT INSERT (c1, c2, c3) ON t1 TO regress_priv_user2;
GRANT UPDATE (c1, c2, c3) ON t1 TO regress_priv_user2;
SET SESSION AUTHORIZATION regress_priv_user2;
INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shownUPDATE t1 SET c2 = 1; -- fail, but row not shownINSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being insertedINSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECTINSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECTUPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modifiedSET SESSION AUTHORIZATION regress_priv_user1;
SET SESSION AUTHORIZATION regress_priv_user1;
GRANT DELETE ON atest5 TO regress_priv_user3;
GRANT SELECT (two) ON atest5 TO regress_priv_user3;
REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
GRANT SELECT (one) ON atest5 TO regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT atest6 FROM atest6; -- failSELECT one FROM atest5 NATURAL JOIN atest6; -- failSET SESSION AUTHORIZATION regress_priv_user1;
ALTER TABLE atest6 DROP COLUMN three;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT atest6 FROM atest6; -- okSELECT one FROM atest5 NATURAL JOIN atest6; -- okSET SESSION AUTHORIZATION regress_priv_user1;
ALTER TABLE atest6 DROP COLUMN two;
REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT * FROM atest6; -- failSELECT 1 FROM atest6; -- failSET SESSION AUTHORIZATION regress_priv_user3;
DELETE FROM atest5 WHERE one = 1; -- failDELETE FROM atest5 WHERE two = 2; -- okSET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
GRANT SELECT(fx,fy,tableoid) ON atestp2 TO regress_priv_user2;
GRANT SELECT(fx) ON atestc TO regress_priv_user2;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT fx FROM atestp2; -- okSELECT fy FROM atestp2; -- okSELECT atestp2 FROM atestp2; -- okSELECT tableoid FROM atestp2; -- okSELECT fy FROM atestc; -- failSET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(fy,tableoid) ON atestc TO regress_priv_user2;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT fx FROM atestp2; -- still okSELECT fy FROM atestp2; -- okSELECT atestp2 FROM atestp2; -- okSELECT tableoid FROM atestp2; -- ok\c -REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
GRANT USAGE ON LANGUAGE sql TO regress_priv_user1; -- okGRANT USAGE ON LANGUAGE c TO PUBLIC; -- failSET SESSION AUTHORIZATION regress_priv_user1;
GRANT USAGE ON LANGUAGE sql TO regress_priv_user2; -- failCREATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
CREATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
CREATE PROCEDURE priv_testproc1(int) AS 'select $1;' LANGUAGE sql;
REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC; -- fail, not a functionREVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
GRANT EXECUTE ON PROCEDURE priv_testproc1(int) TO regress_priv_user2;
GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3; -- semantic errorGRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3; -- semantic errorGRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3; -- semantic errorGRANT ALL PRIVILEGES ON FUNCTION priv_testfunc1(int) TO regress_priv_user4;
GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
GRANT ALL PRIVILEGES ON FUNCTION priv_testagg1(int) TO regress_priv_user4;
GRANT ALL PRIVILEGES ON PROCEDURE priv_testproc1(int) TO regress_priv_user4;
CREATE FUNCTION priv_testfunc4(boolean) RETURNS text  AS 'select col1 from atest2 where col2 = $1;'  LANGUAGE sql SECURITY DEFINER;
GRANT EXECUTE ON FUNCTION priv_testfunc4(boolean) TO regress_priv_user3;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT priv_testfunc1(5), priv_testfunc2(5); -- okCREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- failSELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- okCALL priv_testproc1(6); -- okSET SESSION AUTHORIZATION regress_priv_user3;
SELECT priv_testfunc1(5); -- failSELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- failCALL priv_testproc1(6); -- failSELECT col1 FROM atest2 WHERE col2 = true; -- failSELECT priv_testfunc4(true); -- okSET SESSION AUTHORIZATION regress_priv_user4;
SELECT priv_testfunc1(5); -- okSELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- okCALL priv_testproc1(6); -- okDROP FUNCTION priv_testfunc1(int); -- failDROP AGGREGATE priv_testagg1(int); -- failDROP PROCEDURE priv_testproc1(int); -- fail\c -DROP FUNCTION priv_testfunc1(int); -- okGRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
BEGIN;
::SELECT '{1}'::int4[]::int8[];
REVOKE ALL ON FUNCTION int8(integer) FROM PUBLIC;
::SELECT '{1}'::int4[]::int8[]; --superuser, succeedSET SESSION AUTHORIZATION regress_priv_user4;
::SELECT '{1}'::int4[]::int8[]; --other user, failROLLBACK;
\\c -CREATE TYPE priv_testtype1 AS (a int, b text);
REVOKE USAGE ON TYPE priv_testtype1 FROM PUBLIC;
GRANT USAGE ON TYPE priv_testtype1 TO regress_priv_user2;
GRANT USAGE ON TYPE _priv_testtype1 TO regress_priv_user2; -- failGRANT USAGE ON DOMAIN priv_testtype1 TO regress_priv_user2; -- failCREATE DOMAIN priv_testdomain1 AS int;
REVOKE USAGE on DOMAIN priv_testdomain1 FROM PUBLIC;
GRANT USAGE ON DOMAIN priv_testdomain1 TO regress_priv_user2;
GRANT USAGE ON TYPE priv_testdomain1 TO regress_priv_user2; -- okSET SESSION AUTHORIZATION regress_priv_user1;
CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
CREATE DOMAIN priv_testdomain3a AS int;
CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3a AS $$ SELECT $1::priv_testdomain3a $$ LANGUAGE SQL;
CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
DROP FUNCTION castfunc(int) CASCADE;
DROP DOMAIN priv_testdomain3a;
CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
CREATE TABLE test5a (a int, b priv_testdomain1);
CREATE TABLE test6a OF priv_testtype1;
CREATE TABLE test10a (a int[], b priv_testtype1[]);
ALTER TABLE test9a ADD COLUMN c priv_testdomain1;
ALTER TABLE test9a ALTER COLUMN b TYPE priv_testdomain1;
CREATE TYPE test7a AS (a int, b priv_testdomain1);
CREATE TYPE test8a AS (a int, b int);
ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
::CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
SET SESSION AUTHORIZATION regress_priv_user2;
CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
CREATE DOMAIN priv_testdomain2b AS priv_testdomain1;
CREATE DOMAIN priv_testdomain3b AS int;
CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3b AS $$ SELECT $1::priv_testdomain3b $$ LANGUAGE SQL;
CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
CREATE FUNCTION priv_testfunc5b(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
CREATE FUNCTION priv_testfunc6b(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
CREATE TABLE test5b (a int, b priv_testdomain1);
CREATE TABLE test6b OF priv_testtype1;
CREATE TABLE test10b (a int[], b priv_testtype1[]);
ALTER TABLE test9b ADD COLUMN c priv_testdomain1;
ALTER TABLE test9b ALTER COLUMN b TYPE priv_testdomain1;
CREATE TYPE test7b AS (a int, b priv_testdomain1);
CREATE TYPE test8b AS (a int, b int);
ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
::CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
\\c -DROP AGGREGATE priv_testagg1b(priv_testdomain1);
DROP DOMAIN priv_testdomain2b;
DROP OPERATOR !! (NONE, priv_testdomain1);
DROP FUNCTION priv_testfunc5b(a priv_testdomain1);
DROP FUNCTION priv_testfunc6b(b int);
DROP TYPE test7b;
DROP TYPE test8b;
DROP CAST (priv_testdomain1 AS priv_testdomain3b);
DROP FUNCTION castfunc(int) CASCADE;
DROP DOMAIN priv_testdomain3b;
DROP TYPE priv_testtype1; -- okDROP DOMAIN priv_testdomain1; -- okSET SESSION AUTHORIZATION regress_priv_user5;
TRUNCATE atest2; -- okTRUNCATE atest3; -- failselect has_table_privilege(NULL,'pg_authid','select');
\\c -select has_table_privilege(current_user,'pg_authid','select');
select has_table_privilege(t2.oid,'pg_authid','update')from (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t2.oid,'pg_authid','delete')from (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(current_user,t1.oid,'rule')from (select oid from pg_class where relname = 'pg_authid') as t1;
select has_table_privilege(current_user,t1.oid,'references')from (select oid from pg_class where relname = 'pg_authid') as t1;
select has_table_privilege(t2.oid,t1.oid,'select')from (select oid from pg_class where relname = 'pg_authid') as t1,  (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t2.oid,t1.oid,'insert')from (select oid from pg_class where relname = 'pg_authid') as t1,  (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t1.oid,'select')from (select oid from pg_class where relname = 'pg_authid') as t1;
select has_table_privilege(t1.oid,'trigger')from (select oid from pg_class where relname = 'pg_authid') as t1;
SET SESSION AUTHORIZATION regress_priv_user3;
select has_table_privilege(t2.oid,'pg_class','update')from (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t2.oid,'pg_class','delete')from (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(current_user,t1.oid,'references')from (select oid from pg_class where relname = 'pg_class') as t1;
select has_table_privilege(t2.oid,t1.oid,'select')from (select oid from pg_class where relname = 'pg_class') as t1,  (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t2.oid,t1.oid,'insert')from (select oid from pg_class where relname = 'pg_class') as t1,  (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t1.oid,'select')from (select oid from pg_class where relname = 'pg_class') as t1;
select has_table_privilege(t1.oid,'trigger')from (select oid from pg_class where relname = 'pg_class') as t1;
select has_table_privilege(t2.oid,'atest1','update')from (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t2.oid,'atest1','delete')from (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(current_user,t1.oid,'references')from (select oid from pg_class where relname = 'atest1') as t1;
select has_table_privilege(t2.oid,t1.oid,'select')from (select oid from pg_class where relname = 'atest1') as t1,  (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t2.oid,t1.oid,'insert')from (select oid from pg_class where relname = 'atest1') as t1,  (select oid from pg_roles where rolname = current_user) as t2;
select has_table_privilege(t1.oid,'select')from (select oid from pg_class where relname = 'atest1') as t1;
select has_table_privilege(t1.oid,'trigger')from (select oid from pg_class where relname = 'atest1') as t1;
select has_column_privilege('pg_authid',NULL,'select');
::::::alter table mytable drop column f2;
::revoke select on table mytable from regress_priv_user3;
::SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT ON atest4 TO regress_priv_user2 WITH GRANT OPTION;
GRANT UPDATE ON atest4 TO regress_priv_user2;
GRANT SELECT ON atest4 TO GROUP regress_priv_group1 WITH GRANT OPTION;
SET SESSION AUTHORIZATION regress_priv_user2;
GRANT SELECT ON atest4 TO regress_priv_user3;
GRANT UPDATE ON atest4 TO regress_priv_user3; -- failSET SESSION AUTHORIZATION regress_priv_user1;
REVOKE SELECT ON atest4 FROM regress_priv_user3; -- does nothingSELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- trueREVOKE SELECT ON atest4 FROM regress_priv_user2; -- failREVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE; -- okSELECT has_table_privilege('regress_priv_user2', 'atest4', 'SELECT'); -- trueSELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- falseSELECT has_table_privilege('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION'); -- trueSET SESSION AUTHORIZATION regress_priv_user4;
CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS	'GRANT regress_priv_group2 TO regress_priv_user5';
GRANT regress_priv_group2 TO regress_priv_user5; -- ok: had ADMIN OPTIONSET ROLE regress_priv_group2;
GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE suspended privilegeSET SESSION AUTHORIZATION regress_priv_user1;
GRANT regress_priv_group2 TO regress_priv_user5; -- fails: no ADMIN OPTIONSELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMINSET ROLE regress_priv_group2;
GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE did not helpSET SESSION AUTHORIZATION regress_priv_group2;
GRANT regress_priv_group2 TO regress_priv_user5; -- ok: a role can self-adminCREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS	'GRANT regress_priv_group2 TO regress_priv_user5';
SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINERDROP FUNCTION dogrant_fails();
SET SESSION AUTHORIZATION regress_priv_user4;
DROP FUNCTION dogrant_ok();
REVOKE regress_priv_group2 FROM regress_priv_user5;
\\c -CREATE SEQUENCE x_seq;
GRANT USAGE on x_seq to regress_priv_user2;
SET SESSION AUTHORIZATION regress_priv_user2;
\\c -SET SESSION AUTHORIZATION regress_priv_user1;
GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
GRANT SELECT ON LARGE OBJECT 1003 TO regress_priv_user2;
GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regress_priv_user2;
GRANT ALL ON LARGE OBJECT 1005 TO regress_priv_user2;
GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user2 WITH GRANT OPTION;
GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;	-- to be failedGRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;	-- to be failedGRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;	-- to be failed\c -SET SESSION AUTHORIZATION regress_priv_user2;
SELECT loread(lo_open(1001, x'20000'::int), 32);	-- allowed, for nowSELECT lowrite(lo_open(1001, x'40000'::int), 'abcd');	-- fail, wrong modeSELECT loread(lo_open(1001, x'40000'::int), 32);
SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be deniedSELECT loread(lo_open(1003, x'40000'::int), 32);
SELECT loread(lo_open(1004, x'40000'::int), 32);
SELECT lowrite(lo_open(1001, x'20000'::int), 'abcd');
SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be deniedSELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');	-- to be deniedSELECT lowrite(lo_open(1004, x'20000'::int), 'abcd');
GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user3;
GRANT UPDATE ON LARGE OBJECT 1006 TO regress_priv_user3;	-- to be deniedREVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
GRANT ALL ON LARGE OBJECT 2001 TO regress_priv_user3;
SELECT lo_unlink(1001);		-- to be deniedSELECT lo_unlink(2002);
\\c -SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
SET SESSION AUTHORIZATION regress_priv_user3;
SELECT loread(lo_open(1001, x'40000'::int), 32);
SELECT loread(lo_open(1003, x'40000'::int), 32);	-- to be deniedSELECT loread(lo_open(1005, x'40000'::int), 32);
SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);	-- to be deniedSELECT lo_truncate(lo_open(2001, x'20000'::int), 10);
\\c -SET lo_compat_privileges = false;	-- default settingSET SESSION AUTHORIZATION regress_priv_user4;
SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be deniedSELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be deniedSELECT lo_truncate(lo_open(1002, x'20000'::int), 10);	-- to be deniedSELECT lo_put(1002, 1, 'abcd');				-- to be deniedSELECT lo_unlink(1002);					-- to be deniedSELECT lo_export(1001, '/dev/null');			-- to be deniedSELECT lo_import('/dev/null');				-- to be deniedSELECT lo_import('/dev/null', 2003);			-- to be denied\c -SET lo_compat_privileges = true;	-- compatibility modeSET SESSION AUTHORIZATION regress_priv_user4;
SELECT loread(lo_open(1002, x'40000'::int), 32);
SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
SELECT lo_export(1001, '/dev/null');			-- to be denied\c -SELECT * FROM pg_largeobject LIMIT 0;
SET SESSION AUTHORIZATION regress_priv_user1;
SELECT * FROM pg_largeobject LIMIT 0;			-- to be denied\c -CREATE SCHEMA testns;
GRANT ALL ON SCHEMA testns TO regress_priv_user1;
CREATE TABLE testns.acltest1 (x int);
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- noSELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- noALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT SELECT ON TABLES TO public;
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- noSELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- noDROP TABLE testns.acltest1;
CREATE TABLE testns.acltest1 (x int);
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yesSELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- noALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regress_priv_user1;
DROP TABLE testns.acltest1;
CREATE TABLE testns.acltest1 (x int);
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yesSELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- yesALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regress_priv_user1;
DROP TABLE testns.acltest1;
CREATE TABLE testns.acltest1 (x int);
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yesSELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- noALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE EXECUTE ON FUNCTIONS FROM public;
ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2; -- errorBEGIN;
ALTER DEFAULT PRIVILEGES GRANT USAGE ON SCHEMAS TO regress_priv_user2;
CREATE SCHEMA testns2;
SELECT has_schema_privilege('regress_priv_user2', 'testns2', 'USAGE'); -- yesSELECT has_schema_privilege('regress_priv_user2', 'testns2', 'CREATE'); -- noALTER DEFAULT PRIVILEGES REVOKE USAGE ON SCHEMAS FROM regress_priv_user2;
CREATE SCHEMA testns3;
SELECT has_schema_privilege('regress_priv_user2', 'testns3', 'USAGE'); -- noSELECT has_schema_privilege('regress_priv_user2', 'testns3', 'CREATE'); -- noALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
CREATE SCHEMA testns4;
SELECT has_schema_privilege('regress_priv_user2', 'testns4', 'USAGE'); -- yesSELECT has_schema_privilege('regress_priv_user2', 'testns4', 'CREATE'); -- yesALTER DEFAULT PRIVILEGES REVOKE ALL ON SCHEMAS FROM regress_priv_user2;
COMMIT;
CREATE SCHEMA testns5;
SELECT has_schema_privilege('regress_priv_user2', 'testns5', 'USAGE'); -- noSELECT has_schema_privilege('regress_priv_user2', 'testns5', 'CREATE'); -- noSET ROLE regress_priv_user1;
CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE'); -- noSELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE'); -- noSELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE'); -- noALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON ROUTINES to public;
DROP FUNCTION testns.foo();
CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
DROP AGGREGATE testns.agg1(int);
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
DROP PROCEDURE testns.bar();
CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE'); -- yesSELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE'); -- yesSELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE'); -- yes (counts as function here)DROP FUNCTION testns.foo();
DROP AGGREGATE testns.agg1(int);
DROP PROCEDURE testns.bar();
ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE USAGE ON TYPES FROM public;
CREATE DOMAIN testns.priv_testdomain1 AS int;
SELECT has_type_privilege('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE'); -- noALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON TYPES to public;
DROP DOMAIN testns.priv_testdomain1;
CREATE DOMAIN testns.priv_testdomain1 AS int;
SELECT has_type_privilege('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE'); -- yesDROP DOMAIN testns.priv_testdomain1;
RESET ROLE;
SELECT count(*)  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid  WHERE nspname = 'testns';
DROP SCHEMA testns CASCADE;
DROP SCHEMA testns2 CASCADE;
DROP SCHEMA testns3 CASCADE;
DROP SCHEMA testns4 CASCADE;
DROP SCHEMA testns5 CASCADE;
SELECT d.*     -- check that entries went away  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid  WHERE nspname IS NULL AND defaclnamespace != 0;
\\c -CREATE SCHEMA testns;
CREATE TABLE testns.t1 (f1 int);
CREATE TABLE testns.t2 (f1 int);
SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- falseGRANT ALL ON ALL TABLES IN SCHEMA testns TO regress_priv_user1;
SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- trueSELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT'); -- trueREVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regress_priv_user1;
SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- falseSELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT'); -- falseCREATE FUNCTION testns.priv_testfunc(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
CREATE AGGREGATE testns.priv_testagg(int) (sfunc = int4pl, stype = int4);
CREATE PROCEDURE testns.priv_testproc(int) AS 'select 3' LANGUAGE sql;
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- true by defaultSELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- true by defaultSELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- true by defaultREVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- falseSELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- falseSELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- still true, not a functionREVOKE ALL ON ALL PROCEDURES IN SCHEMA testns FROM PUBLIC;
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- now falseGRANT ALL ON ALL ROUTINES IN SCHEMA testns TO PUBLIC;
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- trueSELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- trueSELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- trueDROP SCHEMA testns CASCADE;
\\c -CREATE ROLE regress_schemauser1 superuser login;
CREATE ROLE regress_schemauser2 superuser login;
SET SESSION ROLE regress_schemauser1;
CREATE SCHEMA testns;
SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
ALTER SCHEMA testns OWNER TO regress_schemauser2;
ALTER ROLE regress_schemauser2 RENAME TO regress_schemauser_renamed;
SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
set session role regress_schemauser_renamed;
DROP SCHEMA testns CASCADE;
\\c -DROP ROLE regress_schemauser1;
DROP ROLE regress_schemauser_renamed;
\\c -set session role regress_priv_user1;
grant select on dep_priv_test to regress_priv_user2 with grant option;
grant select on dep_priv_test to regress_priv_user3 with grant option;
set session role regress_priv_user2;
grant select on dep_priv_test to regress_priv_user4 with grant option;
set session role regress_priv_user3;
grant select on dep_priv_test to regress_priv_user4 with grant option;
set session role regress_priv_user4;
grant select on dep_priv_test to regress_priv_user5;
set session role regress_priv_user2;
revoke select on dep_priv_test from regress_priv_user4 cascade;
set session role regress_priv_user3;
revoke select on dep_priv_test from regress_priv_user4 cascade;
set session role regress_priv_user1;
\\cdrop sequence x_seq;
DROP AGGREGATE priv_testagg1(int);
DROP FUNCTION priv_testfunc2(int);
DROP FUNCTION priv_testfunc4(boolean);
DROP PROCEDURE priv_testproc1(int);
DROP VIEW atestv3 CASCADE;
DROP GROUP regress_priv_group1;
DROP GROUP regress_priv_group2;
REVOKE USAGE ON LANGUAGE sql FROM regress_priv_user1;
DROP OWNED BY regress_priv_user1;
DROP USER regress_priv_user1;
DROP USER regress_priv_user2;
DROP USER regress_priv_user3;
DROP USER regress_priv_user4;
DROP USER regress_priv_user5;
DROP USER regress_priv_user6;
CREATE USER regress_locktable_user;
GRANT SELECT ON lock_table TO regress_locktable_user;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should failROLLBACK;
BEGIN;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should passCOMMIT;
BEGIN;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should failROLLBACK;
\\cREVOKE SELECT ON lock_table FROM regress_locktable_user;
GRANT INSERT ON lock_table TO regress_locktable_user;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should passCOMMIT;
BEGIN;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should failROLLBACK;
BEGIN;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should failROLLBACK;
\\cREVOKE INSERT ON lock_table FROM regress_locktable_user;
GRANT UPDATE ON lock_table TO regress_locktable_user;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should passCOMMIT;
BEGIN;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should failROLLBACK;
BEGIN;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should passCOMMIT;
\\cREVOKE UPDATE ON lock_table FROM regress_locktable_user;
GRANT DELETE ON lock_table TO regress_locktable_user;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should passCOMMIT;
BEGIN;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should failROLLBACK;
BEGIN;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should passCOMMIT;
\\cREVOKE DELETE ON lock_table FROM regress_locktable_user;
GRANT TRUNCATE ON lock_table TO regress_locktable_user;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should passCOMMIT;
BEGIN;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should failROLLBACK;
BEGIN;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should passCOMMIT;
\\cREVOKE TRUNCATE ON lock_table FROM regress_locktable_user;
DROP USER regress_locktable_user;
SET client_min_messages TO 'warning';
DROP USER IF EXISTS regress_rls_alice;
DROP USER IF EXISTS regress_rls_bob;
DROP USER IF EXISTS regress_rls_carol;
DROP USER IF EXISTS regress_rls_dave;
DROP USER IF EXISTS regress_rls_exempt_user;
DROP ROLE IF EXISTS regress_rls_group1;
DROP ROLE IF EXISTS regress_rls_group2;
DROP SCHEMA IF EXISTS regress_rls_schema CASCADE;
RESET client_min_messages;
CREATE USER regress_rls_alice NOLOGIN;
CREATE USER regress_rls_bob NOLOGIN;
CREATE USER regress_rls_carol NOLOGIN;
CREATE USER regress_rls_dave NOLOGIN;
CREATE USER regress_rls_exempt_user BYPASSRLS NOLOGIN;
CREATE ROLE regress_rls_group1 NOLOGIN;
CREATE ROLE regress_rls_group2 NOLOGIN;
GRANT regress_rls_group1 TO regress_rls_bob;
GRANT regress_rls_group2 TO regress_rls_carol;
CREATE SCHEMA regress_rls_schema;
GRANT ALL ON SCHEMA regress_rls_schema to public;
SET search_path = regress_rls_schema;
CREATE OR REPLACE FUNCTION f_leak(text) RETURNS bool    COST 0.0000001 LANGUAGE plpgsql    AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1; RETURN true; END';
GRANT EXECUTE ON FUNCTION f_leak(text) TO public;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE uaccount (    pguser      name primary key,    seclv       int);
GRANT SELECT ON uaccount TO public;
GRANT ALL ON category TO public;
CREATE TABLE document (    did         int primary key,    cid         int references category(cid),    dlevel      int not null,    dauthor     name,    dtitle      text);
GRANT ALL ON document TO public;
ALTER TABLE document ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON document AS PERMISSIVE    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY p1 ON document AS UGLY    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave    USING (cid <> 44 AND cid < 50);
CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave    USING (cid <> 44);
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO ON;
SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)  WHERE f_leak(dtitle) ORDER BY did;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)  WHERE f_leak(dtitle) ORDER BY did;
EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
SET SESSION AUTHORIZATION regress_rls_dave;
EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies'); -- failINSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies'); -- failALTER POLICY p1 ON document USING (true);    --failDROP POLICY p1 ON document;                  --failSET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY p1 ON document USING (dauthor = current_user);
SET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY p2 ON category    USING (CASE WHEN current_user = 'regress_rls_bob' THEN cid IN (11, 33)           WHEN current_user = 'regress_rls_carol' THEN cid IN (22, 44)           ELSE false END);
ALTER TABLE category ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
DELETE FROM category WHERE cid = 33;    -- fails with FK violationSET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga'); -- Must fail with unique violation, revealing presence of did we can't seeSELECT * FROM document WHERE did = 8; -- and confirm we can't see itINSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga'); -- Should fail with RLS check violation, not duplicate key violationUPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5; -- Should fail with RLS check violation, not duplicate key violationRESET SESSION AUTHORIZATION;
SET row_security TO ON;
RESET SESSION AUTHORIZATION;
SET row_security TO OFF;
SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET row_security TO OFF;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security TO ON;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security TO OFF;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security TO ON;
ALTER TABLE t1 DROP COLUMN junk1;    -- just a disturbing factorGRANT ALL ON t1 TO public;
COPY t1 FROM stdin WITH ;
101	1	aba102	2	bbb103	3	ccc104	4	dad\.CREATE TABLE t2 (c float) INHERITS (t1);
GRANT ALL ON t2 TO public;
COPY t2 FROM stdin;
201	1	abc	1.1202	2	bcd	2.2203	3	cde	3.3204	4	def	4.4\.CREATE TABLE t3 (id int not null primary key, c text, b text, a int);
ALTER TABLE t3 INHERIT t1;
GRANT ALL ON t3 TO public;
COPY t3(id, a,b,c) FROM stdin;
301	1	xxx	X302	2	yyy	Y303	3	zzz	Z\.CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0); -- be even numberCREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1); -- be odd numberALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE t2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
::EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
SELECT * FROM t1 FOR SHARE;
EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
::SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
EXPLAIN (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
RESET SESSION AUTHORIZATION;
SET row_security TO OFF;
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET row_security TO OFF;
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE part_document (    did         int,    cid         int,    dlevel      int not null,    dauthor     name,    dtitle      text) PARTITION BY RANGE (cid);
GRANT ALL ON part_document TO public;
CREATE TABLE part_document_fiction PARTITION OF part_document FOR VALUES FROM (11) to (12);
CREATE TABLE part_document_satire PARTITION OF part_document FOR VALUES FROM (55) to (56);
CREATE TABLE part_document_nonfiction PARTITION OF part_document FOR VALUES FROM (99) to (100);
GRANT ALL ON part_document_fiction TO public;
GRANT ALL ON part_document_satire TO public;
GRANT ALL ON part_document_nonfiction TO public;
ALTER TABLE part_document ENABLE ROW LEVEL SECURITY;
CREATE POLICY pp1 ON part_document AS PERMISSIVE    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave    USING (cid < 55);
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO ON;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
SET SESSION AUTHORIZATION regress_rls_dave;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1'); -- failINSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r'); -- failINSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- failINSERT INTO part_document_satire VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- successSELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER TABLE part_document_satire ENABLE ROW LEVEL SECURITY;
CREATE POLICY pp3 ON part_document_satire AS RESTRICTIVE    USING (cid < 55);
SET SESSION AUTHORIZATION regress_rls_dave;
INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- failSELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
ALTER POLICY pp1 ON part_document USING (true);    --failDROP POLICY pp1 ON part_document;                  --failSET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY pp1 ON part_document USING (dauthor = current_user);
SET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESET SESSION AUTHORIZATION;
SET row_security TO ON;
SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET row_security TO OFF;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security TO ON;
SET SESSION AUTHORIZATION regress_rls_dave;
SET row_security TO OFF;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security TO ON;
CREATE POLICY pp3 ON part_document AS RESTRICTIVE    USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
SET SESSION AUTHORIZATION regress_rls_carol;
INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3'); -- failSET SESSION AUTHORIZATION regress_rls_alice;
SET row_security TO ON;
CREATE POLICY d1 ON dependent FOR ALL    TO PUBLIC    USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
DROP TABLE dependee; -- Should fail without CASCADE due to dependency on row security qual?DROP TABLE dependee CASCADE;
EXPLAIN (COSTS OFF) SELECT * FROM dependent; -- After drop, should be unqualifiedSET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM rec1; -- fail, direct recursionSET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM rec1;    -- fail, mutual recursionSET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM rec1;    -- fail, mutual recursion via viewsSET SESSION AUTHORIZATION regress_rls_bob;
DROP VIEW rec1v, rec2v CASCADE;
CREATE VIEW rec1v WITH (security_barrier) AS SELECT * FROM rec1;
CREATE VIEW rec2v WITH (security_barrier) AS SELECT * FROM rec2;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM rec1;    -- fail, mutual recursion via s.b. viewsSET SESSION AUTHORIZATION regress_rls_alice;
INSERT INTO s1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
INSERT INTO s2 (SELECT x, md5(x::text) FROM generate_series(-6,6) x);
GRANT SELECT ON s1, s2 TO regress_rls_bob;
CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
ALTER TABLE s1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE s2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM s1 WHERE f_leak(b); -- fail (infinite recursion)INSERT INTO s1 VALUES (1, 'foo'); -- fail (infinite recursion)SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p3 on s1;
ALTER POLICY p2 ON s2 USING (x % 2 = 0);
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM s1 WHERE f_leak(b);	-- OKEXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY p1 ON s1 USING (a in (select x from v2)); -- using VIEW in RLS policySET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM s1 WHERE f_leak(b);	-- OKEXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM s1 WHERE f_leak(b);	-- fail (infinite recursion via view)PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
EXECUTE p1(2);
EXPLAIN (COSTS OFF) EXECUTE p1(2);
RESET SESSION AUTHORIZATION;
SET row_security TO OFF;
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
EXECUTE p1(2);
EXPLAIN (COSTS OFF) EXECUTE p1(2);
PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1;
EXECUTE p2(2);
EXPLAIN (COSTS OFF) EXECUTE p2(2);
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO ON;
EXECUTE p2(2);
EXPLAIN (COSTS OFF) EXECUTE p2(2);
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
||UPDATE t1 SET b = b || b WHERE f_leak(b);
EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
||UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *;
UPDATE t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
UPDATE t2 SET b=t2.b FROM t3WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
UPDATE t1 SET b=t1.b FROM t2WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
UPDATE t2 SET b=t2.b FROM t1WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.bAND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.bAND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.bAND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.bAND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
RESET SESSION AUTHORIZATION;
SET row_security TO OFF;
SELECT * FROM t1 ORDER BY a,b;
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO ON;
EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
DELETE FROM only t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
DELETE FROM t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
SET SESSION AUTHORIZATION regress_rls_alice;
INSERT INTO b1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
CREATE POLICY p1 ON b1 USING (a % 2 = 0);
ALTER TABLE b1 ENABLE ROW LEVEL SECURITY;
GRANT ALL ON b1 TO regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_bob;
CREATE VIEW bv1 WITH (security_barrier) AS SELECT * FROM b1 WHERE a > 0 WITH CHECK OPTION;
GRANT ALL ON bv1 TO regress_rls_carol;
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM bv1 WHERE f_leak(b);
INSERT INTO bv1 VALUES (-1, 'xxx'); -- should fail view WCOINSERT INTO bv1 VALUES (11, 'xxx'); -- should fail RLS checkINSERT INTO bv1 VALUES (12, 'xxx'); -- okEXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
EXPLAIN (COSTS OFF) DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
SET SESSION AUTHORIZATION regress_rls_alice;
SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p1 ON document;
DROP POLICY p1r ON document;
CREATE POLICY p1 ON document FOR SELECT USING (true);
CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
CREATE POLICY p3 ON document FOR UPDATE  USING (cid = (SELECT cid from category WHERE cname = 'novel'))  WITH CHECK (dauthor = current_user);
SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor;
INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction'); -- preparation for next statementINSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p1 ON document;
DROP POLICY p2 ON document;
DROP POLICY p3 ON document;
CREATE POLICY p3_with_default ON document FOR UPDATE  USING (cid = (SELECT cid from category WHERE cname = 'novel'));
SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')    ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *;
SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p3_with_default ON document;
CREATE POLICY p3_with_all ON document FOR ALL  USING (cid = (SELECT cid from category WHERE cname = 'novel'))  WITH CHECK (dauthor = current_user);
SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33;
INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')    ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol';
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT SELECT ON z1,z2 TO regress_rls_group1, regress_rls_group2,    regress_rls_bob, regress_rls_carol;
CREATE POLICY p1 ON z1 TO regress_rls_group1 USING (a % 2 = 0);
CREATE POLICY p2 ON z1 TO regress_rls_group2 USING (a % 2 = 1);
ALTER TABLE z1 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
PREPARE plancache_test AS SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
PREPARE plancache_test2 AS WITH q AS MATERIALIZED (SELECT * FROM z1 WHERE f_leak(b)) SELECT * FROM q,z2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
PREPARE plancache_test3 AS WITH q AS MATERIALIZED (SELECT * FROM z2) SELECT * FROM q,z1 WHERE f_leak(z1.b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET ROLE regress_rls_group1;
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET ROLE regress_rls_group2;
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT SELECT ON rls_view TO regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_alice;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_bob;
GRANT SELECT ON rls_view TO regress_rls_alice;
SET SESSION AUTHORIZATION regress_rls_alice;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM rls_view; --fail - permission denied.EXPLAIN (COSTS OFF) SELECT * FROM rls_view; --fail - permission denied.SET SESSION AUTHORIZATION regress_rls_bob;
GRANT SELECT ON rls_view TO regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT ALL ON x1 TO PUBLIC;
CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
ALTER TABLE x1 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
||UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
SET SESSION AUTHORIZATION regress_rls_carol;
||UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
DELETE FROM x1 WHERE f_leak(b) RETURNING *;
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT ALL ON y1, y2 TO regress_rls_bob;
CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);  --failCREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);  --OKALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE y2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE VIEW rls_sbv WITH (security_barrier) AS    SELECT * FROM y1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
SET SESSION AUTHORIZATION regress_rls_bob;
CREATE VIEW rls_sbv WITH (security_barrier) AS    SELECT * FROM y1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
SET SESSION AUTHORIZATION regress_rls_alice;
INSERT INTO y2 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
CREATE POLICY p2 ON y2 USING (a % 3 = 0);
CREATE POLICY p3 ON y2 USING (a % 4 = 0);
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak('abc');
EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc);
EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
RESET SESSION AUTHORIZATION;
DROP TABLE t1 CASCADE;
GRANT SELECT ON t1 TO regress_rls_bob, regress_rls_carol;
CREATE POLICY p1 ON t1 TO regress_rls_bob USING ((a % 2) = 0);
CREATE POLICY p2 ON t1 TO regress_rls_carol USING ((a % 4) = 0);
ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
SET ROLE regress_rls_bob;
PREPARE role_inval AS SELECT * FROM t1;
EXPLAIN (COSTS OFF) EXECUTE role_inval;
SET ROLE regress_rls_carol;
EXPLAIN (COSTS OFF) EXECUTE role_inval;
SET ROLE regress_rls_bob;
EXPLAIN (COSTS OFF) EXECUTE role_inval;
RESET SESSION AUTHORIZATION;
DROP TABLE t1 CASCADE;
CREATE POLICY p1 ON t1 USING (a % 2 = 0);
ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
GRANT ALL ON t1 TO regress_rls_bob;
INSERT INTO t1 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
SET SESSION AUTHORIZATION regress_rls_bob;
WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
EXPLAIN (COSTS OFF)WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1; --failWITH cte1 AS (UPDATE t1 SET a = a RETURNING *) SELECT * FROM cte1; --okWITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1; --failWITH cte1 AS (INSERT INTO t1 VALUES (20, 'Success') RETURNING *) SELECT * FROM cte1; --okRESET SESSION AUTHORIZATION;
ALTER POLICY p1 ON t1 RENAME TO p1; --failSELECT polname, relname    FROM pg_policy pol    JOIN pg_class pc ON (pc.oid = pol.polrelid)    WHERE relname = 't1';
ALTER POLICY p1 ON t1 RENAME TO p2; --okSELECT polname, relname    FROM pg_policy pol    JOIN pg_class pc ON (pc.oid = pol.polrelid)    WHERE relname = 't1';
SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO t2 (SELECT * FROM t1);
EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
EXPLAIN (COSTS OFF) SELECT * FROM t2;
SELECT * INTO t4 FROM t1;
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT ALL ON blog, comment TO regress_rls_bob;
CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
ALTER TABLE blog ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY comment_1 ON comment USING (blog_id < 4);
ALTER TABLE comment ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_alice;
DROP TABLE blog, comment;
RESET SESSION AUTHORIZATION;
DROP POLICY p2 ON t1;
ALTER TABLE t1 OWNER TO regress_rls_alice;
RESET SESSION AUTHORIZATION;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
SET SESSION AUTHORIZATION regress_rls_alice;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO ON;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
RESET SESSION AUTHORIZATION;
DROP TABLE copy_t CASCADE;
CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY;
GRANT ALL ON copy_t TO regress_rls_bob, regress_rls_exempt_user;
INSERT INTO copy_t (SELECT x, md5(x::text) FROM generate_series(0,10) x);
RESET SESSION AUTHORIZATION;
SET row_security TO OFF;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
SET row_security TO ON;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO OFF;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - would be affected by RLSSET row_security TO ON;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --okSET SESSION AUTHORIZATION regress_rls_exempt_user;
SET row_security TO OFF;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --okSET row_security TO ON;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --okSET SESSION AUTHORIZATION regress_rls_carol;
SET row_security TO OFF;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - would be affected by RLSSET row_security TO ON;
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','; --fail - permission deniedRESET SESSION AUTHORIZATION;
SET row_security TO ON;
CREATE POLICY p1 ON copy_rel_to USING (a % 2 = 0);
ALTER TABLE copy_rel_to ENABLE ROW LEVEL SECURITY;
GRANT ALL ON copy_rel_to TO regress_rls_bob, regress_rls_exempt_user;
RESET SESSION AUTHORIZATION;
SET row_security TO OFF;
COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
SET row_security TO ON;
COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO OFF;
COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --fail - would be affected by RLSSET row_security TO ON;
COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --okSET SESSION AUTHORIZATION regress_rls_exempt_user;
SET row_security TO OFF;
COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --okSET row_security TO ON;
COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --okSET SESSION AUTHORIZATION regress_rls_carol;
SET row_security TO OFF;
COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --fail - permission deniedSET row_security TO ON;
COPY copy_rel_to TO STDOUT WITH DELIMITER ','; --fail - permission deniedRESET SESSION AUTHORIZATION;
SET row_security TO OFF;
COPY copy_t FROM STDIN; --ok1	abc2	bcd3	cde4	def\.SET row_security TO ON;
COPY copy_t FROM STDIN; --ok1	abc2	bcd3	cde4	def\.SET SESSION AUTHORIZATION regress_rls_bob;
SET row_security TO OFF;
COPY copy_t FROM STDIN; --fail - would be affected by RLS.SET row_security TO ON;
COPY copy_t FROM STDIN; --fail - COPY FROM not supported by RLS.SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET row_security TO ON;
COPY copy_t FROM STDIN; --ok1	abc2	bcd3	cde4	def\.SET SESSION AUTHORIZATION regress_rls_carol;
SET row_security TO OFF;
COPY copy_t FROM STDIN; --fail - permission denied.SET row_security TO ON;
COPY copy_t FROM STDIN; --fail - permission denied.RESET SESSION AUTHORIZATION;
DROP TABLE copy_rel_to CASCADE;
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT ALL ON current_check TO PUBLIC;
CREATE POLICY p1 ON current_check FOR SELECT USING (currentid % 2 = 0);
CREATE POLICY p2 ON current_check FOR DELETE USING (currentid = 4 AND rlsuser = current_user);
CREATE POLICY p3 ON current_check FOR UPDATE USING (currentid = 4) WITH CHECK (rlsuser = current_user);
ALTER TABLE current_check ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
||UPDATE current_check SET payload = payload || '_new' WHERE currentid = 2 RETURNING *;
BEGIN;
DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM current_check;
FETCH ABSOLUTE 1 FROM current_check_cursor;
||UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
FETCH RELATIVE 1 FROM current_check_cursor;
||UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
EXPLAIN (COSTS OFF) UPDATE current_check SET payload = payload WHERE CURRENT OF current_check_cursor;
FETCH ABSOLUTE 1 FROM current_check_cursor;
DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
FETCH RELATIVE 1 FROM current_check_cursor;
DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
COMMIT;
SET row_security TO ON;
SET SESSION AUTHORIZATION regress_rls_alice;
ANALYZE current_check;
SET SESSION AUTHORIZATION regress_rls_bob;
BEGIN;
CREATE TABLE coll_t (c) AS VALUES ('bar'::text);
CREATE POLICY coll_p ON coll_t USING (c < ('foo'::text COLLATE "C"));
ALTER TABLE coll_t ENABLE ROW LEVEL SECURITY;
GRANT SELECT ON coll_t TO regress_rls_alice;
::SELECT (string_to_array(polqual, ':'))[7] AS inputcollid FROM pg_policy WHERE polrelid = 'coll_t'::regclass;
SET SESSION AUTHORIZATION regress_rls_alice;
ROLLBACK;
RESET SESSION AUTHORIZATION;
BEGIN;
CREATE ROLE regress_rls_eve;
CREATE ROLE regress_rls_frank;
CREATE TABLE tbl1 (c) AS VALUES ('bar'::text);
GRANT SELECT ON TABLE tbl1 TO regress_rls_eve;
CREATE POLICY P ON tbl1 TO regress_rls_eve, regress_rls_frank USING (true);
::::SELECT refclassid::regclass, deptype  FROM pg_depend  WHERE classid = 'pg_policy'::regclass  AND refobjid = 'tbl1'::regclass;
::::SELECT refclassid::regclass, deptype  FROM pg_shdepend  WHERE classid = 'pg_policy'::regclass  AND refobjid IN ('regress_rls_eve'::regrole, 'regress_rls_frank'::regrole);
SAVEPOINT q;
DROP ROLE regress_rls_eve; --fails due to dependency on POLICY pROLLBACK TO q;
ALTER POLICY p ON tbl1 TO regress_rls_frank USING (true);
SAVEPOINT q;
DROP ROLE regress_rls_eve; --fails due to dependency on GRANT SELECTROLLBACK TO q;
REVOKE ALL ON TABLE tbl1 FROM regress_rls_eve;
SAVEPOINT q;
DROP ROLE regress_rls_eve; --succeedsROLLBACK TO q;
SAVEPOINT q;
DROP ROLE regress_rls_frank; --fails due to dependency on POLICY pROLLBACK TO q;
DROP POLICY p ON tbl1;
SAVEPOINT q;
DROP ROLE regress_rls_frank; -- succeedsROLLBACK TO q;
ROLLBACK; -- cleanupBEGIN;
CREATE POLICY p ON t USING (c % 2 = 1);
ALTER TABLE t ENABLE ROW LEVEL SECURITY;
SAVEPOINT q;
CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD  SELECT * FROM generate_series(1,5) t0(c); -- fails due to row level security enabledROLLBACK TO q;
ALTER TABLE t DISABLE ROW LEVEL SECURITY;
SAVEPOINT q;
CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD  SELECT * FROM generate_series(1,5) t0(c); -- fails due to policy p on tROLLBACK TO q;
DROP POLICY p ON t;
CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD  SELECT * FROM generate_series(1,5) t0(c); -- succeedsROLLBACK;
BEGIN;
CREATE TABLE t (c) AS VALUES ('bar'::text);
CREATE POLICY p ON t USING (max(c)); -- fails: aggregate functions are not allowed in policy expressionsROLLBACK;
SET SESSION AUTHORIZATION regress_rls_alice;
GRANT ALL ON r1, r2 TO regress_rls_bob;
CREATE POLICY p1 ON r1 USING (true);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON r2 FOR SELECT USING (true);
CREATE POLICY p2 ON r2 FOR INSERT WITH CHECK (false);
CREATE POLICY p3 ON r2 FOR UPDATE USING (false);
CREATE POLICY p4 ON r2 FOR DELETE USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO r2 VALUES (2); -- Not allowedUPDATE r2 SET a = 2 RETURNING *; -- Updates nothingDELETE FROM r2 RETURNING *; -- Deletes nothingINSERT INTO r1 SELECT a + 1 FROM r2 RETURNING *; -- OKUPDATE r1 SET a = r2.a + 2 FROM r2 WHERE r1.a = r2.a RETURNING *; -- OKDELETE FROM r1 USING r2 WHERE r1.a = r2.a + 2 RETURNING *; -- OKSELECT * FROM r1;
SET SESSION AUTHORIZATION regress_rls_alice;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security = on;
CREATE POLICY p1 ON r1 USING (false);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
TABLE r1;
TABLE r1;
DELETE FROM r1;
TABLE r1;
SET row_security = off;
TABLE r1;
DELETE FROM r1;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security = on;
CREATE POLICY p1 ON r2 USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
DELETE FROM r1;
DROP POLICY p1 ON r2;
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
ALTER TABLE r2 DISABLE ROW LEVEL SECURITY;
DELETE FROM r2;
CREATE POLICY p1 ON r1 USING (false);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
TABLE r1;
CREATE POLICY p1 ON r2 USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
DELETE FROM r1;
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
TABLE r2;
CREATE POLICY p1 ON r2 USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
TABLE r2;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security = on;
CREATE POLICY p1 ON r1 FOR SELECT USING (false);
CREATE POLICY p2 ON r1 FOR INSERT WITH CHECK (true);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
TABLE r1;
SET row_security = off;
TABLE r1;
SET row_security = on;
INSERT INTO r1 VALUES (10), (20) RETURNING *;
SET SESSION AUTHORIZATION regress_rls_alice;
SET row_security = on;
CREATE POLICY p1 ON r1 FOR SELECT USING (a < 20);
CREATE POLICY p2 ON r1 FOR UPDATE USING (a < 20) WITH CHECK (true);
CREATE POLICY p3 ON r1 FOR INSERT WITH CHECK (true);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
ALTER TABLE r1 NO FORCE ROW LEVEL SECURITY;
TABLE r1;
TABLE r1;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
UPDATE r1 SET a = 30 RETURNING *;
INSERT INTO r1 VALUES (10)    ON CONFLICT (a) DO UPDATE SET a = 30 RETURNING *;
INSERT INTO r1 VALUES (10)    ON CONFLICT (a) DO UPDATE SET a = 30;
INSERT INTO r1 VALUES (10)    ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET a = 30;
RESET SESSION AUTHORIZATION;
CREATE POLICY dep_p1 ON dep1 TO regress_rls_bob USING (c1 > (select max(dep2.c1) from dep2));
ALTER POLICY dep_p1 ON dep1 TO regress_rls_bob,regress_rls_carol;
ALTER POLICY dep_p1 ON dep1 USING (true);
RESET SESSION AUTHORIZATION;
CREATE ROLE regress_rls_dob_role1;
CREATE ROLE regress_rls_dob_role2;
CREATE TABLE dob_t2 (c1 int) PARTITION BY RANGE (c1);
CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t1; -- should fail, already goneCREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t1; -- should succeedCREATE POLICY p1 ON dob_t2 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t2; -- should succeedDROP USER regress_rls_dob_role1;
DROP USER regress_rls_dob_role2;
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON rls_tbl USING (EXISTS (SELECT 1 FROM ref_tbl));
GRANT SELECT ON ref_tbl TO regress_rls_bob;
GRANT SELECT ON rls_tbl TO regress_rls_bob;
ALTER VIEW rls_view OWNER TO regress_rls_bob;
GRANT SELECT ON rls_view TO regress_rls_alice;
SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM ref_tbl; -- Permission deniedSELECT * FROM rls_tbl; -- Permission deniedSELECT * FROM rls_view; -- OKRESET SESSION AUTHORIZATION;
ANALYZE rls_tbl;
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
GRANT SELECT ON rls_tbl TO regress_rls_alice;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE FUNCTION op_leak(int, int) RETURNS bool    AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2; RETURN $1 < $2; END'    LANGUAGE plpgsql;
CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,                     restrict = scalarltsel);
SELECT * FROM rls_tbl WHERE a <<< 1000;
DROP OPERATOR <<< (int, int);
DROP FUNCTION op_leak(int, int);
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY p1 ON rls_tbl USING (rls_tbl >= ROW(1,1,1));
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_tbl FORCE ROW LEVEL SECURITY;
EXPLAIN (VERBOSE, COSTS OFF)INSERT INTO rls_tbl  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
RESET SESSION AUTHORIZATION;
RESET SESSION AUTHORIZATION;
DROP SCHEMA regress_rls_schema CASCADE;
DROP USER regress_rls_alice;
DROP USER regress_rls_bob;
DROP USER regress_rls_carol;
DROP USER regress_rls_dave;
DROP USER regress_rls_exempt_user;
DROP ROLE regress_rls_group1;
DROP ROLE regress_rls_group2;
CREATE SCHEMA regress_rls_schema;
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON rls_tbl USING (c1 > 5);
CREATE POLICY p2 ON rls_tbl FOR SELECT USING (c1 <= 3);
CREATE POLICY p3 ON rls_tbl FOR UPDATE USING (c1 <= 3) WITH CHECK (c1 > 5);
CREATE POLICY p4 ON rls_tbl FOR DELETE USING (c1 <= 3);
ALTER TABLE rls_tbl_force ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_tbl_force FORCE ROW LEVEL SECURITY;
CREATE POLICY p1 ON rls_tbl_force USING (c1 = 5) WITH CHECK (c1 < 5);
CREATE POLICY p2 ON rls_tbl_force FOR SELECT USING (c1 = 8);
CREATE POLICY p3 ON rls_tbl_force FOR UPDATE USING (c1 = 8) WITH CHECK (c1 >= 5);
CREATE POLICY p4 ON rls_tbl_force FOR DELETE USING (c1 = 8);
CREATE FUNCTION alter_op_test_fn(boolean, boolean)RETURNS boolean AS $$ SELECT NULL::BOOLEAN; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION customcontsel(internal, oid, internal, integer)RETURNS float8 AS 'contsel' LANGUAGE internal STABLE STRICT;
CREATE OPERATOR === (    LEFTARG = boolean,    RIGHTARG = boolean,    PROCEDURE = alter_op_test_fn,    COMMUTATOR = ===,    NEGATOR = !==,    RESTRICT = customcontsel,    JOIN = contjoinsel,    HASHES, MERGES);
SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptypeFROM pg_dependWHERE classid = 'pg_operator'::regclass AND      objid = '===(bool,bool)'::regoperatorORDER BY 1;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = NONE);
::SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptypeFROM pg_dependWHERE classid = 'pg_operator'::regclass AND      objid = '===(bool,bool)'::regoperatorORDER BY 1;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = contsel);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = contjoinsel);
::SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptypeFROM pg_dependWHERE classid = 'pg_operator'::regclass AND      objid = '===(bool,bool)'::regoperatorORDER BY 1;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE, JOIN = NONE);
::SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptypeFROM pg_dependWHERE classid = 'pg_operator'::regclass AND      objid = '===(bool,bool)'::regoperatorORDER BY 1;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = customcontsel, JOIN = contjoinsel);
::SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptypeFROM pg_dependWHERE classid = 'pg_operator'::regclass AND      objid = '===(bool,bool)'::regoperatorORDER BY 1;
ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = ====);
ALTER OPERATOR === (boolean, boolean) SET (NEGATOR = ====);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = non_existent_func);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = non_existent_func);
ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = !==);
ALTER OPERATOR === (boolean, boolean) SET (NEGATOR = !==);
ALTER OPERATOR & (bit, bit) SET ("Restrict" = _int_contsel, "Join" = _int_contjoinsel);
CREATE USER regress_alter_op_user;
SET SESSION AUTHORIZATION regress_alter_op_user;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
RESET SESSION AUTHORIZATION;
DROP USER regress_alter_op_user;
DROP OPERATOR === (boolean, boolean);
DROP FUNCTION customcontsel(internal, oid, internal, integer);
DROP FUNCTION alter_op_test_fn(boolean, boolean);
set plan_cache_mode = force_generic_plan;
create table lp (a char) partition by list (a);
create table lp_default partition of lp default;
create table lp_ef partition of lp for values in ('e', 'f');
create table lp_ad partition of lp for values in ('a', 'd');
create table lp_bc partition of lp for values in ('b', 'c');
create table lp_g partition of lp for values in ('g');
create table lp_null partition of lp for values in (null);
explain (costs off) select * from lp;
explain (costs off) select * from lp where a > 'a' and a < 'd';
explain (costs off) select * from lp where a > 'a' and a <= 'd';
explain (costs off) select * from lp where a = 'a';
explain (costs off) select * from lp where 'a' = a;	/* commuted */explain (costs off) select * from lp where a is not null;
explain (costs off) select * from lp where a is null;
explain (costs off) select * from lp where a = 'a' or a = 'c';
explain (costs off) select * from lp where a is not null and (a = 'a' or a = 'c');
explain (costs off) select * from lp where a <> 'g';
explain (costs off) select * from lp where a <> 'a' and a <> 'd';
explain (costs off) select * from lp where a not in ('a', 'd');
create table coll_pruning (a text collate "C") partition by list (a);
create table coll_pruning_a partition of coll_pruning for values in ('a');
create table coll_pruning_b partition of coll_pruning for values in ('b');
create table coll_pruning_def partition of coll_pruning default;
explain (costs off) select * from coll_pruning where a collate "C" = 'a' collate "C";
explain (costs off) select * from coll_pruning where a collate "POSIX" = 'a' collate "POSIX";
create table rlp (a int, b varchar) partition by range (a);
create table rlp_default partition of rlp default partition by list (a);
create table rlp_default_default partition of rlp_default default;
create table rlp_default_10 partition of rlp_default for values in (10);
create table rlp_default_30 partition of rlp_default for values in (30);
create table rlp_default_null partition of rlp_default for values in (null);
create table rlp1 partition of rlp for values from (minvalue) to (1);
create table rlp2 partition of rlp for values from (1) to (10);
create table rlp3 (b varchar, a int) partition by list (b varchar_ops);
create table rlp3_default partition of rlp3 default;
create table rlp3abcd partition of rlp3 for values in ('ab', 'cd');
create table rlp3efgh partition of rlp3 for values in ('ef', 'gh');
create table rlp3nullxy partition of rlp3 for values in (null, 'xy');
alter table rlp attach partition rlp3 for values from (15) to (20);
create table rlp4 partition of rlp for values from (20) to (30) partition by range (a);
create table rlp4_default partition of rlp4 default;
create table rlp4_1 partition of rlp4 for values from (20) to (25);
create table rlp4_2 partition of rlp4 for values from (25) to (29);
create table rlp5 partition of rlp for values from (31) to (maxvalue) partition by range (a);
create table rlp5_default partition of rlp5 default;
create table rlp5_1 partition of rlp5 for values from (31) to (40);
explain (costs off) select * from rlp where a < 1;
explain (costs off) select * from rlp where 1 > a;	/* commuted */explain (costs off) select * from rlp where a <= 1;
explain (costs off) select * from rlp where a = 1;
explain (costs off) select * from rlp where a = 1::bigint;		/* same as above */explain (costs off) select * from rlp where a = 1::numeric;		/* no pruning */explain (costs off) select * from rlp where a <= 10;
explain (costs off) select * from rlp where a > 10;
explain (costs off) select * from rlp where a < 15;
explain (costs off) select * from rlp where a <= 15;
explain (costs off) select * from rlp where a > 15 and b = 'ab';
explain (costs off) select * from rlp where a = 16;
explain (costs off) select * from rlp where a = 16 and b in ('not', 'in', 'here');
explain (costs off) select * from rlp where a = 16 and b < 'ab';
explain (costs off) select * from rlp where a = 16 and b <= 'ab';
explain (costs off) select * from rlp where a = 16 and b is null;
explain (costs off) select * from rlp where a = 16 and b is not null;
explain (costs off) select * from rlp where a is null;
explain (costs off) select * from rlp where a is not null;
explain (costs off) select * from rlp where a > 30;
explain (costs off) select * from rlp where a = 30;	/* only default is scanned */explain (costs off) select * from rlp where a <= 31;
explain (costs off) select * from rlp where a = 1 or a = 7;
explain (costs off) select * from rlp where a = 1 or b = 'ab';
explain (costs off) select * from rlp where a > 20 and a < 27;
explain (costs off) select * from rlp where a = 29;
explain (costs off) select * from rlp where a >= 29;
explain (costs off) select * from rlp where a < 1 or (a > 20 and a < 25);
explain (costs off) select * from rlp where a = 20 or a = 40;
explain (costs off) select * from rlp3 where a = 20;   /* empty */explain (costs off) select * from rlp where a > 1 and a = 10;	/* only default */explain (costs off) select * from rlp where a > 1 and a >=15;	/* rlp3 onwards, including default */explain (costs off) select * from rlp where a = 1 and a = 3;	/* empty */explain (costs off) select * from rlp where (a = 1 and a = 3) or (a > 1 and a = 15);
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
create table mc3p_default partition of mc3p default;
create table mc3p0 partition of mc3p for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
create table mc3p1 partition of mc3p for values from (1, 1, 1) to (10, 5, 10);
create table mc3p2 partition of mc3p for values from (10, 5, 10) to (10, 10, 10);
create table mc3p3 partition of mc3p for values from (10, 10, 10) to (10, 10, 20);
create table mc3p4 partition of mc3p for values from (10, 10, 20) to (10, maxvalue, maxvalue);
create table mc3p5 partition of mc3p for values from (11, 1, 1) to (20, 10, 10);
create table mc3p6 partition of mc3p for values from (20, 10, 10) to (20, 20, 20);
create table mc3p7 partition of mc3p for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
explain (costs off) select * from mc3p where a = 1;
explain (costs off) select * from mc3p where a = 1 and abs(b) < 1;
explain (costs off) select * from mc3p where a = 1 and abs(b) = 1;
explain (costs off) select * from mc3p where a = 1 and abs(b) = 1 and c < 8;
explain (costs off) select * from mc3p where a = 10 and abs(b) between 5 and 35;
explain (costs off) select * from mc3p where a > 10;
explain (costs off) select * from mc3p where a >= 10;
explain (costs off) select * from mc3p where a < 10;
explain (costs off) select * from mc3p where a <= 10 and abs(b) < 10;
explain (costs off) select * from mc3p where a = 11 and abs(b) = 0;
explain (costs off) select * from mc3p where a = 20 and abs(b) = 10 and c = 100;
explain (costs off) select * from mc3p where a > 20;
explain (costs off) select * from mc3p where a >= 20;
explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20);
explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1;
explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1 or a = 1;
explain (costs off) select * from mc3p where a = 1 or abs(b) = 1 or c = 1;
explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 10);
explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 9);
create table mc2p (a int, b int) partition by range (a, b);
create table mc2p_default partition of mc2p default;
create table mc2p0 partition of mc2p for values from (minvalue, minvalue) to (1, minvalue);
create table mc2p1 partition of mc2p for values from (1, minvalue) to (1, 1);
create table mc2p2 partition of mc2p for values from (1, 1) to (2, minvalue);
create table mc2p3 partition of mc2p for values from (2, minvalue) to (2, 1);
create table mc2p4 partition of mc2p for values from (2, 1) to (2, maxvalue);
create table mc2p5 partition of mc2p for values from (2, maxvalue) to (maxvalue, maxvalue);
explain (costs off) select * from mc2p where a < 2;
explain (costs off) select * from mc2p where a = 2 and b < 1;
explain (costs off) select * from mc2p where a > 1;
explain (costs off) select * from mc2p where a = 1 and b > 1;
explain (costs off) select * from mc2p where a = 1 and b is null;
explain (costs off) select * from mc2p where a is null and b is null;
explain (costs off) select * from mc2p where a is null and b = 1;
explain (costs off) select * from mc2p where a is null;
explain (costs off) select * from mc2p where b is null;
create table boolpart (a bool) partition by list (a);
create table boolpart_default partition of boolpart default;
create table boolpart_t partition of boolpart for values in ('true');
create table boolpart_f partition of boolpart for values in ('false');
explain (costs off) select * from boolpart where a in (true, false);
explain (costs off) select * from boolpart where a = false;
explain (costs off) select * from boolpart where not a = false;
explain (costs off) select * from boolpart where a is true or a is not true;
explain (costs off) select * from boolpart where a is not true;
explain (costs off) select * from boolpart where a is not true and a is not false;
explain (costs off) select * from boolpart where a is unknown;
explain (costs off) select * from boolpart where a is not unknown;
create table boolrangep (a bool, b bool, c int) partition by range (a,b,c);
create table boolrangep_tf partition of boolrangep for values from ('true', 'false', 0) to ('true', 'false', 100);
create table boolrangep_ft partition of boolrangep for values from ('false', 'true', 0) to ('false', 'true', 100);
create table boolrangep_ff1 partition of boolrangep for values from ('false', 'false', 0) to ('false', 'false', 50);
create table boolrangep_ff2 partition of boolrangep for values from ('false', 'false', 50) to ('false', 'false', 100);
explain (costs off)  select * from boolrangep where not a and not b and c = 25;
create table coercepart (a varchar) partition by list (a);
create table coercepart_ab partition of coercepart for values in ('ab');
create table coercepart_bc partition of coercepart for values in ('bc');
create table coercepart_cd partition of coercepart for values in ('cd');
explain (costs off) select * from coercepart where a in ('ab', to_char(125, '999'));
explain (costs off) select * from coercepart where a ~ any ('{ab}');
explain (costs off) select * from coercepart where a !~ all ('{ab}');
explain (costs off) select * from coercepart where a ~ any ('{ab,bc}');
explain (costs off) select * from coercepart where a !~ all ('{ab,bc}');
explain (costs off) select * from coercepart where a = any ('{ab,bc}');
explain (costs off) select * from coercepart where a = any ('{ab,null}');
explain (costs off) select * from coercepart where a = any (null::text[]);
explain (costs off) select * from coercepart where a = all ('{ab}');
explain (costs off) select * from coercepart where a = all ('{ab,bc}');
explain (costs off) select * from coercepart where a = all ('{ab,null}');
explain (costs off) select * from coercepart where a = all (null::text[]);
CREATE TABLE part (a INT, b INT) PARTITION BY LIST (a);
CREATE TABLE part_p1 PARTITION OF part FOR VALUES IN (-2,-1,0,1,2);
CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);  -- failALTER TABLE part_rev DROP COLUMN c;
ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);  -- now it's okINSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM part p(x) ORDER BY x;
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = t1.b and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.c = t1.b and abs(t2.b) = 1 and t2.a = 1) s where t1.a = 1;
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = 1 and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
create table rp (a int) partition by range (a);
create table rp0 partition of rp for values from (minvalue) to (1);
create table rp1 partition of rp for values from (1) to (2);
create table rp2 partition of rp for values from (2) to (maxvalue);
explain (costs off) select * from rp where a <> 1;
explain (costs off) select * from rp where a <> 1 and a <> 2;
explain (costs off) select * from lp where a <> 'a';
explain (costs off) select * from lp where a <> 'a' and a is null;
explain (costs off) select * from lp where (a <> 'a' and a <> 'd') or a is null;
explain (costs off) select * from rlp where a = 15 and b <> 'ab' and b <> 'cd' and b <> 'xy' and b is not null;
create table coll_pruning_multi (a text) partition by range (substr(a, 1) collate "POSIX", substr(a, 1) collate "C");
create table coll_pruning_multi1 partition of coll_pruning_multi for values from ('a', 'a') to ('a', 'e');
create table coll_pruning_multi2 partition of coll_pruning_multi for values from ('a', 'e') to ('a', 'z');
create table coll_pruning_multi3 partition of coll_pruning_multi for values from ('b', 'a') to ('b', 'e');
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C";
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'a' collate "POSIX";
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C" and substr(a, 1) = 'a' collate "POSIX";
create table like_op_noprune (a text) partition by list (a);
create table like_op_noprune1 partition of like_op_noprune for values in ('ABC');
create table like_op_noprune2 partition of like_op_noprune for values in ('BCD');
explain (costs off) select * from like_op_noprune where a like '%BC';
create table lparted_by_int2 (a smallint) partition by list (a);
create table lparted_by_int2_1 partition of lparted_by_int2 for values in (1);
create table lparted_by_int2_16384 partition of lparted_by_int2 for values in (16384);
explain (costs off) select * from lparted_by_int2 where a = 100000000000000;
create table rparted_by_int2 (a smallint) partition by range (a);
create table rparted_by_int2_1 partition of rparted_by_int2 for values from (1) to (10);
create table rparted_by_int2_16384 partition of rparted_by_int2 for values from (10) to (16384);
explain (costs off) select * from rparted_by_int2 where a > 100000000000000;
create table rparted_by_int2_maxvalue partition of rparted_by_int2 for values from (16384) to (maxvalue);
explain (costs off) select * from rparted_by_int2 where a > 100000000000000;
drop table lp, coll_pruning, rlp, mc3p, mc2p, boolpart, boolrangep, rp, coll_pruning_multi, like_op_noprune, lparted_by_int2, rparted_by_int2;
create table hp (a int, b text) partition by hash (a part_test_int4_ops, b part_test_text_ops);
create table hp0 partition of hp for values with (modulus 4, remainder 0);
create table hp3 partition of hp for values with (modulus 4, remainder 3);
create table hp1 partition of hp for values with (modulus 4, remainder 1);
create table hp2 partition of hp for values with (modulus 4, remainder 2);
insert into hp values (null, null);
insert into hp values (1, null);
insert into hp values (null, 'xxx');
::explain (costs off) select * from hp where a = 1;
explain (costs off) select * from hp where b = 'xxx';
explain (costs off) select * from hp where a is null;
explain (costs off) select * from hp where b is null;
explain (costs off) select * from hp where a < 1 and b = 'xxx';
explain (costs off) select * from hp where a <> 1 and b = 'yyy';
explain (costs off) select * from hp where a <> 1 and b <> 'xxx';
explain (costs off) select * from hp where a is null and b is null;
explain (costs off) select * from hp where a = 1 and b is null;
explain (costs off) select * from hp where a = 1 and b = 'xxx';
explain (costs off) select * from hp where a is null and b = 'xxx';
explain (costs off) select * from hp where a = 2 and b = 'xxx';
explain (costs off) select * from hp where a = 1 and b = 'abcde';
explain (costs off) select * from hp where (a = 1 and b = 'abcde') or (a = 2 and b = 'xxx') or (a is null and b is null);
create table ab (a int not null, b int not null) partition by list (a);
create table ab_a2 partition of ab for values in(2) partition by list (b);
create table ab_a2_b1 partition of ab_a2 for values in (1);
create table ab_a2_b2 partition of ab_a2 for values in (2);
create table ab_a2_b3 partition of ab_a2 for values in (3);
create table ab_a1 partition of ab for values in(1) partition by list (b);
create table ab_a1_b1 partition of ab_a1 for values in (1);
create table ab_a1_b2 partition of ab_a1 for values in (2);
create table ab_a1_b3 partition of ab_a1 for values in (3);
create table ab_a3 partition of ab for values in(3) partition by list (b);
create table ab_a3_b1 partition of ab_a3 for values in (1);
create table ab_a3_b2 partition of ab_a3 for values in (2);
create table ab_a3_b3 partition of ab_a3 for values in (3);
set enable_indexonlyscan = off;
prepare ab_q1 (int, int, int) asselect * from ab where a between $1 and $2 and b <= $3;
explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 2, 3);
explain (analyze, costs off, summary off, timing off) execute ab_q1 (1, 2, 3);
deallocate ab_q1;
prepare ab_q1 (int, int) asselect a from ab where a between $1 and $2 and b < 3;
explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 2);
explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 4);
prepare ab_q2 (int, int) asselect a from ab where a between $1 and $2 and b < (select 3);
explain (analyze, costs off, summary off, timing off) execute ab_q2 (2, 2);
prepare ab_q3 (int, int) asselect a from ab where b between $1 and $2 and a < (select 3);
explain (analyze, costs off, summary off, timing off) execute ab_q3 (2, 2);
create table list_part (a int) partition by list (a);
create table list_part1 partition of list_part for values in (1);
create table list_part2 partition of list_part for values in (2);
create table list_part3 partition of list_part for values in (3);
create table list_part4 partition of list_part for values in (4);
begin;
declare cur SCROLL CURSOR for select 1 from list_part where a > (select 1) and a < (select 4);
move 3 from cur;
fetch backward all from cur;
commit;
begin;
create function list_part_fn(int) returns int as $$ begin return $1; end;$$ language plpgsql stable;
explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(1);
explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(a);
explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(1) + a;
rollback;
create function explain_parallel_append(text) returns setof textlanguage plpgsql as$$declare    ln text;
begin    for ln in        execute format('explain (analyze, costs off, summary off, timing off) %s',            $1)    loop        return next ln;
    end loop;
end;
$$;
prepare ab_q4 (int, int) asselect avg(a) from ab where a between $1 and $2 and b < 4;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set min_parallel_table_scan_size = 0;
set max_parallel_workers_per_gather = 2;
prepare ab_q5 (int, int, int) asselect avg(a) from ab where a in($1,$2,$3) and b < 4;
analyze lprt_a;
set enable_hashjoin = 0;
set enable_mergejoin = 0;
delete from lprt_a where a = 1;
reset enable_hashjoin;
reset enable_mergejoin;
reset parallel_setup_cost;
reset parallel_tuple_cost;
reset min_parallel_table_scan_size;
reset max_parallel_workers_per_gather;
explain (analyze, costs off, summary off, timing off)select * from ab where a = (select max(a) from lprt_a) and b = (select max(a)-1 from lprt_a);
explain (analyze, costs off, summary off, timing off)select * from (select * from ab where a = 1 union all select * from ab) ab where b = (select 1);
explain (analyze, costs off, summary off, timing off)select * from (select * from ab where a = 1 union all (values(10,5)) union all select * from ab) ab where b = (select 1);
set enable_bitmapscan = 0;
set enable_indexscan = 0;
prepare ab_q6 asselect * from (	select tableoid::regclass,a,b from abunion all	select tableoid::regclass,x,y from xy_1union all	select tableoid::regclass,a,b from ab) ab where a = $1 and b = (select -10);
explain (analyze, costs off, summary off, timing off) execute ab_q6(1);
execute ab_q6(100);
reset enable_bitmapscan;
reset enable_indexscan;
deallocate ab_q1;
deallocate ab_q2;
deallocate ab_q3;
deallocate ab_q4;
deallocate ab_q5;
deallocate ab_q6;
explain (analyze, costs off, summary off, timing off)update ab_a1 set b = 3 from ab where ab.a = 1 and ab.a = ab_a1.a;
table ab;
truncate ab;
explain (analyze, costs off, summary off, timing off)update ab_a1 set b = 3 from ab_a2 where ab_a2.b = (select 1);
::drop table ab, lprt_a;
create table tprt (col1 int) partition by range (col1);
create table tprt_1 partition of tprt for values from (1) to (501);
create table tprt_2 partition of tprt for values from (501) to (1001);
create table tprt_3 partition of tprt for values from (1001) to (2001);
create table tprt_4 partition of tprt for values from (2001) to (3001);
create table tprt_5 partition of tprt for values from (3001) to (4001);
create table tprt_6 partition of tprt for values from (4001) to (5001);
set enable_hashjoin = off;
set enable_mergejoin = off;
explain (analyze, costs off, summary off, timing off)select * from tbl1 join tprt on tbl1.col1 > tprt.col1;
explain (analyze, costs off, summary off, timing off)select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
select tbl1.col1, tprt.col1 from tbl1inner join tprt on tbl1.col1 > tprt.col1order by tbl1.col1, tprt.col1;
select tbl1.col1, tprt.col1 from tbl1inner join tprt on tbl1.col1 = tprt.col1order by tbl1.col1, tprt.col1;
explain (analyze, costs off, summary off, timing off)select * from tbl1 inner join tprt on tbl1.col1 > tprt.col1;
explain (analyze, costs off, summary off, timing off)select * from tbl1 inner join tprt on tbl1.col1 = tprt.col1;
select tbl1.col1, tprt.col1 from tbl1inner join tprt on tbl1.col1 > tprt.col1order by tbl1.col1, tprt.col1;
select tbl1.col1, tprt.col1 from tbl1inner join tprt on tbl1.col1 = tprt.col1order by tbl1.col1, tprt.col1;
delete from tbl1;
explain (analyze, costs off, summary off, timing off)select * from tbl1 join tprt on tbl1.col1 < tprt.col1;
select tbl1.col1, tprt.col1 from tbl1inner join tprt on tbl1.col1 < tprt.col1order by tbl1.col1, tprt.col1;
delete from tbl1;
explain (analyze, costs off, summary off, timing off)select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
select tbl1.col1, tprt.col1 from tbl1inner join tprt on tbl1.col1 = tprt.col1order by tbl1.col1, tprt.col1;
drop table tbl1, tprt;
create table part_abc (a int not null, b int not null, c int not null) partition by list (a);
create table part_bac (b int not null, a int not null, c int not null) partition by list (b);
create table part_cab (c int not null, a int not null, b int not null) partition by list (c);
alter table part_abc attach partition part_bac for values in(1);
alter table part_bac attach partition part_cab for values in(2);
alter table part_cab attach partition part_abc_p1 for values in(3);
prepare part_abc_q1 (int, int, int) asselect * from part_abc where a = $1 and b = $2 and c = $3;
explain (analyze, costs off, summary off, timing off) execute part_abc_q1 (1, 2, 3);
deallocate part_abc_q1;
create table listp (a int, b int) partition by list (a);
create table listp_1 partition of listp for values in(1) partition by list (b);
create table listp_1_1 partition of listp_1 for values in(1);
create table listp_2 partition of listp for values in(2) partition by list (b);
create table listp_2_1 partition of listp_2 for values in(2);
prepare q1 (int,int) as select * from listp where b in ($1,$2);
explain (analyze, costs off, summary off, timing off)  execute q1 (1,1);
explain (analyze, costs off, summary off, timing off)  execute q1 (2,2);
explain (analyze, costs off, summary off, timing off)  execute q1 (0,0);
deallocate q1;
prepare q1 (int,int,int,int) as select * from listp where b in($1,$2) and $3 <> b and $4 <> b;
explain (analyze, costs off, summary off, timing off)  execute q1 (1,2,2,0);
explain (analyze, costs off, summary off, timing off)  execute q1 (1,2,2,1);
explain (analyze, costs off, summary off, timing off)select * from listp where a = (select null::int);
create table stable_qual_pruning (a timestamp) partition by range (a);
create table stable_qual_pruning1 partition of stable_qual_pruning  for values from ('2000-01-01') to ('2000-02-01');
create table stable_qual_pruning2 partition of stable_qual_pruning  for values from ('2000-02-01') to ('2000-03-01');
create table stable_qual_pruning3 partition of stable_qual_pruning  for values from ('3000-02-01') to ('3000-03-01');
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning where a < localtimestamp;
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning where a < '2000-02-01'::timestamptz;
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning  where a = any(array['2010-02-01', '2020-01-01']::timestamp[]);
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning  where a = any(array['2000-02-01', '2010-01-01']::timestamp[]);
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning  where a = any(array['2000-02-01', localtimestamp]::timestamp[]);
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning  where a = any(array['2010-02-01', '2020-01-01']::timestamptz[]);
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning  where a = any(array['2000-02-01', '2010-01-01']::timestamptz[]);
explain (analyze, costs off, summary off, timing off)select * from stable_qual_pruning  where a = any(null::timestamptz[]);
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
create table mc3p0 partition of mc3p  for values from (0, 0, 0) to (0, maxvalue, maxvalue);
create table mc3p1 partition of mc3p  for values from (1, 1, 1) to (2, minvalue, minvalue);
create table mc3p2 partition of mc3p  for values from (2, minvalue, minvalue) to (3, maxvalue, maxvalue);
explain (analyze, costs off, summary off, timing off)select * from mc3p where a < 3 and abs(b) = 1;
prepare ps1 as  select * from mc3p where a = $1 and abs(b) < (select 3);
explain (analyze, costs off, summary off, timing off)execute ps1(1);
deallocate ps1;
prepare ps2 as  select * from mc3p where a <= $1 and abs(b) < (select 3);
explain (analyze, costs off, summary off, timing off)execute ps2(1);
deallocate ps2;
create table boolvalues (value bool not null);
create table boolp (a bool) partition by list (a);
create table boolp_t partition of boolp for values in('t');
create table boolp_f partition of boolp for values in('f');
explain (analyze, costs off, summary off, timing off)select * from boolp where a = (select value from boolvalues where value);
explain (analyze, costs off, summary off, timing off)select * from boolp where a = (select value from boolvalues where not value);
set enable_seqscan = off;
set enable_sort = off;
create table ma_test (a int, b int) partition by range (a);
create table ma_test_p1 partition of ma_test for values from (0) to (10);
create table ma_test_p2 partition of ma_test for values from (10) to (20);
create table ma_test_p3 partition of ma_test for values from (20) to (30);
insert into ma_test select x,x from generate_series(0,29) t(x);
create index on ma_test (b);
analyze ma_test;
prepare mt_q1 (int) as select a from ma_test where a >= $1 and a % 10 = 5 order by b;
explain (analyze, costs off, summary off, timing off) execute mt_q1(15);
execute mt_q1(15);
explain (analyze, costs off, summary off, timing off) execute mt_q1(25);
execute mt_q1(25);
explain (analyze, costs off, summary off, timing off) execute mt_q1(35);
execute mt_q1(35);
deallocate mt_q1;
explain (analyze, costs off, summary off, timing off) select * from ma_test where a >= (select min(b) from ma_test_p2) order by b;
reset enable_seqscan;
reset enable_sort;
reset enable_indexonlyscan;
create table pp_arrpart (a int[]) partition by list (a);
create table pp_arrpart1 partition of pp_arrpart for values in ('{1}');
create table pp_arrpart2 partition of pp_arrpart for values in ('{2, 3}', '{4, 5}');
explain (costs off) select * from pp_arrpart where a = '{1}';
explain (costs off) select * from pp_arrpart where a = '{1, 2}';
explain (costs off) select * from pp_arrpart where a in ('{4, 5}', '{1}');
explain (costs off) update pp_arrpart set a = a where a = '{1}';
explain (costs off) delete from pp_arrpart where a = '{1}';
create table pph_arrpart (a int[]) partition by hash (a);
create table pph_arrpart1 partition of pph_arrpart for values with (modulus 2, remainder 0);
create table pph_arrpart2 partition of pph_arrpart for values with (modulus 2, remainder 1);
::explain (costs off) select * from pph_arrpart where a = '{1}';
explain (costs off) select * from pph_arrpart where a = '{1, 2}';
explain (costs off) select * from pph_arrpart where a in ('{4, 5}', '{1}');
create type pp_colors as enum ('green', 'blue', 'black');
create table pp_enumpart (a pp_colors) partition by list (a);
create table pp_enumpart_green partition of pp_enumpart for values in ('green');
create table pp_enumpart_blue partition of pp_enumpart for values in ('blue');
explain (costs off) select * from pp_enumpart where a = 'blue';
explain (costs off) select * from pp_enumpart where a = 'black';
drop type pp_colors;
create type pp_rectype as (a int, b int);
create table pp_recpart (a pp_rectype) partition by list (a);
create table pp_recpart_11 partition of pp_recpart for values in ('(1,1)');
create table pp_recpart_23 partition of pp_recpart for values in ('(2,3)');
explain (costs off) select * from pp_recpart where a = '(1,1)'::pp_rectype;
explain (costs off) select * from pp_recpart where a = '(1,2)'::pp_rectype;
drop type pp_rectype;
create table pp_intrangepart (a int4range) partition by list (a);
create table pp_intrangepart12 partition of pp_intrangepart for values in ('[1,2]');
create table pp_intrangepart2inf partition of pp_intrangepart for values in ('[2,)');
explain (costs off) select * from pp_intrangepart where a = '[1,2]'::int4range;
explain (costs off) select * from pp_intrangepart where a = '(1,2)'::int4range;
create table pp_lp (a int, value int) partition by list (a);
create table pp_lp1 partition of pp_lp for values in(1);
create table pp_lp2 partition of pp_lp for values in(2);
explain (costs off) select * from pp_lp where a = 1;
explain (costs off) update pp_lp set value = 10 where a = 1;
explain (costs off) delete from pp_lp where a = 1;
set enable_partition_pruning = off;
set constraint_exclusion = 'partition'; -- this should not affect the result.explain (costs off) select * from pp_lp where a = 1;
explain (costs off) update pp_lp set value = 10 where a = 1;
explain (costs off) delete from pp_lp where a = 1;
set constraint_exclusion = 'off'; -- this should not affect the result.explain (costs off) select * from pp_lp where a = 1;
explain (costs off) update pp_lp set value = 10 where a = 1;
explain (costs off) delete from pp_lp where a = 1;
create table inh_lp1 (a int, value int, check(a = 1)) inherits (inh_lp);
create table inh_lp2 (a int, value int, check(a = 2)) inherits (inh_lp);
set constraint_exclusion = 'partition';
explain (costs off) select * from inh_lp where a = 1;
explain (costs off) update inh_lp set value = 10 where a = 1;
explain (costs off) delete from inh_lp where a = 1;
explain (costs off) update inh_lp1 set value = 10 where a = 2;
drop table inh_lp cascade;
reset enable_partition_pruning;
reset constraint_exclusion;
create temp table pp_temp_parent (a int) partition by list (a);
create temp table pp_temp_part_1 partition of pp_temp_parent for values in (1);
create temp table pp_temp_part_def partition of pp_temp_parent default;
explain (costs off) select * from pp_temp_parent where true;
explain (costs off) select * from pp_temp_parent where a = 2;
create temp table p (a int, b int, c int) partition by list (a);
create temp table p1 partition of p for values in (1);
create temp table p2 partition of p for values in (2);
create temp table q (a int, b int, c int) partition by list (a);
create temp table q1 partition of q for values in (1) partition by list (b);
create temp table q11 partition of q1 for values in (1) partition by list (c);
create temp table q111 partition of q11 for values in (1);
create temp table q2 partition of q for values in (2) partition by list (b);
create temp table q21 partition of q2 for values in (1);
create temp table q22 partition of q2 for values in (2);
explain (costs off)select *from (      select * from p      union all      select * from q1      union all      select 1, 1, 1     ) s(a, b, c)where s.a = 1 and s.b = 1 and s.c = (select 1);
select *from (      select * from p      union all      select * from q1      union all      select 1, 1, 1     ) s(a, b, c)where s.a = 1 and s.b = 1 and s.c = (select 1);
prepare q (int, int) asselect *from (      select * from p      union all      select * from q1      union all      select 1, 1, 1     ) s(a, b, c)where s.a = $1 and s.b = $2 and s.c = (select 1);
explain (costs off) execute q (1, 1);
execute q (1, 1);
drop table p, q;
create table listp (a int, b int) partition by list (a);
create table listp1 partition of listp for values in(1);
create table listp2 partition of listp for values in(2) partition by list(b);
create table listp2_10 partition of listp2 for values in (10);
explain (analyze, costs off, summary off, timing off)select * from listp where a = (select 2) and b <> 10;
set enable_partition_pruning to off;
set constraint_exclusion to 'partition';
explain (costs off) select * from listp1 where a = 2;
explain (costs off) update listp1 set a = 1 where a = 2;
set constraint_exclusion to 'on';
explain (costs off) select * from listp1 where a = 2;
explain (costs off) update listp1 set a = 1 where a = 2;
reset constraint_exclusion;
reset enable_partition_pruning;
create table copydml_test (id serial, t text);
copy (insert into copydml_test (t) values ('f') returning id) to stdout;
copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
copy (delete from copydml_test where t = 'g' returning id) to stdout;
\\copy (insert into copydml_test (t) values ('f') returning id) to stdout;
\\copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
\\copy (delete from copydml_test where t = 'g' returning id) to stdout;
copy (insert into copydml_test default values) to stdout;
copy (update copydml_test set t = 'g') to stdout;
copy (delete from copydml_test) to stdout;
create rule qqq as on insert to copydml_test do instead nothing;
copy (insert into copydml_test default values) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do also delete from copydml_test;
copy (insert into copydml_test default values) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do instead (delete from copydml_test; delete from copydml_test);
copy (insert into copydml_test default values) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test where new.t <> 'f' do instead delete from copydml_test;
copy (insert into copydml_test default values) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do instead nothing;
copy (update copydml_test set t = 'f') to stdout;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do also delete from copydml_test;
copy (update copydml_test set t = 'f') to stdout;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do instead (delete from copydml_test; delete from copydml_test);
copy (update copydml_test set t = 'f') to stdout;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test where new.t <> 'f' do instead delete from copydml_test;
copy (update copydml_test set t = 'f') to stdout;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do instead nothing;
copy (delete from copydml_test) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do also insert into copydml_test default values;
copy (delete from copydml_test) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do instead (insert into copydml_test default values; insert into copydml_test default values);
copy (delete from copydml_test) to stdout;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test where old.t <> 'f' do instead insert into copydml_test default values;
copy (delete from copydml_test) to stdout;
drop rule qqq on copydml_test;
create function qqq_trig() returns trigger as $$beginif tg_op in ('INSERT', 'UPDATE') then    raise notice '% %', tg_op, new.id;
    return new;
else    raise notice '% %', tg_op, old.id;
    return old;
end if;
end$$ language plpgsql;
create trigger qqqbef before insert or update or delete on copydml_test    for each row execute procedure qqq_trig();
create trigger qqqaf after insert or update or delete on copydml_test    for each row execute procedure qqq_trig();
copy (insert into copydml_test (t) values ('f') returning id) to stdout;
copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
copy (delete from copydml_test where t = 'g' returning id) to stdout;
drop function qqq_trig();
VACUUM;
\\a\tSELECT relname, relhasindex   FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace   WHERE relkind IN ('r', 'p') AND (nspname ~ '^pg_temp_') IS NOT TRUE   ORDER BY relname;
\\a\tSELECT relname, nspname FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace JOIN pg_attribute a ON (attrelid = c.oid AND attname = 'oid') WHERE relkind = 'r' and c.oid < 16384     AND ((nspname ~ '^pg_') IS NOT FALSE)     AND NOT EXISTS (SELECT 1 FROM pg_index i WHERE indrelid = c.oid                     AND indkey[0] = a.attnum AND indnatts = 1                     AND indisunique AND indimmediate);
SELECT relname, relkind  FROM pg_class WHERE relkind IN ('v', 'c', 'f', 'p', 'I')       AND relfilenode <> 0;
::::::::::::::create temp table snapshot_test (	nr	integer,	snap	txid_snapshot);
select id, txid_visible_in_snapshot(id, snap)from snapshot_test, generate_series(11, 21) idwhere nr = 2;
select id, txid_visible_in_snapshot(id, snap)from snapshot_test, generate_series(90, 160) idwhere nr = 4;
select txid_snapshot '1000100010001000:1000100010001100:1000100010001012,1000100010001013';
SELECT txid_snapshot '1:9223372036854775807:3';
SELECT txid_snapshot '1:9223372036854775808:3';
BEGIN;
\SELECT txid_current() \gsetSELECT txid_current_if_assigned() IS NOT DISTINCT FROM BIGINT :'txid_current';
COMMIT;
BEGIN;
\SELECT txid_current() AS committed \gsetCOMMIT;
BEGIN;
\SELECT txid_current() AS rolledback \gsetROLLBACK;
BEGIN;
\SELECT txid_current() AS inprogress \gsetSELECT txid_status(:committed) AS committed;
::SELECT txid_status(1); -- BootstrapTransactionId is always committedSELECT txid_status(2); -- FrozenTransactionId is always committedSELECT txid_status(3); -- in regress testing FirstNormalTransactionId will always be behind oldestXminCOMMIT;
BEGIN;
CREATE FUNCTION test_future_xid_status(bigint)RETURNS voidLANGUAGE plpgsqlAS$$BEGIN  PERFORM txid_status($1);
  RAISE EXCEPTION 'didn''t ERROR at xid in the future as expected';
EXCEPTION  WHEN invalid_parameter_value THEN    RAISE NOTICE 'Got expected error for xid in the future';
END;
$$;
:ROLLBACK;
CREATE TABLE BIT_TABLE(b BIT(11));
INSERT INTO BIT_TABLE VALUES (B'10'); -- too shortINSERT INTO BIT_TABLE VALUES (B'00000000000');
INSERT INTO BIT_TABLE VALUES (B'11011000000');
INSERT INTO BIT_TABLE VALUES (B'01010101010');
INSERT INTO BIT_TABLE VALUES (B'101011111010'); -- too longSELECT * FROM BIT_TABLE;
CREATE TABLE VARBIT_TABLE(v BIT VARYING(11));
INSERT INTO VARBIT_TABLE VALUES (B'');
INSERT INTO VARBIT_TABLE VALUES (B'0');
INSERT INTO VARBIT_TABLE VALUES (B'010101');
INSERT INTO VARBIT_TABLE VALUES (B'01010101010');
INSERT INTO VARBIT_TABLE VALUES (B'101011111010'); -- too longSELECT * FROM VARBIT_TABLE;
||SELECT b,       SUBSTRING(b FROM 2 FOR 4) AS sub_2_4,       SUBSTRING(b FROM 7 FOR 13) AS sub_7_13,       SUBSTRING(b FROM 6) AS sub_6       FROM BIT_TABLE;
SELECT v,       SUBSTRING(v FROM 2 FOR 4) AS sub_2_4,       SUBSTRING(v FROM 7 FOR 13) AS sub_7_13,       SUBSTRING(v FROM 6) AS sub_6       FROM VARBIT_TABLE;
CREATE TABLE varbit_table (a BIT VARYING(16), b BIT VARYING(16));
COPY varbit_table FROM stdin;
X0F	X10X1F	X11X2F	X12X3F	X13X8F	X04X000F	X0010X0123	XFFFFX2468	X2468XFA50	X05AFX1234	XFFF5\.SELECT a, b, ~a AS "~ a", a & b AS "a & b",       a | b AS "a | b", a # b AS "a # b" FROM varbit_table;
SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",        a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM varbit_table;
SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM varbit_table;
CREATE TABLE bit_table (a BIT(16), b BIT(16));
COPY bit_table FROM stdin;
X0F00	X1000X1F00	X1100X2F00	X1200X3F00	X1300X8F00	X0400X000F	X0010X0123	XFFFFX2468	X2468XFA50	X05AFX1234	XFFF5\.SELECT a,b,~a AS "~ a",a & b AS "a & b",	a|b AS "a | b", a # b AS "a # b" FROM bit_table;
SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",        a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM bit_table;
SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM bit_table;
select B'001' & B'10';
select B'0111' | B'011';
select B'0010' # B'011101';
SELECT POSITION(B'1010' IN B'0000101');   -- 0SELECT POSITION(B'1010' IN B'00001010');  -- 5SELECT POSITION(B'1010' IN B'00000101');  -- 0SELECT POSITION(B'1010' IN B'000001010');  -- 6SELECT POSITION(B'' IN B'00001010');  -- 1SELECT POSITION(B'0' IN B'');  -- 0SELECT POSITION(B'' IN B'');  -- 0SELECT POSITION(B'101101' IN B'001011011011011000');  -- 3SELECT POSITION(B'10110110' IN B'001011011011010');  -- 3SELECT POSITION(B'1011011011011' IN B'001011011011011');  -- 3SELECT POSITION(B'1011011011011' IN B'00001011011011011');  -- 5SELECT POSITION(B'11101011' IN B'11101011'); -- 1SELECT POSITION(B'11101011' IN B'011101011'); -- 2SELECT POSITION(B'11101011' IN B'00011101011'); -- 4SELECT POSITION(B'11101011' IN B'0000011101011'); -- 6SELECT POSITION(B'111010110' IN B'111010110'); -- 1SELECT POSITION(B'111010110' IN B'0111010110'); -- 2SELECT POSITION(B'111010110' IN B'000111010110'); -- 4SELECT POSITION(B'111010110' IN B'00000111010110'); -- 6SELECT POSITION(B'111010110' IN B'11101011'); -- 0SELECT POSITION(B'111010110' IN B'011101011'); -- 0SELECT POSITION(B'111010110' IN B'00011101011'); -- 0SELECT POSITION(B'111010110' IN B'0000011101011'); -- 0SELECT POSITION(B'111010110' IN B'111010110'); -- 1SELECT POSITION(B'111010110' IN B'0111010110'); -- 2SELECT POSITION(B'111010110' IN B'000111010110'); -- 4SELECT POSITION(B'111010110' IN B'00000111010110'); -- 6SELECT POSITION(B'111010110' IN B'000001110101111101011'); -- 0SELECT POSITION(B'111010110' IN B'0000001110101111101011'); -- 0SELECT POSITION(B'111010110' IN B'000000001110101111101011'); -- 0SELECT POSITION(B'111010110' IN B'00000000001110101111101011'); -- 0SELECT POSITION(B'111010110' IN B'0000011101011111010110'); -- 14SELECT POSITION(B'111010110' IN B'00000011101011111010110'); -- 15SELECT POSITION(B'111010110' IN B'0000000011101011111010110'); -- 17SELECT POSITION(B'111010110' IN B'000000000011101011111010110'); -- 19SELECT POSITION(B'000000000011101011111010110' IN B'000000000011101011111010110'); -- 1SELECT POSITION(B'00000000011101011111010110' IN B'000000000011101011111010110'); -- 2SELECT POSITION(B'0000000000011101011111010110' IN B'000000000011101011111010110'); -- 0CREATE TABLE BIT_SHIFT_TABLE(b BIT(16));
INSERT INTO BIT_SHIFT_TABLE VALUES (B'1101100000000000');
INSERT INTO BIT_SHIFT_TABLE SELECT b>>1 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>2 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>4 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>8 FROM BIT_SHIFT_TABLE;
SELECT POSITION(B'1101' IN b),       POSITION(B'11011' IN b),       b       FROM BIT_SHIFT_TABLE ;
SELECT b, b >> 1 AS bsr, b << 1 AS bsl       FROM BIT_SHIFT_TABLE ;
SELECT b, b >> 8 AS bsr8, b << 8 AS bsl8       FROM BIT_SHIFT_TABLE ;
::SELECT b::bit(15), b::bit(15) >> 1 AS bsr, b::bit(15) << 1 AS bsl       FROM BIT_SHIFT_TABLE ;
::SELECT b::bit(15), b::bit(15) >> 8 AS bsr8, b::bit(15) << 8 AS bsl8       FROM BIT_SHIFT_TABLE ;
CREATE TABLE VARBIT_SHIFT_TABLE(v BIT VARYING(20));
INSERT INTO VARBIT_SHIFT_TABLE VALUES (B'11011');
||INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0' AS BIT VARYING(6)) >>1 FROM VARBIT_SHIFT_TABLE;
||INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00' AS BIT VARYING(8)) >>2 FROM VARBIT_SHIFT_TABLE;
||INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0000' AS BIT VARYING(12)) >>4 FROM VARBIT_SHIFT_TABLE;
||INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00000000' AS BIT VARYING(20)) >>8 FROM VARBIT_SHIFT_TABLE;
SELECT POSITION(B'1101' IN v),       POSITION(B'11011' IN v),       v       FROM VARBIT_SHIFT_TABLE ;
SELECT v, v >> 1 AS vsr, v << 1 AS vsl       FROM VARBIT_SHIFT_TABLE ;
SELECT v, v >> 8 AS vsr8, v << 8 AS vsl8       FROM VARBIT_SHIFT_TABLE ;
SELECT get_bit(B'0101011000100', 10);
SELECT set_bit(B'0101011000100100', 15, 1);
SELECT set_bit(B'0101011000100100', 16, 1);	-- failSELECT overlay(B'0101011100' placing '001' from 2 for 3);
SELECT overlay(B'0101011100' placing '101' from 6);
SELECT overlay(B'0101011100' placing '001' from 11);
SELECT overlay(B'0101011100' placing '001' from 20);
CREATE TABLE bit_defaults(  b1 bit(4) DEFAULT '1001',  b2 bit(4) DEFAULT B'0101',  b3 bit varying(5) DEFAULT '1001',  b4 bit varying(5) DEFAULT B'0101');
TABLE bit_defaults;
SELECT size, pg_size_pretty(size), pg_size_pretty(-1 * size) FROM    (VALUES (10::bigint), (1000::bigint), (1000000::bigint),            (1000000000::bigint), (1000000000000::bigint),            (1000000000000000::bigint)) x(size);
SELECT size, pg_size_pretty(size), pg_size_pretty(-1 * size) FROM    (VALUES (10::numeric), (1000::numeric), (1000000::numeric),            (1000000000::numeric), (1000000000000::numeric),            (1000000000000000::numeric),            (10.5::numeric), (1000.5::numeric), (1000000.5::numeric),            (1000000000.5::numeric), (1000000000000.5::numeric),            (1000000000000000.5::numeric)) x(size);
SELECT size, pg_size_bytes(size) FROM    (VALUES ('1'), ('123bytes'), ('1kB'), ('1MB'), (' 1 GB'), ('1.5 GB '),            ('1TB'), ('3000 TB'), ('1e6 MB')) x(size);
SELECT size, pg_size_bytes(size) FROM    (VALUES ('1'), ('123bYteS'), ('1kb'), ('1mb'), (' 1 Gb'), ('1.5 gB '),            ('1tb'), ('3000 tb'), ('1e6 mb')) x(size);
SELECT size, pg_size_bytes(size) FROM    (VALUES ('-1'), ('-123bytes'), ('-1kb'), ('-1mb'), (' -1 Gb'), ('-1.5 gB '),            ('-1tb'), ('-3000 TB'), ('-10e-1 MB')) x(size);
SELECT size, pg_size_bytes(size) FROM     (VALUES ('-1.'), ('-1.kb'), ('-1. kb'), ('-0. gb'),             ('-.1'), ('-.1kb'), ('-.1 kb'), ('-.0 gb')) x(size);
SELECT pg_size_bytes('1 byte');  -- the singular "byte" is not supportedSELECT pg_size_bytes('');
/* If objects exist, return oids */CREATE ROLE regress_regrole_test;
/* If objects don't exist, raise errors. */DROP ROLE regress_regrole_test;
/* If objects don't exist, return NULL with no error. */SELECT to_regoper('||//');
create table gin_test_tbl(i int4[]) with (autovacuum_enabled = off);
create index gin_test_idx on gin_test_tbl using gin (i)  with (fastupdate = on, gin_pending_list_limit = 4096);
select gin_clean_pending_list('gin_test_idx')>10 as many; -- flush the fastupdate buffersinsert into gin_test_tbl select array[3, 1, g] from generate_series(1, 1000) g;
vacuum gin_test_tbl; -- flush the fastupdate buffersselect gin_clean_pending_list('gin_test_idx'); -- nothing to flushdelete from gin_test_tbl where i @> array[2];
vacuum gin_test_tbl;
alter index gin_test_idx set (fastupdate = off);
delete from gin_test_tbl where i @> array[2];
vacuum gin_test_tbl;
::SELECT '"\u"'::jsonpath;		-- ERROR, incomplete escapeSELECT '"\u00"'::jsonpath;		-- ERROR, incomplete escapeSELECT '"\u000g"'::jsonpath;	-- ERROR, g is not a hex digitSELECT '"\u0000"'::jsonpath;	-- OK, legal escapeSELECT '"\uaBcD"'::jsonpath;	-- OK, uppercase and lower case both OKselect '"\ud83d\ude04\ud83d\udc36"'::jsonpath as correct_in_utf8;
::select '"\ud83d\ud83d"'::jsonpath; -- 2 high surrogates in a rowselect '"\ude04\ud83d"'::jsonpath; -- surrogates in wrong orderselect '"\ud83dX"'::jsonpath; -- orphan high surrogateselect '"\ude04X"'::jsonpath; -- orphan low surrogateselect '"the Copyright \u00a9 sign"'::jsonpath as correct_in_utf8;
::select '"dollar \u0024 character"'::jsonpath as correct_everywhere;
::select '"dollar \\u0024 character"'::jsonpath as not_an_escape;
::select '"null \u0000 escape"'::jsonpath as not_unescaped;
::select '"null \\u0000 escape"'::jsonpath as not_an_escape;
::SELECT '$."\u"'::jsonpath;		-- ERROR, incomplete escapeSELECT '$."\u00"'::jsonpath;	-- ERROR, incomplete escapeSELECT '$."\u000g"'::jsonpath;	-- ERROR, g is not a hex digitSELECT '$."\u0000"'::jsonpath;	-- OK, legal escapeSELECT '$."\uaBcD"'::jsonpath;	-- OK, uppercase and lower case both OKselect '$."\ud83d\ude04\ud83d\udc36"'::jsonpath as correct_in_utf8;
::select '$."\ud83d\ud83d"'::jsonpath; -- 2 high surrogates in a rowselect '$."\ude04\ud83d"'::jsonpath; -- surrogates in wrong orderselect '$."\ud83dX"'::jsonpath; -- orphan high surrogateselect '$."\ude04X"'::jsonpath; -- orphan low surrogateselect '$."the Copyright \u00a9 sign"'::jsonpath as correct_in_utf8;
::select '$."dollar \u0024 character"'::jsonpath as correct_everywhere;
::select '$."dollar \\u0024 character"'::jsonpath as not_an_escape;
::select '$."null \u0000 escape"'::jsonpath as not_unescaped;
::select '$."null \\u0000 escape"'::jsonpath as not_an_escape;
CREATE TABLESPACE regress_tblspacewith LOCATION '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/testtablespace' WITH (some_nonexistent_parameter = true); -- failCREATE TABLESPACE regress_tblspacewith LOCATION '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/testtablespace' WITH (random_page_cost = 3.0); -- okSELECT spcoptions FROM pg_tablespace WHERE spcname = 'regress_tblspacewith';
DROP TABLESPACE regress_tblspacewith;
CREATE TABLESPACE regress_tblspace LOCATION '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/testtablespace';
ALTER TABLESPACE regress_tblspace SET (random_page_cost = 1.0, seq_page_cost = 1.1);
ALTER TABLESPACE regress_tblspace SET (some_nonexistent_parameter = true);  -- failALTER TABLESPACE regress_tblspace RESET (random_page_cost = 2.0); -- failALTER TABLESPACE regress_tblspace RESET (random_page_cost, effective_io_concurrency); -- okCREATE SCHEMA testschema;
CREATE TABLE testschema.foo (i int) TABLESPACE regress_tblspace;
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c    where c.reltablespace = t.oid AND c.relname = 'foo';
INSERT INTO testschema.foo VALUES(1);
INSERT INTO testschema.foo VALUES(2);
CREATE TABLE testschema.asselect TABLESPACE regress_tblspace AS SELECT 1;
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c    where c.reltablespace = t.oid AND c.relname = 'asselect';
PREPARE selectsource(int) AS SELECT $1;
CREATE TABLE testschema.asexecute TABLESPACE regress_tblspace    AS EXECUTE selectsource(2);
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c    where c.reltablespace = t.oid AND c.relname = 'asexecute';
CREATE INDEX foo_idx on testschema.foo(i) TABLESPACE regress_tblspace;
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c    where c.reltablespace = t.oid AND c.relname = 'foo_idx';
CREATE TABLE testschema.part (a int) PARTITION BY LIST (a);
SET default_tablespace TO pg_global;
CREATE TABLE testschema.part_1 PARTITION OF testschema.part FOR VALUES IN (1);
RESET default_tablespace;
CREATE TABLE testschema.part_1 PARTITION OF testschema.part FOR VALUES IN (1);
SET default_tablespace TO regress_tblspace;
CREATE TABLE testschema.part_2 PARTITION OF testschema.part FOR VALUES IN (2);
SET default_tablespace TO pg_global;
CREATE TABLE testschema.part_3 PARTITION OF testschema.part FOR VALUES IN (3);
ALTER TABLE testschema.part SET TABLESPACE regress_tblspace;
CREATE TABLE testschema.part_3 PARTITION OF testschema.part FOR VALUES IN (3);
CREATE TABLE testschema.part_4 PARTITION OF testschema.part FOR VALUES IN (4)  TABLESPACE pg_default;
CREATE TABLE testschema.part_56 PARTITION OF testschema.part FOR VALUES IN (5, 6)  PARTITION BY LIST (a);
ALTER TABLE testschema.part SET TABLESPACE pg_default;
CREATE TABLE testschema.part_78 PARTITION OF testschema.part FOR VALUES IN (7, 8)  PARTITION BY LIST (a);
CREATE TABLE testschema.part_910 PARTITION OF testschema.part FOR VALUES IN (9, 10)  PARTITION BY LIST (a) TABLESPACE regress_tblspace;
RESET default_tablespace;
CREATE TABLE testschema.part_78 PARTITION OF testschema.part FOR VALUES IN (7, 8)  PARTITION BY LIST (a);
SELECT relname, spcname FROM pg_catalog.pg_class c    JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid)    LEFT JOIN pg_catalog.pg_tablespace t ON c.reltablespace = t.oid    where c.relname LIKE 'part%' AND n.nspname = 'testschema' order by relname;
RESET default_tablespace;
DROP TABLE testschema.part;
CREATE TABLE testschema.part (a int) PARTITION BY LIST (a);
CREATE TABLE testschema.part1 PARTITION OF testschema.part FOR VALUES IN (1);
CREATE INDEX part_a_idx ON testschema.part (a) TABLESPACE regress_tblspace;
CREATE TABLE testschema.part2 PARTITION OF testschema.part FOR VALUES IN (2);
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c    where c.reltablespace = t.oid AND c.relname LIKE 'part%_idx';
CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE pg_default;
CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE pg_default) PARTITION BY LIST (a);
SET default_tablespace TO 'pg_default';
CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE regress_tblspace;
CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE regress_tblspace) PARTITION BY LIST (a);
CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE regress_tblspace) PARTITION BY LIST (a) TABLESPACE regress_tblspace;
SET default_tablespace TO '';
CREATE TABLE testschema.dflt2 (a int PRIMARY KEY) PARTITION BY LIST (a);
DROP TABLE testschema.dflt, testschema.dflt2;
CREATE TABLE testschema.test_default_tab(id bigint) TABLESPACE regress_tblspace;
INSERT INTO testschema.test_default_tab VALUES (1);
CREATE INDEX test_index1 on testschema.test_default_tab (id);
CREATE INDEX test_index2 on testschema.test_default_tab (id) TABLESPACE regress_tblspace;
ALTER TABLE testschema.test_default_tab ADD CONSTRAINT test_index3 PRIMARY KEY (id);
ALTER TABLE testschema.test_default_tab ADD CONSTRAINT test_index4 UNIQUE (id) USING INDEX TABLESPACE regress_tblspace;
SET default_tablespace TO regress_tblspace;
ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
SELECT * FROM testschema.test_default_tab;
ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
SELECT * FROM testschema.test_default_tab;
SET default_tablespace TO '';
ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
DROP TABLE testschema.test_default_tab;
CREATE TABLE testschema.test_default_tab_p(id bigint, val bigint)    PARTITION BY LIST (id) TABLESPACE regress_tblspace;
CREATE TABLE testschema.test_default_tab_p1 PARTITION OF testschema.test_default_tab_p    FOR VALUES IN (1);
INSERT INTO testschema.test_default_tab_p VALUES (1);
CREATE INDEX test_index1 on testschema.test_default_tab_p (val);
CREATE INDEX test_index2 on testschema.test_default_tab_p (val) TABLESPACE regress_tblspace;
ALTER TABLE testschema.test_default_tab_p ADD CONSTRAINT test_index3 PRIMARY KEY (id);
ALTER TABLE testschema.test_default_tab_p ADD CONSTRAINT test_index4 UNIQUE (id) USING INDEX TABLESPACE regress_tblspace;
SET default_tablespace TO regress_tblspace;
ALTER TABLE testschema.test_default_tab_p ALTER val TYPE bigint;
SELECT * FROM testschema.test_default_tab_p;
ALTER TABLE testschema.test_default_tab_p ALTER val TYPE int;
SELECT * FROM testschema.test_default_tab_p;
SET default_tablespace TO '';
ALTER TABLE testschema.test_default_tab_p ALTER val TYPE int;
ALTER TABLE testschema.test_default_tab_p ALTER val TYPE bigint;
DROP TABLE testschema.test_default_tab_p;
CREATE TABLE testschema.test_tab(id int) TABLESPACE regress_tblspace;
INSERT INTO testschema.test_tab VALUES (1);
SET default_tablespace TO regress_tblspace;
ALTER TABLE testschema.test_tab ADD CONSTRAINT test_tab_unique UNIQUE (id);
SET default_tablespace TO '';
ALTER TABLE testschema.test_tab ADD CONSTRAINT test_tab_pkey PRIMARY KEY (id);
SELECT * FROM testschema.test_tab;
DROP TABLE testschema.test_tab;
CREATE TABLE testschema.test_tab(a int, b int, c int);
SET default_tablespace TO regress_tblspace;
ALTER TABLE testschema.test_tab ADD CONSTRAINT test_tab_unique UNIQUE (a);
CREATE INDEX test_tab_a_idx ON testschema.test_tab (a);
SET default_tablespace TO '';
CREATE INDEX test_tab_b_idx ON testschema.test_tab (b);
ALTER TABLE testschema.test_tab ALTER b TYPE bigint, ADD UNIQUE (c);
DROP TABLE testschema.test_tab;
CREATE TABLE testschema.atable AS VALUES (1), (2);
CREATE UNIQUE INDEX anindex ON testschema.atable(column1);
ALTER TABLE testschema.atable SET TABLESPACE regress_tblspace;
ALTER INDEX testschema.anindex SET TABLESPACE regress_tblspace;
ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_global;
ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_default;
ALTER INDEX testschema.part_a_idx SET TABLESPACE regress_tblspace;
INSERT INTO testschema.atable VALUES(3);	-- okINSERT INTO testschema.atable VALUES(1);	-- fail (checks index)SELECT COUNT(*) FROM testschema.atable;		-- checks heapCREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
CREATE TABLE bar (i int) TABLESPACE regress_nosuchspace;
DROP TABLESPACE regress_tblspace;
CREATE ROLE regress_tablespace_user1 login;
CREATE ROLE regress_tablespace_user2 login;
GRANT USAGE ON SCHEMA testschema TO regress_tablespace_user2;
ALTER TABLESPACE regress_tblspace OWNER TO regress_tablespace_user1;
CREATE TABLE testschema.tablespace_acl (c int);
CREATE INDEX k ON testschema.tablespace_acl (c) TABLESPACE regress_tblspace;
ALTER TABLE testschema.tablespace_acl OWNER TO regress_tablespace_user2;
SET SESSION ROLE regress_tablespace_user2;
CREATE TABLE tablespace_table (i int) TABLESPACE regress_tblspace; -- failALTER TABLE testschema.tablespace_acl ALTER c TYPE bigint;
RESET ROLE;
ALTER TABLESPACE regress_tblspace RENAME TO regress_tblspace_renamed;
ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
ALTER INDEX ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
DROP TABLESPACE regress_tblspace_renamed;
DROP SCHEMA testschema CASCADE;
DROP ROLE regress_tablespace_user1;
DROP ROLE regress_tablespace_user2;
/* * This test is intended to pass on all platforms supported by Postgres. * We can therefore only assume that the default, C, and POSIX collations * are available --- and since the regression tests are often run in a * C-locale database, these may well all have the same behavior.  But * fortunately, the system doesn't know that and will treat them as * incompatible collations.  It is therefore at least possible to test * parser behaviors such as collation conflict resolution.  This test will, * however, be more revealing when run in a database with non-C locale, * since any departure from C sorting behavior will show as a failure. */CREATE SCHEMA collate_tests;
SET search_path = collate_tests;
CREATE TABLE collate_test1 (    a int,    b text COLLATE "C" NOT NULL);
CREATE TABLE collate_test_fail (    a int COLLATE "C",    b text);
CREATE TABLE collate_test_like (    LIKE collate_test1);
CREATE TABLE collate_test2 (    a int,    b text COLLATE "POSIX");
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc';
SELECT * FROM collate_test1 WHERE b >= 'abc' COLLATE "C";
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'abc' COLLATE "C";
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "POSIX"; -- failCREATE DOMAIN testdomain_p AS text COLLATE "POSIX";
CREATE DOMAIN testdomain_i AS int COLLATE "POSIX"; -- failCREATE TABLE collate_test4 (    a int,    b testdomain_p);
CREATE TABLE collate_test5 (    a int,    b testdomain_p COLLATE "C");
SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
SELECT 'bbc' COLLATE "C" > 'Abc' COLLATE "C" AS "true";
SELECT 'bbc' COLLATE "POSIX" < 'Abc' COLLATE "POSIX" AS "false";
CREATE TABLE collate_test10 (    a int,    x text COLLATE "C",    y text COLLATE "POSIX");
SELECT a, lower(x COLLATE "C"), lower(y COLLATE "C") FROM collate_test10;
SELECT a, x, y FROM collate_test10 ORDER BY lower(y), a;
CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
CREATE VIEW collview2 AS SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
||CREATE VIEW collview3 AS SELECT a, lower((x || x) COLLATE "POSIX") FROM collate_test10;
SELECT table_name, view_definition FROM information_schema.views  WHERE table_name LIKE 'collview%' ORDER BY 1;
CREATE DOMAIN testdomain AS text;
::::::::::SELECT array_agg(b ORDER BY b) FROM collate_test1;
SELECT array_agg(b ORDER BY b) FROM collate_test2;
SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;  -- failSELECT array_agg(x COLLATE "C" ORDER BY y COLLATE "POSIX") FROM collate_test10;
SELECT array_agg(a ORDER BY x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
SELECT array_agg(a ORDER BY x||y) FROM collate_test10;  -- failSELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test1 ORDER BY 2;
SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2 ORDER BY 2; -- failSELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- okSELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- failSELECT a, b COLLATE "C" FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2; -- okSELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test2 ORDER BY 2; -- failSELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test2 ORDER BY 2; -- failCREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- failselect x < y from collate_test10; -- failselect x || y from collate_test10; -- ok, because || is not collation awareselect x, y from collate_test10 order by x || y; -- not so okWITH RECURSIVE foo(x) AS   (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)   UNION ALL   SELECT (x || 'c') COLLATE "POSIX" FROM foo WHERE length(x) < 10)SELECT * FROM foo;
SELECT a, b, a < b as lt FROM  (VALUES ('a', 'B'), ('A', 'b' COLLATE "C")) v(a,b);
SELECT * FROM collate_test10 WHERE (x COLLATE "POSIX", y COLLATE "C") NOT IN (SELECT y, x FROM collate_test10);
SELECT * FROM collate_test10 WHERE (x, y) NOT IN (SELECT y COLLATE "C", x COLLATE "POSIX" FROM collate_test10);
SELECT CAST('42' AS text COLLATE "C");
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
CREATE FUNCTION dup (anyelement) RETURNS anyelement    AS 'select $1' LANGUAGE sql;
CREATE INDEX collate_test1_idx2 ON collate_test1 (b COLLATE "POSIX");
CREATE INDEX collate_test1_idx3 ON collate_test1 ((b COLLATE "POSIX")); -- this is different grammaticallyCREATE INDEX collate_test1_idx4 ON collate_test1 (((b||'foo') COLLATE "POSIX"));
CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "POSIX"); -- failCREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "POSIX")); -- failSELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
SET enable_seqscan TO 0;
SET enable_hashjoin TO 0;
SET enable_nestloop TO 0;
CREATE TABLE collate_test20 (f1 text COLLATE "C" PRIMARY KEY);
CREATE TABLE collate_test21 (f2 text COLLATE "POSIX" REFERENCES collate_test20);
INSERT INTO collate_test21 VALUES ('baz'); -- failCREATE TABLE collate_test22 (f2 text COLLATE "POSIX");
ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20; -- failDELETE FROM collate_test22 WHERE f2 = 'baz';
ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20;
RESET enable_seqscan;
RESET enable_hashjoin;
RESET enable_nestloop;
EXPLAIN (COSTS OFF)  SELECT * FROM collate_test10 ORDER BY x, y;
EXPLAIN (COSTS OFF)  SELECT * FROM collate_test10 ORDER BY x DESC, y COLLATE "C" ASC NULLS FIRST;
CREATE COLLATION mycoll1 FROM "C";
CREATE COLLATION mycoll2 ( LC_COLLATE = "POSIX", LC_CTYPE = "POSIX" );
CREATE COLLATION mycoll3 FROM "default";  -- intentionally unsupportedDROP COLLATION mycoll1;
CREATE TABLE collate_test23 (f1 text collate mycoll2);
DROP COLLATION mycoll2;  -- failCREATE COLLATION case_coll ("Lc_Collate" = "POSIX", "Lc_Ctype" = "POSIX");
INSERT INTO vctable VALUES ('foo' COLLATE "C");
SELECT collation for ('foo'); -- unknown type - nullSELECT collation for ('foo'::text);
SELECT collation for ((SELECT a FROM collate_test1 LIMIT 1)); -- non-collatable type - errorSELECT collation for ((SELECT b FROM collate_test1 LIMIT 1));
DROP SCHEMA collate_tests CASCADE;
/constraints.sql/copy.sql/create_function_1.sql/create_function_2.sql/largeobject.sql/misc.sql/security_label.sql/tablespace.sqlCREATE TABLE CASE_TBL (  i integer,  f double precision);
INSERT INTO CASE_TBL VALUES (4, NULL);
INSERT INTO CASE2_TBL VALUES (1, NULL);
INSERT INTO CASE2_TBL VALUES (NULL, -6);
SELECT COALESCE(a.f, b.i, b.j)  FROM CASE_TBL a, CASE2_TBL b;
SELECT *  FROM CASE_TBL a, CASE2_TBL b  WHERE COALESCE(a.f, b.i, b.j) = 2;
SELECT '' AS Five, NULLIF(a.i,b.i) AS "NULLIF(a.i,b.i)",  NULLIF(b.i, 4) AS "NULLIF(b.i,4)"  FROM CASE_TBL a, CASE2_TBL b;
SELECT '' AS "Two", *  FROM CASE_TBL a, CASE2_TBL b  WHERE COALESCE(f,b.i) = 2;
UPDATE CASE_TBL  SET i = CASE WHEN b.i >= 2 THEN (2 * j)                ELSE (3 * j) END  FROM CASE2_TBL b  WHERE j = -CASE_TBL.i;
BEGIN;
CREATE FUNCTION vol(text) returns text as  'begin return $1; end' language plpgsql volatile;
SELECT CASE  (CASE vol('bar')    WHEN 'foo' THEN 'it was foo!'    WHEN vol(null) THEN 'null input'    WHEN 'bar' THEN 'it was bar!' END  )  WHEN 'it was foo!' THEN 'foo recognized'  WHEN 'it was bar!' THEN 'bar recognized'  ELSE 'unrecognized' END;
CREATE DOMAIN foodomain AS text;
CREATE FUNCTION volfoo(text) returns foodomain as  'begin return $1::foodomain; end' language plpgsql volatile;
CREATE FUNCTION inline_eq(foodomain, foodomain) returns boolean as  'SELECT CASE $2::text WHEN $1::text THEN true ELSE false END' language sql;
CREATE OPERATOR = (procedure = inline_eq,                   leftarg = foodomain, rightarg = foodomain);
::SELECT CASE volfoo('bar') WHEN 'foo'::foodomain THEN 'is foo' ELSE 'is not foo' END;
ROLLBACK;
BEGIN;
CREATE DOMAIN arrdomain AS int[];
CREATE FUNCTION make_ad(int,int) returns arrdomain as  'declare x arrdomain;
   begin     x := array[$1,$2];
     return x;
   end' language plpgsql volatile;
CREATE FUNCTION ad_eq(arrdomain, arrdomain) returns boolean as  'begin return array_eq($1, $2); end' language plpgsql;
CREATE OPERATOR = (procedure = ad_eq,                   leftarg = arrdomain, rightarg = arrdomain);
::SELECT CASE make_ad(1,2)  WHEN array[2,4]::arrdomain THEN 'wrong'  WHEN array[2,5]::arrdomain THEN 'still wrong'  WHEN array[1,2]::arrdomain THEN 'right'  END;
ROLLBACK;
BEGIN;
CREATE TYPE casetestenum AS ENUM ('e', 'f', 'g');
::SELECT  CASE 'foo'::text    WHEN 'foo' THEN ARRAY['a', 'b', 'c', 'd'] || enum_range(NULL::casetestenum)::text[]    ELSE ARRAY['x', 'y']    END;
ROLLBACK;
SET password_encryption = 'novalue'; -- errorSET password_encryption = true; -- okSET password_encryption = 'md5'; -- okSET password_encryption = 'scram-sha-256'; -- okSET password_encryption = 'md5';
CREATE ROLE regress_passwd1 PASSWORD 'role_pwd1';
SET password_encryption = 'on';
CREATE ROLE regress_passwd2 PASSWORD 'role_pwd2';
SET password_encryption = 'scram-sha-256';
CREATE ROLE regress_passwd3 PASSWORD 'role_pwd3';
CREATE ROLE regress_passwd4 PASSWORD NULL;
    FROM pg_authid    WHERE rolname LIKE 'regress_passwd%'    ORDER BY rolname, rolpassword;
ALTER ROLE regress_passwd2 RENAME TO regress_passwd2_new;
SELECT rolname, rolpassword    FROM pg_authid    WHERE rolname LIKE 'regress_passwd2_new'    ORDER BY rolname, rolpassword;
ALTER ROLE regress_passwd2_new RENAME TO regress_passwd2;
SET password_encryption = 'md5';
ALTER ROLE regress_passwd2 PASSWORD 'foo';
ALTER ROLE regress_passwd1 PASSWORD 'md5cd3578025fe2c3d7ed1b9a9b26238b70';
ALTER ROLE regress_passwd3 PASSWORD 'SCRAM-SHA-256$4096:VLK4RMaQLCvNtQ==$6YtlR4t69SguDiwFvbVgVZtuz6gpJQQqUMZ7IQJK5yI=:ps75jrHeYU4lXCcXI4O8oIdJ3eO8o2jirjruw9phBTo=';
SET password_encryption = 'scram-sha-256';
ALTER ROLE  regress_passwd4 PASSWORD 'foo';
CREATE ROLE regress_passwd5 PASSWORD 'md5e73a4b11df52a6068f8b39f90be36023';
CREATE ROLE regress_passwd6 PASSWORD 'SCRAM-SHA-256$1234';
CREATE ROLE regress_passwd7 PASSWORD 'md5012345678901234567890123456789zz';
CREATE ROLE regress_passwd8 PASSWORD 'md501234567890123456789012345678901zz';
    FROM pg_authid    WHERE rolname LIKE 'regress_passwd%'    ORDER BY rolname, rolpassword;
CREATE ROLE regress_passwd_empty PASSWORD '';
ALTER ROLE regress_passwd_empty PASSWORD 'md585939a5ce845f1a1b620742e3c659e0a';
ALTER ROLE regress_passwd_empty PASSWORD 'SCRAM-SHA-256$4096:hpFyHTUsSWcR7O9P$LgZFIt6Oqdo27ZFKbZ2nV+vtnYM995pDh9ca6WSi120=:qVV5NeluNfUPkwm7Vqat25RjSPLkGeoZBQs6wVv+um4=';
CREATE ROLE regress_passwd_sha_len0 PASSWORD 'SCRAM-SHA-256$4096:A6xHKoH/494E941doaPOYg==$Ky+A30sewHIH3VHQLRN9vYsuzlgNyGNKCh37dy96Rqw=:COPdlNiIkrsacU5QoxydEuOH6e/KfiipeETb/bPw8ZI=';
CREATE ROLE regress_passwd_sha_len1 PASSWORD 'SCRAM-SHA-256$4096:A6xHKoH/494E941doaPOYg==$Ky+A30sewHIH3VHQLRN9vYsuzlgNyGNKCh37dy96RqwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=:COPdlNiIkrsacU5QoxydEuOH6e/KfiipeETb/bPw8ZI=';
CREATE ROLE regress_passwd_sha_len2 PASSWORD 'SCRAM-SHA-256$4096:A6xHKoH/494E941doaPOYg==$Ky+A30sewHIH3VHQLRN9vYsuzlgNyGNKCh37dy96Rqw=:COPdlNiIkrsacU5QoxydEuOH6e/KfiipeETb/bPw8ZIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=';
DROP ROLE regress_passwd1;
DROP ROLE regress_passwd2;
DROP ROLE regress_passwd3;
DROP ROLE regress_passwd4;
DROP ROLE regress_passwd5;
DROP ROLE regress_passwd6;
DROP ROLE regress_passwd7;
DROP ROLE regress_passwd8;
DROP ROLE regress_passwd_empty;
DROP ROLE regress_passwd_sha_len0;
DROP ROLE regress_passwd_sha_len1;
DROP ROLE regress_passwd_sha_len2;
SELECT rolname, rolpassword    FROM pg_authid    WHERE rolname LIKE 'regress_passwd%'    ORDER BY rolname, rolpassword;
CREATE ROLE regress_subscription_user LOGIN SUPERUSER;
CREATE ROLE regress_subscription_user2;
CREATE ROLE regress_subscription_user_dummy LOGIN NOSUPERUSER;
SET SESSION AUTHORIZATION 'regress_subscription_user';
CREATE SUBSCRIPTION regress_testsub CONNECTION 'foo';
CREATE SUBSCRIPTION regress_testsub PUBLICATION foo;
BEGIN;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub WITH (create_slot);
COMMIT;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo, testpub, foo WITH (connect = false);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
COMMENT ON SUBSCRIPTION regress_testsub IS 'test subscription';
SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
SET SESSION AUTHORIZATION 'regress_subscription_user2';
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo WITH (connect = false);
SET SESSION AUTHORIZATION 'regress_subscription_user';
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, copy_data = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, enabled = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, create_slot = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = false);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = false);
CREATE SUBSCRIPTION regress_testsub3 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, connect = false);
ALTER SUBSCRIPTION regress_testsub3 ENABLE;
ALTER SUBSCRIPTION regress_testsub3 REFRESH PUBLICATION;
DROP SUBSCRIPTION regress_testsub3;
ALTER SUBSCRIPTION regress_testsub CONNECTION 'foobar';
ALTER SUBSCRIPTION regress_testsub SET PUBLICATION testpub2, testpub3 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist2';
ALTER SUBSCRIPTION regress_testsub SET (slot_name = 'newname');
ALTER SUBSCRIPTION regress_doesnotexist CONNECTION 'dbname=regress_doesnotexist2';
ALTER SUBSCRIPTION regress_testsub SET (create_slot = false);
BEGIN;
ALTER SUBSCRIPTION regress_testsub ENABLE;
ALTER SUBSCRIPTION regress_testsub DISABLE;
COMMIT;
SET ROLE regress_subscription_user_dummy;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_dummy;
RESET ROLE;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_foo;
ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = local);
ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = foobar);
ALTER SUBSCRIPTION regress_testsub_foo RENAME TO regress_testsub;
ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user2;
ALTER ROLE regress_subscription_user2 SUPERUSER;
ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user2;
BEGIN;
DROP SUBSCRIPTION regress_testsub;
COMMIT;
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
BEGIN;
DROP SUBSCRIPTION regress_testsub;
COMMIT;
DROP SUBSCRIPTION IF EXISTS regress_testsub;
DROP SUBSCRIPTION regress_testsub;  -- failRESET SESSION AUTHORIZATION;
DROP ROLE regress_subscription_user;
DROP ROLE regress_subscription_user2;
DROP ROLE regress_subscription_user_dummy;
DELETE FROM vactst WHERE i != 0;
VACUUM FULL vactst;
DELETE FROM vactst WHERE i != 0;
VACUUM (FULL) vactst;
DELETE FROM vactst;
VACUUM (FULL, FREEZE) vactst;
VACUUM (ANALYZE, FULL) vactst;
ALTER TABLE vaccluster CLUSTER ON vaccluster_pkey;
CLUSTER vaccluster;
CREATE FUNCTION do_analyze() RETURNS VOID VOLATILE LANGUAGE SQL	AS 'ANALYZE pg_am';
CREATE FUNCTION wrap_do_analyze(c INT) RETURNS INT IMMUTABLE LANGUAGE SQL	AS 'SELECT $1 FROM do_analyze()';
CREATE INDEX ON vaccluster(wrap_do_analyze(i));
ANALYZE vaccluster;
DELETE FROM vactst WHERE i % 7 = 0; -- delete a few rows outsideBEGIN;
DELETE FROM vactst WHERE i % 5 <> 0; -- delete a few rows insideANALYZE vactst;
COMMIT;
VACUUM FULL pg_am;
VACUUM FULL pg_class;
VACUUM FULL pg_database;
VACUUM FULL vaccluster;
VACUUM FULL vactst;
VACUUM (DISABLE_PAGE_SKIPPING) vaccluster;
ALTER TABLE no_index_cleanup ALTER COLUMN t SET STORAGE EXTERNAL;
VACUUM (INDEX_CLEANUP TRUE, FULL TRUE) no_index_cleanup;
VACUUM (FULL TRUE) no_index_cleanup;
ALTER TABLE no_index_cleanup SET (vacuum_index_cleanup = false);
DELETE FROM no_index_cleanup WHERE i < 15;
VACUUM no_index_cleanup;
ALTER TABLE no_index_cleanup SET (vacuum_index_cleanup = true);
VACUUM no_index_cleanup;
DELETE FROM no_index_cleanup WHERE i < 45;
ALTER TABLE no_index_cleanup SET (vacuum_index_cleanup = false,    toast.vacuum_index_cleanup = true);
VACUUM no_index_cleanup;
ALTER TABLE no_index_cleanup SET (vacuum_index_cleanup = true,    toast.vacuum_index_cleanup = false);
VACUUM no_index_cleanup;
VACUUM (INDEX_CLEANUP FALSE) vaccluster;
VACUUM (INDEX_CLEANUP FALSE) vactst; -- index cleanup option is ignored if no indexesVACUUM (INDEX_CLEANUP FALSE, FREEZE TRUE) vaccluster;
CREATE TABLE vac_truncate_test(i INT NOT NULL, j text)	WITH (vacuum_truncate=true, autovacuum_enabled=false);
INSERT INTO vac_truncate_test VALUES (1, NULL), (NULL, NULL);
VACUUM (TRUNCATE FALSE) vac_truncate_test;
VACUUM vac_truncate_test;
VACUUM (TRUNCATE FALSE, FULL TRUE) vac_truncate_test;
CREATE TABLE vacparted (a int, b char) PARTITION BY LIST (a);
CREATE TABLE vacparted1 PARTITION OF vacparted FOR VALUES IN (1);
VACUUM (ANALYZE) vacparted;
VACUUM (FULL) vacparted;
VACUUM (FREEZE) vacparted;
VACUUM ANALYZE vacparted(a,b,a);
ANALYZE vacparted(a,b,b);
VACUUM vaccluster, vactst;
VACUUM vacparted, does_not_exist;
VACUUM (FREEZE) vacparted, vaccluster, vactst;
VACUUM (FREEZE) does_not_exist, vaccluster;
VACUUM ANALYZE vactst, vacparted (a);
VACUUM ANALYZE vactst (does_not_exist), vacparted (b);
VACUUM FULL vacparted, vactst;
VACUUM FULL vactst, vacparted (a, b), vaccluster (i);
ANALYZE vactst, vacparted;
ANALYZE vacparted (b), vactst;
ANALYZE vactst, does_not_exist, vacparted;
ANALYZE vactst (i), vacparted (does_not_exist);
ANALYZE vactst, vactst;
BEGIN;  -- ANALYZE behaves differently inside a transaction blockANALYZE vactst, vactst;
COMMIT;
ANALYZE (VERBOSE) does_not_exist;
ANALYZE (nonexistent-arg) does_not_exist;
ANALYZE (nonexistentarg) does_not_exit;
SET client_min_messages TO 'ERROR';
ANALYZE (SKIP_LOCKED, VERBOSE) does_not_exist;
ANALYZE (VERBOSE, SKIP_LOCKED) does_not_exist;
VACUUM (SKIP_LOCKED) vactst;
VACUUM (SKIP_LOCKED, FULL) vactst;
ANALYZE (SKIP_LOCKED) vactst;
RESET client_min_messages;
SET default_transaction_isolation = serializable;
VACUUM vactst;
ANALYZE vactst;
RESET default_transaction_isolation;
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
ANALYZE vactst;
COMMIT;
CREATE TABLE vacowned_parted (a int) PARTITION BY LIST (a);
CREATE TABLE vacowned_part1 PARTITION OF vacowned_parted FOR VALUES IN (1);
CREATE TABLE vacowned_part2 PARTITION OF vacowned_parted FOR VALUES IN (2);
CREATE ROLE regress_vacuum;
SET ROLE regress_vacuum;
VACUUM vacowned;
ANALYZE vacowned;
VACUUM (ANALYZE) vacowned;
VACUUM pg_catalog.pg_class;
ANALYZE pg_catalog.pg_class;
VACUUM (ANALYZE) pg_catalog.pg_class;
VACUUM pg_catalog.pg_authid;
ANALYZE pg_catalog.pg_authid;
VACUUM (ANALYZE) pg_catalog.pg_authid;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE vacowned_parted;
ANALYZE vacowned_part1;
ANALYZE vacowned_part2;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
ALTER TABLE vacowned_parted OWNER TO regress_vacuum;
ALTER TABLE vacowned_part1 OWNER TO regress_vacuum;
SET ROLE regress_vacuum;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE vacowned_parted;
ANALYZE vacowned_part1;
ANALYZE vacowned_part2;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
ALTER TABLE vacowned_parted OWNER TO CURRENT_USER;
SET ROLE regress_vacuum;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE vacowned_parted;
ANALYZE vacowned_part1;
ANALYZE vacowned_part2;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
ALTER TABLE vacowned_parted OWNER TO regress_vacuum;
ALTER TABLE vacowned_part1 OWNER TO CURRENT_USER;
SET ROLE regress_vacuum;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE vacowned_parted;
ANALYZE vacowned_part1;
ANALYZE vacowned_part2;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
DROP ROLE regress_vacuum;
CREATE TABLE TIMESTAMP_TBL (d1 timestamp(2) without time zone);
BEGIN;
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'today';
SELECT count(*) AS Three FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'tomorrow';
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'yesterday';
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp(2) without time zone 'now';
COMMIT;
DELETE FROM TIMESTAMP_TBL;
BEGIN;
SELECT count(*) AS two FROM TIMESTAMP_TBL WHERE d1 = timestamp(2) without time zone 'now';
COMMIT;
TRUNCATE TIMESTAMP_TBL;
set datestyle to ymd;
reset datestyle;
::::SELECT '4714-11-23 23:59:59 BC'::timestamp;  -- out of rangeSELECT '' AS "48", d1 FROM TIMESTAMP_TBL   WHERE d1 > timestamp without time zone '1997-01-02';
SELECT '' AS "15", d1 FROM TIMESTAMP_TBL   WHERE d1 < timestamp without time zone '1997-01-02';
SELECT '' AS one, d1 FROM TIMESTAMP_TBL   WHERE d1 = timestamp without time zone '1997-01-02';
SELECT '' AS "63", d1 FROM TIMESTAMP_TBL   WHERE d1 != timestamp without time zone '1997-01-02';
SELECT '' AS "16", d1 FROM TIMESTAMP_TBL   WHERE d1 <= timestamp without time zone '1997-01-02';
SELECT '' AS "49", d1 FROM TIMESTAMP_TBL   WHERE d1 >= timestamp without time zone '1997-01-02';
SELECT '' AS "54", d1 - timestamp without time zone '1997-01-02' AS diff   FROM TIMESTAMP_TBL WHERE d1 BETWEEN '1902-01-01' AND '2038-01-01';
SELECT '' AS date_trunc_week, date_trunc( 'week', timestamp '2004-02-29 15:44:17.71393' ) AS week_trunc;
SELECT '' AS "54", d1 - timestamp without time zone '1997-01-02' AS diff  FROM TIMESTAMP_TBL  WHERE d1 BETWEEN timestamp without time zone '1902-01-01'   AND timestamp without time zone '2038-01-01';
SELECT '' AS "54", d1 as "timestamp",   date_part( 'year', d1) AS year, date_part( 'month', d1) AS month,   date_part( 'day', d1) AS day, date_part( 'hour', d1) AS hour,   date_part( 'minute', d1) AS minute, date_part( 'second', d1) AS second   FROM TIMESTAMP_TBL WHERE d1 BETWEEN '1902-01-01' AND '2038-01-01';
SELECT '' AS to_char_6, to_char(d1, E'"HH:MI:SS is" HH:MI:SS "\\"text between quote marks\\""')   FROM TIMESTAMP_TBL;
SELECT '' AS to_char_12, to_char(d, 'FF1 FF2 FF3 FF4 FF5 FF6  ff1 ff2 ff3 ff4 ff5 ff6  MS US')   FROM (VALUES       ('2018-11-02 12:34:56'::timestamp),       ('2018-11-02 12:34:56.78'),       ('2018-11-02 12:34:56.78901'),       ('2018-11-02 12:34:56.78901234')   ) d(d);
CREATE TABLE clstr_tst_s (rf_a SERIAL PRIMARY KEY,	b INT);
CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,	b INT,	c TEXT,	d TEXT,	CONSTRAINT clstr_tst_con FOREIGN KEY (b) REFERENCES clstr_tst_s);
CREATE TABLE clstr_tst_inh () INHERITS (clstr_tst);
CLUSTER clstr_tst_c ON clstr_tst;
SELECT a,b,c,substring(d for 30), length(d) from clstr_tst;
SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a;
SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY b;
SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY c;
SELECT a,b,c,substring(d for 30), length(d) from clstr_tst;
::SELECT conname FROM pg_constraint WHERE conrelid = 'clstr_tst'::regclassORDER BY 1;
SELECT relname, relkind,    EXISTS(SELECT 1 FROM pg_class WHERE oid = c.reltoastrelid) AS hastoastFROM pg_class c WHERE relname LIKE 'clstr_tst%' ORDER BY relname;
SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2WHERE pg_class.oid=indexrelid	AND indrelid=pg_class_2.oid	AND pg_class_2.relname = 'clstr_tst'	AND indisclustered;
ALTER TABLE clstr_tst CLUSTER ON clstr_tst_b_c;
SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2WHERE pg_class.oid=indexrelid	AND indrelid=pg_class_2.oid	AND pg_class_2.relname = 'clstr_tst'	AND indisclustered;
ALTER TABLE clstr_tst SET WITHOUT CLUSTER;
SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2WHERE pg_class.oid=indexrelid	AND indrelid=pg_class_2.oid	AND pg_class_2.relname = 'clstr_tst'	AND indisclustered;
CREATE USER regress_clstr_user;
ALTER TABLE clstr_1 OWNER TO regress_clstr_user;
ALTER TABLE clstr_3 OWNER TO regress_clstr_user;
GRANT SELECT ON clstr_2 TO regress_clstr_user;
CLUSTER clstr_2;
CLUSTER clstr_1_pkey ON clstr_1;
CLUSTER clstr_2 USING clstr_2_pkey;
SELECT * FROM clstr_1 UNION ALL  SELECT * FROM clstr_2 UNION ALL  SELECT * FROM clstr_3;
DELETE FROM clstr_1;
DELETE FROM clstr_2;
DELETE FROM clstr_3;
SET SESSION AUTHORIZATION regress_clstr_user;
CLUSTER;
SELECT * FROM clstr_1 UNION ALL  SELECT * FROM clstr_2 UNION ALL  SELECT * FROM clstr_3;
DELETE FROM clstr_1;
CLUSTER clstr_1;
CREATE TABLE clustertest (key int PRIMARY KEY);
BEGIN;
UPDATE clustertest SET key = 100 WHERE key = 10;
UPDATE clustertest SET key = 35 WHERE key = 40;
UPDATE clustertest SET key = 60 WHERE key = 50;
UPDATE clustertest SET key = 70 WHERE key = 60;
UPDATE clustertest SET key = 80 WHERE key = 70;
CLUSTER clustertest_pkey ON clustertest;
COMMIT;
cluster clstr_temp using clstr_temp_pkey;
RESET SESSION AUTHORIZATION;
CREATE TABLE clstrpart (a int) PARTITION BY RANGE (a);
ALTER TABLE clstrpart CLUSTER ON clstrpart_idx;
CLUSTER clstrpart USING clstrpart_idx;
set enable_indexscan = off;
set maintenance_work_mem = '1MB';
cluster clstr_4 using cluster_sort;
select * from(select hundred, lag(hundred) over () as lhundred,        thousand, lag(thousand) over () as lthousand,        tenthous, lag(tenthous) over () as ltenthous from clstr_4) sswhere row(hundred, thousand, tenthous) <= row(lhundred, lthousand, ltenthous);
reset enable_indexscan;
reset maintenance_work_mem;
CREATE TABLE clstr_expression(id serial primary key, a int, b text COLLATE "C");
INSERT INTO clstr_expression(a, b) SELECT g.i % 42, 'prefix'||g.i FROM generate_series(1, 133) g(i);
BEGIN;
SET LOCAL enable_seqscan = false;
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE upper(b) = 'PREFIX3';
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
COMMIT;
CLUSTER clstr_expression USING clstr_expression_minus_a;
BEGIN;
SET LOCAL enable_seqscan = false;
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE upper(b) = 'PREFIX3';
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
COMMIT;
CLUSTER clstr_expression USING clstr_expression_upper_b;
BEGIN;
SET LOCAL enable_seqscan = false;
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE upper(b) = 'PREFIX3';
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
COMMIT;
DROP USER regress_clstr_user;
CREATE TABLE LSEG_TBL (s lseg);
INSERT INTO LSEG_TBL VALUES ('[(-10,2),(-10,3)]');	-- verticalINSERT INTO LSEG_TBL VALUES ('[(0,-20),(30,-20)]');	-- horizontalINSERT INTO LSEG_TBL VALUES ('[(NaN,1),(NaN,90)]');	-- NaNINSERT INTO LSEG_TBL VALUES ('(3asdf,2 ,3,4r2)');
SELECT pg_notify('notify_async1',NULL);
SELECT pg_notify(NULL,'sample message1');
NOTIFY notify_async2;
LISTEN notify_async2;
UNLISTEN notify_async2;
UNLISTEN *;
CREATE TABLE POLYGON_TBL(f1 polygon);
INSERT INTO POLYGON_TBL(f1) VALUES ('(7,8),(5,6),(3,4),(1,2)'); -- ReverseINSERT INTO POLYGON_TBL(f1) VALUES ('(1,2),(7,8),(5,6),(3,-4)');
CREATE TABLE quad_poly_tbl (id int, p polygon);
INSERT INTO quad_poly_tbl	SELECT i, polygon '((200, 300),(210, 310),(230, 290))'	FROM generate_series(10001, 11000) AS i;
INSERT INTO quad_poly_tbl	VALUES		(11001, NULL),		(11002, NULL),		(11003, NULL);
CREATE INDEX quad_poly_tbl_idx ON quad_poly_tbl USING spgist(p);
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
CREATE TEMP TABLE quad_poly_tbl_ord_seq2 ASSELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, idFROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p << polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p << polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p &< polygon '((300,300),(400,600),(600,500),(700,200))';
&SELECT count(*) FROM quad_poly_tbl WHERE p &< polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p && polygon '((300,300),(400,600),(600,500),(700,200))';
&&SELECT count(*) FROM quad_poly_tbl WHERE p && polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p &> polygon '((300,300),(400,600),(600,500),(700,200))';
&SELECT count(*) FROM quad_poly_tbl WHERE p &> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p >> polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p >> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p <<| polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p <<| polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p &<| polygon '((300,300),(400,600),(600,500),(700,200))';
&|SELECT count(*) FROM quad_poly_tbl WHERE p &<| polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p |&> polygon '((300,300),(400,600),(600,500),(700,200))';
|&SELECT count(*) FROM quad_poly_tbl WHERE p |&> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p |>> polygon '((300,300),(400,600),(600,500),(700,200))';
|SELECT count(*) FROM quad_poly_tbl WHERE p |>> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
@SELECT count(*) FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p @> polygon '((340,550),(343,552),(341,553))';
@SELECT count(*) FROM quad_poly_tbl WHERE p @> polygon '((340,550),(343,552),(341,553))';
EXPLAIN (COSTS OFF)SELECT count(*) FROM quad_poly_tbl WHERE p ~= polygon '((200, 300),(210, 310),(230, 290))';
~SELECT count(*) FROM quad_poly_tbl WHERE p ~= polygon '((200, 300),(210, 310),(230, 290))';
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)SELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, idFROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
CREATE TEMP TABLE quad_poly_tbl_ord_idx2 ASSELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, idFROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT *FROM quad_poly_tbl_ord_seq2 seq FULL JOIN quad_poly_tbl_ord_idx2 idx	ON seq.n = idx.n AND seq.id = idx.id AND		(seq.dist = idx.dist OR seq.dist IS NULL AND idx.dist IS NULL)WHERE seq.id IS NULL OR idx.id IS NULL;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
create table gist_point_tbl(id int4, p point);
create index gist_pointidx on gist_point_tbl using gist(p);
create index gist_pointidx2 on gist_point_tbl using gist(p) with (buffering = on, fillfactor=50);
create index gist_pointidx3 on gist_point_tbl using gist(p) with (buffering = off);
create index gist_pointidx4 on gist_point_tbl using gist(p) with (buffering = auto);
drop index gist_pointidx2, gist_pointidx3, gist_pointidx4;
create index gist_pointidx5 on gist_point_tbl using gist(p) with (buffering = invalid_value);
create index gist_pointidx5 on gist_point_tbl using gist(p) with (fillfactor=9);
create index gist_pointidx5 on gist_point_tbl using gist(p) with (fillfactor=101);
delete from gist_point_tbl where id % 2 = 1;
delete from gist_point_tbl where id > 5000;
vacuum analyze gist_point_tbl;
alter index gist_pointidx SET (fillfactor = 40);
create table gist_tbl (b box, p point, c circle);
insert into gist_tblselect box(point(0.05*i, 0.05*i), point(0.05*i, 0.05*i)),       point(0.05*i, 0.05*i),       circle(point(0.05*i, 0.05*i), 1.0)from generate_series(0,10000) as i;
vacuum analyze gist_tbl;
set enable_seqscan=off;
set enable_bitmapscan=off;
set enable_indexonlyscan=on;
create index gist_tbl_point_index on gist_tbl using gist (p);
explain (costs off)select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5));
@explain (costs off)select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5))order by p <-> point(0.201, 0.201);
@select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5))order by p <-> point(0.201, 0.201);
explain (costs off)select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5))order by point(0.101, 0.101) <-> p;
@select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5))order by point(0.101, 0.101) <-> p;
explain (costs off)select p from  (values (box(point(0,0), point(0.5,0.5))),          (box(point(0.5,0.5), point(0.75,0.75))),          (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb)cross join lateral  (select p from gist_tbl where p <@ bb order by p <-> bb[0] limit 2) ss;
select p from  (values (box(point(0,0), point(0.5,0.5))),          (box(point(0.5,0.5), point(0.75,0.75))),          (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb)cross join lateral  (select p from gist_tbl where p <@ bb order by p <-> bb[0] limit 2) ss;
create index gist_tbl_box_index on gist_tbl using gist (b);
explain (costs off)select b from gist_tbl where b <@ box(point(5,5), point(6,6));
@explain (costs off)select b from gist_tbl where b <@ box(point(5,5), point(6,6))order by b <-> point(5.2, 5.91);
@select b from gist_tbl where b <@ box(point(5,5), point(6,6))order by b <-> point(5.2, 5.91);
explain (costs off)select b from gist_tbl where b <@ box(point(5,5), point(6,6))order by point(5.2, 5.91) <-> b;
@select b from gist_tbl where b <@ box(point(5,5), point(6,6))order by point(5.2, 5.91) <-> b;
create index gist_tbl_multi_index on gist_tbl using gist (p, c);
explain (costs off)select p, c from gist_tblwhere p <@ box(point(5,5), point(6, 6));
select b, p from gist_tblwhere b <@ box(point(4.5, 4.5), point(5.5, 5.5))and p <@ box(point(5,5), point(6, 6));
reset enable_seqscan;
reset enable_bitmapscan;
reset enable_indexonlyscan;
CALL nonexistent();  -- errorCALL random();  -- errorCREATE FUNCTION cp_testfunc1(a int) RETURNS int LANGUAGE SQL AS $$ SELECT a $$;
CREATE PROCEDURE ptest1(x text)LANGUAGE SQLAS $$INSERT INTO cp_test VALUES (1, x);
$$;
::SELECT ptest1('x');  -- errorCALL ptest1('a');  -- okCALL ptest1('xy' || 'zzy');  -- ok, constant-folded argCALL ptest1(substring(random()::numeric(20,15)::text, 1, 1));  -- ok, volatile argSELECT * FROM cp_test ORDER BY b COLLATE "C";
CREATE PROCEDURE ptest2()LANGUAGE SQLAS $$SELECT 5;
$$;
CALL ptest2();
TRUNCATE cp_test;
CREATE PROCEDURE ptest3(y text)LANGUAGE SQLAS $$CALL ptest1(y);
CALL ptest1($1);
$$;
CALL ptest3('b');
CREATE PROCEDURE ptest4a(INOUT a int, INOUT b int)LANGUAGE SQLAS $$SELECT 1, 2;
$$;
CALL ptest4a(NULL, NULL);
CREATE PROCEDURE ptest4b(INOUT b int, INOUT a int)LANGUAGE SQLAS $$CALL ptest4a(a, b);  -- error, not supported$$;
DROP PROCEDURE ptest4a;
CREATE OR REPLACE PROCEDURE ptest5(a int, b text, c int default 100)LANGUAGE SQLAS $$INSERT INTO cp_test VALUES(a, b);
$$;
TRUNCATE cp_test;
CALL ptest5(10, 'Hello', 20);
CALL ptest5(10, 'Hello');
CALL ptest5(10, b => 'Hello');
CALL ptest5(b => 'Hello', a => 10);
CREATE PROCEDURE ptest6(a int, b anyelement)LANGUAGE SQLAS $$SELECT NULL::int;
$$;
CALL ptest6(1, 2);
CREATE PROCEDURE ptest7(a text, b text)LANGUAGE SQLAS $$SELECT a = b;
$$;
CALL ptest7(least('a', 'b'), 'a');
CALL version();  -- error: not a procedureCALL sum(1);  -- error: not a procedureCREATE PROCEDURE ptestx() LANGUAGE SQL WINDOW AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
CREATE PROCEDURE ptestx() LANGUAGE SQL STRICT AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
CREATE PROCEDURE ptestx(OUT a int) LANGUAGE SQL AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
ALTER PROCEDURE ptest1(text) STRICT;
ALTER FUNCTION ptest1(text) VOLATILE;  -- error: not a functionALTER PROCEDURE cp_testfunc1(int) VOLATILE;  -- error: not a procedureALTER PROCEDURE nonexistent() VOLATILE;
DROP FUNCTION ptest1(text);  -- error: not a functionDROP PROCEDURE cp_testfunc1(int);  -- error: not a procedureDROP PROCEDURE nonexistent();
CREATE USER regress_cp_user1;
GRANT INSERT ON cp_test TO regress_cp_user1;
REVOKE EXECUTE ON PROCEDURE ptest1(text) FROM PUBLIC;
SET ROLE regress_cp_user1;
CALL ptest1('a');  -- errorRESET ROLE;
GRANT EXECUTE ON PROCEDURE ptest1(text) TO regress_cp_user1;
SET ROLE regress_cp_user1;
CALL ptest1('a');  -- okRESET ROLE;
ALTER ROUTINE cp_testfunc1(int) RENAME TO cp_testfunc1a;
ALTER ROUTINE cp_testfunc1a RENAME TO cp_testfunc1;
ALTER ROUTINE ptest1(text) RENAME TO ptest1a;
ALTER ROUTINE ptest1a RENAME TO ptest1;
DROP ROUTINE cp_testfunc1(int);
DROP PROCEDURE ptest1;
DROP PROCEDURE ptest2;
DROP USER regress_cp_user1;
COPY aggtest FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/agg.data';
COPY onek FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/onek.data';
COPY onek TO '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/onek.data';
DELETE FROM onek;
COPY onek FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/onek.data';
COPY tenk1 FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/tenk.data';
COPY slow_emp4000 FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/rect.data';
COPY person FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/person.data';
COPY emp FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/emp.data';
COPY student FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/student.data';
COPY stud_emp FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/stud_emp.data';
COPY road FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/streets.data';
COPY real_city FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/real_city.data';
COPY hash_i4_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/hash.data';
COPY hash_name_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/hash.data';
COPY hash_txt_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/hash.data';
COPY hash_f8_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/hash.data';
COPY test_tsvector FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/tsearch.data';
COPY testjsonb FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/jsonb.data';
COPY bt_i4_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/desc.data';
COPY bt_name_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/hash.data';
COPY bt_txt_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/desc.data';
COPY bt_f8_heap FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/hash.data';
COPY array_op_test FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/array.data';
COPY array_index_op_test FROM '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/data/array.data';
ANALYZE aggtest;
ANALYZE onek;
ANALYZE tenk1;
ANALYZE slow_emp4000;
ANALYZE person;
ANALYZE emp;
ANALYZE student;
ANALYZE stud_emp;
ANALYZE road;
ANALYZE real_city;
ANALYZE hash_i4_heap;
ANALYZE hash_name_heap;
ANALYZE hash_txt_heap;
ANALYZE hash_f8_heap;
ANALYZE test_tsvector;
ANALYZE bt_i4_heap;
ANALYZE bt_name_heap;
ANALYZE bt_txt_heap;
ANALYZE bt_f8_heap;
ANALYZE array_op_test;
ANALYZE array_index_op_test;
insert into copytest values('DOS',E'abc\r\ndef',1);
insert into copytest values('Unix',E'abc\ndef',2);
insert into copytest values('Mac',E'abc\rdef',3);
insert into copytest values(E'esc\\ape',E'a\\r\\\r\\\n\\nb',4);
copy copytest to '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/copytest.csv' csv;
create temp table copytest2 (like copytest);
copy copytest2 from '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/copytest.csv' csv;
truncate copytest2;
copy copytest to '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/copytest.csv' csv quote '''' escape E'\\';
copy copytest2 from '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/copytest.csv' csv quote '''' escape E'\\';
create temp table copytest3 (	c1 int,	"col with , comma" text,	"col with "" quote"  int);
copy copytest3 from stdin csv header;
this is just a line full of junk that would error out if parsed1,a,12,b,2\.copy copytest3 to stdout csv header;
create table parted_copytest (	a int,	b int,	c text) partition by list (b);
alter table parted_copytest attach partition parted_copytest_a1 for values in(1);
alter table parted_copytest attach partition parted_copytest_a2 for values in(2);
copy (select * from parted_copytest order by a) to '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/parted_copytest.csv';
truncate parted_copytest;
copy parted_copytest from '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/parted_copytest.csv';
begin;
truncate parted_copytest;
copy parted_copytest from '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/parted_copytest.csv' (freeze);
rollback;
::select tableoid::regclass,count(*),sum(a) from parted_copytestgroup by tableoid order by tableoid::regclass::name;
truncate parted_copytest;
create function part_ins_func() returns trigger language plpgsql as $$begin  return new;
end;
$$;
copy parted_copytest from '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/results/parted_copytest.csv';
::select tableoid::regclass,count(*),sum(a) from parted_copytestgroup by tableoid order by tableoid::regclass::name;
truncate table parted_copytest;
create index on parted_copytest (b);
drop trigger part_ins_trig on parted_copytest_a2;
copy parted_copytest from stdin;
1	1	str12	2	str2\.select * from parted_copytest where b = 1;
BEGIN;
SELECT *   INTO TABLE xacttest   FROM aggtest;
END;
BEGIN;
CREATE TABLE disappear (a int4);
DELETE FROM aggtest;
ABORT;
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ ONLY, DEFERRABLE; -- okSELECT * FROM writetest; -- okSET TRANSACTION READ WRITE; --failCOMMIT;
BEGIN;
SET TRANSACTION READ ONLY; -- okSET TRANSACTION READ WRITE; -- okSET TRANSACTION READ ONLY; -- okSELECT * FROM writetest; -- okSAVEPOINT x;
SET TRANSACTION READ ONLY; -- okSELECT * FROM writetest; -- okSET TRANSACTION READ ONLY; -- okSET TRANSACTION READ WRITE; --failCOMMIT;
BEGIN;
SET TRANSACTION READ WRITE; -- okSAVEPOINT x;
SET TRANSACTION READ WRITE; -- okSET TRANSACTION READ ONLY; -- okSELECT * FROM writetest; -- okSET TRANSACTION READ ONLY; -- okSET TRANSACTION READ WRITE; --failCOMMIT;
BEGIN;
SET TRANSACTION READ WRITE; -- okSAVEPOINT x;
SET TRANSACTION READ ONLY; -- okSELECT * FROM writetest; -- okROLLBACK TO SAVEPOINT x;
SHOW transaction_read_only;  -- offSAVEPOINT y;
SET TRANSACTION READ ONLY; -- okSELECT * FROM writetest; -- okRELEASE SAVEPOINT y;
SHOW transaction_read_only;  -- offCOMMIT;
SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY;
DROP TABLE writetest; -- failINSERT INTO writetest VALUES (1); -- failSELECT * FROM writetest; -- okDELETE FROM temptest; -- okUPDATE temptest SET a = 0 FROM writetest WHERE temptest.a = 1 AND writetest.a = temptest.a; -- okPREPARE test AS UPDATE writetest SET a = 0; -- okEXECUTE test; -- failSELECT * FROM writetest, temptest; -- okCREATE TABLE test AS SELECT * FROM writetest; -- failSTART TRANSACTION READ WRITE;
DROP TABLE writetest; -- okCOMMIT;
SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE;
BEGIN;
	SAVEPOINT one;
	ROLLBACK TO SAVEPOINT one;
	RELEASE SAVEPOINT one;
	SAVEPOINT two;
	RELEASE SAVEPOINT two;
COMMIT;
SELECT * FROM trans_foo;		-- should be emptySELECT * FROM trans_bar;		-- shouldn't existSELECT * FROM trans_barbaz;	-- should be emptySELECT * FROM trans_baz;		-- should be emptyBEGIN;
	SAVEPOINT one;
	ROLLBACK TO one;
	RELEASE SAVEPOINT one;
	SAVEPOINT two;
	RELEASE two;
	SAVEPOINT three;
		SAVEPOINT four;
		RELEASE SAVEPOINT four;
	ROLLBACK TO SAVEPOINT three;
	RELEASE SAVEPOINT three;
COMMIT;
SELECT * FROM trans_foo;		-- should have 1 and 3SELECT * FROM trans_barbaz;	-- should have 1BEGIN;
	SAVEPOINT one;
	ROLLBACK TO SAVEPOINT one;
	RELEASE SAVEPOINT one;
	SAVEPOINT two;
		SAVEPOINT three;
			SAVEPOINT four;
				SAVEPOINT five;
				ROLLBACK TO SAVEPOINT five;
COMMIT;
COMMIT;		-- should not be in a transaction blockSELECT * FROM savepoints;
BEGIN;
	SAVEPOINT one;
		DELETE FROM savepoints WHERE a=1;
	RELEASE SAVEPOINT one;
	SAVEPOINT two;
		DELETE FROM savepoints WHERE a=1;
		SAVEPOINT three;
			DELETE FROM savepoints WHERE a=2;
ROLLBACK;
COMMIT;		-- should not be in a transaction blockSELECT * FROM savepoints;
BEGIN;
	SAVEPOINT one;
COMMIT;
BEGIN;
	SAVEPOINT one;
	RELEASE SAVEPOINT one;
COMMIT;
SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=8;
SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=7;
BEGIN;
	SAVEPOINT one;
	ROLLBACK TO SAVEPOINT one;
COMMIT;
SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=9 AND b.a=11;
BEGIN;
	SAVEPOINT one;
		SAVEPOINT two;
	ROLLBACK TO SAVEPOINT one;
		SAVEPOINT two;
			SAVEPOINT three;
COMMIT;
BEGIN;
	SAVEPOINT one;
		SAVEPOINT two;
	ROLLBACK TO SAVEPOINT one;
	ROLLBACK TO SAVEPOINT one;
COMMIT;
SAVEPOINT one;
ROLLBACK TO SAVEPOINT one;
RELEASE SAVEPOINT one;
BEGIN;
  SAVEPOINT one;
  SAVEPOINT two;    -- ignored till the end of ...  RELEASE SAVEPOINT one;      -- ignored till the end of ...  ROLLBACK TO SAVEPOINT one;
COMMIT;
SELECT 1;			-- this should workBEGIN;
	DECLARE c CURSOR FOR SELECT unique2 FROM tenk1 ORDER BY unique2;
	SAVEPOINT one;
		FETCH 10 FROM c;
	ROLLBACK TO SAVEPOINT one;
		FETCH 10 FROM c;
	RELEASE SAVEPOINT one;
	FETCH 10 FROM c;
	CLOSE c;
	DECLARE c CURSOR FOR SELECT unique2/0 FROM tenk1 ORDER BY unique2;
	SAVEPOINT two;
		FETCH 10 FROM c;
	ROLLBACK TO SAVEPOINT two;
	-- c is now dead to the world ...		FETCH 10 FROM c;
	ROLLBACK TO SAVEPOINT two;
	RELEASE SAVEPOINT two;
	FETCH 10 FROM c;
COMMIT;
create or replace function max_xacttest() returns smallint language sql as'select max(a) from xacttest' stable;
begin;
rollback;
create or replace function max_xacttest() returns smallint language sql as'select max(a) from xacttest' volatile;
begin;
rollback;
create or replace function max_xacttest() returns smallint language plpgsql as'begin return max(a) from xacttest; end' stable;
begin;
rollback;
create or replace function max_xacttest() returns smallint language plpgsql as'begin return max(a) from xacttest; end' volatile;
begin;
rollback;
BEGIN;
	savepoint x;
	rollback to x;
ROLLBACK;
create function inverse(int) returns float8 as$$begin  analyze revalidate_bug;
  return 1::float8/$1;
exception  when division_by_zero then return 0;
end$$ language plpgsql volatile;
create table revalidate_bug (c float8 unique);
drop function inverse(int);
begin;
savepoint x;
declare foo cursor for select * from abc;
fetch from foo;
rollback to x;
fetch from foo;
commit;
begin;
declare foo cursor for select * from abc;
fetch from foo;
savepoint x;
fetch from foo;
rollback to x;
fetch from foo;
abort;
CREATE FUNCTION invert(x float8) RETURNS float8 LANGUAGE plpgsql AS$$ begin return 1/x; end $$;
CREATE FUNCTION create_temp_tab() RETURNS textLANGUAGE plpgsql AS $$BEGIN  CREATE TEMP TABLE new_table (f1 float8);
  -- case of interest is that we fail while holding an open  -- relcache reference to new_table  INSERT INTO new_table SELECT invert(0.0);
  RETURN 'foo';
END $$;
BEGIN;
DECLARE ok CURSOR FOR SELECT * FROM int8_tbl;
DECLARE ctt CURSOR FOR SELECT create_temp_tab();
FETCH ok;
SAVEPOINT s1;
FETCH ok;  -- should workFETCH ctt; -- error occurs hereROLLBACK TO s1;
FETCH ok;  -- should workFETCH ctt; -- must be rejectedCOMMIT;
DROP FUNCTION create_temp_tab();
DROP FUNCTION invert(x float8);
SET default_transaction_read_only = on;
START TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE, DEFERRABLE;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
COMMIT AND CHAIN;  -- TBLOCK_ENDSHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO abc VALUES (3);  -- check it's really abortedCOMMIT AND CHAIN;  -- TBLOCK_ABORT_ENDSHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
COMMIT;
START TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE, DEFERRABLE;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
SAVEPOINT x;
COMMIT AND CHAIN;  -- TBLOCK_ABORT_PENDINGSHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
COMMIT;
START TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ WRITE, NOT DEFERRABLE;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
ROLLBACK AND CHAIN;  -- TBLOCK_ABORT_PENDINGSHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
ROLLBACK AND CHAIN;  -- TBLOCK_ABORT_ENDSHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
ROLLBACK;
COMMIT AND CHAIN;  -- errorROLLBACK AND CHAIN;  -- errorSELECT * FROM abc ORDER BY 1;
RESET default_transaction_read_only;
\\\\\rollback;  -- we are not in a transaction at this pointbegin\; insert into i_table values(3)\; commit;
rollback;  -- we are not in a transaction at this pointbegin\; insert into i_table values(4)\; rollback;
rollback;  -- we are not in a transaction at this pointselect 1\; begin\; insert into i_table values(5);
commit;
\select 1\; begin\; insert into i_table values(6);
rollback;
\insert into i_table values(7)\; commit\; insert into i_table values(8)\; select 1/0;
\insert into i_table values(9)\; rollback\; select 2;
rollback;  -- we are not in a transaction at this pointSELECT 1\; VACUUM;
\SELECT 1\; COMMIT\; VACUUM;
\SELECT 1\; SAVEPOINT sp;
\SELECT 1\; COMMIT\; SAVEPOINT sp;
ROLLBACK TO SAVEPOINT sp\; SELECT 2;
\SELECT 2\; RELEASE SAVEPOINT sp\; SELECT 3;
\SELECT 1\; BEGIN\; SAVEPOINT sp\; ROLLBACK TO SAVEPOINT sp\; COMMIT;
SET TRANSACTION READ ONLY\; COMMIT AND CHAIN;  -- errorSHOW transaction_read_only;
SET TRANSACTION READ ONLY\; ROLLBACK AND CHAIN;  -- errorSHOW transaction_read_only;
\INSERT INTO abc VALUES (7)\; COMMIT\; INSERT INTO abc VALUES (8)\; COMMIT AND CHAIN;  -- 7 commit, 8 errorINSERT INTO abc VALUES (9)\; ROLLBACK\; INSERT INTO abc VALUES (10)\; ROLLBACK AND CHAIN;  -- 9 rollback, 10 errorINSERT INTO abc VALUES (11)\; COMMIT AND CHAIN\; INSERT INTO abc VALUES (12)\; COMMIT;  -- 11 error, 12 not reachedINSERT INTO abc VALUES (13)\; ROLLBACK AND CHAIN\; INSERT INTO abc VALUES (14)\; ROLLBACK;  -- 13 error, 14 not reachedSTART TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (15)\; COMMIT AND CHAIN;  -- 15 okSHOW transaction_isolation;  -- transaction is active at this pointCOMMIT;
START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (16)\; ROLLBACK AND CHAIN;  -- 16 okSHOW transaction_isolation;  -- transaction is active at this pointROLLBACK;
START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (17)\; COMMIT\; INSERT INTO abc VALUES (18)\; COMMIT AND CHAIN;  -- 17 commit, 18 errorSHOW transaction_isolation;  -- out of transaction blockSTART TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (19)\; ROLLBACK\; INSERT INTO abc VALUES (20)\; ROLLBACK AND CHAIN;  -- 19 rollback, 20 errorSHOW transaction_isolation;  -- out of transaction blockSELECT * FROM abc ORDER BY 1;
begin;
rollback to X;
CREATE SCHEMA testxmlschema;
CREATE TABLE testxmlschema.test1 (a int, b text);
INSERT INTO testxmlschema.test1 VALUES (1, 'one'), (2, 'two'), (-1, null);
CREATE DOMAIN testxmldomain AS varchar;
CREATE TABLE testxmlschema.test2 (z int, y varchar(500), x char(6), w numeric(9,2), v smallint, u bigint, t real, s time, r timestamp, q date, p xml, o testxmldomain, n bool, m bytea, aaa text);
ALTER TABLE testxmlschema.test2 DROP COLUMN aaa;
INSERT INTO testxmlschema.test2 VALUES (55, 'abc', 'def', 98.6, 2, 999, 0, '21:07', '2009-06-08 21:07:30', '2009-06-08', NULL, 'ABC', true, 'XYZ');
DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM testxmlschema.test1 ORDER BY 1, 2;
::::MOVE BACKWARD ALL IN xc;
::::CREATE DOMAIN testboolxmldomain AS bool;
CREATE DOMAIN testdatexmldomain AS date;
CREATE TABLE testxmlschema.test3    AS SELECT true c1,              true::testboolxmldomain c2,              '2013-02-21'::date c3,              '2013-02-21'::testdatexmldomain c4;
SELECT xmlforest(c1, c2, c3, c4) FROM testxmlschema.test3;
CREATE FUNCTION widget_in(cstring)   RETURNS widget   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT IMMUTABLE;
CREATE FUNCTION widget_out(widget)   RETURNS cstring   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT IMMUTABLE;
CREATE FUNCTION int44in(cstring)   RETURNS city_budget   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT IMMUTABLE;
CREATE FUNCTION int44out(city_budget)   RETURNS cstring   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT IMMUTABLE;
CREATE FUNCTION check_primary_key ()	RETURNS trigger	AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/refint.so'	LANGUAGE C;
CREATE FUNCTION check_foreign_key ()	RETURNS trigger	AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/refint.so'	LANGUAGE C;
CREATE FUNCTION autoinc ()	RETURNS trigger	AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/autoinc.so'	LANGUAGE C;
CREATE FUNCTION trigger_return_old ()        RETURNS trigger        AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'        LANGUAGE C;
CREATE FUNCTION ttdummy ()        RETURNS trigger        AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'        LANGUAGE C;
CREATE FUNCTION set_ttdummy (int4)        RETURNS int4        AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'        LANGUAGE C STRICT;
CREATE FUNCTION make_tuple_indirect (record)        RETURNS record        AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'        LANGUAGE C STRICT;
CREATE FUNCTION test_atomic_ops()    RETURNS bool    AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'    LANGUAGE C;
CREATE FUNCTION test_fdw_handler()    RETURNS fdw_handler    AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so', 'test_fdw_handler'    LANGUAGE C;
CREATE FUNCTION test_support_func(internal)    RETURNS internal    AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so', 'test_support_func'    LANGUAGE C STRICT;
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL    AS 'SELECT ''not an integer'';';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL    AS 'not even SQL';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL    AS 'SELECT 1, 2, 3;';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL    AS 'SELECT $2;';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL    AS 'a', 'b';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE C    AS 'nosuchfile';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE C    AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so', 'nosuchsymbol';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE internal    AS 'nosuch';
explain (verbose, costs off)SELECT generate_series(1, generate_series(1, 3)), generate_series(2, 4);
explain (verbose, costs off)SELECT unnest(ARRAY[1, 2]) FROM few WHERE false;
explain (verbose, costs off)SELECT * FROM few f1,  (SELECT unnest(ARRAY[1,2]) FROM few f2 WHERE false OFFSET 0) ss;
SELECT * FROM few f1,  (SELECT unnest(ARRAY[1,2]) FROM few f2 WHERE false OFFSET 0) ss;
SELECT few.id, generate_series(1,3) g FROM few ORDER BY id DESC;
SELECT few.id, generate_series(1,3) g FROM few ORDER BY id, g DESC;
SELECT few.id, generate_series(1,3) g FROM few ORDER BY id, generate_series(1,3) DESC;
SELECT few.id FROM few ORDER BY id, generate_series(1,3) DESC;
SET enable_hashagg TO 0; -- stable output orderSELECT few.dataa, count(*), min(id), max(id), unnest('{1,1,3}'::int[]) FROM few WHERE few.id = 1 GROUP BY few.dataa;
SELECT few.dataa, count(*), min(id), max(id), unnest('{1,1,3}'::int[]) FROM few WHERE few.id = 1 GROUP BY few.dataa, unnest('{1,1,3}'::int[]);
SELECT few.dataa, count(*), min(id), max(id), unnest('{1,1,3}'::int[]) FROM few WHERE few.id = 1 GROUP BY few.dataa, 5;
RESET enable_hashagg;
SELECT few.dataa, count(*) FROM few WHERE dataa = 'a' GROUP BY few.dataa ORDER BY 2;
SELECT few.dataa, count(*) FROM few WHERE dataa = 'a' GROUP BY few.dataa, unnest('{1,1,3}'::int[]) ORDER BY 2;
SELECT sum((3 = ANY(SELECT generate_series(1,4)))::int);
SELECT sum((3 = ANY(SELECT lag(x) over(order by x)                    FROM generate_series(1,4) x))::int);
SELECT few.dataa, count(*), min(id), max(id), generate_series(1,3) FROM few GROUP BY few.dataa ORDER BY 5, 1;
set enable_hashagg = false;
reset enable_hashagg;
explain (verbose, costs off)select 'foo' as f, generate_series(1,2) as g from few order by 1;
INSERT INTO fewmore VALUES(1) RETURNING generate_series(1,3);
VALUES(1, generate_series(1,2));
SELECT generate_series(1,3) IS DISTINCT FROM 2;
SELECT DISTINCT ON (a) a, b, generate_series(1,3) gFROM (VALUES (3, 2), (3,1), (1,1), (1,4), (5,3), (5,1)) AS t(a, b);
SELECT DISTINCT ON (a) a, b, generate_series(1,3) gFROM (VALUES (3, 2), (3,1), (1,1), (1,4), (5,3), (5,1)) AS t(a, b)ORDER BY a, b DESC;
SELECT DISTINCT ON (a) a, b, generate_series(1,3) gFROM (VALUES (3, 2), (3,1), (1,1), (1,4), (5,3), (5,1)) AS t(a, b)ORDER BY a, b DESC, g DESC;
SELECT DISTINCT ON (a, b, g) a, b, generate_series(1,3) gFROM (VALUES (3, 2), (3,1), (1,1), (1,4), (5,3), (5,1)) AS t(a, b)ORDER BY a, b DESC, g DESC;
SELECT DISTINCT ON (g) a, b, generate_series(1,3) gFROM (VALUES (3, 2), (3,1), (1,1), (1,4), (5,3), (5,1)) AS t(a, b);
SELECT a, generate_series(1,2) FROM (VALUES(1),(2),(3)) r(a) LIMIT 2 OFFSET 2;
SELECT (SELECT generate_series(1,3) LIMIT 1 OFFSET few.id) FROM few;
SELECT (SELECT generate_series(1,3) LIMIT 1 OFFSET g.i) FROM generate_series(0,3) g(i);
CREATE OPERATOR |@| (PROCEDURE = unnest, RIGHTARG = ANYARRAY);
|@|explain (verbose, costs off)select generate_series(1,3) as x, generate_series(1,3) + 1 as xp1;
explain (verbose, costs off)select generate_series(1,3)+1 order by generate_series(1,3);
explain (verbose, costs off)select generate_series(1,3) as x, generate_series(3,6) + 1 as y;
BEGIN;
TRUNCATE truncate_a;
ROLLBACK;
BEGIN;
TRUNCATE truncate_a;
COMMIT;
CREATE TABLE trunc_c (a serial PRIMARY KEY);
TRUNCATE TABLE truncate_a;		-- failTRUNCATE TABLE truncate_a,trunc_b;		-- failTRUNCATE TABLE truncate_a,trunc_b,trunc_e;	-- okTRUNCATE TABLE truncate_a,trunc_e;		-- failTRUNCATE TABLE trunc_c;		-- failTRUNCATE TABLE trunc_c,trunc_d;		-- failTRUNCATE TABLE trunc_c,trunc_d,trunc_e;	-- okTRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;	-- failTRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;	-- okTRUNCATE TABLE truncate_a RESTRICT; -- failTRUNCATE TABLE truncate_a CASCADE;  -- okALTER TABLE truncate_a ADD FOREIGN KEY (col1) REFERENCES trunc_c;
TRUNCATE TABLE trunc_c;
TRUNCATE TABLE trunc_c,truncate_a;
TRUNCATE TABLE trunc_c,truncate_a,trunc_d;
TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;
TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e,trunc_b;
SELECT * FROM truncate_a   UNION ALL SELECT * FROM trunc_c   UNION ALL SELECT * FROM trunc_b   UNION ALL SELECT * FROM trunc_d;
TRUNCATE TABLE trunc_c CASCADE;  -- okSELECT * FROM truncate_a   UNION ALL SELECT * FROM trunc_c   UNION ALL SELECT * FROM trunc_b   UNION ALL SELECT * FROM trunc_d;
DROP TABLE truncate_a,trunc_c,trunc_b,trunc_d,trunc_e CASCADE;
CREATE TABLE trunc_fa (col2a text) INHERITS (trunc_f);
CREATE TABLE trunc_fb (col2b int) INHERITS (trunc_f);
CREATE TABLE trunc_faa (col3 text) INHERITS (trunc_fa);
BEGIN;
TRUNCATE trunc_f;
ROLLBACK;
BEGIN;
TRUNCATE ONLY trunc_f;
ROLLBACK;
BEGIN;
TRUNCATE ONLY trunc_fb, ONLY trunc_fa;
ROLLBACK;
BEGIN;
TRUNCATE ONLY trunc_fb, trunc_fa;
ROLLBACK;
DROP TABLE trunc_f CASCADE;
CREATE TABLE trunc_trigger_log (tgop text, tglevel text, tgwhen text,        tgargv text, tgtable name, rowcount bigint);
CREATE FUNCTION trunctrigger() RETURNS trigger as $$declare c bigint;
begin    execute 'select count(*) from ' || quote_ident(tg_table_name) into c;
    return null;
end;
$$ LANGUAGE plpgsql;
CREATE TRIGGER tBEFORE TRUNCATE ON trunc_trigger_testFOR EACH STATEMENTEXECUTE PROCEDURE trunctrigger('before trigger truncate');
TRUNCATE trunc_trigger_test;
DROP TRIGGER t ON trunc_trigger_test;
truncate trunc_trigger_log;
CREATE TRIGGER ttAFTER TRUNCATE ON trunc_trigger_testFOR EACH STATEMENTEXECUTE PROCEDURE trunctrigger('after trigger truncate');
TRUNCATE trunc_trigger_test;
DROP FUNCTION trunctrigger();
CREATE SEQUENCE truncate_a_id1 START WITH 33;
CREATE TABLE truncate_a (id serial,                         id1 integer default nextval('truncate_a_id1'));
ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;
TRUNCATE truncate_a;
TRUNCATE truncate_a RESTART IDENTITY;
CREATE TABLE truncate_b (id int GENERATED ALWAYS AS IDENTITY (START WITH 44));
TRUNCATE truncate_b;
TRUNCATE truncate_b RESTART IDENTITY;
BEGIN;
TRUNCATE truncate_a RESTART IDENTITY;
ROLLBACK;
SELECT nextval('truncate_a_id1'); -- fail, seq should have been droppedCREATE TABLE truncparted (a int, b char) PARTITION BY LIST (a);
TRUNCATE ONLY truncparted;
CREATE TABLE truncparted1 PARTITION OF truncparted FOR VALUES IN (1);
TRUNCATE ONLY truncparted;
TRUNCATE truncparted;
CREATE FUNCTION tp_ins_data() RETURNS void LANGUAGE plpgsql AS $$  BEGIN	INSERT INTO truncprim VALUES (1), (100), (150);
  END$$;
CREATE FUNCTION tp_chk_data(OUT pktb regclass, OUT pkval int, OUT fktb regclass, OUT fkval int)  RETURNS SETOF record LANGUAGE plpgsql AS $$  BEGIN    RETURN QUERY SELECT      pk.tableoid::regclass, pk.a, fk.tableoid::regclass, fk.a    FROM truncprim pk FULL JOIN truncpart fk USING (a)    ORDER BY 2, 4;
  END$$;
CREATE TABLE truncpart (a int REFERENCES truncprim)  PARTITION BY RANGE (a);
CREATE TABLE truncpart_1 PARTITION OF truncpart FOR VALUES FROM (0) TO (100);
CREATE TABLE truncpart_2 PARTITION OF truncpart FOR VALUES FROM (100) TO (200)  PARTITION BY RANGE (a);
CREATE TABLE truncpart_2_1 PARTITION OF truncpart_2 FOR VALUES FROM (100) TO (150);
CREATE TABLE truncpart_2_d PARTITION OF truncpart_2 DEFAULT;
TRUNCATE TABLE truncprim;	-- should failselect tp_ins_data();
TRUNCATE TABLE truncprim, truncpart;
select * from tp_chk_data();
TRUNCATE TABLE truncprim CASCADE;
SELECT * FROM tp_chk_data();
TRUNCATE TABLE truncpart;
SELECT * FROM tp_chk_data();
DROP TABLE truncprim, truncpart;
DROP FUNCTION tp_ins_data(), tp_chk_data();
SHOW datestyle;
SET vacuum_cost_delay TO 40;
SET datestyle = 'ISO, YMD';
SHOW vacuum_cost_delay;
SHOW datestyle;
::SET LOCAL vacuum_cost_delay TO 50;
SHOW vacuum_cost_delay;
SET LOCAL datestyle = 'SQL';
SHOW datestyle;
::BEGIN;
SET LOCAL vacuum_cost_delay TO 50;
SHOW vacuum_cost_delay;
SET LOCAL datestyle = 'SQL';
SHOW datestyle;
::COMMIT;
SHOW vacuum_cost_delay;
SHOW datestyle;
::BEGIN;
SET vacuum_cost_delay TO 60;
SHOW vacuum_cost_delay;
SET datestyle = 'German';
SHOW datestyle;
::ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
::BEGIN;
SET vacuum_cost_delay TO 70;
SET datestyle = 'MDY';
SHOW datestyle;
::SAVEPOINT first_sp;
SET vacuum_cost_delay TO 80.1;
SHOW vacuum_cost_delay;
SET datestyle = 'German, DMY';
SHOW datestyle;
::ROLLBACK TO first_sp;
SHOW datestyle;
::SAVEPOINT second_sp;
SET vacuum_cost_delay TO '900us';
SET datestyle = 'SQL, YMD';
SHOW datestyle;
::SAVEPOINT third_sp;
SET vacuum_cost_delay TO 100;
SHOW vacuum_cost_delay;
SET datestyle = 'Postgres, MDY';
SHOW datestyle;
::ROLLBACK TO third_sp;
SHOW vacuum_cost_delay;
SHOW datestyle;
::ROLLBACK TO second_sp;
SHOW vacuum_cost_delay;
SHOW datestyle;
::ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
::BEGIN;
SHOW vacuum_cost_delay;
SHOW datestyle;
::SAVEPOINT sp;
SET LOCAL vacuum_cost_delay TO 30;
SHOW vacuum_cost_delay;
SET LOCAL datestyle = 'Postgres, MDY';
SHOW datestyle;
::ROLLBACK TO sp;
SHOW vacuum_cost_delay;
SHOW datestyle;
::ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
::BEGIN;
SHOW vacuum_cost_delay;
SHOW datestyle;
::SAVEPOINT sp;
SET LOCAL vacuum_cost_delay TO 30;
SHOW vacuum_cost_delay;
SET LOCAL datestyle = 'Postgres, MDY';
SHOW datestyle;
::RELEASE SAVEPOINT sp;
SHOW vacuum_cost_delay;
SHOW datestyle;
::ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
::BEGIN;
SET vacuum_cost_delay TO 40;
SET LOCAL vacuum_cost_delay TO 50;
SHOW vacuum_cost_delay;
SET datestyle = 'ISO, DMY';
SET LOCAL datestyle = 'Postgres, MDY';
SHOW datestyle;
::COMMIT;
SHOW vacuum_cost_delay;
SHOW datestyle;
::SET datestyle = iso, ymd;
SHOW datestyle;
::RESET datestyle;
SHOW datestyle;
::SET seq_page_cost TO 'NaN';
SET vacuum_cost_delay TO '10s';
CREATE TEMP TABLE reset_test ( data text ) ON COMMIT DELETE ROWS;
DISCARD TEMP;
DECLARE foo CURSOR WITH HOLD FOR SELECT 1;
PREPARE foo AS SELECT 1;
LISTEN foo_event;
SET vacuum_cost_delay = 13;
CREATE TEMP TABLE tmp_foo (data text) ON COMMIT DELETE ROWS;
CREATE ROLE regress_guc_user;
SET SESSION AUTHORIZATION regress_guc_user;
SHOW vacuum_cost_delay;
DISCARD ALL;
SHOW vacuum_cost_delay;
DROP ROLE regress_guc_user;
set search_path = foo, public, not_there_initially;
create schema not_there_initially;
drop schema not_there_initially;
reset search_path;
set work_mem = '3MB';
create function report_guc(text) returns text as$$ select current_setting($1) $$ language sqlset work_mem = '1MB';
alter function report_guc(text) set work_mem = '2MB';
alter function report_guc(text) reset all;
create or replace function myfunc(int) returns text as $$begin  set local work_mem = '2MB';
  return current_setting('work_mem');
end $$language plpgsqlset work_mem = '1MB';
alter function myfunc(int) reset all;
set work_mem = '3MB';
create or replace function myfunc(int) returns text as $$begin  set work_mem = '2MB';
  return current_setting('work_mem');
end $$language plpgsqlset work_mem = '1MB';
set work_mem = '3MB';
create or replace function myfunc(int) returns text as $$begin  set work_mem = '2MB';
  perform 1/$1;
  return current_setting('work_mem');
end $$language plpgsqlset work_mem = '1MB';
select current_setting('nosuch.setting');  -- FAILselect current_setting('nosuch.setting', false);  -- FAILselect current_setting('nosuch.setting', true) is null;
set nosuch.setting = 'nada';
create function func_with_bad_set() returns int as $$ select 1 $$language sqlset default_text_search_config = no_such_config;
set check_function_bodies = off;
create function func_with_bad_set() returns int as $$ select 1 $$language sqlset default_text_search_config = no_such_config;
reset check_function_bodies;
set default_with_oids to f;
set default_with_oids to t;
SELECT DISTINCT two, string4, ten   FROM tmp   ORDER BY two using <, string4 using <, ten using <;
SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
EXPLAIN (VERBOSE, COSTS OFF)SELECT count(*) FROM  (SELECT DISTINCT two, four, two FROM tenk1) ss;
INSERT INTO DISTTABLE VALUES(NULL);
SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
SELECT 1 IS DISTINCT FROM 2 as "yes";
SELECT 2 IS DISTINCT FROM 2 as "no";
SELECT 2 IS DISTINCT FROM null as "yes";
SELECT null IS DISTINCT FROM null as "no";
SELECT 1 IS NOT DISTINCT FROM 2 as "no";
SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
SELECT 2 IS NOT DISTINCT FROM null as "no";
SELECT null IS NOT DISTINCT FROM null as "yes";
CREATE TABLE arrtest (	a 			int2[],	b 			int4[][][],	c 			name[],	d			text[][],	e 			float8[],	f			char(5)[],	g			varchar(5)[]);
INSERT INTO arrtest (a[1:5], b[1:1][1:2][1:2], c, d, f, g)   VALUES ('{1,2,3,4,5}', '{{{0,0},{1,2}}}', '{}', '{}', '{}', '{}');
UPDATE arrtest SET e[0] = '1.1';
UPDATE arrtest SET e[1] = '2.2';
INSERT INTO arrtest (a, b[1:2][1:2], c, d, e, f, g)   VALUES ('{11,12,23}', '{{3,4},{4,5}}', '{"foobar"}',           '{{"elt1", "elt2"}}', '{"3.4", "6.7"}',           '{"abc","abcde"}', '{"abc","abcde"}');
INSERT INTO arrtest (a, b[1:2], c, d[1:2])   VALUES ('{}', '{3,4}', '{foo,bar}', '{bar,foo}');
SELECT arrtest.a[1],          arrtest.b[1][1][1],          arrtest.c[1],          arrtest.d[1][1],          arrtest.e[0]   FROM arrtest;
:SELECT a[1:3],          b[1:1][1:2][1:2],          c[1:2],          d[1:1][1:2]   FROM arrtest;
::_SELECT *   FROM arrtest   WHERE a[1] < 5 and         c = '{"foobar"}'::_name;
UPDATE arrtest  SET a[1:2] = '{16,25}'  WHERE NOT a = '{}'::_int2;
UPDATE arrtest  SET b[1:1][1:1][1:2] = '{113, 117}',      b[1:1][1:2][2:2] = '{142, 147}'  WHERE array_dims(b) = '[1:1][1:2][1:2]';
UPDATE arrtest  SET c[2:2] = '{"new_word"}'  WHERE array_dims(c) is not null;
:SELECT a[1:3],          b[1:1][1:2][1:2],          c[1:2],          d[1:1][2:2]   FROM arrtest;
:SELECT b[1:1][2][2],       d[1:1][2]   FROM arrtest;
UPDATE arrtest SET a[4] = NULL WHERE a[2] IS NULL;
DELETE FROM arrtest WHERE a[2] IS NULL AND b IS NULL;
::select '{{1,2,3},{4,5,6},{7,8,9}}'::int[];
::select ('{{1,2,3},{4,5,6},{7,8,9}}'::int[])[1:2][2];
::select '[0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}'::int[];
::select ('[0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}'::int[])[1:2][2];
::SELECT ('{}'::int[])[1][2][3][4][5][6][7];
::SELECT ('{{{1},{2},{3}},{{4},{5},{6}}}'::int[])[1][NULL][1];
::SELECT ('{{{1},{2},{3}},{{4},{5},{6}}}'::int[])[1][NULL:1][1];
::SELECT ('{{{1},{2},{3}},{{4},{5},{6}}}'::int[])[1][1:NULL][1];
UPDATE arrtest  SET c[NULL] = '{"can''t assign"}'  WHERE array_dims(c) is not null;
UPDATE arrtest  SET c[NULL:1] = '{"can''t assign"}'  WHERE array_dims(c) is not null;
UPDATE arrtest  SET c[1:NULL] = '{"can''t assign"}'  WHERE array_dims(c) is not null;
CREATE TEMP TABLE arrtest_s (  a       int2[],  b       int2[][]);
:::::::SELECT a[:], b[:] FROM arrtest_s;
UPDATE arrtest_s SET a[:3] = '{11, 12, 13}', b[:2][:2] = '{{11,12}, {14,15}}'  WHERE array_lower(a,1) = 1;
UPDATE arrtest_s SET a[3:] = '{23, 24, 25}', b[2:][2:] = '{{25,26}, {28,29}}';
UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';
UPDATE arrtest_s SET a[:] = '{23, 24, 25}';  -- fail, too smallINSERT INTO arrtest_s VALUES(NULL, NULL);
UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';  -- fail, no good with nullSELECT f1[0:1] FROM POINT_TBL;
:::SELECT f1[:] FROM POINT_TBL;
UPDATE point_tbl SET f1[0] = 10 WHERE f1 IS NULL RETURNING *;
INSERT INTO point_tbl(f1[0]) VALUES(0) RETURNING *;
UPDATE point_tbl SET f1[0] = NULL WHERE f1::text = '(10,10)'::point::text RETURNING *;
UPDATE point_tbl SET f1[0] = -10, f1[1] = -10 WHERE f1::text = '(10,10)'::point::text RETURNING *;
UPDATE point_tbl SET f1[3] = 10 WHERE f1::text = '(-10,-10)'::point::text RETURNING *;
CREATE TEMP TABLE arrtest1 (i int[], t text[]);
insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
update arrtest1 set i[2] = 22, t[2] = 'twenty-two';
update arrtest1 set i[5] = 5, t[5] = 'five';
update arrtest1 set i[8] = 8, t[8] = 'eight';
update arrtest1 set i[0] = 0, t[0] = 'zero';
update arrtest1 set i[-3] = -3, t[-3] = 'minus-three';
update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
delete from arrtest1;
insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
CREATE TEMP TABLE arrtest2 (i integer ARRAY[4], f float8[], n numeric[], t text[], d timestamp[]);
INSERT INTO arrtest2 VALUES(  ARRAY[[[113,142],[1,147]]],  ARRAY[1.1,1.2,1.3]::float8[],  ARRAY[1.1,1.2,1.3],  ARRAY[[['aaa','aab'],['aba','abb'],['aca','acb']],[['baa','bab'],['bba','bbb'],['bca','bcb']]],  ARRAY['19620326','19931223','19970117']::timestamp[]);
CREATE TEMP TABLE arrtest_f (f0 int, f1 text, f2 float8);
SELECT t.f[1][3][1] AS "131", t.f[2][2][1] AS "221" FROM (  SELECT ARRAY[[[111,112],[121,122],[131,132]],[[211,212],[221,122],[231,232]]] AS f) AS t;
SELECT ARRAY[[[[[['hello'],['world']]]]]];
SELECT ARRAY(select f2 from arrtest_f order by f2) AS "ARRAY";
::SELECT '{1,null,3}'::int[];
SELECT ARRAY[1,NULL,3];
SELECT array_cat(ARRAY[1,2], ARRAY[[3,4],[5,6]]) AS "{{1,2},{3,4},{5,6}}";
SELECT array_cat(ARRAY[[3,4],[5,6]], ARRAY[1,2]) AS "{{3,4},{5,6},{1,2}}";
SELECT array_position(ARRAY[[1,2],[3,4]], 3);
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], NULL);
SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], NULL);
SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], 'sat');
SELECT array_positions(NULL, 10);
SELECT array_positions(NULL, NULL::int);
SELECT array_positions(ARRAY[[1,2],[3,4]], 4);
SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], NULL);
SELECT array_positions(ARRAY[1,2,3,NULL,5,6,1,2,3,NULL,5,6], NULL);
SELECT array_length(array_positions(ARRAY(SELECT 'AAAAAAAAAAAAAAAAAAAAAAAAA'::text || i % 10                                          FROM generate_series(1,100) g(i)),                                  'AAAAAAAAAAAAAAAAAAAAAAAAA5'), 1);
DO $$DECLARE  o int;
  a int[] := ARRAY[1,2,3,2,3,1,2];
BEGIN  o := array_position(a, 2);
  WHILE o IS NOT NULL  LOOP    RAISE NOTICE '%', o;
    o := array_position(a, 2, o + 1);
  END LOOP;
END$$ LANGUAGE plpgsql;
::SELECT array_position('[2:4]={1,2,3}'::int[], 1);
::SELECT array_positions('[2:4]={1,2,3}'::int[], 1);
SELECT    array_position(ids, (1, 1)),    array_positions(ids, (1, 1))        FROM(VALUES    (ARRAY[(0, 0), (1, 1)]),    (ARRAY[(1, 1)])) AS f (ids);
SELECT a FROM arrtest WHERE b = ARRAY[[[113,142],[1,147]]];
||SELECT ARRAY[1,2] || 3 AS "{1,2,3}";
||SELECT 0 || ARRAY[1,2] AS "{0,1,2}";
||SELECT ARRAY[1,2] || ARRAY[3,4] AS "{1,2,3,4}";
SELECT ARRAY[[['hello','world']]] || ARRAY[[['happy','birthday']]] AS "ARRAY";
SELECT ARRAY[[1,2],[3,4]] || ARRAY[5,6] AS "{{1,2},{3,4},{5,6}}";
||SELECT ARRAY[0,0] || ARRAY[1,1] || ARRAY[2,2] AS "{0,0,1,1,2,2}";
||SELECT 0 || ARRAY[1,2] || 3 AS "{0,1,2,3}";
@&&SELECT * FROM array_op_test WHERE i && '{32}' ORDER BY seqno;
@&&SELECT * FROM array_op_test WHERE i && '{17}' ORDER BY seqno;
@&&SELECT * FROM array_op_test WHERE i && '{32,17}' ORDER BY seqno;
@@&&SELECT * FROM array_op_test WHERE i && '{}' ORDER BY seqno;
@@&&SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
@@&&SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
@&&SELECT * FROM array_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
@&&SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
@@&&SELECT * FROM array_op_test WHERE t && '{}' ORDER BY seqno;
@::SELECT ARRAY[1,2,3]::text[]::int[]::float8[] AS "{1,2,3}";
::SELECT ARRAY[1,2,3]::text[]::int[]::float8[] is of (float8[]) as "TRUE";
SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] AS "{{a,bc},{def,hijk}}";
SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] is of (varchar[]) as "TRUE";
SELECT CAST(ARRAY[[[[[['a','bb','ccc']]]]]] as text[]) as "{{{{{{a,bb,ccc}}}}}}";
SELECT NULL::text[]::int[] AS "NULL";
select 33 = all ('{1,2,33}');
select 33 >= all ('{1,2,33}');
select null::int >= all ('{1,2,33}');
select null::int >= all ('{}');
select null::int >= any ('{}');
select 33.4 > all (array[1,2,3]);
select 33 = any (null::int[]);
select null::int = any ('{1,2,3}');
select 33 = all (null::int[]);
select null::int = all ('{1,2,3}');
select 33 = all ('{1,null,3}');
select 33 = all ('{33,null,33}');
SELECT -1 != ALL(ARRAY(SELECT NULLIF(g.i, 900) FROM generate_series(1,1000) g(i)));
create temp table arr_tbl (f1 int[] unique);
set enable_seqscan to off;
set enable_bitmapscan to off;
create temp table arr_pk_tbl (pk int4 primary key, f1 int[]);
insert into arr_pk_tbl values (1, '{3,4,5}') on conflict (pk)  do update set f1[1] = excluded.f1[1], f1[3] = excluded.f1[3]  returning pk, f1;
insert into arr_pk_tbl(pk, f1[1:2]) values (1, '{6,7,8}') on conflict (pk)  do update set f1[1] = excluded.f1[1],    f1[2] = excluded.f1[2],    f1[3] = excluded.f1[3]  returning pk, f1;
reset enable_seqscan;
reset enable_bitmapscan;
select 'foo' like any (array['%a', '%o']); -- tselect 'foo' like any (array['%a', '%b']); -- fselect 'foo' like all (array['f%', '%o']); -- tselect 'foo' like all (array['f%', '%b']); -- fselect 'foo' not like any (array['%a', '%b']); -- tselect 'foo' not like all (array['%a', '%o']); -- fselect 'foo' ilike any (array['%A', '%O']); -- tselect 'foo' ilike all (array['F%', '%O']); -- tselect '{{1,{2}},{2,3}}'::text[];
::select '{{},{}}'::text[];
select E'{{1,2},\\{2,3}}'::text[];
::select '{{"1 2" x},{3}}'::text[];
::select '{}}'::text[];
::select '{ }}'::text[];
select array[];
::select '{}'::text[];
::select '{{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}'::text[];
::select '{0 second  ,0 second}'::interval[];
::select '{ { "," } , { 3 } }'::text[];
::select '  {   {  "  0 second  "   ,  0 second  }   }'::text[];
::select '{           0 second,           @ 1 hour @ 42 minutes @ 20 seconds         }'::interval[];
select array[]::text[];
::select '[0:1]={1.1,2.2}'::float8[];
CREATE TEMP TABLE arraggtest ( f1 INT[], f2 TEXT[][], f3 FLOAT[]);
INSERT INTO arraggtest (f1, f2, f3) VALUES('{4,2,6,7,8,1}','{{red},{black},{purple},{blue},{blue}}',NULL);
create type comptype as (f1 int, f2 text);
create table comptable (c1 comptype, c2 comptype[]);
insert into comptable  values (row(1,'foo'), array[row(2,'bar')::comptype, row(3,'baz')::comptype]);
create type _comptype as enum('fooey');
select c2[2].f2 from comptable;
drop type _comptype;
drop type comptype;
create or replace function unnest1(anyarray)returns setof anyelement as $$select $1[s] from generate_subscripts($1,1) g(s);
$$ language sql immutable;
create or replace function unnest2(anyarray)returns setof anyelement as $$select $1[s1][s2] from generate_subscripts($1,1) g1(s1),                   generate_subscripts($1,2) g2(s2);
$$ language sql immutable;
select * from unnest2(array[[1,2,3],[4,5,6]]);
drop function unnest1(anyarray);
drop function unnest2(anyarray);
select array_fill(null::integer, array[3,3],array[2,2]);
select array_fill(null::integer, array[3,3]);
select array_fill(null::text, array[3,3],array[2,2]);
select array_fill(null::text, array[3,3]);
::select array_fill('juhu'::text, array[3,3],array[2,2]);
::select array_fill('juhu'::text, array[3,3]);
select array_fill(1, null, array[2,2]);
select array_fill(1, array[2,2], null);
select array_fill(1, array[1,2,null]);
select array_fill(1, array[[1,2],[3,4]]);
select string_to_array('1|2|3', NULL);
select string_to_array(NULL, '|') IS NULL;
select array_to_string(NULL::int4[], ',') IS NULL;
::select array_to_string('{}'::int4[], ',');
select array_to_string(array[1,2,3,4,NULL,6], ',');
select array_to_string(array[1,2,3,4,NULL,6], ',', '*');
select array_to_string(array[1,2,3,4,NULL,6], NULL);
select array_to_string(array[1,2,3,4,NULL,6], ',', NULL);
select array_length(array[[1,2,3], [4,5,6]], 0);
select array_length(array[[1,2,3], [4,5,6]], 1);
select array_length(array[[1,2,3], [4,5,6]], 2);
select array_length(array[[1,2,3], [4,5,6]], 3);
select cardinality(NULL::int[]);
::select cardinality('{}'::int[]);
::select cardinality('[2:4]={5,6,7}'::int[]);
::select cardinality('{{1,2}}'::int[]);
::select cardinality('{{1,2},{3,4},{5,6}}'::int[]);
::select cardinality('{{{1,9},{5,6}},{{2,3},{3,4}}}'::int[]);
select array_agg(ar)  from (values ('{1,2}'::int[]), ('{3,4}'::int[])) v(ar);
select array_agg(distinct ar order by ar desc)  from (select array[i / 2] from generate_series(1,10) a(i)) b(ar);
select array_agg(ar)  from (select array_agg(array[i, i+1, i-1])        from generate_series(1,2) a(i)) b(ar);
select array_agg(array[i+1.2, i+1.3, i+1.4]) from generate_series(1,3) g(i);
::select array_agg(array['Hello', i::text]) from generate_series(9,11) g(i);
select array_agg(array[i, nullif(i, 3), i+1]) from generate_series(1,4) g(i);
::select array_agg('{}'::int[]) from generate_series(1,2);
select array_agg(null::int[]) from generate_series(1,2);
select array_agg(ar)  from (values ('{1,2}'::int[]), ('{3}'::int[])) v(ar);
::select unnest(array[1,2,3,4.5]::float8[]);
::select unnest(array[1,2,3,4.5]::numeric[]);
select unnest(array[1,2,3,null,4,null,null,5,6]);
select unnest(array[1,2,3,null,4,null,null,5,6]::text[]);
select abs(unnest(array[1,2,null,-3]));
select array_remove(array[1,NULL,NULL,3], NULL);
select array_remove('{{1,2,2},{1,4,3}}', 2); -- not allowedselect array_remove(array['X','X','X'], 'X') = '{}';
select array_replace(array[1,2,5,4],5,NULL);
select array_replace(array[1,2,NULL,4,NULL],NULL,5);
select array_replace(array[1,NULL,3],NULL,NULL);
select array_replace(array['AB',NULL,'CDE'],NULL,'12');
select array(select array[i,i/2] from generate_series(1,5) i);
select array(select array['Hello', i::text] from generate_series(9,11) i);
create temp table t1 (f1 int8_tbl[]);
insert into t1 (f1[5].q1) values(42);
update t1 set f1[5].q2 = 43;
::insert into src  select string_agg(random()::text,'') from generate_series(1,10000);
create type textandtext as (c1 text, c2 text);
create temp table dest (f1 textandtext[]);
insert into dest select array[row(f1,f1)::textandtext] from src;
select length(md5((f1[1]).c2)) from dest;
delete from src;
select length(md5((f1[1]).c2)) from dest;
truncate table src;
select length(md5((f1[1]).c2)) from dest;
drop type textandtext;
::SELECT    op,    width_bucket(op::numeric, ARRAY[1, 3, 5, 10.0]::numeric[]) AS wb_n1,    width_bucket(op::numeric, ARRAY[0, 5.5, 9.99]::numeric[]) AS wb_n2,    width_bucket(op::numeric, ARRAY[-6, -5, 2.0]::numeric[]) AS wb_n3,    width_bucket(op::float8, ARRAY[1, 3, 5, 10.0]::float8[]) AS wb_f1,    width_bucket(op::float8, ARRAY[0, 5.5, 9.99]::float8[]) AS wb_f2,    width_bucket(op::float8, ARRAY[-6, -5, 2.0]::float8[]) AS wb_f3FROM (VALUES  (-5.2),  (-0.0000000001),  (0.000000000001),  (1),  (1.99999999999999),  (2),  (2.00000000000001),  (3),  (4),  (4.5),  (5),  (5.5),  (6),  (7),  (8),  (9),  (9.99999999999999),  (10),  (10.0000000000001)) v(op);
::SELECT    op,    width_bucket(op, ARRAY[1, 3, 9, 'NaN', 'NaN']::float8[]) AS wbFROM (VALUES  (-5.2::float8),  (4::float8),  (77::float8),  ('NaN'::float8)) v(op);
SELECT    op,    width_bucket(op, ARRAY[1, 3, 5, 10]) AS wb_1FROM generate_series(0,11) as op;
::SELECT width_bucket(now(),                    array['yesterday', 'today', 'tomorrow']::timestamptz[]);
::SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
SELECT width_bucket(5, ARRAY[3, 4, NULL]);
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foo1';
ROLLBACK PREPARED 'foo1';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foo2';
COMMIT PREPARED 'foo2';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foo3';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foo3';
ROLLBACK PREPARED 'foo3';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foo4';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foo5';
ROLLBACK PREPARED 'foo4';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  SAVEPOINT a;
  ROLLBACK TO a;
  SAVEPOINT b;
PREPARE TRANSACTION 'regress-one';
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  DECLARE foo CURSOR FOR SELECT * FROM pxtest4;
  -- Fetch 1 tuple, keeping the cursor open  FETCH 1 FROM foo;
PREPARE TRANSACTION 'regress-two';
FETCH 1 FROM foo;
begin;
lock table pxtest3 in access share mode nowait;
rollback;
\\c -SELECT gid FROM pg_prepared_xacts;
begin;
lock table pxtest3 in access share mode nowait;
rollback;
COMMIT PREPARED 'regress-one';
COMMIT PREPARED 'regress-two';
DROP TABLE pxtest3;  -- will still be there if prepared xacts are disabledDROP TABLE pxtest4;
CREATE ROLE regress_test_def_superuser;
CREATE ROLE regress_test_superuser WITH SUPERUSER;
ALTER ROLE regress_test_superuser WITH NOSUPERUSER;
ALTER ROLE regress_test_superuser WITH SUPERUSER;
CREATE ROLE regress_test_def_inherit;
CREATE ROLE regress_test_inherit WITH NOINHERIT;
ALTER ROLE regress_test_inherit WITH INHERIT;
ALTER ROLE regress_test_inherit WITH NOINHERIT;
CREATE ROLE regress_test_def_createrole;
CREATE ROLE regress_test_createrole WITH CREATEROLE;
ALTER ROLE regress_test_createrole WITH NOCREATEROLE;
ALTER ROLE regress_test_createrole WITH CREATEROLE;
CREATE ROLE regress_test_def_createdb;
CREATE ROLE regress_test_createdb WITH CREATEDB;
ALTER ROLE regress_test_createdb WITH NOCREATEDB;
ALTER ROLE regress_test_createdb WITH CREATEDB;
CREATE ROLE regress_test_def_role_canlogin;
CREATE ROLE regress_test_role_canlogin WITH LOGIN;
ALTER ROLE regress_test_role_canlogin WITH NOLOGIN;
ALTER ROLE regress_test_role_canlogin WITH LOGIN;
CREATE USER regress_test_def_user_canlogin;
CREATE USER regress_test_user_canlogin WITH NOLOGIN;
ALTER USER regress_test_user_canlogin WITH LOGIN;
ALTER USER regress_test_user_canlogin WITH NOLOGIN;
CREATE ROLE regress_test_def_replication;
CREATE ROLE regress_test_replication WITH REPLICATION;
ALTER ROLE regress_test_replication WITH NOREPLICATION;
ALTER ROLE regress_test_replication WITH REPLICATION;
CREATE ROLE regress_test_def_bypassrls;
CREATE ROLE regress_test_bypassrls WITH BYPASSRLS;
ALTER ROLE regress_test_bypassrls WITH NOBYPASSRLS;
ALTER ROLE regress_test_bypassrls WITH BYPASSRLS;
DROP ROLE regress_test_def_superuser;
DROP ROLE regress_test_superuser;
DROP ROLE regress_test_def_inherit;
DROP ROLE regress_test_inherit;
DROP ROLE regress_test_def_createrole;
DROP ROLE regress_test_createrole;
DROP ROLE regress_test_def_createdb;
DROP ROLE regress_test_createdb;
DROP ROLE regress_test_def_role_canlogin;
DROP ROLE regress_test_role_canlogin;
DROP USER regress_test_def_user_canlogin;
DROP USER regress_test_user_canlogin;
DROP ROLE regress_test_def_replication;
DROP ROLE regress_test_replication;
DROP ROLE regress_test_def_bypassrls;
DROP ROLE regress_test_bypassrls;
CREATE TABLE itest1 (a int generated by default as identity, b text);
CREATE TABLE itest2 (a bigint generated always as identity, b text);
CREATE TABLE itest3 (a smallint generated by default as identity (start with 7 increment by 5), b text);
ALTER TABLE itest3 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- errorSELECT table_name, column_name, column_default, is_nullable, is_identity, identity_generation, identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle FROM information_schema.columns WHERE table_name LIKE 'itest_' ORDER BY 1, 2;
SELECT sequence_name FROM information_schema.sequences WHERE sequence_name LIKE 'itest%';
ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, requires NOT NULLALTER TABLE itest4 ALTER COLUMN a SET NOT NULL;
ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- okALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;  -- error, disallowedALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, already setALTER TABLE itest4 ALTER COLUMN b ADD GENERATED ALWAYS AS IDENTITY;  -- error, wrong data typeALTER TABLE itest4 ALTER COLUMN b SET DEFAULT '';
CREATE TABLE itest_err_1 (a text generated by default as identity);
CREATE TABLE itest_err_2 (a int generated always as identity generated by default as identity);
CREATE TABLE itest_err_3 (a int default 5 generated by default as identity);
CREATE TABLE itest_err_4 (a serial generated by default as identity);
INSERT INTO itest3 VALUES (DEFAULT, 'a');
INSERT INTO itest3 VALUES (DEFAULT, 'b'), (DEFAULT, 'c');
INSERT INTO itest1 OVERRIDING USER VALUE VALUES (10, 'xyz');
INSERT INTO itest2 OVERRIDING SYSTEM VALUE VALUES (10, 'xyz');
UPDATE itest1 SET a = DEFAULT WHERE a = 2;
UPDATE itest2 SET a = DEFAULT WHERE a = 2;
CREATE TABLE itest9 (a int GENERATED ALWAYS AS IDENTITY, b text, c bigint);
COPY itest9 FROM stdin;
100	foo	200101	bar	201\.COPY itest9 (b, c) FROM stdin;
foo2	202bar2	203\.SELECT * FROM itest9 ORDER BY c;
ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;
ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;  -- errorALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY IF EXISTS;  -- noopINSERT INTO itest4 DEFAULT VALUES;  -- fails because NOT NULL is not droppedALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;
CREATE TABLE itest10 (a int generated by default as identity, b text);
CREATE TABLE itest11 (a int generated always as identity, b text);
INSERT INTO itestv10 OVERRIDING USER VALUE VALUES (11, 'xyz');
INSERT INTO itestv11 OVERRIDING SYSTEM VALUE VALUES (11, 'xyz');
DROP VIEW itestv10, itestv11;
ALTER TABLE itest13 ADD COLUMN b int GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE itest13 ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE itest1 ALTER COLUMN a SET DEFAULT 1;
CREATE TABLE itest5 (a serial, b text);
ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE itest3 ALTER COLUMN a TYPE int;
::::SELECT seqtypid::regtype FROM pg_sequence WHERE seqrelid = 'itest3_a_seq'::regclass;
ALTER TABLE itest3 ALTER COLUMN a TYPE text;  -- errorALTER TABLE itest3  ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY,  ALTER COLUMN c SET GENERATED ALWAYS;
CREATE TABLE itest6 (a int GENERATED ALWAYS AS IDENTITY, b text);
ALTER TABLE itest6 ALTER COLUMN a SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 100 RESTART;
SELECT table_name, column_name, is_identity, identity_generation FROM information_schema.columns WHERE table_name = 'itest6';
ALTER TABLE itest6 ALTER COLUMN b SET INCREMENT BY 2;  -- fail, not identityALTER SEQUENCE itest6_a_seq OWNED BY NONE;
CREATE TABLE itest7 (a int GENERATED ALWAYS AS IDENTITY);
CREATE TABLE itest7a (b text) INHERITS (itest7);
CREATE TABLE itest7c (a int GENERATED ALWAYS AS IDENTITY) INHERITS (itest7b);
CREATE TABLE itest7e () INHERITS (itest7d);
ALTER TABLE itest7d ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY;  -- errorSELECT table_name, column_name, is_nullable, is_identity, identity_generation FROM information_schema.columns WHERE table_name LIKE 'itest7%' ORDER BY 1, 2;
ALTER TABLE itest7 ALTER COLUMN a SET GENERATED BY DEFAULT;
ALTER TABLE itest7 ALTER COLUMN a RESTART;
ALTER TABLE itest7 ALTER COLUMN a DROP IDENTITY;
CREATE USER regress_identity_user1;
CREATE TABLE itest8 (a int GENERATED ALWAYS AS IDENTITY, b text);
GRANT SELECT, INSERT ON itest8 TO regress_identity_user1;
SET ROLE regress_identity_user1;
RESET ROLE;
DROP USER regress_identity_user1;
CREATE TYPE itest_type AS (f1 integer, f2 text, f3 bigint);
CREATE TABLE itest12 OF itest_type (f1 WITH OPTIONS GENERATED ALWAYS AS IDENTITY); -- errorDROP TYPE itest_type CASCADE;
CREATE TABLE itest_parent (f1 date NOT NULL, f2 text, f3 bigint) PARTITION BY RANGE (f1);
CREATE TABLE itest_child PARTITION OF itest_parent (    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01'); -- errorDROP TABLE itest_parent;
CREATE TABLE itest14 (id serial);
ALTER TABLE itest14 ALTER id DROP DEFAULT;
ALTER TABLE itest14 ALTER id ADD GENERATED BY DEFAULT AS IDENTITY;
INSERT INTO itest14 (id) VALUES (DEFAULT);
create function sp_parallel_restricted(int) returns int as  $$begin return $1; end$$ language plpgsql parallel restricted;
begin isolation level repeatable read;
set parallel_setup_cost=0;
set parallel_tuple_cost=0;
set min_parallel_table_scan_size=0;
set max_parallel_workers_per_gather=4;
explain (costs off)  select round(avg(aa)), sum(aa) from a_star;
alter table c_star set (parallel_workers = 0);
alter table d_star set (parallel_workers = 0);
explain (costs off)  select round(avg(aa)), sum(aa) from a_star;
alter table a_star set (parallel_workers = 0);
alter table b_star set (parallel_workers = 0);
alter table e_star set (parallel_workers = 0);
alter table f_star set (parallel_workers = 0);
explain (costs off)  select round(avg(aa)), sum(aa) from a_star;
alter table a_star reset (parallel_workers);
alter table b_star reset (parallel_workers);
alter table c_star reset (parallel_workers);
alter table d_star reset (parallel_workers);
alter table e_star reset (parallel_workers);
alter table f_star reset (parallel_workers);
set enable_parallel_append to off;
explain (costs off)  select round(avg(aa)), sum(aa) from a_star;
reset enable_parallel_append;
create function sp_test_func() returns setof text as$$ select 'foo'::varchar union all select 'bar'::varchar $$language sql stable;
create table part_pa_test(a int, b int) partition by range(a);
create table part_pa_test_p1 partition of part_pa_test for values from (minvalue) to (0);
create table part_pa_test_p2 partition of part_pa_test for values from (0) to (maxvalue);
explain (costs off)	select (select max((select pa1.b from part_pa_test pa1 where pa1.a = pa2.a)))	from part_pa_test pa2;
set parallel_leader_participation = off;
explain (costs off)  select count(*) from tenk1 where stringu1 = 'GRAAAA';
set max_parallel_workers = 0;
explain (costs off)  select count(*) from tenk1 where stringu1 = 'GRAAAA';
reset max_parallel_workers;
reset parallel_leader_participation;
alter table tenk1 set (parallel_workers = 4);
explain (verbose, costs off)select sp_parallel_restricted(unique1) from tenk1  where stringu1 = 'GRAAAA' order by 1;
explain (costs off)	select length(stringu1) from tenk1 group by length(stringu1);
explain (costs off)	select stringu1, count(*) from tenk1 group by stringu1 order by stringu1;
explain (costs off)	select  sum(sp_parallel_restricted(unique1)) from tenk1	group by(sp_parallel_restricted(unique1));
prepare tenk1_count(integer) As select  count((unique1)) from tenk1 where hundred > $1;
explain (costs off) execute tenk1_count(1);
execute tenk1_count(1);
deallocate tenk1_count;
alter table tenk2 set (parallel_workers = 0);
explain (costs off)	select count(*) from tenk1 where (two, four) not in	(select hundred, thousand from tenk2 where thousand > 100);
explain (costs off)	select * from tenk1 where (unique1 + random())::integer not in	(select ten from tenk2);
alter table tenk2 reset (parallel_workers);
set enable_indexscan = off;
set enable_indexonlyscan = off;
set enable_bitmapscan = off;
alter table tenk2 set (parallel_workers = 2);
explain (costs off)	select count(*) from tenk1        where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2);
select count(*) from tenk1    where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2);
reset enable_indexscan;
reset enable_indexonlyscan;
reset enable_bitmapscan;
alter table tenk2 reset (parallel_workers);
set enable_seqscan to off;
set enable_bitmapscan to off;
explain (costs off)	select  count((unique1)) from tenk1 where hundred > 1;
explain (costs off)	select  count(*) from tenk1 where thousand > 95;
set enable_material = false;
explain (costs off)select * from  (select count(unique1) from tenk1 where hundred > 10) ss  right join (values (1),(2),(3)) v(x) on true;
select * from  (select count(unique1) from tenk1 where hundred > 10) ss  right join (values (1),(2),(3)) v(x) on true;
explain (costs off)select * from  (select count(*) from tenk1 where thousand > 99) ss  right join (values (1),(2),(3)) v(x) on true;
select * from  (select count(*) from tenk1 where thousand > 99) ss  right join (values (1),(2),(3)) v(x) on true;
reset enable_seqscan;
set enable_indexonlyscan to off;
set enable_indexscan to off;
alter table tenk1 set (parallel_workers = 0);
alter table tenk2 set (parallel_workers = 1);
explain (costs off)select count(*) from tenk1  left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss  on tenk1.unique1 < ss.unique1 + 1  where tenk1.unique1 < 2;
select count(*) from tenk1  left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss  on tenk1.unique1 < ss.unique1 + 1  where tenk1.unique1 < 2;
alter table tenk1 set (parallel_workers = 4);
alter table tenk2 reset (parallel_workers);
reset enable_material;
reset enable_bitmapscan;
reset enable_indexonlyscan;
reset enable_indexscan;
set enable_seqscan to off;
set enable_indexscan to off;
set enable_hashjoin to off;
set enable_mergejoin to off;
set enable_material to off;
DO $$BEGIN SET effective_io_concurrency = 50;
EXCEPTION WHEN invalid_parameter_value THENEND $$;
set work_mem='64kB';  --set small work mem to force lossy pagesexplain (costs off)	select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0;
select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0;
reset enable_seqscan;
alter table tenk2 set (parallel_workers = 0);
explain (analyze, timing off, summary off, costs off)   select count(*) from tenk1, tenk2 where tenk1.hundred > 1        and tenk2.thousand=0;
alter table tenk2 reset (parallel_workers);
reset work_mem;
create function explain_parallel_sort_stats() returns setof textlanguage plpgsql as$$declare ln text;
begin    for ln in        explain (analyze, timing off, summary off, costs off)          select * from          (select ten from tenk1 where ten < 100 order by ten) ss          right join (values (1),(2),(3)) v(x) on true    loop        ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
        return next ln;
    end loop;
end;
$$;
select * from explain_parallel_sort_stats();
reset enable_indexscan;
reset enable_hashjoin;
reset enable_mergejoin;
reset enable_material;
reset effective_io_concurrency;
drop function explain_parallel_sort_stats();
set enable_hashjoin to off;
set enable_nestloop to off;
explain (costs off)	select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1;
select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1;
reset enable_hashjoin;
reset enable_nestloop;
set enable_hashagg = false;
explain (costs off)   select count(*) from tenk1 group by twenty;
create function sp_simple_func(var1 integer) returns integeras $$begin        return var1 + 10;
end;
$$ language plpgsql PARALLEL SAFE;
explain (costs off, verbose)    select ten, sp_simple_func(ten) from tenk1 where ten < 100 order by ten;
drop function sp_simple_func(integer);
explain (costs off)   select count(*), generate_series(1,2) from tenk1 group by twenty;
set parallel_leader_participation = off;
explain (costs off)   select count(*) from tenk1 group by twenty;
reset parallel_leader_participation;
set enable_material = false;
explain (costs off)select * from  (select string4, count(unique2)   from tenk1 group by string4 order by string4) ss  right join (values (1),(2),(3)) v(x) on true;
select * from  (select string4, count(unique2)   from tenk1 group by string4 order by string4) ss  right join (values (1),(2),(3)) v(x) on true;
reset enable_material;
reset enable_hashagg;
explain (costs off)select avg(unique1::int8) from tenk1;
::explain (costs off)  select fivethous from tenk1 order by fivethous limit 4;
set max_parallel_workers = 0;
explain (costs off)   select string4 from tenk1 order by string4 limit 5;
set parallel_leader_participation = off;
explain (costs off)   select string4 from tenk1 order by string4 limit 5;
reset parallel_leader_participation;
reset max_parallel_workers;
SAVEPOINT settings;
SET LOCAL force_parallel_mode = 1;
explain (costs off)  select stringu1::int2 from tenk1 where unique1 = 1;
ROLLBACK TO SAVEPOINT settings;
CREATE FUNCTION make_record(n int)  RETURNS RECORD LANGUAGE plpgsql PARALLEL SAFE AS$$BEGIN  RETURN CASE n           WHEN 1 THEN ROW(1)           WHEN 2 THEN ROW(1, 2)           WHEN 3 THEN ROW(1, 2, 3)           WHEN 4 THEN ROW(1, 2, 3, 4)           ELSE ROW(1, 2, 3, 4, 5)         END;
END;
$$;
SAVEPOINT settings;
SET LOCAL force_parallel_mode = 1;
ROLLBACK TO SAVEPOINT settings;
DROP function make_record(n int);
drop role if exists regress_parallel_worker;
create role regress_parallel_worker;
set role regress_parallel_worker;
reset session authorization;
drop role regress_parallel_worker;
set force_parallel_mode = 1;
reset force_parallel_mode;
reset role;
explain (costs off, verbose)  select count(*) from tenk1 a where (unique1, two) in    (select unique1, row_number() over() from tenk1 b);
explain (costs off)  select * from tenk1 a where two in    (select two from tenk1 b where stringu1 like '%AAAA' limit 3);
SAVEPOINT settings;
SET LOCAL force_parallel_mode = 1;
EXPLAIN (analyze, timing off, summary off, costs off) SELECT * FROM tenk1;
ROLLBACK TO SAVEPOINT settings;
SAVEPOINT settings;
SET LOCAL force_parallel_mode = 1;
::ROLLBACK TO SAVEPOINT settings;
SAVEPOINT settings;
SET LOCAL parallel_setup_cost = 10;
EXPLAIN (COSTS OFF)SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1UNION ALLSELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1;
ROLLBACK TO SAVEPOINT settings;
EXPLAIN (COSTS OFF)SELECT unique1 FROM tenk1 WHERE fivethous =	(SELECT unique1 FROM tenk1 WHERE fivethous = 1 LIMIT 1)UNION ALLSELECT unique1 FROM tenk1 WHERE fivethous =	(SELECT unique2 FROM tenk1 WHERE fivethous = 1 LIMIT 1)ORDER BY 1;
SELECT * FROM information_schema.foreign_data_wrapper_optionsORDER BY 1, 2, 3;
CREATE FUNCTION make_some_array(int,int) returns int[] as$$declare x int[];
  begin    x[1] := $1;
    x[2] := $2;
    return x;
  end$$ language plpgsql parallel safe;
CREATE TABLE fooarr(f1 text, f2 int[], f3 text);
PREPARE pstmt(text, int[]) AS SELECT * FROM fooarr WHERE f1 = $1 AND f2 = $2;
EXPLAIN (COSTS OFF) EXECUTE pstmt('1', make_some_array(1,2));
EXECUTE pstmt('1', make_some_array(1,2));
DEALLOCATE pstmt;
CREATE VIEW tenk1_vw_sec WITH (security_barrier) AS SELECT * FROM tenk1;
EXPLAIN (COSTS OFF)SELECT 1 FROM tenk1_vw_sec  WHERE (SELECT sum(f1) FROM int4_tbl WHERE f1 < unique1) < 100;
rollback;
SET max_parallel_maintenance_workers = 0;
SET max_parallel_workers = 0;
CREATE TABLE abbrev_abort_uuids (    id serial not null,    abort_increasing uuid,    abort_decreasing uuid,    noabort_increasing uuid,    noabort_decreasing uuid);
||INSERT INTO abbrev_abort_uuids (abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasing)    SELECT        ('00000000-0000-0000-0000-'||to_char(g.i, '000000000000FM'))::uuid abort_increasing,        ('00000000-0000-0000-0000-'||to_char(20000 - g.i, '000000000000FM'))::uuid abort_decreasing,        (to_char(g.i % 10009, '00000000FM')||'-0000-0000-0000-'||to_char(g.i, '000000000000FM'))::uuid noabort_increasing,        (to_char(((20000 - g.i) % 10009), '00000000FM')||'-0000-0000-0000-'||to_char(20000 - g.i, '000000000000FM'))::uuid noabort_decreasing    FROM generate_series(0, 20000, 1) g(i);
INSERT INTO abbrev_abort_uuids (abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasing)    SELECT abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasing    FROM abbrev_abort_uuids    WHERE (id < 10 OR id > 19990) AND id % 3 = 0 AND abort_increasing is not null;
SELECT abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_increasing OFFSET 20000 - 4;
SELECT abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_decreasing NULLS FIRST OFFSET 20000 - 4;
SELECT noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_increasing OFFSET 20000 - 4;
SELECT noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing NULLS FIRST OFFSET 20000 - 4;
EXPLAIN (COSTS OFF)SELECT id, noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_increasing LIMIT 5;
EXPLAIN (COSTS OFF)SELECT id, noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing LIMIT 5;
EXPLAIN (COSTS OFF)SELECT id, abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_increasing LIMIT 5;
EXPLAIN (COSTS OFF)SELECT id, abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_decreasing LIMIT 5;
BEGIN;
SET LOCAL enable_indexscan = false;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__abort_increasing_idx;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid LIMIT 5;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid DESC LIMIT 5;
ROLLBACK;
BEGIN;
SET LOCAL enable_indexscan = false;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__abort_decreasing_idx;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid LIMIT 5;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid DESC LIMIT 5;
ROLLBACK;
BEGIN;
SET LOCAL enable_indexscan = false;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__noabort_increasing_idx;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid LIMIT 5;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid DESC LIMIT 5;
ROLLBACK;
BEGIN;
SET LOCAL enable_indexscan = false;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__noabort_decreasing_idx;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid LIMIT 5;
SELECT id, abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasingFROM abbrev_abort_uuidsORDER BY ctid DESC LIMIT 5;
ROLLBACK;
BEGIN;
SET LOCAL enable_indexscan = false;
EXPLAIN (COSTS OFF) DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
FETCH LAST FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
COMMIT;
BEGIN;
SET LOCAL enable_indexscan = false;
SET LOCAL work_mem = '100kB';
EXPLAIN (COSTS OFF) DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
FETCH LAST FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
COMMIT;
SELECT    -- fixed-width by-value datum    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],    -- fixed-width by-ref datum    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],    -- variable-width datum    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],    -- fixed width by-value datum tuplesort    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),    -- ensure state is shared    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),    -- fixed width by-ref datum tuplesort    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),    -- variable width by-ref datum tuplesort    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),    -- multi-column tuplesort    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)FROM (    SELECT * FROM abbrev_abort_uuids    UNION ALL    SELECT NULL, NULL, NULL, NULL, NULL) s;
BEGIN;
SET LOCAL work_mem = '100kB';
SELECT    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)FROM (    SELECT * FROM abbrev_abort_uuids    UNION ALL    SELECT NULL, NULL, NULL, NULL, NULL) s;
ROLLBACK;
INSERT INTO test_mark_restore(col1, col2, col12)   SELECT a.i, b.i, a.i * b.i FROM generate_series(1, 500) a(i), generate_series(1, 5) b(i);
BEGIN;
SET LOCAL enable_nestloop = off;
SET LOCAL enable_hashjoin = off;
SET LOCAL enable_material = off;
SELECT $$    SELECT col12, count(distinct a.col1), count(distinct a.col2), count(distinct b.col1), count(distinct b.col2), count(*)    FROM test_mark_restore a        JOIN test_mark_restore b USING(col12)    GROUP BY 1    HAVING count(*) > 1    ORDER BY 2 DESC, 1 DESC, 3 DESC, 4 DESC, 5 DESC, 6 DESC    LIMIT 10$$ AS qry \gsetEXPLAIN (COSTS OFF) :qry;
::qry;
SET LOCAL work_mem = '100kB';
EXPLAIN (COSTS OFF) :qry;
::qry;
COMMIT;
REINDEX TABLE pg_class; -- mapped, non-shared, criticalREINDEX TABLE pg_index; -- non-mapped, non-shared, criticalREINDEX TABLE pg_operator; -- non-mapped, non-shared, criticalREINDEX TABLE pg_database; -- mapped, shared, criticalREINDEX TABLE pg_shdescription; -- mapped, shared non-criticalREINDEX INDEX pg_class_oid_index; -- mapped, non-shared, criticalREINDEX INDEX pg_class_relname_nsp_index; -- mapped, non-shared, non-criticalREINDEX INDEX pg_index_indexrelid_index; -- non-mapped, non-shared, criticalREINDEX INDEX pg_index_indrelid_index; -- non-mapped, non-shared, non-criticalREINDEX INDEX pg_database_oid_index; -- mapped, shared, criticalREINDEX INDEX pg_shdescription_o_c_index; -- mapped, shared, non-criticalcreate type textrange as range (subtype=text, collation="C");
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::CREATE TABLE numrange_test (nr NUMRANGE);
@@|select range_adjacent(numrange(2.0, 3.0), numrange(3.1, null));
||@@&&select numrange(4.5, 5.5, '[]') && numrange(5.5, 6.5);
select numrange(1.0, 2.0) << numrange(3.0, 4.0);
select numrange(1.0, 3.0,'[]') << numrange(3.0, 4.0,'[]');
select numrange(1.0, 3.0,'()') << numrange(3.0, 4.0,'()');
select numrange(1.0, 2.0) >> numrange(3.0, 4.0);
&select numrange(1.0, 2.0) + numrange(2.5, 3.0); -- should failselect range_merge(numrange(1.0, 2.0), numrange(2.0, 3.0));
select range_merge(numrange(1.0, 2.0), numrange(2.5, 3.0)); -- shouldn't failselect numrange(1.0, 2.0) * numrange(2.0, 3.0);
create table numrange_test2(nr numrange);
create index numrange_test2_hash_idx on numrange_test2 using hash (nr);
::select * from numrange_test2 where nr = 'empty'::numrange;
set enable_nestloop=t;
set enable_hashjoin=f;
set enable_mergejoin=f;
set enable_nestloop=f;
set enable_hashjoin=t;
set enable_mergejoin=f;
set enable_nestloop=f;
set enable_hashjoin=f;
set enable_mergejoin=t;
set enable_nestloop to default;
set enable_hashjoin to default;
set enable_mergejoin to default;
::::::::::::::::::::::::::::::::::::::::create table test_range_gist(ir int4range);
create index test_range_gist_idx on test_range_gist using gist (ir);
::::insert into test_range_gist select int4range(NULL,g*10,'(]') from generate_series(1,100) g;
insert into test_range_gist select int4range(g*10,NULL,'(]') from generate_series(1,100) g;
SET enable_seqscan    = t;
SET enable_indexscan  = f;
SET enable_bitmapscan = f;
@::select count(*) from test_range_gist where ir @> 'empty'::int4range;
@@&&select count(*) from test_range_gist where ir && int4range(10,20);
@select count(*) from test_range_gist where ir << int4range(100,500);
select count(*) from test_range_gist where ir >> int4range(100,500);
&&|SET enable_seqscan    = f;
SET enable_indexscan  = t;
SET enable_bitmapscan = f;
@::select count(*) from test_range_gist where ir @> 'empty'::int4range;
@@&&select count(*) from test_range_gist where ir && int4range(10,20);
@select count(*) from test_range_gist where ir << int4range(100,500);
select count(*) from test_range_gist where ir >> int4range(100,500);
&&|create index test_range_gist_idx on test_range_gist using gist (ir);
@::select count(*) from test_range_gist where ir @> 'empty'::int4range;
@@&&select count(*) from test_range_gist where ir && int4range(10,20);
@select count(*) from test_range_gist where ir << int4range(100,500);
select count(*) from test_range_gist where ir >> int4range(100,500);
&&|create table test_range_spgist(ir int4range);
create index test_range_spgist_idx on test_range_spgist using spgist (ir);
::::insert into test_range_spgist select int4range(NULL,g*10,'(]') from generate_series(1,100) g;
insert into test_range_spgist select int4range(g*10,NULL,'(]') from generate_series(1,100) g;
SET enable_seqscan    = t;
SET enable_indexscan  = f;
SET enable_bitmapscan = f;
@::select count(*) from test_range_spgist where ir @> 'empty'::int4range;
@@&&select count(*) from test_range_spgist where ir && int4range(10,20);
@select count(*) from test_range_spgist where ir << int4range(100,500);
select count(*) from test_range_spgist where ir >> int4range(100,500);
&&|SET enable_seqscan    = f;
SET enable_indexscan  = t;
SET enable_bitmapscan = f;
@::select count(*) from test_range_spgist where ir @> 'empty'::int4range;
@@&&select count(*) from test_range_spgist where ir && int4range(10,20);
@select count(*) from test_range_spgist where ir << int4range(100,500);
select count(*) from test_range_spgist where ir >> int4range(100,500);
&&|create index test_range_spgist_idx on test_range_spgist using spgist (ir);
@::select count(*) from test_range_spgist where ir @> 'empty'::int4range;
@@&&select count(*) from test_range_spgist where ir && int4range(10,20);
@select count(*) from test_range_spgist where ir << int4range(100,500);
select count(*) from test_range_spgist where ir >> int4range(100,500);
&&|explain (costs off)select ir from test_range_spgist where ir -|- int4range(10,20) order by ir;
|RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
create table test_range_elem(i int4);
@create table test_range_excl(  room int4range,  speaker int4range,  during tsrange,  exclude using gist (room with =, during with &&),  exclude using gist (speaker with =, during with &&));
::::set timezone to '-08';
::::set timezone to default;
create type float8range as range (subtype=float8, subtype_diff=float4mi);
create type float8range as range (subtype=float8, subtype_diff=float8mi);
::@select '[123.001, 5.e9)'::float8range @> 888.882::float8;
create table float8range_test(f8r float8range, i int);
create domain mydomain as int4;
create type mydomainrange as range(subtype=mydomain);
::@select '[4,50)'::mydomainrange @> 7::mydomain;
drop domain mydomain;  -- faildrop domain mydomain cascade;
create domain restrictedrange as int4range check (upper(value) < 10);
::@select '[4,5)'::restrictedrange @> 7;
::@select '[4,50)'::restrictedrange @> 7; -- should faildrop domain restrictedrange;
create type textrange1 as range(subtype=text, collation="C");
create type textrange2 as range(subtype=text, collation="C");
@::select textrange1('a','Z') @> 'b'::text;
@::select textrange2('a','z') @> 'b'::text;
drop type textrange1;
drop type textrange2;
create function anyarray_anyrange_func(a anyarray, r anyrange)  returns anyelement as 'select $1[1] + lower($2);' language sql;
drop function anyarray_anyrange_func(anyarray, anyrange);
create function bogus_func(anyelement)  returns anyrange as 'select int4range(1,10)' language sql;
create function bogus_func(int)  returns anyrange as 'select int4range(1,10)' language sql;
create function range_add_bounds(anyrange)  returns anyelement as 'select lower($1) + upper($1)' language sql;
create function rangetypes_sql(q anyrange, b anyarray, out c anyelement)  as $$ select upper($1) + $2[1] $$  language sql;
select rangetypes_sql(numrange(1,10), ARRAY[2,20]);  -- match failureselect ARRAY[numrange(1.1, 1.2), numrange(12.3, 155.5)];
create table i8r_array (f1 int, f2 int8range[]);
create type arrayrange as range (subtype=int4[]);
select arrayrange(ARRAY[2,1], ARRAY[1,2]);  -- failselect array[1,1] <@ arrayrange(array[1,2], array[2,1]);
@create type two_ints as (a int, b int);
create type two_ints_range as range (subtype = two_ints);
select *, row_to_json(upper(t)) as u from  (values (two_ints_range(row(1,2), row(3,4))),          (two_ints_range(row(5,6), row(7,8)))) v(t);
drop type two_ints cascade;
create type cashrange as range (subtype = money);
set enable_sort = off;  -- try to make it pick a hash setop implementationselect '(2,5)'::cashrange except select '(5,6)'::cashrange;
reset enable_sort;
create function outparam_succeed(i anyrange, out r anyrange, out t text)  as $$ select $1, 'foo'::text $$ language sql;
create function inoutparam_succeed(out i anyelement, inout r anyrange)  as $$ select upper($1), $1 $$ language sql;
create function table_succeed(i anyelement, r anyrange) returns table(i anyelement, r anyrange)  as $$ select $1, $2 $$ language sql;
create function outparam_fail(i anyelement, out r anyrange, out t text)  as $$ select '[1,10]', 'foo' $$ language sql;
create function inoutparam_fail(inout i anyelement, out r anyrange)  as $$ select $1, '[1,10]' $$ language sql;
create function table_fail(i anyelement) returns table(i anyelement, r anyrange)  as $$ select $1, '[1,10]' $$ language sql;
create table idxpart (a int, b int, c text) partition by range (a);
create table idxpart1 partition of idxpart for values from (0) to (10);
create table idxpart2 partition of idxpart for values from (10) to (100)	partition by range (b);
create table idxpart21 partition of idxpart2 for values from (0) to (100);
create index idxpart_idx on only idxpart(a);
create index on idxpart (a);
::select relname, relkind, relhassubclass, inhparent::regclass    from pg_class left join pg_index ix on (indexrelid = oid)	left join pg_inherits on (ix.indexrelid = inhrelid)	where relname like 'idxpart%' order by relname;
create table idxpart (a int, b int, c text) partition by range (a);
create table idxpart1 partition of idxpart for values from (0) to (10);
CREATE TABLE idxpart (col1 INT) PARTITION BY RANGE (col1);
CREATE INDEX ON idxpart (col1);
SELECT col2 FROM idxpart_two fk LEFT OUTER JOIN idxpart pk ON (col1 = col2);
DROP table idxpart, idxpart_two;
CREATE TABLE idxpart (a INT, b TEXT, c INT) PARTITION BY RANGE(a);
CREATE TABLE idxpart1 PARTITION OF idxpart FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
ALTER TABLE idxpart ALTER COLUMN c TYPE numeric;
create table idxpart (a int, b int, c text) partition by range (a);
create table idxpart1 (like idxpart);
alter table idxpart attach partition idxpart1 for values from (0) to (10);
create table idxpart (a int, b int) partition by range (a, b);
create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);
create index on idxpart1 (a, b);
create index on idxpart (a, b);
::select relname, relkind, relhassubclass, inhparent::regclass    from pg_class left join pg_index ix on (indexrelid = oid)	left join pg_inherits on (ix.indexrelid = inhrelid)	where relname like 'idxpart%' order by relname;
create table idxpart (a int) partition by range (a);
create index on idxpart (a);
create table idxpart1 partition of idxpart for values from (0) to (10);
drop index idxpart1_a_idx;	-- no waydrop index idxpart_a_idx;	-- both indexes go awayselect relname, relkind from pg_class  where relname like 'idxpart%' order by relname;
create index on idxpart (a);
drop table idxpart1;		-- the index on partition goes away tooselect relname, relkind from pg_class  where relname like 'idxpart%' order by relname;
create table idxpart (a int, b int) partition by range (a, b);
create table idxpart1 partition of idxpart for values from (0, 0) to (10, 10);
create index idxpart_a_b_idx on only idxpart (a, b);
create index idxpart1_tst2 on idxpart1 using hash (a);
alter index idxpart attach partition idxpart1;
alter index idxpart_a_b_idx attach partition idxpart1;
alter index idxpart_a_b_idx attach partition idxpart_a_b_idx;
alter index idxpart_a_b_idx attach partition idxpart1_b_idx;
alter index idxpart_a_b_idx attach partition idxpart1_tst1;
alter index idxpart_a_b_idx attach partition idxpart1_tst2;
alter index idxpart_a_b_idx attach partition idxpart1_tst3;
alter index idxpart_a_b_idx attach partition idxpart1_a_b_idx;
alter index idxpart_a_b_idx attach partition idxpart1_a_b_idx; -- quietcreate index idxpart1_2_a_b on idxpart1 (a, b);
alter index idxpart_a_b_idx attach partition idxpart1_2_a_b;
::::::select indexrelid::regclass, indrelid::regclass  from pg_index where indexrelid::regclass::text like 'idxpart%';
create table idxpart (a int, b int) partition by range (a);
create index on idxpart1 using hash (a);
create index on idxpart1 (a) where b > 1;
create index on idxpart1 ((a + 0));
create index on idxpart1 (a, a);
create index on idxpart (a);
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
create table idxpart (a int) partition by range (a);
create table idxpart1 partition of idxpart for values from (0) to (100);
create table idxpart2 partition of idxpart for values from (100) to (1000)  partition by range (a);
create table idxpart21 partition of idxpart2 for values from (100) to (200);
create table idxpart22 partition of idxpart2 for values from (200) to (300);
create index on idxpart22 (a);
create index on only idxpart2 (a);
create index on idxpart (a);
::::::select indexrelid::regclass, indrelid::regclass, inhparent::regclass  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)where indexrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
alter index idxpart2_a_idx attach partition idxpart22_a_idx;
::::::select indexrelid::regclass, indrelid::regclass, inhparent::regclass  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)where indexrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
alter index idxpart2_a_idx attach partition idxpart22_a_idx;
create index on idxpart21 (a);
alter index idxpart2_a_idx attach partition idxpart21_a_idx;
create table idxpart (a int, b int, c text) partition by range (a);
create table idxpart1 (like idxpart including indexes);
::select relname, relkind, inhparent::regclass    from pg_class left join pg_index ix on (indexrelid = oid)	left join pg_inherits on (ix.indexrelid = inhrelid)	where relname like 'idxpart%' order by relname;
alter table idxpart attach partition idxpart1 for values from (0) to (10);
::select relname, relkind, inhparent::regclass    from pg_class left join pg_index ix on (indexrelid = oid)	left join pg_inherits on (ix.indexrelid = inhrelid)	where relname like 'idxpart%' order by relname;
create table idxpart (a int, b int) partition by range (a);
create table idxpart1 partition of idxpart for values from (1) to (1000) partition by range (a);
create table idxpart11 partition of idxpart1 for values from (1) to (100);
create index on only idxpart1 (a);
create index on only idxpart (a);
alter index idxpart_a_idx attach partition idxpart1_a_idx;
create index on idxpart11 (a);
alter index idxpart1_a_idx attach partition idxpart11_a_idx;
create table idxpart (a int) partition by range (a);
create table idxpart1 (like idxpart);
create index on idxpart1 (a);
create index on idxpart (a);
create table idxpart2 (like idxpart);
alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
create table idxpart3 partition of idxpart for values from (2000) to (3000);
alter table idxpart detach partition idxpart1;
alter table idxpart detach partition idxpart2;
alter table idxpart detach partition idxpart3;
drop table idxpart, idxpart1, idxpart2, idxpart3;
create table idxpart (a int) partition by range (a);
create table idxpart1 (like idxpart);
create index on idxpart1 (a);
create index on idxpart (a);
create table idxpart2 (like idxpart);
alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
create table idxpart3 partition of idxpart for values from (2000) to (3000);
alter table idxpart detach partition idxpart1;
alter table idxpart detach partition idxpart2;
alter table idxpart detach partition idxpart3;
drop table idxpart, idxpart1, idxpart2, idxpart3;
create table idxpart (a int, b int, c int) partition by range(a);
create index on idxpart(c);
create table idxpart1 partition of idxpart for values from (0) to (250);
create table idxpart2 partition of idxpart for values from (250) to (500);
alter table idxpart detach partition idxpart2;
alter table idxpart2 drop column c;
drop table idxpart, idxpart2;
create table idxpart (a int, b int) partition by range (a);
create table idxpart1 (like idxpart);
create index on idxpart1 ((a + b));
create index on idxpart ((a + b));
create table idxpart2 (like idxpart);
alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
create table idxpart3 partition of idxpart for values from (2000) to (3000);
::select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef  from pg_class join pg_inherits on inhrelid = oid,  lateral pg_get_indexdef(pg_class.oid)  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
create table idxpart (a text) partition by range (a);
create table idxpart1 (like idxpart);
create table idxpart2 (like idxpart);
create index on idxpart2 (a collate "POSIX");
create index on idxpart2 (a);
create index on idxpart2 (a collate "C");
alter table idxpart attach partition idxpart1 for values from ('aaa') to ('bbb');
alter table idxpart attach partition idxpart2 for values from ('bbb') to ('ccc');
create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');
create index on idxpart (a collate "C");
create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');
::select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef  from pg_class left join pg_inherits on inhrelid = oid,  lateral pg_get_indexdef(pg_class.oid)  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
create table idxpart (a text) partition by range (a);
create table idxpart1 (like idxpart);
create table idxpart2 (like idxpart);
create index on idxpart2 (a);
alter table idxpart attach partition idxpart1 for values from ('aaa') to ('bbb');
alter table idxpart attach partition idxpart2 for values from ('bbb') to ('ccc');
create table idxpart3 partition of idxpart for values from ('ccc') to ('ddd');
create index on idxpart (a text_pattern_ops);
create table idxpart4 partition of idxpart for values from ('ddd') to ('eee');
::select relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef  from pg_class left join pg_inherits on inhrelid = oid,  lateral pg_get_indexdef(pg_class.oid)  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
create index on only idxpart (a text_pattern_ops);
alter index idxpart_a_idx attach partition idxpart2_a_idx;
create table idxpart (col1 int, a int, col2 int, b int) partition by range (a);
alter table idxpart drop column col1, drop column col2;
alter table idxpart1 drop column col1, drop column col2, drop column col3;
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
create index idxpart_1_idx on only idxpart (b, a);
create index idxpart_2_idx on only idxpart ((b + a)) where a > 1;
alter index idxpart_1_idx attach partition idxpart1_1b_idx;	-- failalter index idxpart_1_idx attach partition idxpart1_1_idx;
alter index idxpart_2_idx attach partition idxpart1_2b_idx;	-- failalter index idxpart_2_idx attach partition idxpart1_2c_idx;	-- failalter index idxpart_2_idx attach partition idxpart1_2_idx;	-- okselect relname as child, inhparent::regclass as parent, pg_get_indexdef as childdef  from pg_class left join pg_inherits on inhrelid = oid,  lateral pg_get_indexdef(pg_class.oid)  where relkind in ('i', 'I') and relname like 'idxpart%' order by relname;
create table idxpart (a int, b int, c text) partition by range (a);
alter table idxpart attach partition idxpart1 for values from (0) to (10);
create index on idxpart2 (a);
create index on idxpart2 (c, b);
alter table idxpart attach partition idxpart2 for values from (10) to (20);
select c.relname, pg_get_indexdef(indexrelid)  from pg_class c join pg_index i on c.oid = i.indexrelid  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
create table idxpart (col1 int, col2 int, a int, b int) partition by range (a);
alter table idxpart drop column col1, drop column col2;
alter table idxpart1 drop column col1, drop column col2;
alter table idxpart2 drop column col1, drop column col2;
create index on idxpart2 (abs(b));
alter table idxpart attach partition idxpart2 for values from (0) to (1);
create index on idxpart (abs(b));
create index on idxpart ((b + 1));
alter table idxpart attach partition idxpart1 for values from (1) to (2);
select c.relname, pg_get_indexdef(indexrelid)  from pg_class c join pg_index i on c.oid = i.indexrelid  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
create table idxpart (col1 int, a int, col3 int, b int) partition by range (a);
alter table idxpart drop column col1, drop column col3;
alter table idxpart1 drop column col1, drop column col2, drop column col3, drop column col4;
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
create index on idxpart2 (a) where b > 1000;
alter table idxpart2 drop column col1, drop column col2;
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
create index on idxpart (a) where b > 1000;
select c.relname, pg_get_indexdef(indexrelid)  from pg_class c join pg_index i on c.oid = i.indexrelid  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
alter table idxpart1 drop column drop_1;
alter table idxpart1 drop column drop_2;
alter table idxpart1 drop column drop_3;
create index on idxpart1 (col_keep);
create table idxpart (col_keep int) partition by range (col_keep);
create index on idxpart (col_keep);
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
::::select attrelid::regclass, attname, attnum from pg_attribute  where attrelid::regclass::text like 'idxpart%' and attnum > 0  order by attrelid::regclass, attnum;
create table idxpart(drop_1 int, drop_2 int, col_keep int, drop_3 int) partition by range (col_keep);
alter table idxpart drop column drop_1;
alter table idxpart drop column drop_2;
alter table idxpart drop column drop_3;
create index on idxpart1 (col_keep);
create index on idxpart (col_keep);
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
::::select attrelid::regclass, attname, attnum from pg_attribute  where attrelid::regclass::text like 'idxpart%' and attnum > 0  order by attrelid::regclass, attnum;
create table idxpart (a int primary key, b int) partition by range (a);
create table failpart partition of idxpart (b primary key) for values from (0) to (100);
create table idxpart (a int) partition by range (a);
create table idxpart1pk partition of idxpart (a primary key) for values from (0) to (100);
create table idxpart (a int unique, b int) partition by range (a, b);
create table idxpart (a int, b int unique) partition by range (a, b);
create table idxpart (a int primary key, b int) partition by range (b, a);
create table idxpart (a int, b int primary key) partition by range (b, a);
create table idxpart (a int, b int, c text, primary key  (a, b, c)) partition by range (b, c, a);
create table idxpart (a int, exclude (a with = )) partition by range (a);
create table idxpart (a int primary key, b int) partition by range ((b + a));
create table idxpart (a int unique, b int) partition by range ((b + a));
create table idxpart (a int, b int, c text) partition by range (a, b);
alter table idxpart add primary key (a);	-- not an incomplete one thoughalter table idxpart add primary key (a, b);	-- this workscreate table idxpart1 partition of idxpart for values from (0, 0) to (1000, 1000);
create table idxpart (a int, b int) partition by range (a, b);
alter table idxpart add unique (a);			-- not an incomplete one thoughalter table idxpart add unique (b, a);		-- this worksdrop table idxpart;
create table idxpart (a int, b int) partition by range (a);
alter table idxpart add exclude (a with =);
create table idxpart (a int, b int, primary key (a, b)) partition by range (a, b);
create table idxpart1 partition of idxpart for values from (1, 1) to (10, 10);
create table idxpart2 partition of idxpart for values from (10, 10) to (20, 20)  partition by range (b);
create table idxpart21 partition of idxpart2 for values from (10) to (15);
create table idxpart22 partition of idxpart2 for values from (15) to (20);
alter table idxpart attach partition idxpart3 for values from (20, 20) to (30, 30);
::::::select conname, contype, conrelid::regclass, conindid::regclass, conkey  from pg_constraint where conrelid::regclass::text like 'idxpart%'  order by conname;
create table idxpart (a int, b int, primary key (a)) partition by range (a);
create table idxpart2 partition of idxpartfor values from (0) to (1000) partition by range (b); -- faildrop table idxpart;
create table idxpart (a int unique, b int) partition by range (a);
create table idxpart1 (a int not null, b int, unique (a, b))  partition by range (a, b);
alter table idxpart attach partition idxpart1 for values from (1) to (1000);
DROP TABLE idxpart, idxpart1;
create table idxpart (a int, b int, primary key (a, b)) partition by range (a);
create table idxpart2 partition of idxpart for values from (0) to (1000) partition by range (b);
create table idxpart21 partition of idxpart2 for values from (0) to (1000);
::::::select conname, contype, conrelid::regclass, conindid::regclass, conkey  from pg_constraint where conrelid::regclass::text like 'idxpart%'  order by conname;
create table idxpart (i int) partition by hash (i);
create table idxpart0 partition of idxpart (i) for values with (modulus 2, remainder 0);
create table idxpart1 partition of idxpart (i) for values with (modulus 2, remainder 1);
alter table idxpart0 add primary key(i);
alter table idxpart add primary key(i);
::::::select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,  conname, conislocal, coninhcount, connoinherit, convalidated  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)  left join pg_constraint con on (idx.indexrelid = con.conindid)  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
drop index idxpart0_pkey;								-- faildrop index idxpart1_pkey;								-- failalter table idxpart0 drop constraint idxpart0_pkey;		-- failalter table idxpart1 drop constraint idxpart1_pkey;		-- failalter table idxpart drop constraint idxpart_pkey;		-- okselect indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,  conname, conislocal, coninhcount, connoinherit, convalidated  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)  left join pg_constraint con on (idx.indexrelid = con.conindid)  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
CREATE TABLE idxpart (c1 INT PRIMARY KEY, c2 INT, c3 VARCHAR(10)) PARTITION BY RANGE(c1);
CREATE TABLE idxpart1 (LIKE idxpart);
ALTER TABLE idxpart1 ADD PRIMARY KEY (c1, c2);
ALTER TABLE idxpart ATTACH PARTITION idxpart1 FOR VALUES FROM (100) TO (200);
DROP TABLE idxpart, idxpart1;
create table idxpart (a int, b int, primary key (a)) partition by range (a);
create table idxpart1 (a int not null, b int) partition by range (a);
alter table idxpart1 attach partition idxpart11 for values from (0) to (1000);
alter table idxpart attach partition idxpart1 for values from (0) to (10000);
drop table idxpart, idxpart1, idxpart11;
create table idxpart (a int) partition by range (a);
create table idxpart0 (like idxpart);
alter table idxpart0 add primary key (a);
alter table idxpart attach partition idxpart0 for values from (0) to (1000);
alter table only idxpart add primary key (a);
::::::select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,  conname, conislocal, coninhcount, connoinherit, convalidated  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)  left join pg_constraint con on (idx.indexrelid = con.conindid)  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
alter index idxpart_pkey attach partition idxpart0_pkey;
::::::select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,  conname, conislocal, coninhcount, connoinherit, convalidated  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)  left join pg_constraint con on (idx.indexrelid = con.conindid)  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
create table idxpart (a int) partition by range (a);
create table idxpart0 (like idxpart);
alter table idxpart0 add unique (a);
alter table idxpart attach partition idxpart0 default;
alter table only idxpart add primary key (a);  -- fail, no NOT NULL constraintalter table idxpart0 alter column a set not null;
alter table only idxpart add primary key (a);  -- now it worksalter table idxpart0 alter column a drop not null;  -- fail, pkey needs itdrop table idxpart;
create table idxpart (a int, b int) partition by range (a);
create unique index on idxpart1 (a);
alter table idxpart add primary key (a);
alter table idxpart attach partition idxpart1 for values from (1) to (1000);
::::::select indrelid::regclass, indexrelid::regclass, inhparent::regclass, indisvalid,  conname, conislocal, coninhcount, connoinherit, convalidated  from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)  left join pg_constraint con on (idx.indexrelid = con.conindid)  where indrelid::regclass::text like 'idxpart%'  order by indexrelid::regclass::text collate "C";
create table idxpart (a int, b int) partition by range (a);
create unique index on idxpart1 (a);
alter table idxpart attach partition idxpart1 for values from (1) to (1000);
alter table only idxpart add primary key (a);
alter index idxpart_pkey attach partition idxpart1_a_idx;	-- faildrop table idxpart;
create table idxpart (a int, b text, primary key (a, b)) partition by range (a);
create table idxpart1 partition of idxpart for values from (0) to (100000);
create table idxpart2 (c int, like idxpart);
alter table idxpart2 drop column c;
create unique index on idxpart (a);
alter table idxpart attach partition idxpart2 for values from (100000) to (1000000);
||::create table idxpart (a int) partition by range (a);
create table idxpart1 partition of idxpart for values from (0) to (100);
create table idxpart2 partition of idxpart for values from (100) to (1000)  partition by range (a);
create table idxpart21 partition of idxpart2 for values from (100) to (200);
create table idxpart22 partition of idxpart2 for values from (200) to (300);
create index on idxpart22 (a);
create index on only idxpart2 (a);
alter index idxpart2_a_idx attach partition idxpart22_a_idx;
create index on idxpart (a);
create table idxpart_another (a int, b int, primary key (a, b)) partition by range (a);
create table idxpart_another_1 partition of idxpart_another for values from (0) to (100);
create table idxpart3 (c int, b int, a int) partition by range (a);
alter table idxpart3 drop column b, drop column c;
create table idxpart31 partition of idxpart3 for values from (1000) to (1200);
create table idxpart32 partition of idxpart3 for values from (1200) to (1400);
alter table idxpart attach partition idxpart3 for values from (1000) to (2000);
create schema regress_indexing;
set search_path to regress_indexing;
create table pk (a int primary key) partition by range (a);
create table pk1 partition of pk for values from (0) to (1000);
alter table pk2 drop column b;
alter table pk2 alter a set not null;
alter table pk attach partition pk2 for values from (1000) to (2000);
create table pk3 partition of pk for values from (2000) to (3000);
create table pk4 (like pk);
alter table pk attach partition pk4 for values from (3000) to (4000);
create table pk5 (like pk) partition by range (a);
create table pk51 partition of pk5 for values from (4000) to (4500);
create table pk52 partition of pk5 for values from (4500) to (5000);
alter table pk attach partition pk5 for values from (4000) to (5000);
reset search_path;
create table covidxpart (a int, b int) partition by list (a);
create unique index on covidxpart (a) include (b);
create table covidxpart1 partition of covidxpart for values in (1);
create table covidxpart2 partition of covidxpart for values in (2);
alter table covidxpart3 drop c;
alter table covidxpart attach partition covidxpart3 for values in (3);
create unique index on covidxpart4 (a) include (b);
create unique index on covidxpart4 (a);
alter table covidxpart attach partition covidxpart4 for values in (4);
create unique index on covidxpart (b) include (a); -- should failcreate table parted_pk_detach_test (a int primary key) partition by list (a);
create table parted_pk_detach_test1 partition of parted_pk_detach_test for values in (1);
alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;	-- should failalter table parted_pk_detach_test detach partition parted_pk_detach_test1;
alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;
drop table parted_pk_detach_test, parted_pk_detach_test1;
create table parted_uniq_detach_test (a int unique) partition by list (a);
create table parted_uniq_detach_test1 partition of parted_uniq_detach_test for values in (1);
alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;	-- should failalter table parted_uniq_detach_test detach partition parted_uniq_detach_test1;
alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;
drop table parted_uniq_detach_test, parted_uniq_detach_test1;
create table parted_index_col_drop(a int, b int, c int)  partition by list (a);
create table parted_index_col_drop1 partition of parted_index_col_drop  for values in (1) partition by list (a);
create table parted_index_col_drop2 partition of parted_index_col_drop  for values in (2) partition by list (a);
create table parted_index_col_drop11 partition of parted_index_col_drop1  for values in (1);
create index on parted_index_col_drop (b);
create index on parted_index_col_drop (c);
create index on parted_index_col_drop (b, c);
alter table parted_index_col_drop drop column c;
SELECT b, c FROM test_having	GROUP BY b, c HAVING count(*) = 1 ORDER BY b, c;
SELECT b, c FROM test_having	GROUP BY b, c HAVING b = 3 ORDER BY b, c;
SELECT min(a), max(a) FROM test_having HAVING min(a) = max(a);
SELECT min(a), max(a) FROM test_having HAVING min(a) < max(a);
SELECT a FROM test_having HAVING min(a) < max(a);
SELECT 1 AS one FROM test_having HAVING a > 1;
SELECT 1 AS one FROM test_having HAVING 1 > 2;
SELECT 1 AS one FROM test_having HAVING 1 < 2;
SELECT 1 AS one FROM test_having WHERE 1/a = 1 HAVING 1 < 2;
SELECT char 'c' = char 'c' AS true;
SELECT '' AS six, c.*   FROM CHAR_TBL c   WHERE c.f1 <> 'a';
SELECT '' AS one, c.*   FROM CHAR_TBL c   WHERE c.f1 = 'a';
SELECT '' AS five, c.*   FROM CHAR_TBL c   WHERE c.f1 < 'a';
SELECT '' AS six, c.*   FROM CHAR_TBL c   WHERE c.f1 <= 'a';
SELECT '' AS one, c.*   FROM CHAR_TBL c   WHERE c.f1 > 'a';
SELECT '' AS two, c.*   FROM CHAR_TBL c   WHERE c.f1 >= 'a';
SELECT '' AS six, c.*   FROM VARCHAR_TBL c   WHERE c.f1 <> 'a';
SELECT '' AS one, c.*   FROM VARCHAR_TBL c   WHERE c.f1 = 'a';
SELECT '' AS five, c.*   FROM VARCHAR_TBL c   WHERE c.f1 < 'a';
SELECT '' AS six, c.*   FROM VARCHAR_TBL c   WHERE c.f1 <= 'a';
SELECT '' AS one, c.*   FROM VARCHAR_TBL c   WHERE c.f1 > 'a';
SELECT '' AS two, c.*   FROM VARCHAR_TBL c   WHERE c.f1 >= 'a';
(SELECT unique1 AS random  FROM onek ORDER BY random() LIMIT 1)INTERSECT(SELECT unique1 AS random  FROM onek ORDER BY random() LIMIT 1)INTERSECT(SELECT unique1 AS random  FROM onek ORDER BY random() LIMIT 1);
SELECT count(*) AS random INTO RANDOM_TBL  FROM onek WHERE random() < 1.0/10;
SELECT AVG(random) FROM RANDOM_TBL  HAVING AVG(random) NOT BETWEEN 80 AND 120;
CREATE TABLE num_data (id int4, val numeric(210,10));
CREATE TABLE num_exp_add (id1 int4, id2 int4, expected numeric(210,10));
CREATE TABLE num_exp_sub (id1 int4, id2 int4, expected numeric(210,10));
CREATE TABLE num_exp_div (id1 int4, id2 int4, expected numeric(210,10));
CREATE TABLE num_exp_mul (id1 int4, id2 int4, expected numeric(210,10));
CREATE TABLE num_exp_sqrt (id int4, expected numeric(210,10));
CREATE TABLE num_exp_ln (id int4, expected numeric(210,10));
CREATE TABLE num_exp_log10 (id int4, expected numeric(210,10));
CREATE TABLE num_exp_power_10_ln (id int4, expected numeric(210,10));
CREATE TABLE num_result (id1 int4, id2 int4, result numeric(210,10));
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
BEGIN TRANSACTION;
COMMIT TRANSACTION;
VACUUM ANALYZE num_exp_add;
VACUUM ANALYZE num_exp_sub;
VACUUM ANALYZE num_exp_div;
VACUUM ANALYZE num_exp_mul;
VACUUM ANALYZE num_exp_sqrt;
VACUUM ANALYZE num_exp_ln;
VACUUM ANALYZE num_exp_log10;
VACUUM ANALYZE num_exp_power_10_ln;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val + t2.val    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_add t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val + t2.val, 10)    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 10) as expected    FROM num_result t1, num_exp_add t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 10);
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val - t2.val    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_sub t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val - t2.val, 40)    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 40)    FROM num_result t1, num_exp_sub t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 40);
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val * t2.val    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_mul t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val * t2.val, 30)    FROM num_data t1, num_data t2;
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 30) as expected    FROM num_result t1, num_exp_mul t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 30);
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val / t2.val    FROM num_data t1, num_data t2    WHERE t2.val != '0.0';
SELECT t1.id1, t1.id2, t1.result, t2.expected    FROM num_result t1, num_exp_div t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val / t2.val, 80)    FROM num_data t1, num_data t2    WHERE t2.val != '0.0';
SELECT t1.id1, t1.id2, t1.result, round(t2.expected, 80) as expected    FROM num_result t1, num_exp_div t2    WHERE t1.id1 = t2.id1 AND t1.id2 = t2.id2    AND t1.result != round(t2.expected, 80);
DELETE FROM num_result;
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_sqrt t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
DELETE FROM num_result;
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_ln t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT id, 0, LOG(numeric '10', ABS(val))    FROM num_data    WHERE val != '0.0';
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_log10 t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
DELETE FROM num_result;
INSERT INTO num_result SELECT id, 0, POWER(numeric '10', LN(ABS(round(val,200))))    FROM num_data    WHERE val != '0.0';
SELECT t1.id1, t1.result, t2.expected    FROM num_result t1, num_exp_power_10_ln t2    WHERE t1.id1 = t2.id    AND t1.result != t2.expected;
CREATE TABLE fract_only (id int, val numeric(4,4));
INSERT INTO fract_only VALUES (3, '1.0');	-- should failINSERT INTO fract_only VALUES (4, '-0.9999');
INSERT INTO fract_only VALUES (6, '0.99995');  -- should failINSERT INTO fract_only VALUES (7, '0.00001');
::::SELECT 'NaN'::float8::numeric;
::::SELECT 'Infinity'::float8::numeric;
::::SELECT '-Infinity'::float8::numeric;
::::SELECT 'NaN'::float4::numeric;
::::SELECT 'Infinity'::float4::numeric;
::::SELECT '-Infinity'::float4::numeric;
::SELECT i as pow,	round((-2.5 * 10 ^ i)::numeric, -i),	round((-1.5 * 10 ^ i)::numeric, -i),	round((-0.5 * 10 ^ i)::numeric, -i),	round((0.5 * 10 ^ i)::numeric, -i),	round((1.5 * 10 ^ i)::numeric, -i),	round((2.5 * 10 ^ i)::numeric, -i)FROM generate_series(-5,5) AS t(i);
::::::::::::::::::::::CREATE TABLE width_bucket_test (operand_num numeric, operand_f8 float8);
COPY width_bucket_test (operand_num) FROM stdin;
-5.2-0.00000000010.0000000000011.999999999999992.000000000000014.55.59.999999999999991010.0000000000001\.UPDATE width_bucket_test SET operand_f8 = operand_num::float8;
::::SELECT width_bucket(0.0::float8, 'Infinity'::float8, 5, 10); -- errorSELECT width_bucket(0.0::float8, 5, '-Infinity'::float8, 20); -- errorSELECT width_bucket('Infinity'::float8, 1, 10, 10),       width_bucket('-Infinity'::float8, 1, 10, 10);
SELECT '' AS to_char_20, to_char(val, E'99999 "text" 9999 "9999" 999 "\\"text between quote marks\\"" 9999') FROM num_data;
::SELECT '' AS to_char_24, to_char('100'::numeric, 'FM999.9');
::SELECT '' AS to_char_25, to_char('100'::numeric, 'FM999.');
::SELECT '' AS to_char_26, to_char('100'::numeric, 'FM999');
::SELECT '' AS to_char_27, to_char('100'::numeric, 'foo999');
::SELECT '' AS to_char_28, to_char('100'::numeric, 'f\oo999');
::SELECT '' AS to_char_29, to_char('100'::numeric, 'f\\oo999');
::SELECT '' AS to_char_30, to_char('100'::numeric, 'f\"oo999');
::SELECT '' AS to_char_31, to_char('100'::numeric, 'f\\"oo999');
::SELECT '' AS to_char_32, to_char('100'::numeric, 'f"ool"999');
::SELECT '' AS to_char_33, to_char('100'::numeric, 'f"\ool"999');
::SELECT '' AS to_char_34, to_char('100'::numeric, 'f"\\ool"999');
::SELECT '' AS to_char_35, to_char('100'::numeric, 'f"ool\"999');
::SELECT '' AS to_char_36, to_char('100'::numeric, 'f"ool\\"999');
SET lc_numeric = 'C';
RESET lc_numeric;
::select 999999999999999999999::numeric/1000000000000000000000;
::select div(999999999999999999999::numeric,1000000000000000000000);
::select mod(999999999999999999999::numeric,1000000000000000000000);
::select div(-9999999999999999999999::numeric,1000000000000000000000);
::select mod(-9999999999999999999999::numeric,1000000000000000000000);
::select div(-9999999999999999999999::numeric,1000000000000000000000)*1000000000000000000000 + mod(-9999999999999999999999::numeric,1000000000000000000000);
::select 'NaN'::numeric ^ 'NaN'::numeric;
::select 'NaN'::numeric ^ 0;
::select 'NaN'::numeric ^ 1;
::select 0 ^ 'NaN'::numeric;
::select 1 ^ 'NaN'::numeric;
::select exp(1.0::numeric(71,70));
::select * from generate_series(0.0::numeric, 4.0::numeric);
::select * from generate_series(0.1::numeric, 4.0::numeric, 1.3::numeric);
::select * from generate_series(4.0::numeric, -1.5::numeric, -2.2::numeric);
::select * from generate_series(-100::numeric, 100::numeric, 0::numeric);
::select * from generate_series(-100::numeric, 100::numeric, 'nan'::numeric);
::select * from generate_series('nan'::numeric, 100::numeric, 10::numeric);
::select * from generate_series(0::numeric, 'nan'::numeric, 10::numeric);
::select (i / (10::numeric ^ 131071))::numeric(1,0)	from generate_series(6 * (10::numeric ^ 131071),			     9 * (10::numeric ^ 131071),			     10::numeric ^ 131071) as a(i);
::select * from generate_series(1::numeric, 3::numeric) i, generate_series(i,3) j;
::select * from generate_series(1::numeric, 3::numeric) i, generate_series(1,i) j;
::select * from generate_series(1::numeric, 3::numeric) i, generate_series(1,5,i) j;
select ln(1.2345678e-28);
select log(1.234567e-89);
select log(1.23e-89, 6.4689e45);
select log(3.1954752e47, 9.4792021e-73);
select scale(numeric 'NaN');
select scale(NULL::numeric);
::SELECT SUM(9999::numeric) FROM generate_series(1, 100000);
::SELECT SUM((-9999)::numeric) FROM generate_series(1, 100000);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::select '"\z"'::jsonpath;  -- unrecognized escape is just the literal charselect '$.g ? ($.a == 1)'::jsonpath;
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::PREPARE q1 AS SELECT 1 AS a;
EXECUTE q1;
PREPARE q1 AS SELECT 2;
DEALLOCATE q1;
PREPARE q1 AS SELECT 2;
EXECUTE q1;
PREPARE q2 AS SELECT 2 AS b;
DEALLOCATE PREPARE q1;
DEALLOCATE PREPARE q2;
PREPARE q2(text) AS	SELECT datname, datistemplate, datallowconn	FROM pg_database WHERE datname = $1;
EXECUTE q2('postgres');
PREPARE q3(text, int, float, boolean, smallint) AS	SELECT * FROM tenk1 WHERE string4 = $1 AND (four = $2 OR	ten = $3::bigint OR true = $4 OR odd = $5::int)	ORDER BY unique1;
EXECUTE q3('AAAAxx', 5::smallint, 10.5::float, false, 4::bigint);
EXECUTE q3('bool');
EXECUTE q3('bytea', 5::smallint, 10.5::float, false, 4::bigint, true);
EXECUTE q3(5::smallint, 10.5::float, false, 4::bigint, 'bytea');
PREPARE q4(nonexistenttype) AS SELECT $1;
PREPARE q5(int, text) AS	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2	ORDER BY unique1;
CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
CREATE TEMPORARY TABLE q5_prep_nodata AS EXECUTE q5(200, 'DTAAAA')    WITH NO DATA;
PREPARE q6 AS    SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;
PREPARE q7(unknown) AS    SELECT * FROM road WHERE thepath = $1;
DEALLOCATE ALL;
create function check_estimated_rows(text) returns table (estimated int, actual int)language plpgsql as$$declare    ln text;
    tmp text[];
    first_row bool := true;
begin    for ln in        execute format('explain analyze %s', $1)    loop        if first_row then            first_row := false;
            return query select tmp[1]::int, tmp[2]::int;
        end if;
    end loop;
end;
$$;
CREATE STATISTICS tst;
CREATE STATISTICS tst ON a, b;
CREATE STATISTICS tst FROM sometab;
CREATE STATISTICS tst ON a, b FROM nonexistent;
CREATE STATISTICS tst ON a, b FROM pg_class;
CREATE STATISTICS tst ON relname, relname, relnatts FROM pg_class;
CREATE STATISTICS tst ON relnatts + relpages FROM pg_class;
CREATE STATISTICS tst ON (relpages, reltuples) FROM pg_class;
CREATE STATISTICS tst (unrecognized) ON relname, relnatts FROM pg_class;
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
DROP STATISTICS ab1_a_b_stats;
CREATE SCHEMA regress_schema_2;
CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1;
DROP STATISTICS regress_schema_2.ab1_a_b_stats;
CREATE STATISTICS ab1_b_c_stats ON b, c FROM ab1;
CREATE STATISTICS ab1_a_b_c_stats ON a, b, c FROM ab1;
CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
ALTER TABLE ab1 DROP COLUMN a;
ALTER TABLE ab1 ALTER a SET STATISTICS 0;
CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
ANALYZE ab1;
ALTER TABLE ab1 ALTER a SET STATISTICS -1;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
ANALYZE ab1;
SELECT stxname, stxdndistinct, stxddependencies, stxdmcv  FROM pg_statistic_ext s, pg_statistic_ext_data d WHERE s.stxname = 'ab1_a_b_stats'   AND d.stxoid = s.oid;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS -1;
ANALYZE ab1 (a);
ANALYZE ab1;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
ALTER STATISTICS IF EXISTS ab1_a_b_stats SET STATISTICS 0;
CREATE TABLE ab1c () INHERITS (ab1);
CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
ANALYZE ab1;
DROP TABLE ab1 CASCADE;
CREATE schema tststats;
CREATE TABLE tststats.t (a int, b int, c text);
CREATE INDEX ti ON tststats.t (a, b);
CREATE SEQUENCE tststats.s;
CREATE VIEW tststats.v AS SELECT * FROM tststats.t;
CREATE MATERIALIZED VIEW tststats.mv AS SELECT * FROM tststats.t;
CREATE TYPE tststats.ty AS (a int, b int, c text);
CREATE FOREIGN DATA WRAPPER extstats_dummy_fdw;
CREATE SERVER extstats_dummy_srv FOREIGN DATA WRAPPER extstats_dummy_fdw;
CREATE FOREIGN TABLE tststats.f (a int, b int, c text) SERVER extstats_dummy_srv;
CREATE TABLE tststats.pt (a int, b int, c text) PARTITION BY RANGE (a, b);
CREATE TABLE tststats.pt1 PARTITION OF tststats.pt FOR VALUES FROM (-10, -10) TO (10, 10);
CREATE STATISTICS tststats.s1 ON a, b FROM tststats.t;
CREATE STATISTICS tststats.s2 ON a, b FROM tststats.ti;
CREATE STATISTICS tststats.s3 ON a, b FROM tststats.s;
CREATE STATISTICS tststats.s4 ON a, b FROM tststats.v;
CREATE STATISTICS tststats.s5 ON a, b FROM tststats.mv;
CREATE STATISTICS tststats.s6 ON a, b FROM tststats.ty;
CREATE STATISTICS tststats.s7 ON a, b FROM tststats.f;
CREATE STATISTICS tststats.s8 ON a, b FROM tststats.pt;
CREATE STATISTICS tststats.s9 ON a, b FROM tststats.pt1;
DO $$DECLARE	relname text := reltoastrelid::regclass FROM pg_class WHERE oid = 'tststats.t'::regclass;
BEGIN	EXECUTE 'CREATE STATISTICS tststats.s10 ON a, b FROM ' || relname;
EXCEPTION WHEN wrong_object_type THEN	RAISE NOTICE 'stats on toast table not created';
END;
$$;
DROP SCHEMA tststats CASCADE;
DROP FOREIGN DATA WRAPPER extstats_dummy_fdw CASCADE;
CREATE TABLE ndistinct (    filler1 TEXT,    filler2 NUMERIC,    a INT,    b INT,    filler3 DATE,    c INT,    d INT);
::INSERT INTO ndistinct (a, b, c, filler1)     SELECT i/100, i/100, i/100, cash_words((i/100)::money)       FROM generate_series(1,1000) s(i);
ANALYZE ndistinct;
CREATE STATISTICS s10 ON a, b, c FROM ndistinct;
ANALYZE ndistinct;
SELECT s.stxkind, d.stxdndistinct  FROM pg_statistic_ext s, pg_statistic_ext_data d WHERE s.stxrelid = 'ndistinct'::regclass   AND d.stxoid = s.oid;
TRUNCATE TABLE ndistinct;
::INSERT INTO ndistinct (a, b, c, filler1)     SELECT mod(i,50), mod(i,51), mod(i,32),            cash_words(mod(i,33)::int::money)       FROM generate_series(1,5000) s(i);
ANALYZE ndistinct;
SELECT s.stxkind, d.stxdndistinct  FROM pg_statistic_ext s, pg_statistic_ext_data d WHERE s.stxrelid = 'ndistinct'::regclass   AND d.stxoid = s.oid;
DROP STATISTICS s10;
SELECT s.stxkind, d.stxdndistinct  FROM pg_statistic_ext s, pg_statistic_ext_data d WHERE s.stxrelid = 'ndistinct'::regclass   AND d.stxoid = s.oid;
CREATE TABLE functional_dependencies (    filler1 TEXT,    filler2 NUMERIC,    a INT,    b TEXT,    filler3 DATE,    c INT,    d TEXT);
INSERT INTO functional_dependencies (a, b, c, filler1)     SELECT mod(i, 23), mod(i, 29), mod(i, 31), i FROM generate_series(1,5000) s(i);
ANALYZE functional_dependencies;
CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
ANALYZE functional_dependencies;
TRUNCATE functional_dependencies;
DROP STATISTICS func_deps_stat;
INSERT INTO functional_dependencies (a, b, c, filler1)     SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
ANALYZE functional_dependencies;
CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
ANALYZE functional_dependencies;
ALTER TABLE functional_dependencies ALTER COLUMN c TYPE numeric;
ANALYZE functional_dependencies;
CREATE TABLE mcv_lists (    filler1 TEXT,    filler2 NUMERIC,    a INT,    b VARCHAR,    filler3 DATE,    c INT,    d TEXT);
INSERT INTO mcv_lists (a, b, c, filler1)     SELECT mod(i,37), mod(i,41), mod(i,43), mod(i,47) FROM generate_series(1,5000) s(i);
ANALYZE mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
ANALYZE mcv_lists;
TRUNCATE mcv_lists;
DROP STATISTICS mcv_lists_stats;
INSERT INTO mcv_lists (a, b, c, filler1)     SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
ANALYZE mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
ANALYZE mcv_lists;
ALTER TABLE mcv_lists ALTER COLUMN d TYPE VARCHAR(64);
SELECT d.stxdmcv IS NOT NULL  FROM pg_statistic_ext s, pg_statistic_ext_data d WHERE s.stxname = 'mcv_lists_stats'   AND d.stxoid = s.oid;
ALTER TABLE mcv_lists ALTER COLUMN c TYPE numeric;
ANALYZE mcv_lists;
TRUNCATE mcv_lists;
DROP STATISTICS mcv_lists_stats;
INSERT INTO mcv_lists (a, b, c, filler1)     SELECT         (CASE WHEN mod(i,100) = 1 THEN NULL ELSE mod(i,100) END),         (CASE WHEN mod(i,50) = 1  THEN NULL ELSE mod(i,50) END),         (CASE WHEN mod(i,25) = 1  THEN NULL ELSE mod(i,25) END),         i     FROM generate_series(1,5000) s(i);
ANALYZE mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
ANALYZE mcv_lists;
TRUNCATE mcv_lists;
INSERT INTO mcv_lists (a, b, c) SELECT 1, 2, 3 FROM generate_series(1,1000) s(i);
ANALYZE mcv_lists;
SELECT m.*  FROM pg_statistic_ext s, pg_statistic_ext_data d,       pg_mcv_list_items(d.stxdmcv) m WHERE s.stxname = 'mcv_lists_stats'   AND d.stxoid = s.oid;
TRUNCATE mcv_lists;
DROP STATISTICS mcv_lists_stats;
INSERT INTO mcv_lists (a, b, c, d)     SELECT         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 0 END),         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 'x' END),         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 0 END),         (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 'x' END)     FROM generate_series(1,5000) s(i);
ANALYZE mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON b, d FROM mcv_lists;
ANALYZE mcv_lists;
CREATE TABLE mcv_lists_arrays (    a TEXT[],    b NUMERIC[],    c INT[]);
::INSERT INTO mcv_lists_arrays (a, b, c)     SELECT         ARRAY[md5((i/100)::text), md5((i/100-1)::text), md5((i/100+1)::text)],         ARRAY[(i/100-1)::numeric/1000, (i/100)::numeric/1000, (i/100+1)::numeric/1000],         ARRAY[(i/100-1), i/100, (i/100+1)]     FROM generate_series(1,5000) s(i);
CREATE STATISTICS mcv_lists_arrays_stats (mcv) ON a, b, c  FROM mcv_lists_arrays;
ANALYZE mcv_lists_arrays;
CREATE TABLE mcv_lists_bool (    a BOOL,    b BOOL,    c BOOL);
INSERT INTO mcv_lists_bool (a, b, c)     SELECT         (mod(i,2) = 0), (mod(i,4) = 0), (mod(i,8) = 0)     FROM generate_series(1,10000) s(i);
ANALYZE mcv_lists_bool;
CREATE STATISTICS mcv_lists_bool_stats (mcv) ON a, b, c  FROM mcv_lists_bool;
ANALYZE mcv_lists_bool;
CREATE SCHEMA tststats;
CREATE TABLE tststats.priv_test_tbl (    a int,    b int);
INSERT INTO tststats.priv_test_tbl     SELECT mod(i,5), mod(i,10) FROM generate_series(1,100) s(i);
CREATE STATISTICS tststats.priv_test_stats (mcv) ON a, b  FROM tststats.priv_test_tbl;
ANALYZE tststats.priv_test_tbl;
CREATE USER regress_stats_user1;
GRANT USAGE ON SCHEMA tststats TO regress_stats_user1;
SET SESSION AUTHORIZATION regress_stats_user1;
SELECT * FROM tststats.priv_test_tbl; -- Permission deniedCREATE FUNCTION op_leak(int, int) RETURNS bool    AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2; RETURN $1 < $2; END'    LANGUAGE plpgsql;
CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,                     restrict = scalarltsel);
SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Permission deniedDELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Permission deniedRESET SESSION AUTHORIZATION;
CREATE VIEW tststats.priv_test_view WITH (security_barrier=true)    AS SELECT * FROM tststats.priv_test_tbl WHERE false;
GRANT SELECT, DELETE ON tststats.priv_test_view TO regress_stats_user1;
SET SESSION AUTHORIZATION regress_stats_user1;
SELECT * FROM tststats.priv_test_view WHERE a <<< 0 AND b <<< 0; -- Should not leakDELETE FROM tststats.priv_test_view WHERE a <<< 0 AND b <<< 0; -- Should not leakRESET SESSION AUTHORIZATION;
ALTER TABLE tststats.priv_test_tbl ENABLE ROW LEVEL SECURITY;
GRANT SELECT, DELETE ON tststats.priv_test_tbl TO regress_stats_user1;
SET SESSION AUTHORIZATION regress_stats_user1;
SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Should not leakDELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Should not leakDROP OPERATOR <<< (int, int);
DROP FUNCTION op_leak(int, int);
RESET SESSION AUTHORIZATION;
DROP SCHEMA tststats CASCADE;
DROP USER regress_stats_user1;
SELECT name 'name string' = name 'name string' AS "True";
SELECT name 'name string' = name 'name string ' AS "False";
CREATE TABLE NAME_TBL(f1 name);
SELECT '' AS six, c.f1 FROM NAME_TBL c WHERE c.f1 <> '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT '' AS one, c.f1 FROM NAME_TBL c WHERE c.f1 = '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT '' AS three, c.f1 FROM NAME_TBL c WHERE c.f1 < '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT '' AS four, c.f1 FROM NAME_TBL c WHERE c.f1 <= '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT '' AS three, c.f1 FROM NAME_TBL c WHERE c.f1 > '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT '' AS four, c.f1 FROM NAME_TBL c WHERE c.f1 >= '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT '' AS seven, c.f1 FROM NAME_TBL c WHERE c.f1 ~ '.*';
SELECT '' AS zero, c.f1 FROM NAME_TBL c WHERE c.f1 !~ '.*';
SELECT '' AS three, c.f1 FROM NAME_TBL c WHERE c.f1 ~ '[0-9]';
SELECT '' AS two, c.f1 FROM NAME_TBL c WHERE c.f1 ~ '.*asdf.*';
DO $$DECLARE r text[];
BEGIN  r := parse_ident('Schemax.Tabley');
  RAISE NOTICE '%', format('%I.%I', r[1], r[2]);
  r := parse_ident('"SchemaX"."TableY"');
  RAISE NOTICE '%', format('%I.%I', r[1], r[2]);
END;
$$;
SELECT parse_ident('foo.boo[]'); -- should failSELECT parse_ident('foo.boo[]', strict => false); -- okSELECT parse_ident(' ');
SELECT parse_ident(E'X\rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
||SELECT parse_ident(' first . "  second  " ."   third   ". "  ' || repeat('x',66) || '"');
||SELECT parse_ident(' first . "  second  " ."   third   ". "  ' || repeat('x',66) || '"')::name[];
SELECT parse_ident(E'"c".X XXXX\002XXXXXX');
create table rtest_t1 (a int4, b int4);
create table rtest_t2 (a int4, b int4);
create table rtest_t3 (a int4, b int4);
create rule rtest_v1_ins as on insert to rtest_v1 do instead	insert into rtest_t1 values (new.a, new.b);
create rule rtest_v1_upd as on update to rtest_v1 do instead	update rtest_t1 set a = new.a, b = new.b	where a = old.a;
create rule rtest_v1_del as on delete to rtest_v1 do instead	delete from rtest_t1 where a = old.a;
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
create rule rtest_sys_upd as on update to rtest_system do also (	update rtest_interface set sysname = new.sysname		where sysname = old.sysname;
	update rtest_admin set sysname = new.sysname		where sysname = old.sysname	);
create rule rtest_sys_del as on delete to rtest_system do also (	delete from rtest_interface where sysname = old.sysname;
	delete from rtest_admin where sysname = old.sysname;
	);
create rule rtest_pers_upd as on update to rtest_person do also	update rtest_admin set pname = new.pname where pname = old.pname;
create rule rtest_pers_del as on delete to rtest_person do also	delete from rtest_admin where pname = old.pname;
create table rtest_emp (ename char(20), salary money);
create table rtest_emplog (ename char(20), who name, action char(10), newsal money, oldsal money);
create table rtest_empmass (ename char(20), salary money);
create rule rtest_emp_ins as on insert to rtest_emp do	insert into rtest_emplog values (new.ename, current_user,			'hired', new.salary, '0.00');
create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do	insert into rtest_emplog values (new.ename, current_user,			'honored', new.salary, old.salary);
create rule rtest_emp_del as on delete to rtest_emp do	insert into rtest_emplog values (old.ename, current_user,			'fired', '0.00', old.salary);
create table rtest_t4 (a int4, b text);
create table rtest_t5 (a int4, b text);
create table rtest_t6 (a int4, b text);
create table rtest_t7 (a int4, b text);
create table rtest_t8 (a int4, b text);
create table rtest_t9 (a int4, b text);
create rule rtest_t4_ins1 as on insert to rtest_t4		where new.a >= 10 and new.a < 20 do instead	insert into rtest_t5 values (new.a, new.b);
create rule rtest_t4_ins2 as on insert to rtest_t4		where new.a >= 20 and new.a < 30 do	insert into rtest_t6 values (new.a, new.b);
create rule rtest_t5_ins as on insert to rtest_t5		where new.a > 15 do	insert into rtest_t7 values (new.a, new.b);
create rule rtest_t6_ins as on insert to rtest_t6		where new.a > 25 do instead	insert into rtest_t8 values (new.a, new.b);
create table rtest_order1 (a int4);
create table rtest_order2 (a int4, b int4, c text);
create sequence rtest_seq;
create rule rtest_order_r3 as on insert to rtest_order1 do instead	insert into rtest_order2 values (new.a, nextval('rtest_seq'),		'rule 3 - this should run 3rd');
create rule rtest_order_r4 as on insert to rtest_order1		where a < 100 do instead	insert into rtest_order2 values (new.a, nextval('rtest_seq'),		'rule 4 - this should run 4th');
create rule rtest_order_r2 as on insert to rtest_order1 do	insert into rtest_order2 values (new.a, nextval('rtest_seq'),		'rule 2 - this should run 2nd');
create rule rtest_order_r1 as on insert to rtest_order1 do instead	insert into rtest_order2 values (new.a, nextval('rtest_seq'),		'rule 1 - this should run 1st');
create table rtest_nothn1 (a int4, b text);
create table rtest_nothn2 (a int4, b text);
create table rtest_nothn3 (a int4, b text);
create table rtest_nothn4 (a int4, b text);
create rule rtest_nothn_r1 as on insert to rtest_nothn1	where new.a >= 10 and new.a < 20 do instead nothing;
create rule rtest_nothn_r2 as on insert to rtest_nothn1	where new.a >= 30 and new.a < 40 do instead nothing;
create rule rtest_nothn_r3 as on insert to rtest_nothn2	where new.a >= 100 do instead	insert into rtest_nothn3 values (new.a, new.b);
create rule rtest_nothn_r4 as on insert to rtest_nothn2	do instead nothing;
delete from rtest_v1 where a = 1;
delete from rtest_v1 where b = 12;
** Remember the delete rule on rtest_v1: It says** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a** So this time both rows with a = 2 must get deleted\p\rdelete from rtest_v1 where b = 12;
delete from rtest_v1;
delete from rtest_v1;
delete from rtest_v1 where b isnull;
delete from rtest_v1;
insert into rtest_v1 select rtest_t2.a, rtest_t3.b    from rtest_t2, rtest_t3    where rtest_t2.a = rtest_t3.a;
update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
select * from rtest_admin order by pname, sysname;
delete from rtest_system where sysname = 'orion';
delete from rtest_emp where ename = 'gates';
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
delete from rtest_t4;
delete from rtest_t5;
delete from rtest_t6;
delete from rtest_t7;
delete from rtest_t8;
~insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
delete from rtest_nothn1;
delete from rtest_nothn2;
delete from rtest_nothn3;
delete from rtest_nothn4;
create table rtest_view1 (a int4, b text, v bool);
create table rtest_view2 (a int4);
create table rtest_view3 (a int4, b text);
create table rtest_view4 (a int4, b text, c int4);
create view rtest_vview1 as select a, b from rtest_view1 X	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
create view rtest_vview3 as select a, b from rtest_vview2 X	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount	from rtest_view1 X, rtest_view2 Y	where X.a = Y.a	group by X.a, X.b;
create function rtest_viewfunc1(int4) returns int4 as	'select count(*)::int4 from rtest_view2 where a = $1'	language sql;
select * from rtest_vview4 order by a, b;
delete from rtest_view3;
!~insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
delete from rtest_view3;
delete from rtest_view3;
select * from rtest_view4 order by a, b;
delete from rtest_view4;
delete from rtest_view4;
create view rtest_vcomp as	select X.part, (X.size * Y.factor) as size_in_cm			from rtest_comp X, rtest_unitfact Y			where X.unit = Y.unit;
select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
CREATE TABLE shoe_data (	shoename   char(10),      -- primary key	sh_avail   integer,       -- available # of pairs	slcolor    char(10),      -- preferred shoelace color	slminlen   float,         -- minimum shoelace length	slmaxlen   float,         -- maximum shoelace length	slunit     char(8)        -- length unit);
CREATE TABLE shoelace_data (	sl_name    char(10),      -- primary key	sl_avail   integer,       -- available # of pairs	sl_color   char(10),      -- shoelace color	sl_len     float,         -- shoelace length	sl_unit    char(8)        -- length unit);
CREATE TABLE unit (	un_name    char(8),       -- the primary key	un_fact    float          -- factor to transform to cm);
CREATE VIEW shoe AS	SELECT sh.shoename,		   sh.sh_avail,		   sh.slcolor,		   sh.slminlen,		   sh.slminlen * un.un_fact AS slminlen_cm,		   sh.slmaxlen,		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,		   sh.slunit	  FROM shoe_data sh, unit un	 WHERE sh.slunit = un.un_name;
CREATE VIEW shoelace AS	SELECT s.sl_name,		   s.sl_avail,		   s.sl_color,		   s.sl_len,		   s.sl_unit,		   s.sl_len * u.un_fact AS sl_len_cm	  FROM shoelace_data s, unit u	 WHERE s.sl_unit = u.un_name;
CREATE VIEW shoe_ready AS	SELECT rsh.shoename,		   rsh.sh_avail,		   rsl.sl_name,		   rsl.sl_avail,		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail	  FROM shoe rsh, shoelace rsl	 WHERE rsl.sl_color = rsh.slcolor	   AND rsl.sl_len_cm >= rsh.slminlen_cm	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
    CREATE TABLE shoelace_log (        sl_name    char(10),      -- shoelace changed        sl_avail   integer,       -- new available value        log_who    name,          -- who did it        log_when   timestamp      -- when    );
    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data        WHERE NEW.sl_avail != OLD.sl_avail        DO INSERT INTO shoelace_log VALUES (                                        NEW.sl_name,                                        NEW.sl_avail,                                        'Al Bundy',                                        'epoch'                                    );
    CREATE RULE shoelace_ins AS ON INSERT TO shoelace        DO INSTEAD        INSERT INTO shoelace_data VALUES (               NEW.sl_name,               NEW.sl_avail,               NEW.sl_color,               NEW.sl_len,               NEW.sl_unit);
    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace        DO INSTEAD        UPDATE shoelace_data SET               sl_name = NEW.sl_name,               sl_avail = NEW.sl_avail,               sl_color = NEW.sl_color,               sl_len = NEW.sl_len,               sl_unit = NEW.sl_unit         WHERE sl_name = OLD.sl_name;
    CREATE RULE shoelace_del AS ON DELETE TO shoelace        DO INSTEAD        DELETE FROM shoelace_data         WHERE sl_name = OLD.sl_name;
    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok        DO INSTEAD        UPDATE shoelace SET               sl_avail = sl_avail + NEW.ok_quant         WHERE sl_name = NEW.ok_name;
DELETE FROM shoelace WHERE EXISTS    (SELECT * FROM shoelace_candelete             WHERE sl_name = shoelace.sl_name);
create rule rules_foorule as on insert to rules_foo where f1 < 100do instead nothing;
drop rule rules_foorule on rules_foo;
create rule rules_foorule as on insert to rules_foo where f1 < 100do instead insert into rules_foo2 values (f1);
create rule rules_foorule as on insert to rules_foo where f1 < 100do instead insert into rules_foo2 values (new.f1);
drop rule rules_foorule on rules_foo;
create view vview as  select pparent.pid, txt, descrip from    pparent left join cchild using (pid);
create rule rrule as  on update to vview do instead  insert into cchild (pid, descrip)    select old.pid, new.descrip where old.descrip isnull;
  update cchild set descrip = new.descrip where cchild.pid = old.pid;
);
drop rule rrule on vview;
\\a\tSELECT viewname, definition FROM pg_viewsWHERE schemaname IN ('pg_catalog', 'public')ORDER BY viewname;
SELECT tablename, rulename, definition FROM pg_rulesWHERE schemaname IN ('pg_catalog', 'public')ORDER BY tablename, rulename;
\\a\tCREATE TABLE ruletest_tbl (a int, b int);
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
create table rule_and_refint_t1 (	id1a integer,	id1b integer,	primary key (id1a, id1b));
create table rule_and_refint_t2 (	id2a integer,	id2c integer,	primary key (id2a, id2c));
create table rule_and_refint_t3 (	id3a integer,	id3b integer,	id3c integer,	data text,	primary key (id3a, id3b, id3c),	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c));
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')  on conflict (id3a, id3b, id3c) do update  set id3b = excluded.id3b;
insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)  on conflict (sl_name) do update  set sl_avail = excluded.sl_avail;
create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3	where (exists (select 1 from rule_and_refint_t3			where (((rule_and_refint_t3.id3a = new.id3a)			and (rule_and_refint_t3.id3b = new.id3b))			and (rule_and_refint_t3.id3c = new.id3c))))	do instead update rule_and_refint_t3 set data = new.data	where (((rule_and_refint_t3.id3a = new.id3a)	and (rule_and_refint_t3.id3b = new.id3b))	and (rule_and_refint_t3.id3c = new.id3c));
::create view rules_fooview as select 'rules_foo'::text;
drop rule "_RETURN" on rules_fooview;
create rule "_RETURN" as on select to rules_fooview do instead  select 1 as x, 'aaa'::text as y;
select xmin, * from rules_fooview;  -- fail, views don't have such a columnselect reltoastrelid, relkind, relfrozenxid  from pg_class where oid = 'rules_fooview'::regclass;
create table rules_fooview (x int, y text) partition by list (x);
create rule "_RETURN" as on select to rules_fooview do instead  select 1 as x, 'aaa'::text as y;
create table rules_fooview_part partition of rules_fooview for values in (1);
create rule "_RETURN" as on select to rules_fooview_part do instead  select 1 as x, 'aaa'::text as y;
create table id (id serial primary key, name text);
create table test_1 (id integer primary key) inherits (id);
create table test_2 (id integer primary key) inherits (id);
create table test_3 (id integer primary key) inherits (id);
create rule update_id_ordered as on update to id_ordered	do instead update id set name = new.name where id = old.id;
drop table id cascade;
create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1);
create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1);
create rule t1_ins_1 as on insert to t1	where new.a >= 0 and new.a < 10	do instead	insert into t1_1 values (new.a);
create rule t1_ins_2 as on insert to t1	where new.a >= 10 and new.a < 20	do instead	insert into t1_2 values (new.a);
create rule t1_upd_1 as on update to t1	where old.a >= 0 and old.a < 10	do instead	update t1_1 set a = new.a where a = old.a;
create rule t1_upd_2 as on update to t1	where old.a >= 10 and old.a < 20	do instead	update t1_2 set a = new.a where a = old.a;
set constraint_exclusion = on;
reset constraint_exclusion;
::::::create rule r1 as on update to rules_src do also  insert into rules_log values(old.*, 'old'), (new.*, 'new');
create rule r2 as on update to rules_src do also  values(old.*, 'old'), (new.*, 'new');
create rule r3 as on delete to rules_src do notify rules_src_deletion;
create rule r4 as on insert to rules_src do instead insert into rules_log AS trgt SELECT NEW.* RETURNING trgt.f1, trgt.f2;
create rule r5 as on update to rules_src do instead UPDATE rules_log AS trgt SET tag = 'updated' WHERE trgt.f1 = new.f1;
create table rule_dest(f1 int, f2 int[], tag text);
create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt  SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)  WHERE trgt.f1 = new.f1 RETURNING new.*;
drop table rule_t1, rule_dest;
CREATE RULE InsertRule AS    ON INSERT TO rule_v1    DO INSTEAD        INSERT INTO rule_t1 VALUES(new.a);
ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't existALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already existsALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamedDROP VIEW rule_v1;
create view rule_v1 as values(1,2);
create view rule_v1(x) as values(1,2);
create view rule_v1(x) as select * from (values(1,2)) v;
create view rule_v1(x) as select * from (values(1,2)) v(q,w);
CREATE TABLE hats (	hat_name    char(10) primary key,	hat_color   char(10)      -- hat color);
CREATE TABLE hat_data (	hat_name    char(10),	hat_color   char(10)      -- hat color);
create unique index hat_data_unique_idx  on hat_data (hat_name COLLATE "C" bpchar_pattern_ops);
CREATE RULE hat_nosert AS ON INSERT TO hats    DO INSTEAD    INSERT INTO hat_data VALUES (           NEW.hat_name,           NEW.hat_color)        ON CONFLICT (hat_name COLLATE "C" bpchar_pattern_ops) WHERE hat_color = 'green'        DO NOTHING        RETURNING *;
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
DROP RULE hat_nosert ON hats;
CREATE RULE hat_nosert_all AS ON INSERT TO hats    DO INSTEAD    INSERT INTO hat_data VALUES (           NEW.hat_name,           NEW.hat_color)        ON CONFLICT        DO NOTHING        RETURNING *;
DROP RULE hat_nosert_all ON hats;
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
CREATE RULE hat_upsert AS ON INSERT TO hats    DO INSTEAD    INSERT INTO hat_data VALUES (           NEW.hat_name,           NEW.hat_color)        ON CONFLICT (hat_name)        DO UPDATE           SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color           WHERE excluded.hat_color <>  'forbidden' AND hat_data.* != excluded.*        RETURNING *;
INSERT INTO hats VALUES ('h8', 'black') RETURNING *;
INSERT INTO hats VALUES ('h8', 'white') RETURNING *;
INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
explain (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
WITH data(hat_name, hat_color) AS MATERIALIZED (    VALUES ('h8', 'green'),        ('h9', 'blue'),        ('h7', 'forbidden')INSERT INTO hats    SELECT * FROM dataRETURNING *;
EXPLAIN (costs off)WITH data(hat_name, hat_color) AS MATERIALIZED (    VALUES ('h8', 'green'),        ('h9', 'blue'),        ('h7', 'forbidden')INSERT INTO hats    SELECT * FROM dataRETURNING *;
DROP RULE hat_upsert ON hats;
CREATE FUNCTION func_with_set_params() RETURNS integer    AS 'select 1;'    LANGUAGE SQL    SET search_path TO PG_CATALOG    SET extra_float_digits TO 2    SET work_mem TO '4MB'    SET datestyle to iso, mdy    SET local_preload_libraries TO "Mixed/Case", 'c:/''a"/path', '', '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'    IMMUTABLE STRICT;
::::CREATE TABLE rules_parted_table (a int) PARTITION BY LIST (a);
CREATE TABLE rules_parted_table_1 PARTITION OF rules_parted_table FOR VALUES IN (1);
CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table    DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*);
ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect;
CREATE RULE rule1 AS ON INSERT TO ruletest1    DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*);
ALTER TABLE ruletest1 DISABLE RULE rule1;
ALTER TABLE ruletest1 ENABLE RULE rule1;
SET session_replication_role = replica;
ALTER TABLE ruletest1 ENABLE REPLICA RULE rule1;
RESET session_replication_role;
create type int8alias1;
create function int8alias1in(cstring) returns int8alias1  strict immutable language internal as 'int8in';
create function int8alias1out(int8alias1) returns cstring  strict immutable language internal as 'int8out';
create type int8alias1 (    input = int8alias1in,    output = int8alias1out,    like = int8);
create type int8alias2;
create function int8alias2in(cstring) returns int8alias2  strict immutable language internal as 'int8in';
create function int8alias2out(int8alias2) returns cstring  strict immutable language internal as 'int8out';
create type int8alias2 (    input = int8alias2in,    output = int8alias2out,    like = int8);
create cast (int8 as int8alias1) without function;
create cast (int8 as int8alias2) without function;
create cast (int8alias1 as int8) without function;
create cast (int8alias2 as int8) without function;
create function int8alias1eq(int8alias1, int8alias1) returns bool  strict immutable language internal as 'int8eq';
create operator = (    procedure = int8alias1eq,    leftarg = int8alias1, rightarg = int8alias1,    commutator = =,    restrict = eqsel, join = eqjoinsel,    merges);
alter operator family integer_ops using btree add  operator 3 = (int8alias1, int8alias1);
create function int8alias2eq(int8alias2, int8alias2) returns bool  strict immutable language internal as 'int8eq';
create operator = (    procedure = int8alias2eq,    leftarg = int8alias2, rightarg = int8alias2,    commutator = =,    restrict = eqsel, join = eqjoinsel,    merges);
alter operator family integer_ops using btree add  operator 3 = (int8alias2, int8alias2);
create function int8alias1eq(int8, int8alias1) returns bool  strict immutable language internal as 'int8eq';
create operator = (    procedure = int8alias1eq,    leftarg = int8, rightarg = int8alias1,    restrict = eqsel, join = eqjoinsel,    merges);
alter operator family integer_ops using btree add  operator 3 = (int8, int8alias1);
create function int8alias1eq(int8alias1, int8alias2) returns bool  strict immutable language internal as 'int8eq';
create operator = (    procedure = int8alias1eq,    leftarg = int8alias1, rightarg = int8alias2,    restrict = eqsel, join = eqjoinsel,    merges);
alter operator family integer_ops using btree add  operator 3 = (int8alias1, int8alias2);
create function int8alias1lt(int8alias1, int8alias1) returns bool  strict immutable language internal as 'int8lt';
create operator < (    procedure = int8alias1lt,    leftarg = int8alias1, rightarg = int8alias1);
alter operator family integer_ops using btree add  operator 1 < (int8alias1, int8alias1);
create function int8alias1cmp(int8, int8alias1) returns int  strict immutable language internal as 'btint8cmp';
alter operator family integer_ops using btree add  function 1 int8alias1cmp (int8, int8alias1);
create table ec0 (ff int8 primary key, f1 int8, f2 int8);
create table ec1 (ff int8 primary key, f1 int8alias1, f2 int8alias2);
create table ec2 (xf int8 primary key, x1 int8alias1, x2 int8alias2);
set enable_hashjoin = off;
set enable_mergejoin = off;
explain (costs off)  select * from ec0 where ff = f1 and f1 = '42'::int8;
explain (costs off)  select * from ec0 where ff = f1 and f1 = '42'::int8alias1;
explain (costs off)  select * from ec1 where ff = f1 and f1 = '42'::int8alias1;
explain (costs off)  select * from ec1 where ff = f1 and f1 = '42'::int8alias2;
explain (costs off)  select * from ec1, ec2 where ff = x1 and ff = '42'::int8;
explain (costs off)  select * from ec1, ec2 where ff = x1 and ff = '42'::int8alias1;
explain (costs off)  select * from ec1, ec2 where ff = x1 and '42'::int8 = x1;
explain (costs off)  select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias1;
explain (costs off)  select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias2;
explain (costs off)  select * from ec1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss1  where ss1.x = ec1.f1 and ec1.ff = 42::int8;
explain (costs off)  select * from ec1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss1  where ss1.x = ec1.f1 and ec1.ff = 42::int8 and ec1.ff = ec1.f1;
explain (costs off)  select * from ec1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss2  where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
set enable_mergejoin = on;
set enable_nestloop = off;
explain (costs off)  select * from ec1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss2  where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
set enable_nestloop = on;
set enable_mergejoin = off;
explain (costs off)  select * from ec1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss1  where ss1.x = ec1.f1 and ec1.ff = 42::int8;
set enable_mergejoin = on;
set enable_nestloop = off;
explain (costs off)  select * from ec1,    (select ff + 1 as x from       (select ff + 2 as ff from ec1        union all        select ff + 3 as ff from ec1) ss0     union all     select ff + 4 as x from ec1) as ss1  where ss1.x = ec1.f1 and ec1.ff = 42::int8;
set enable_nestloop = on;
set enable_mergejoin = off;
alter table ec1 enable row level security;
create policy p1 on ec1 using (f1 < '5'::int8alias1);
create user regress_user_ectest;
grant select on ec0 to regress_user_ectest;
grant select on ec1 to regress_user_ectest;
explain (costs off)  select * from ec0 a, ec1 b  where a.ff = b.ff and a.ff = 43::bigint::int8alias1;
set session authorization regress_user_ectest;
explain (costs off)  select * from ec0 a, ec1 b  where a.ff = b.ff and a.ff = 43::bigint::int8alias1;
reset session authorization;
revoke select on ec0 from regress_user_ectest;
revoke select on ec1 from regress_user_ectest;
drop user regress_user_ectest;
explain (costs off)  select * from tenk1 where unique1 = unique1 and unique2 = unique2;
explain (costs off)  select * from tenk1 where unique1 = unique1 or unique2 = unique2;
CREATE FUNCTION hobbies(person)   RETURNS setof hobbies_r   AS 'select * from hobbies_r where person = $1.name'   LANGUAGE SQL;
CREATE FUNCTION hobby_construct(text, text)   RETURNS hobbies_r   AS 'select $1 as name, $2 as hobby'   LANGUAGE SQL;
CREATE FUNCTION hobby_construct_named(name text, hobby text)   RETURNS hobbies_r   AS 'select name, hobby'   LANGUAGE SQL;
CREATE FUNCTION hobbies_by_name(hobbies_r.name%TYPE)   RETURNS hobbies_r.person%TYPE   AS 'select person from hobbies_r where name = $1'   LANGUAGE SQL;
CREATE FUNCTION equipment(hobbies_r)   RETURNS setof equipment_r   AS 'select * from equipment_r where hobby = $1.name'   LANGUAGE SQL;
CREATE FUNCTION equipment_named(hobby hobbies_r)   RETURNS setof equipment_r   AS 'select * from equipment_r where equipment_r.hobby = equipment_named.hobby.name'   LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_1a(hobby hobbies_r)   RETURNS setof equipment_r   AS 'select * from equipment_r where hobby = equipment_named_ambiguous_1a.hobby.name'   LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_1b(hobby hobbies_r)   RETURNS setof equipment_r   AS 'select * from equipment_r where equipment_r.hobby = hobby.name'   LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_1c(hobby hobbies_r)   RETURNS setof equipment_r   AS 'select * from equipment_r where hobby = hobby.name'   LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_2a(hobby text)   RETURNS setof equipment_r   AS 'select * from equipment_r where hobby = equipment_named_ambiguous_2a.hobby'   LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_2b(hobby text)   RETURNS setof equipment_r   AS 'select * from equipment_r where equipment_r.hobby = hobby'   LANGUAGE SQL;
CREATE FUNCTION pt_in_widget(point, widget)   RETURNS bool   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT;
CREATE FUNCTION overpaid(emp)   RETURNS bool   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT;
CREATE FUNCTION interpt_pp(path, path)   RETURNS point   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT;
CREATE FUNCTION reverse_name(name)   RETURNS name   AS '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so'   LANGUAGE C STRICT;
LOAD '/mnt/raidssd/sql_sofewares/postgres/src/test/regress/regress.so';
CREATE TABLE TIMESTAMPTZ_TBL (d1 timestamp(2) with time zone);
BEGIN;
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'today';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'yesterday';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp(2) with time zone 'now';
COMMIT;
DELETE FROM TIMESTAMPTZ_TBL;
BEGIN;
SELECT count(*) AS two FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp(2) with time zone 'now';
COMMIT;
DELETE FROM TIMESTAMPTZ_TBL;
set datestyle to ymd;
reset datestyle;
SELECT '19970210 173201' AT TIME ZONE 'America/New_York';
SELECT '19970710 173201' AT TIME ZONE 'America/New_York';
SELECT '19970710 173201' AT TIME ZONE 'America/Does_not_exist';
::SELECT '20500710 173201 Europe/Helsinki'::timestamptz; -- DSTSELECT '20500110 173201 Europe/Helsinki'::timestamptz; -- non-DSTSELECT '205000-07-10 17:32:01 Europe/Helsinki'::timestamptz; -- DSTSELECT '205000-01-10 17:32:01 Europe/Helsinki'::timestamptz; -- non-DSTINSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-06-10 18:32:01 PDT');
::::::::::::::::::SELECT '4714-11-23 23:59:59+00 BC'::timestamptz;  -- out of rangeSELECT '' AS "48", d1 FROM TIMESTAMPTZ_TBL   WHERE d1 > timestamp with time zone '1997-01-02';
SELECT '' AS "15", d1 FROM TIMESTAMPTZ_TBL   WHERE d1 < timestamp with time zone '1997-01-02';
SELECT '' AS one, d1 FROM TIMESTAMPTZ_TBL   WHERE d1 = timestamp with time zone '1997-01-02';
SELECT '' AS "63", d1 FROM TIMESTAMPTZ_TBL   WHERE d1 != timestamp with time zone '1997-01-02';
SELECT '' AS "16", d1 FROM TIMESTAMPTZ_TBL   WHERE d1 <= timestamp with time zone '1997-01-02';
SELECT '' AS "49", d1 FROM TIMESTAMPTZ_TBL   WHERE d1 >= timestamp with time zone '1997-01-02';
SELECT '' AS "54", d1 - timestamp with time zone '1997-01-02' AS diff   FROM TIMESTAMPTZ_TBL WHERE d1 BETWEEN '1902-01-01' AND '2038-01-01';
SELECT '' AS date_trunc_week, date_trunc( 'week', timestamp with time zone '2004-02-29 15:44:17.71393' ) AS week_trunc;
SELECT '' AS date_trunc_at_tz, date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'Australia/Sydney') as sydney_trunc;  -- zone nameSELECT '' AS date_trunc_at_tz, date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'GMT') as gmt_trunc;  -- fixed-offset abbreviationSELECT '' AS date_trunc_at_tz, date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'VET') as vet_trunc;  -- variable-offset abbreviationSELECT '' AS "54", d1 - timestamp with time zone '1997-01-02' AS diff  FROM TIMESTAMPTZ_TBL  WHERE d1 BETWEEN timestamp with time zone '1902-01-01' AND timestamp with time zone '2038-01-01';
SELECT '' AS "54", d1 as timestamptz,   date_part( 'year', d1) AS year, date_part( 'month', d1) AS month,   date_part( 'day', d1) AS day, date_part( 'hour', d1) AS hour,   date_part( 'minute', d1) AS minute, date_part( 'second', d1) AS second   FROM TIMESTAMPTZ_TBL WHERE d1 BETWEEN '1902-01-01' AND '2038-01-01';
SELECT '' AS to_char_6, to_char(d1, E'"HH:MI:SS is" HH:MI:SS "\\"text between quote marks\\""')   FROM TIMESTAMPTZ_TBL;
SELECT '' AS to_char_12, to_char(d, 'FF1 FF2 FF3 FF4 FF5 FF6  ff1 ff2 ff3 ff4 ff5 ff6  MS US')   FROM (VALUES       ('2018-11-02 12:34:56'::timestamptz),       ('2018-11-02 12:34:56.78'),       ('2018-11-02 12:34:56.78901'),       ('2018-11-02 12:34:56.78901234')   ) d(d);
SET timezone = '00:00';
SET timezone = '+02:00';
SET timezone = '-13:00';
SET timezone = '-00:30';
SET timezone = '00:30';
SET timezone = '-04:30';
SET timezone = '04:30';
SET timezone = '-04:15';
SET timezone = '04:15';
RESET timezone;
CREATE TABLE TIMESTAMPTZ_TST (a int , b timestamptz);
set TimeZone to 'America/New_York';
WITH tzs (tz) AS (VALUES    ('+1'), ('+1:'), ('+1:0'), ('+100'), ('+1:00'), ('+01:00'),    ('+10'), ('+1000'), ('+10:'), ('+10:0'), ('+10:00'), ('+10:00:'),    ('+10:00:1'), ('+10:00:01'),    ('+10:00:10'))     SELECT make_timestamptz(2010, 2, 27, 3, 45, 00, tz), tz FROM tzs;
::SELECT make_timestamptz(2014, 12, 10, 0, 0, 0, 'Europe/Prague') = timestamptz '2014-12-10 00:00:00 Europe/Prague';
SELECT make_timestamptz(2014, 12, 10, 0, 0, 0, 'Europe/Prague') AT TIME ZONE 'UTC';
SELECT make_timestamptz(1846, 12, 10, 0, 0, 0, 'Asia/Manila') AT TIME ZONE 'UTC';
SELECT make_timestamptz(1881, 12, 10, 0, 0, 0, 'Europe/Paris') AT TIME ZONE 'UTC';
RESET TimeZone;
SET TimeZone to 'UTC';
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::SELECT '2011-03-27 00:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 01:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 01:59:59'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 02:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 02:00:01'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 02:59:59'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 03:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 03:00:01'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 04:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 00:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 01:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 01:59:59'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 02:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 02:00:01'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 02:59:59'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 03:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 03:00:01'::timestamp AT TIME ZONE 'MSK';
::SELECT '2011-03-27 04:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2014-10-26 00:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-26 00:59:59'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-26 01:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-26 01:00:01'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-26 02:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-26 00:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2014-10-26 00:59:59'::timestamp AT TIME ZONE 'MSK';
::SELECT '2014-10-26 01:00:00'::timestamp AT TIME ZONE 'MSK';
::SELECT '2014-10-26 01:00:01'::timestamp AT TIME ZONE 'MSK';
::SELECT '2014-10-26 02:00:00'::timestamp AT TIME ZONE 'MSK';
SELECT to_timestamp(         0);          -- 1970-01-01 00:00:00+00SELECT to_timestamp( 946684800);          -- 2000-01-01 00:00:00+00SELECT to_timestamp(1262349296.7890123);  -- 2010-01-01 12:34:56.789012+00SELECT to_timestamp(-210866803200);       --   4714-11-24 00:00:00+00 BCSELECT to_timestamp(' Infinity'::float);
::SELECT to_timestamp('-Infinity'::float);
::SELECT to_timestamp('NaN'::float);
SET TimeZone to 'Europe/Moscow';
::::::::::::::::::::::::RESET TimeZone;
::SELECT '2011-03-26 21:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-26 22:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-26 22:59:59 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-26 23:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-26 23:00:01 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-26 23:59:59 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-27 00:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-25 21:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-25 21:59:59 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-25 22:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-25 22:00:01 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2014-10-25 23:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
::SELECT '2011-03-26 21:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2011-03-26 22:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2011-03-26 22:59:59 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2011-03-26 23:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2011-03-26 23:00:01 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2011-03-26 23:59:59 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2011-03-27 00:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2014-10-25 21:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2014-10-25 21:59:59 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2014-10-25 22:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2014-10-25 22:00:01 UTC'::timestamptz AT TIME ZONE 'MSK';
::SELECT '2014-10-25 23:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
create temp table tmptz (f1 timestamptz primary key);
explain (costs off)select * from tmptz where f1 at time zone 'utc' = '2017-01-18 00:00';
select * from tmptz where f1 at time zone 'utc' = '2017-01-18 00:00';
SET search_path = fast_default;
CREATE SCHEMA fast_default;
CREATE TABLE m(id OID);
INSERT INTO m VALUES (NULL::OID);
CREATE FUNCTION set(tabname name) RETURNS VOIDAS $$BEGIN  UPDATE m  SET id = (SELECT c.relfilenode            FROM pg_class AS c, pg_namespace AS s            WHERE c.relname = tabname                AND c.relnamespace = s.oid                AND s.nspname = 'fast_default');
END;
$$ LANGUAGE 'plpgsql';
CREATE FUNCTION comp() RETURNS TEXTAS $$BEGIN  RETURN (SELECT CASE               WHEN m.id = c.relfilenode THEN 'Unchanged'               ELSE 'Rewritten'               END           FROM m, pg_class AS c, pg_namespace AS s           WHERE c.relname = 't'               AND c.relnamespace = s.oid               AND s.nspname = 'fast_default');
END;
$$ LANGUAGE 'plpgsql';
CREATE FUNCTION log_rewrite() RETURNS event_triggerLANGUAGE plpgsql as$func$declare   this_schema text;
begin    select into this_schema relnamespace::regnamespace::text    from pg_class    where oid = pg_event_trigger_table_rewrite_oid();
    if this_schema = 'fast_default'    then        RAISE NOTICE 'rewriting table % for reason %',          pg_event_trigger_table_rewrite_oid()::regclass,          pg_event_trigger_table_rewrite_reason();
    end if;
end;
$$func$;
CREATE TABLE has_volatile ASSELECT * FROM generate_series(1,10) id;
CREATE EVENT TRIGGER has_volatile_rewrite                  ON table_rewrite   EXECUTE PROCEDURE log_rewrite();
ALTER TABLE has_volatile ADD col2 int DEFAULT 1;
ALTER TABLE has_volatile ADD col3 timestamptz DEFAULT current_timestamp;
ALTER TABLE has_volatile ADD col4 int DEFAULT (random() * 10000)::int;
CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT 1);
SELECT set('t');
ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT 'hello',              ALTER COLUMN c_int SET DEFAULT 2;
ALTER TABLE T ADD COLUMN c_text TEXT  DEFAULT 'world',              ALTER COLUMN c_bpchar SET DEFAULT 'dog';
ALTER TABLE T ADD COLUMN c_date DATE DEFAULT '2016-06-02',              ALTER COLUMN c_text SET DEFAULT 'cat';
ALTER TABLE T ADD COLUMN c_timestamp TIMESTAMP DEFAULT '2016-09-01 12:00:00',              ADD COLUMN c_timestamp_null TIMESTAMP,              ALTER COLUMN c_date SET DEFAULT '2010-01-01';
ALTER TABLE T ADD COLUMN c_array TEXT[]                  DEFAULT '{"This", "is", "the", "real", "world"}',              ALTER COLUMN c_timestamp SET DEFAULT '1970-12-31 11:12:13',              ALTER COLUMN c_timestamp_null SET DEFAULT '2016-09-29 12:00:00';
ALTER TABLE T ADD COLUMN c_small SMALLINT DEFAULT -5,              ADD COLUMN c_small_null SMALLINT,              ALTER COLUMN c_array                  SET DEFAULT '{"This", "is", "no", "fantasy"}';
ALTER TABLE T ADD COLUMN c_big BIGINT DEFAULT 180000000000018,              ALTER COLUMN c_small SET DEFAULT 9,              ALTER COLUMN c_small_null SET DEFAULT 13;
ALTER TABLE T ADD COLUMN c_num NUMERIC DEFAULT 1.00000000001,              ALTER COLUMN c_big SET DEFAULT -9999999999999999;
ALTER TABLE T ADD COLUMN c_time TIME DEFAULT '12:00:00',              ALTER COLUMN c_num SET DEFAULT 2.000000000000002;
ALTER TABLE T ADD COLUMN c_interval INTERVAL DEFAULT '1 day',              ALTER COLUMN c_time SET DEFAULT '23:59:59';
ALTER TABLE T ADD COLUMN c_hugetext TEXT DEFAULT repeat('abcdefg',1000),              ALTER COLUMN c_interval SET DEFAULT '3 hours';
ALTER TABLE T ALTER COLUMN c_interval DROP DEFAULT,              ALTER COLUMN c_hugetext SET DEFAULT repeat('poiuyt', 1000);
ALTER TABLE T ALTER COLUMN c_bpchar    DROP DEFAULT,              ALTER COLUMN c_date      DROP DEFAULT,              ALTER COLUMN c_text      DROP DEFAULT,              ALTER COLUMN c_timestamp DROP DEFAULT,              ALTER COLUMN c_array     DROP DEFAULT,              ALTER COLUMN c_small     DROP DEFAULT,              ALTER COLUMN c_big       DROP DEFAULT,              ALTER COLUMN c_num       DROP DEFAULT,              ALTER COLUMN c_time      DROP DEFAULT,              ALTER COLUMN c_hugetext  DROP DEFAULT;
SELECT pk, c_int, c_bpchar, c_text, c_date, c_timestamp,       c_timestamp_null, c_array, c_small, c_small_null,       c_big, c_num, c_time, c_interval,       c_hugetext = repeat('abcdefg',1000) as c_hugetext_origdef,       c_hugetext = repeat('poiuyt', 1000) as c_hugetext_newdefFROM T ORDER BY pk;
CREATE OR REPLACE FUNCTION foo(a INT) RETURNS TEXT AS $$DECLARE res TEXT := '';
        i INT;
BEGIN  i := 0;
  WHILE (i < a) LOOP    res := res || chr(ascii('a') + i);
    i := i + 1;
  END LOOP;
  RETURN res;
END; $$ LANGUAGE PLPGSQL STABLE;
CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT LENGTH(foo(6)));
SELECT set('t');
ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT foo(4),              ALTER COLUMN c_int SET DEFAULT LENGTH(foo(8));
ALTER TABLE T ADD COLUMN c_text TEXT  DEFAULT foo(6),              ALTER COLUMN c_bpchar SET DEFAULT foo(3);
ALTER TABLE T ADD COLUMN c_date DATE                  DEFAULT '2016-06-02'::DATE  + LENGTH(foo(10)),              ALTER COLUMN c_text SET DEFAULT foo(12);
ALTER TABLE T ADD COLUMN c_timestamp TIMESTAMP                  DEFAULT '2016-09-01'::DATE + LENGTH(foo(10)),              ALTER COLUMN c_date                  SET DEFAULT '2010-01-01'::DATE - LENGTH(foo(4));
ALTER TABLE T ADD COLUMN c_array TEXT[]                  DEFAULT ('{"This", "is", "' || foo(4) ||                           '","the", "real", "world"}')::TEXT[],              ALTER COLUMN c_timestamp                  SET DEFAULT '1970-12-31'::DATE + LENGTH(foo(30));
ALTER TABLE T ALTER COLUMN c_int DROP DEFAULT,              ALTER COLUMN c_array                  SET DEFAULT ('{"This", "is", "' || foo(1) ||                               '", "fantasy"}')::text[];
ALTER TABLE T ALTER COLUMN c_bpchar    DROP DEFAULT,              ALTER COLUMN c_date      DROP DEFAULT,              ALTER COLUMN c_text      DROP DEFAULT,              ALTER COLUMN c_timestamp DROP DEFAULT,              ALTER COLUMN c_array     DROP DEFAULT;
DROP FUNCTION foo(INT);
SELECT set('t');
ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
ALTER TABLE T ADD COLUMN c2 TIMESTAMP DEFAULT clock_timestamp();
SELECT set('t');
ALTER TABLE T ADD COLUMN c_bigint BIGINT NOT NULL DEFAULT -1;
INSERT INTO T SELECT b, b - 10 FROM generate_series(11, 20) a(b);
ALTER TABLE T ADD COLUMN c_text TEXT DEFAULT 'hello';
::INSERT INTO T SELECT b, b - 10, (b + 10)::text FROM generate_series(21, 30) a(b);
EXPLAIN (VERBOSE TRUE, COSTS FALSE)SELECT c_bigint, c_text FROM T WHERE c_bigint = -1 LIMIT 1;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) SELECT c_bigint, c_text FROM T WHERE c_text = 'hello' LIMIT 1;
::SELECT COALESCE(c_bigint, pk), COALESCE(c_text, pk::text)FROM TORDER BY pk LIMIT 10;
SELECT SUM(c_bigint), MAX(c_text COLLATE "C" ), MIN(c_text COLLATE "C") FROM T;
SELECT * FROM T ORDER BY c_bigint, c_text, pk LIMIT 10;
EXPLAIN (VERBOSE TRUE, COSTS FALSE)SELECT * FROM T ORDER BY c_bigint, c_text, pk LIMIT 10;
SELECT * FROM T WHERE c_bigint > -1 ORDER BY c_bigint, c_text, pk LIMIT 10;
EXPLAIN (VERBOSE TRUE, COSTS FALSE)SELECT * FROM T WHERE c_bigint > -1 ORDER BY c_bigint, c_text, pk LIMIT 10;
DELETE FROM T WHERE pk BETWEEN 10 AND 20 RETURNING *;
EXPLAIN (VERBOSE TRUE, COSTS FALSE)DELETE FROM T WHERE pk BETWEEN 10 AND 20 RETURNING *;
||UPDATE T SET c_text = '"' || c_text || '"'  WHERE pk < 10;
SELECT set('t');
ALTER TABLE T ADD COLUMN c_int INT NOT NULL DEFAULT -1;
ALTER TABLE T ADD COLUMN c_text TEXT DEFAULT 'Hello';
ALTER TABLE T ALTER COLUMN c_text SET DEFAULT 'world',              ALTER COLUMN c_int  SET DEFAULT 1;
CREATE TABLE t1 ASSELECT 1::int AS a , 2::int AS bFROM generate_series(1,20) q;
SELECT a,       stddev(cast((SELECT sum(1) FROM generate_series(1,20) x) AS float4))          OVER (PARTITION BY a,b,c ORDER BY b)       AS zFROM t1;
CREATE FUNCTION test_trigger()RETURNS triggerLANGUAGE plpgsqlAS $$begin    raise notice 'old tuple: %', to_json(OLD)::text;
    if TG_OP = 'DELETE'    then       return OLD;
    else       return NEW;
    end if;
end;
$$;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
ALTER TABLE t ADD COLUMN x int NOT NULL DEFAULT 4;
ALTER TABLE t ADD COLUMN y int NOT NULL DEFAULT 5;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
ALTER TABLE t ADD COLUMN x int NOT NULL DEFAULT 4;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
ALTER TABLE t ADD COLUMN y int NOT NULL DEFAULT 5;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
INSERT INTO t (a,b,c) VALUES (1,2,NULL);
ALTER TABLE t ADD COLUMN x int NOT NULL DEFAULT 4;
ALTER TABLE t ADD COLUMN y int NOT NULL DEFAULT 5;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
INSERT INTO t (a,b,c) VALUES (1,2,NULL);
ALTER TABLE t ADD COLUMN x int NOT NULL DEFAULT 4;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
INSERT INTO t (a,b,c) VALUES (1,2,NULL);
ALTER TABLE t ADD COLUMN y int NOT NULL DEFAULT 5;
CREATE TABLE t (id serial PRIMARY KEY, a int, b int, c int);
INSERT INTO t (a,b,c) VALUES (1,2,NULL);
ALTER TABLE leader DROP c;
DELETE FROM leader;
ALTER TABLE vtype ADD COLUMN b DOUBLE PRECISION DEFAULT 0.2;
ALTER TABLE vtype ADD COLUMN c BOOLEAN DEFAULT true;
ALTER TABLE vtype      ALTER b TYPE text USING b::text,      ALTER c TYPE text USING c::text;
ALTER TABLE vtype2 ADD COLUMN b varchar(10) DEFAULT 'xxx';
ALTER TABLE vtype2 ALTER COLUMN b SET DEFAULT 'yyy';
ALTER TABLE vtype2 ALTER COLUMN b TYPE varchar(20) USING b::varchar(20);
BEGIN;
CREATE TABLE t();
ALTER TABLE t ADD COLUMN a int DEFAULT 1;
CREATE INDEX ON t(a);
UPDATE t SET a = NULL;
SET LOCAL enable_seqscan = true;
SET LOCAL enable_seqscan = false;
ROLLBACK;
DROP FUNCTION test_trigger();
DROP FUNCTION set(name);
DROP FUNCTION comp();
DROP EVENT TRIGGER has_volatile_rewrite;
DROP FUNCTION log_rewrite;
DROP SCHEMA fast_default;
set search_path = public;
alter table has_fast_default add column f2 int default 42;
table has_fast_default;
/* * This test is for ICU collations. *//* skip test if not UTF8 server encoding or no ICU collations installed */SELECT getdatabaseencoding() <> 'UTF8' OR       (SELECT count(*) FROM pg_collation WHERE collprovider = 'i') = 0       AS skip_test \gset\if :skip_test\quit\endifSET client_encoding TO UTF8;
CREATE SCHEMA collate_tests;
SET search_path = collate_tests;
CREATE TABLE collate_test1 (    a int,    b text COLLATE "en-x-icu" NOT NULL);
CREATE TABLE collate_test_fail (    a int,    b text COLLATE "ja_JP.eucjp-x-icu");
CREATE TABLE collate_test_fail (    a int,    b text COLLATE "foo-x-icu");
CREATE TABLE collate_test_fail (    a int COLLATE "en-x-icu",    b text);
CREATE TABLE collate_test_like (    LIKE collate_test1);
CREATE TABLE collate_test2 (    a int,    b text COLLATE "sv-x-icu");
CREATE TABLE collate_test3 (    a int,    b text COLLATE "C");
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
SELECT * FROM collate_test1 WHERE b >= 'bbc' COLLATE "C";
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "C";
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "en-x-icu";
CREATE DOMAIN testdomain_sv AS text COLLATE "sv-x-icu";
CREATE DOMAIN testdomain_i AS int COLLATE "sv-x-icu"; -- failsCREATE TABLE collate_test4 (    a int,    b testdomain_sv);
CREATE TABLE collate_test5 (    a int,    b testdomain_sv COLLATE "en-x-icu");
SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
SELECT 'bbc' COLLATE "en-x-icu" > 'bc' COLLATE "en-x-icu" AS "true";
SELECT 'bbc' COLLATE "sv-x-icu" > 'bc' COLLATE "sv-x-icu" AS "false";
CREATE TABLE collate_test10 (    a int,    x text COLLATE "en-x-icu",    y text COLLATE "tr-x-icu");
SELECT a, lower(x COLLATE "C"), lower(y COLLATE "C") FROM collate_test10;
SELECT a, x, y FROM collate_test10 ORDER BY lower(y), a;
SELECT * FROM collate_test1 WHERE b ILIKE 'abc';
SELECT * FROM collate_test1 WHERE b ILIKE 'abc%';
SELECT * FROM collate_test1 WHERE b ILIKE '%bc%';
SELECT 'Trkiye' COLLATE "en-x-icu" ILIKE '%KI%' AS "true";
SELECT 'Trkiye' COLLATE "tr-x-icu" ILIKE '%KI%' AS "false";
SELECT 'bt' ILIKE 'BIT' COLLATE "en-x-icu" AS "false";
SELECT 'bt' ILIKE 'BIT' COLLATE "tr-x-icu" AS "true";
SELECT relname FROM pg_class WHERE relname ILIKE 'abc%';
~SELECT * FROM collate_test1 WHERE b ~ '^abc$';
~SELECT * FROM collate_test1 WHERE b ~ '^abc';
~SELECT * FROM collate_test1 WHERE b ~ 'bc';
~~~CREATE TABLE collate_test6 (    a int,    b text COLLATE "en-x-icu");
~SELECT b,       b ~ '^[[:alpha:]]+$' AS is_alpha,       b ~ '^[[:upper:]]+$' AS is_upper,       b ~ '^[[:lower:]]+$' AS is_lower,       b ~ '^[[:digit:]]+$' AS is_digit,       b ~ '^[[:alnum:]]+$' AS is_alnum,       b ~ '^[[:graph:]]+$' AS is_graph,       b ~ '^[[:print:]]+$' AS is_print,       b ~ '^[[:punct:]]+$' AS is_punct,       b ~ '^[[:space:]]+$' AS is_spaceFROM collate_test6;
SELECT 'Trkiye' COLLATE "en-x-icu" ~* 'KI' AS "true";
SELECT 'Trkiye' COLLATE "tr-x-icu" ~* 'KI' AS "true";  -- true with ICUSELECT 'bt' ~* 'BIT' COLLATE "en-x-icu" AS "false";
~SELECT 'bt' ~* 'BIT' COLLATE "tr-x-icu" AS "false";  -- false with ICUSELECT relname FROM pg_class WHERE relname ~* '^abc';
/* not run by default because it requires tr_TR system localeSET lc_time TO 'tr_TR';
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY');
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY' COLLATE "tr-x-icu");
*/CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
CREATE VIEW collview2 AS SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
||CREATE VIEW collview3 AS SELECT a, lower((x || x) COLLATE "C") FROM collate_test10;
SELECT table_name, view_definition FROM information_schema.views  WHERE table_name LIKE 'collview%' ORDER BY 1;
CREATE DOMAIN testdomain AS text;
::::::::::::SELECT array_agg(b ORDER BY b) FROM collate_test1;
SELECT array_agg(b ORDER BY b) FROM collate_test2;
SELECT array_agg(b ORDER BY b) FROM collate_test3;
SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test1 ORDER BY 2;
SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test3 ORDER BY 2; -- failSELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test3; -- okSELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test3 ORDER BY 2; -- failSELECT a, b COLLATE "C" FROM collate_test1 UNION SELECT a, b FROM collate_test3 ORDER BY 2; -- okSELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test3 ORDER BY 2; -- failSELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test3 ORDER BY 2; -- failCREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test3; -- failselect x < y from collate_test10; -- failselect x || y from collate_test10; -- ok, because || is not collation awareselect x, y from collate_test10 order by x || y; -- not so okWITH RECURSIVE foo(x) AS   (SELECT x FROM (VALUES('a' COLLATE "en-x-icu"),('b')) t(x)   UNION ALL   SELECT (x || 'c') COLLATE "de-x-icu" FROM foo WHERE length(x) < 10)SELECT * FROM foo;
SELECT CAST('42' AS text COLLATE "C");
CREATE FUNCTION mylt (text, text) RETURNS boolean LANGUAGE sql    AS $$ select $1 < $2 $$;
CREATE FUNCTION mylt_noninline (text, text) RETURNS boolean LANGUAGE sql    AS $$ select $1 < $2 limit 1 $$;
CREATE FUNCTION mylt_plpgsql (text, text) RETURNS boolean LANGUAGE plpgsql    AS $$ begin return $1 < $2; end $$;
SELECT a.b AS a, b.b AS b, a.b < b.b AS lt,       mylt(a.b, b.b), mylt_noninline(a.b, b.b), mylt_plpgsql(a.b, b.b)FROM collate_test1 a, collate_test1 bORDER BY a.b, b.b;
SELECT a.b AS a, b.b AS b, a.b < b.b COLLATE "C" AS lt,       mylt(a.b, b.b COLLATE "C"), mylt_noninline(a.b, b.b COLLATE "C"),       mylt_plpgsql(a.b, b.b COLLATE "C")FROM collate_test1 a, collate_test1 bORDER BY a.b, b.b;
CREATE FUNCTION mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$declare  xx text := x;
  yy text := y;
begin  return xx < yy;
end$$;
SELECT mylt2('a', 'B' collate "en-x-icu") as t, mylt2('a', 'B' collate "C") as f;
CREATE OR REPLACE FUNCTION  mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$declare  xx text COLLATE "POSIX" := x;
  yy text := y;
begin  return xx < yy;
end$$;
SELECT mylt2('a', 'B' collate "C") as fail; -- conflicting collationsSELECT mylt2('a', 'B' collate "POSIX") as f;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test3)) ORDER BY 1;
CREATE FUNCTION dup (anyelement) RETURNS anyelement    AS 'select $1' LANGUAGE sql;
CREATE INDEX collate_test1_idx2 ON collate_test1 (b COLLATE "C");
CREATE INDEX collate_test1_idx3 ON collate_test1 ((b COLLATE "C")); -- this is different grammaticallyCREATE INDEX collate_test1_idx4 ON collate_test1 (((b||'foo') COLLATE "POSIX"));
CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "C"); -- failCREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "C")); -- failSELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
set enable_seqscan = off;
explain (costs off)select * from collate_test1 where b ilike 'abc';
select * from collate_test1 where b ilike 'abc';
explain (costs off)select * from collate_test1 where b ilike 'ABC';
select * from collate_test1 where b ilike 'ABC';
reset enable_seqscan;
CREATE ROLE regress_test_role;
CREATE SCHEMA test_schema;
do $$BEGIN  EXECUTE 'CREATE COLLATION test0 (provider = icu, locale = ' ||          quote_literal(current_setting('lc_collate')) || ');';
END$$;
CREATE COLLATION test0 FROM "C"; -- fail, duplicate namedo $$BEGIN  EXECUTE 'CREATE COLLATION test1 (provider = icu, lc_collate = ' ||          quote_literal(current_setting('lc_collate')) ||          ', lc_ctype = ' ||          quote_literal(current_setting('lc_ctype')) || ');';
END$$;
CREATE COLLATION test3 (provider = icu, lc_collate = 'en_US.utf8'); -- fail, need lc_ctypeCREATE COLLATION testx (provider = icu, locale = 'nonsense'); /* never fails with ICU */  DROP COLLATION testx;
CREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test5 FROM test0;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test0 RENAME TO test11; -- failALTER COLLATION test1 RENAME TO test22; -- failALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 SET SCHEMA test_schema;
COMMENT ON COLLATION test0 IS 'US English';
SELECT collname, nspname, obj_description(pg_collation.oid, 'pg_collation')    FROM pg_collation JOIN pg_namespace ON (collnamespace = pg_namespace.oid)    WHERE collname LIKE 'test%'    ORDER BY 1;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0; -- failDROP COLLATION IF EXISTS test0;
DROP SCHEMA test_schema;
DROP ROLE regress_test_role;
ALTER COLLATION "en-x-icu" REFRESH VERSION;
CREATE COLLATION test0 FROM "C";
CREATE TABLE collate_dep_test1 (a int, b text COLLATE test0);
CREATE DOMAIN collate_dep_dom1 AS text COLLATE test0;
CREATE TYPE collate_dep_test2 AS (x int, y text COLLATE test0);
CREATE VIEW collate_dep_test3 AS SELECT text 'foo' COLLATE test0 AS foo;
CREATE INDEX collate_dep_test4i ON collate_dep_test4t (b COLLATE test0);
DROP COLLATION test0 RESTRICT; -- failDROP COLLATION test0 CASCADE;
DROP TABLE collate_dep_test1, collate_dep_test4t;
DROP TYPE collate_dep_test2;
create type textrange_c as range(subtype=text, collation="C");
create type textrange_en_us as range(subtype=text, collation="en-x-icu");
@::select textrange_c('A','Z') @> 'b'::text;
@::select textrange_en_us('A','Z') @> 'b'::text;
drop type textrange_c;
drop type textrange_en_us;
CREATE COLLATION testcoll_ignore_accents (provider = icu, locale = '@colStrength=primary;colCaseLevel=yes');
SELECT 'aa' > 'AAA' COLLATE "und-x-icu", 'aa' < 'AAA' COLLATE testcoll_ignore_accents;
CREATE COLLATION testcoll_backwards (provider = icu, locale = '@colBackwards=yes');
SELECT 'cot' < 'cte' COLLATE "und-x-icu", 'cot' > 'cte' COLLATE testcoll_backwards;
CREATE COLLATION testcoll_lower_first (provider = icu, locale = '@colCaseFirst=lower');
CREATE COLLATION testcoll_upper_first (provider = icu, locale = '@colCaseFirst=upper');
SELECT 'aaa' < 'AAA' COLLATE testcoll_lower_first, 'aaa' > 'AAA' COLLATE testcoll_upper_first;
CREATE COLLATION testcoll_shifted (provider = icu, locale = '@colAlternate=shifted');
SELECT 'de-luge' < 'deanza' COLLATE "und-x-icu", 'de-luge' > 'deanza' COLLATE testcoll_shifted;
CREATE COLLATION testcoll_numeric (provider = icu, locale = '@colNumeric=yes');
SELECT 'A-21' > 'A-123' COLLATE "und-x-icu", 'A-21' < 'A-123' COLLATE testcoll_numeric;
CREATE COLLATION testcoll_error1 (provider = icu, locale = '@colNumeric=lower');
CREATE COLLATION testcoll_de_phonebook (provider = icu, locale = 'de@collation=phonebook');
SELECT 'Goldmann' < 'Gtz' COLLATE "de-x-icu", 'Goldmann' > 'Gtz' COLLATE testcoll_de_phonebook;
CREATE COLLATION ctest_det (provider = icu, locale = '', deterministic = true);
CREATE COLLATION ctest_nondet (provider = icu, locale = '', deterministic = false);
&INSERT INTO test6 VALUES (1, U&'\00E4bc');
&INSERT INTO test6 VALUES (2, U&'\0061\0308bc');
SELECT * FROM test6 WHERE b = 'bc' COLLATE ctest_det;
SELECT * FROM test6 WHERE b = 'bc' COLLATE ctest_nondet;
CREATE COLLATION case_sensitive (provider = icu, locale = '');
CREATE COLLATION case_insensitive (provider = icu, locale = '@colStrength=secondary', deterministic = false);
SELECT 'abc' <= 'ABC' COLLATE case_sensitive, 'abc' >= 'ABC' COLLATE case_sensitive;
SELECT 'abc' <= 'ABC' COLLATE case_insensitive, 'abc' >= 'ABC' COLLATE case_insensitive;
CREATE TABLE test1cs (x text COLLATE case_sensitive);
CREATE TABLE test2cs (x text COLLATE case_sensitive);
CREATE TABLE test3cs (x text COLLATE case_sensitive);
SELECT x FROM test3cs WHERE x <> 'abc';
SELECT x FROM test3cs WHERE x ILIKE 'a%';
SELECT x FROM test3cs WHERE x SIMILAR TO 'a%';
~SELECT x FROM test3cs WHERE x ~ 'a';
CREATE UNIQUE INDEX ON test1cs (x);  -- okINSERT INTO test1cs VALUES ('ABC');  -- okCREATE UNIQUE INDEX ON test3cs (x);  -- okSELECT string_to_array('ABC,DEF,GHI' COLLATE case_sensitive, ',', 'abc');
SELECT string_to_array('ABCDEFGHI' COLLATE case_sensitive, NULL, 'b');
CREATE TABLE test1ci (x text COLLATE case_insensitive);
CREATE TABLE test2ci (x text COLLATE case_insensitive);
CREATE TABLE test3ci (x text COLLATE case_insensitive);
CREATE INDEX ON test3ci (x text_pattern_ops);  -- errorINSERT INTO test1ci VALUES ('abc'), ('def'), ('ghi');
SELECT x FROM test3ci WHERE x <> 'abc';
SELECT x FROM test3ci WHERE x ILIKE 'a%';
SELECT x FROM test3ci WHERE x SIMILAR TO 'a%';
~SELECT x FROM test3ci WHERE x ~ 'a';
CREATE UNIQUE INDEX ON test1ci (x);  -- okINSERT INTO test1ci VALUES ('ABC');  -- errorCREATE UNIQUE INDEX ON test3ci (x);  -- errorSELECT string_to_array('ABC,DEF,GHI' COLLATE case_insensitive, ',', 'abc');
SELECT string_to_array('ABCDEFGHI' COLLATE case_insensitive, NULL, 'b');
CREATE TABLE test1bpci (x char(3) COLLATE case_insensitive);
CREATE TABLE test2bpci (x char(3) COLLATE case_insensitive);
CREATE TABLE test3bpci (x char(3) COLLATE case_insensitive);
CREATE INDEX ON test3bpci (x bpchar_pattern_ops);  -- errorINSERT INTO test1bpci VALUES ('abc'), ('def'), ('ghi');
SELECT x FROM test3bpci WHERE x <> 'abc';
SELECT x FROM test3bpci WHERE x ILIKE 'a%';
SELECT x FROM test3bpci WHERE x SIMILAR TO 'a%';
~SELECT x FROM test3bpci WHERE x ~ 'a';
CREATE UNIQUE INDEX ON test1bpci (x);  -- okINSERT INTO test1bpci VALUES ('ABC');  -- errorCREATE UNIQUE INDEX ON test3bpci (x);  -- errorSELECT string_to_array('ABC,DEF,GHI'::char(11) COLLATE case_insensitive, ',', 'abc');
::SELECT string_to_array('ABCDEFGHI'::char(9) COLLATE case_insensitive, NULL, 'b');
CREATE TABLE test4c (x text COLLATE "C");
CREATE INDEX ON test4c (x);
SET enable_seqscan = off;
SELECT x FROM test4c WHERE x LIKE 'ABC' COLLATE case_sensitive;  -- ok, no rowsSELECT x FROM test4c WHERE x LIKE 'ABC%' COLLATE case_sensitive;  -- ok, no rowsSELECT x FROM test4c WHERE x LIKE 'ABC' COLLATE case_insensitive;  -- errorSELECT x FROM test4c WHERE x LIKE 'ABC%' COLLATE case_insensitive;  -- errorRESET enable_seqscan;
SELECT '' = '' COLLATE case_sensitive;
SELECT '' = '' COLLATE case_insensitive;
::SELECT relname FROM pg_class WHERE relname = 'PG_CLASS'::text COLLATE case_insensitive;
::SELECT relname FROM pg_class WHERE 'PG_CLASS'::text = relname COLLATE case_insensitive;
SELECT typname FROM pg_type WHERE typname LIKE 'int_' AND typname <> 'INT2'::text  COLLATE case_insensitive ORDER BY typname;
::SELECT typname FROM pg_type WHERE typname LIKE 'int_' AND 'INT2'::text <> typname  COLLATE case_insensitive ORDER BY typname;
CREATE TEMP TABLE outer_text (f1 text COLLATE case_insensitive, f2 text);
INSERT INTO outer_text VALUES ('A', NULL);
INSERT INTO outer_text VALUES ('B', NULL);
CREATE TEMP TABLE inner_text (c1 text COLLATE case_insensitive, c2 text);
INSERT INTO inner_text VALUES ('a', NULL);
CREATE COLLATION ignore_accents (provider = icu, locale = '@colStrength=primary;colCaseLevel=yes', deterministic = false);
SELECT * FROM test4 WHERE b = 'cote' COLLATE ignore_accents;
SELECT * FROM test4 WHERE b = 'Cote' COLLATE ignore_accents;  -- still case-sensitiveSELECT * FROM test4 WHERE b = 'Cote' COLLATE case_insensitive;
CREATE TABLE test10pk (x text COLLATE case_sensitive PRIMARY KEY);
CREATE TABLE test10fk (x text COLLATE case_insensitive REFERENCES test10pk (x) ON UPDATE CASCADE ON DELETE CASCADE);
INSERT INTO test10fk VALUES ('abc');  -- okINSERT INTO test10fk VALUES ('ABC');  -- errorINSERT INTO test10fk VALUES ('xyz');  -- errorSELECT * FROM test10pk;
UPDATE test10fk SET x = 'ABC' WHERE x = 'abc';  -- errorSELECT * FROM test10fk;
DELETE FROM test10pk WHERE x = 'abc';
CREATE TABLE test11pk (x text COLLATE case_insensitive PRIMARY KEY);
CREATE TABLE test11fk (x text COLLATE case_sensitive REFERENCES test11pk (x) ON UPDATE CASCADE ON DELETE CASCADE);
INSERT INTO test11fk VALUES ('abc');  -- okINSERT INTO test11fk VALUES ('ABC');  -- okINSERT INTO test11fk VALUES ('xyz');  -- errorSELECT * FROM test11pk;
DELETE FROM test11pk WHERE x = 'abc';
CREATE TABLE test20 (a int, b text COLLATE case_insensitive) PARTITION BY LIST (b);
CREATE TABLE test20_1 PARTITION OF test20 FOR VALUES IN ('abc');
CREATE TABLE test21 (a int, b text COLLATE case_insensitive) PARTITION BY RANGE (b);
CREATE TABLE test21_1 PARTITION OF test21 FOR VALUES FROM ('ABC') TO ('DEF');
CREATE TABLE test22 (a int, b text COLLATE case_sensitive) PARTITION BY HASH (b);
CREATE TABLE test22_0 PARTITION OF test22 FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE test22_1 PARTITION OF test22 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
CREATE TABLE test23 (a int, b text COLLATE case_insensitive) PARTITION BY HASH (b);
CREATE TABLE test23_0 PARTITION OF test23 FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE test23_1 PARTITION OF test23 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
SELECT (SELECT count(*) FROM test23_0) <> (SELECT count(*) FROM test23_1);
CREATE TABLE test30 (a int, b char(3) COLLATE case_insensitive) PARTITION BY LIST (b);
CREATE TABLE test30_1 PARTITION OF test30 FOR VALUES IN ('abc');
CREATE TABLE test31 (a int, b char(3) COLLATE case_insensitive) PARTITION BY RANGE (b);
CREATE TABLE test31_1 PARTITION OF test31 FOR VALUES FROM ('ABC') TO ('DEF');
CREATE TABLE test32 (a int, b char(3) COLLATE case_sensitive) PARTITION BY HASH (b);
CREATE TABLE test32_0 PARTITION OF test32 FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE test32_1 PARTITION OF test32 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
CREATE TABLE test33 (a int, b char(3) COLLATE case_insensitive) PARTITION BY HASH (b);
CREATE TABLE test33_0 PARTITION OF test33 FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE test33_1 PARTITION OF test33 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
SELECT (SELECT count(*) FROM test33_0) <> (SELECT count(*) FROM test33_1);
RESET search_path;
SET client_min_messages TO warning;
DROP SCHEMA collate_tests CASCADE;
RESET client_min_messages;
CREATE COLLATION coll_icu_upgrade FROM "und-x-icu";
/* * This test is for Linux/glibc systems and assumes that a full set of * locales is installed.  It must be run in a database with UTF-8 encoding, * because other encodings don't support all the characters used. */SELECT getdatabaseencoding() <> 'UTF8' OR       (SELECT count(*) FROM pg_collation WHERE collname IN ('de_DE', 'en_US', 'sv_SE', 'tr_TR') AND collencoding = pg_char_to_encoding('UTF8')) <> 4 OR       version() !~ 'linux-gnu'       AS skip_test \gset\if :skip_test\quit\endifSET client_encoding TO UTF8;
CREATE SCHEMA collate_tests;
SET search_path = collate_tests;
CREATE TABLE collate_test1 (    a int,    b text COLLATE "en_US" NOT NULL);
CREATE TABLE collate_test_fail (    a int,    b text COLLATE "ja_JP.eucjp");
CREATE TABLE collate_test_fail (    a int,    b text COLLATE "foo");
CREATE TABLE collate_test_fail (    a int COLLATE "en_US",    b text);
CREATE TABLE collate_test_like (    LIKE collate_test1);
CREATE TABLE collate_test2 (    a int,    b text COLLATE "sv_SE");
CREATE TABLE collate_test3 (    a int,    b text COLLATE "C");
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
SELECT * FROM collate_test1 WHERE b >= 'bbc' COLLATE "C";
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "C";
SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "en_US";
CREATE DOMAIN testdomain_sv AS text COLLATE "sv_SE";
CREATE DOMAIN testdomain_i AS int COLLATE "sv_SE"; -- failsCREATE TABLE collate_test4 (    a int,    b testdomain_sv);
CREATE TABLE collate_test5 (    a int,    b testdomain_sv COLLATE "en_US");
SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
SELECT 'bbc' COLLATE "en_US" > 'bc' COLLATE "en_US" AS "true";
SELECT 'bbc' COLLATE "sv_SE" > 'bc' COLLATE "sv_SE" AS "false";
CREATE TABLE collate_test10 (    a int,    x text COLLATE "en_US",    y text COLLATE "tr_TR");
SELECT a, lower(x COLLATE "C"), lower(y COLLATE "C") FROM collate_test10;
SELECT a, x, y FROM collate_test10 ORDER BY lower(y), a;
SELECT * FROM collate_test1 WHERE b ILIKE 'abc';
SELECT * FROM collate_test1 WHERE b ILIKE 'abc%';
SELECT * FROM collate_test1 WHERE b ILIKE '%bc%';
SELECT 'Trkiye' COLLATE "en_US" ILIKE '%KI%' AS "true";
SELECT 'Trkiye' COLLATE "tr_TR" ILIKE '%KI%' AS "false";
SELECT 'bt' ILIKE 'BIT' COLLATE "en_US" AS "false";
SELECT 'bt' ILIKE 'BIT' COLLATE "tr_TR" AS "true";
SELECT relname FROM pg_class WHERE relname ILIKE 'abc%';
~SELECT * FROM collate_test1 WHERE b ~ '^abc$';
~SELECT * FROM collate_test1 WHERE b ~ '^abc';
~SELECT * FROM collate_test1 WHERE b ~ 'bc';
~~~CREATE TABLE collate_test6 (    a int,    b text COLLATE "en_US");
~SELECT b,       b ~ '^[[:alpha:]]+$' AS is_alpha,       b ~ '^[[:upper:]]+$' AS is_upper,       b ~ '^[[:lower:]]+$' AS is_lower,       b ~ '^[[:digit:]]+$' AS is_digit,       b ~ '^[[:alnum:]]+$' AS is_alnum,       b ~ '^[[:graph:]]+$' AS is_graph,       b ~ '^[[:print:]]+$' AS is_print,       b ~ '^[[:punct:]]+$' AS is_punct,       b ~ '^[[:space:]]+$' AS is_spaceFROM collate_test6;
SELECT 'Trkiye' COLLATE "en_US" ~* 'KI' AS "true";
SELECT 'Trkiye' COLLATE "tr_TR" ~* 'KI' AS "false";
~SELECT 'bt' ~* 'BIT' COLLATE "en_US" AS "false";
~SELECT 'bt' ~* 'BIT' COLLATE "tr_TR" AS "true";
~SET lc_time TO 'tr_TR';
SELECT to_char(date '2010-02-01', 'DD TMMON YYYY');
SELECT to_char(date '2010-02-01', 'DD TMMON YYYY' COLLATE "tr_TR");
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY');
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY' COLLATE "tr_TR");
CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
CREATE VIEW collview2 AS SELECT a, b FROM collate_test1 ORDER BY b COLLATE "C";
||CREATE VIEW collview3 AS SELECT a, lower((x || x) COLLATE "C") FROM collate_test10;
SELECT table_name, view_definition FROM information_schema.views  WHERE table_name LIKE 'collview%' ORDER BY 1;
CREATE DOMAIN testdomain AS text;
::::::::::::SELECT array_agg(b ORDER BY b) FROM collate_test1;
SELECT array_agg(b ORDER BY b) FROM collate_test2;
SELECT array_agg(b ORDER BY b) FROM collate_test3;
SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test1 ORDER BY 2;
SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test3 ORDER BY 2; -- failSELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test3; -- okSELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test3 ORDER BY 2; -- failSELECT a, b COLLATE "C" FROM collate_test1 UNION SELECT a, b FROM collate_test3 ORDER BY 2; -- okSELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test3 ORDER BY 2; -- failSELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test3 ORDER BY 2; -- failCREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test3; -- failselect x < y from collate_test10; -- failselect x || y from collate_test10; -- ok, because || is not collation awareselect x, y from collate_test10 order by x || y; -- not so okWITH RECURSIVE foo(x) AS   (SELECT x FROM (VALUES('a' COLLATE "en_US"),('b')) t(x)   UNION ALL   SELECT (x || 'c') COLLATE "de_DE" FROM foo WHERE length(x) < 10)SELECT * FROM foo;
SELECT CAST('42' AS text COLLATE "C");
CREATE FUNCTION mylt (text, text) RETURNS boolean LANGUAGE sql    AS $$ select $1 < $2 $$;
CREATE FUNCTION mylt_noninline (text, text) RETURNS boolean LANGUAGE sql    AS $$ select $1 < $2 limit 1 $$;
CREATE FUNCTION mylt_plpgsql (text, text) RETURNS boolean LANGUAGE plpgsql    AS $$ begin return $1 < $2; end $$;
SELECT a.b AS a, b.b AS b, a.b < b.b AS lt,       mylt(a.b, b.b), mylt_noninline(a.b, b.b), mylt_plpgsql(a.b, b.b)FROM collate_test1 a, collate_test1 bORDER BY a.b, b.b;
SELECT a.b AS a, b.b AS b, a.b < b.b COLLATE "C" AS lt,       mylt(a.b, b.b COLLATE "C"), mylt_noninline(a.b, b.b COLLATE "C"),       mylt_plpgsql(a.b, b.b COLLATE "C")FROM collate_test1 a, collate_test1 bORDER BY a.b, b.b;
CREATE FUNCTION mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$declare  xx text := x;
  yy text := y;
begin  return xx < yy;
end$$;
SELECT mylt2('a', 'B' collate "en_US") as t, mylt2('a', 'B' collate "C") as f;
CREATE OR REPLACE FUNCTION  mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$declare  xx text COLLATE "POSIX" := x;
  yy text := y;
begin  return xx < yy;
end$$;
SELECT mylt2('a', 'B' collate "C") as fail; -- conflicting collationsSELECT mylt2('a', 'B' collate "POSIX") as f;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test3)) ORDER BY 1;
CREATE FUNCTION dup (anyelement) RETURNS anyelement    AS 'select $1' LANGUAGE sql;
CREATE INDEX collate_test1_idx2 ON collate_test1 (b COLLATE "C");
CREATE INDEX collate_test1_idx3 ON collate_test1 ((b COLLATE "C")); -- this is different grammaticallyCREATE INDEX collate_test1_idx4 ON collate_test1 (((b||'foo') COLLATE "POSIX"));
CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "C"); -- failCREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "C")); -- failSELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
CREATE ROLE regress_test_role;
CREATE SCHEMA test_schema;
do $$BEGIN  EXECUTE 'CREATE COLLATION test0 (locale = ' ||          quote_literal(current_setting('lc_collate')) || ');';
END$$;
CREATE COLLATION test0 FROM "C"; -- fail, duplicate nameCREATE COLLATION IF NOT EXISTS test0 FROM "C"; -- ok, skippedCREATE COLLATION IF NOT EXISTS test0 (locale = 'foo'); -- ok, skippeddo $$BEGIN  EXECUTE 'CREATE COLLATION test1 (lc_collate = ' ||          quote_literal(current_setting('lc_collate')) ||          ', lc_ctype = ' ||          quote_literal(current_setting('lc_ctype')) || ');';
END$$;
CREATE COLLATION test3 (lc_collate = 'en_US.utf8'); -- fail, need lc_ctypeCREATE COLLATION testx (locale = 'nonsense'); -- failCREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test5 FROM test0;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test0 RENAME TO test11; -- failALTER COLLATION test1 RENAME TO test22; -- failALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 SET SCHEMA test_schema;
COMMENT ON COLLATION test0 IS 'US English';
SELECT collname, nspname, obj_description(pg_collation.oid, 'pg_collation')    FROM pg_collation JOIN pg_namespace ON (collnamespace = pg_namespace.oid)    WHERE collname LIKE 'test%'    ORDER BY 1;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0; -- failDROP COLLATION IF EXISTS test0;
DROP SCHEMA test_schema;
DROP ROLE regress_test_role;
ALTER COLLATION "en_US" REFRESH VERSION;
CREATE COLLATION test0 FROM "C";
CREATE TABLE collate_dep_test1 (a int, b text COLLATE test0);
CREATE DOMAIN collate_dep_dom1 AS text COLLATE test0;
CREATE TYPE collate_dep_test2 AS (x int, y text COLLATE test0);
CREATE VIEW collate_dep_test3 AS SELECT text 'foo' COLLATE test0 AS foo;
CREATE INDEX collate_dep_test4i ON collate_dep_test4t (b COLLATE test0);
DROP COLLATION test0 RESTRICT; -- failDROP COLLATION test0 CASCADE;
DROP TABLE collate_dep_test1, collate_dep_test4t;
DROP TYPE collate_dep_test2;
create type textrange_c as range(subtype=text, collation="C");
create type textrange_en_us as range(subtype=text, collation="en_US");
@::select textrange_c('A','Z') @> 'b'::text;
@::select textrange_en_us('A','Z') @> 'b'::text;
drop type textrange_c;
drop type textrange_en_us;
CREATE COLLATION ctest_det (locale = 'en_US.utf8', deterministic = true);
CREATE COLLATION ctest_nondet (locale = 'en_US.utf8', deterministic = false);
SET client_min_messages TO warning;
DROP SCHEMA collate_tests CASCADE;
CREATE TABLE test_replica_identity (       id serial primary key,       keya text not null,       keyb text not null,       nonkey text,       CONSTRAINT test_replica_identity_unique_defer UNIQUE (keya, keyb) DEFERRABLE,       CONSTRAINT test_replica_identity_unique_nondefer UNIQUE (keya, keyb)) ;
CREATE TABLE test_replica_identity_othertable (id serial primary key);
CREATE INDEX test_replica_identity_hash ON test_replica_identity USING hash (nonkey);
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
::SELECT relreplident FROM pg_class WHERE oid = 'pg_class'::regclass;
::SELECT relreplident FROM pg_class WHERE oid = 'pg_constraint'::regclass;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_nonkey;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_hash;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_expr;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_partial;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_othertable_pkey;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_defer;
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_pkey;
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_nondefer;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
::SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
ALTER TABLE test_replica_identity REPLICA IDENTITY DEFAULT;
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
::SELECT count(*) FROM pg_index WHERE indrelid = 'test_replica_identity'::regclass AND indisreplident;
ALTER TABLE test_replica_identity REPLICA IDENTITY FULL;
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
ALTER TABLE test_replica_identity REPLICA IDENTITY NOTHING;
::SELECT relreplident FROM pg_class WHERE oid = 'test_replica_identity'::regclass;
CREATE TEXT SEARCH DICTIONARY ispell (                        Template=ispell,                        DictFile=ispell_sample,                        AffFile=ispell_sample);
CREATE TEXT SEARCH DICTIONARY hunspell (                        Template=ispell,                        DictFile=ispell_sample,                        AffFile=hunspell_sample);
CREATE TEXT SEARCH DICTIONARY hunspell_long (                        Template=ispell,                        DictFile=hunspell_sample_long,                        AffFile=hunspell_sample_long);
CREATE TEXT SEARCH DICTIONARY hunspell_num (                        Template=ispell,                        DictFile=hunspell_sample_num,                        AffFile=hunspell_sample_num);
CREATE TEXT SEARCH DICTIONARY hunspell_err (						Template=ispell,						DictFile=ispell_sample,						AffFile=hunspell_sample_long);
CREATE TEXT SEARCH DICTIONARY hunspell_err (						Template=ispell,						DictFile=ispell_sample,						AffFile=hunspell_sample_num);
CREATE TEXT SEARCH DICTIONARY hunspell_invalid_1 (						Template=ispell,						DictFile=hunspell_sample_long,						AffFile=ispell_sample);
CREATE TEXT SEARCH DICTIONARY hunspell_invalid_2 (						Template=ispell,						DictFile=hunspell_sample_long,						AffFile=hunspell_sample_num);
CREATE TEXT SEARCH DICTIONARY hunspell_invalid_3 (						Template=ispell,						DictFile=hunspell_sample_num,						AffFile=ispell_sample);
CREATE TEXT SEARCH DICTIONARY hunspell_err (						Template=ispell,						DictFile=hunspell_sample_num,						AffFile=hunspell_sample_long);
CREATE TEXT SEARCH DICTIONARY synonym (						Template=synonym,						Synonyms=synonym_sample);
CREATE TEXT SEARCH DICTIONARY thesaurus (                        Template=thesaurus,						DictFile=thesaurus_sample,						Dictionary=english_stem);
CREATE TEXT SEARCH CONFIGURATION ispell_tst (						COPY=english);
ALTER TEXT SEARCH CONFIGURATION ispell_tst ALTER MAPPING FOR	word, numword, asciiword, hword, numhword, asciihword, hword_part, hword_numpart, hword_asciipart	WITH ispell, english_stem;
CREATE TEXT SEARCH CONFIGURATION hunspell_tst (						COPY=ispell_tst);
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING	REPLACE ispell WITH hunspell;
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING	REPLACE hunspell WITH hunspell_long;
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING	REPLACE hunspell_long WITH hunspell_num;
CREATE TEXT SEARCH CONFIGURATION synonym_tst (						COPY=english);
ALTER TEXT SEARCH CONFIGURATION synonym_tst ALTER MAPPING FOR	asciiword, hword_asciipart, asciihword	WITH synonym, english_stem;
CREATE TEXT SEARCH CONFIGURATION thesaurus_tst (						COPY=synonym_tst);
ALTER TEXT SEARCH CONFIGURATION thesaurus_tst ALTER MAPPING FOR	asciiword, hword_asciipart, asciihword	WITH synonym, thesaurus, english_stem;
CREATE TEXT SEARCH DICTIONARY tsdict_case	Template = ispell,	"DictFile" = ispell_sample,	"AffFile" = ispell_sample);
SELECT oid, prsnameFROM pg_ts_parserWHERE prsnamespace = 0 OR prsstart = 0 OR prstoken = 0 OR prsend = 0 OR      -- prsheadline is optional      prslextype = 0;
SELECT oid, dictnameFROM pg_ts_dictWHERE dictnamespace = 0 OR dictowner = 0 OR dicttemplate = 0;
SELECT oid, tmplnameFROM pg_ts_templateWHERE tmplnamespace = 0 OR tmpllexize = 0;  -- tmplinit is optionalSELECT oid, cfgnameFROM pg_ts_configWHERE cfgnamespace = 0 OR cfgowner = 0 OR cfgparser = 0;
SELECT mapcfg, maptokentype, mapseqnoFROM pg_ts_config_mapWHERE mapcfg = 0 OR mapdict = 0;
SELECT * FROM  ( SELECT oid AS cfgid, (ts_token_type(cfgparser)).tokid AS tokid    FROM pg_ts_config ) AS ttRIGHT JOIN pg_ts_config_map AS m    ON (tt.cfgid=m.mapcfg AND tt.tokid=m.maptokentype)WHERE    tt.cfgid IS NULL OR tt.tokid IS NULL;
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
@@SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
create index wowidx on test_tsvector using gist (a);
SET enable_seqscan=OFF;
SET enable_indexscan=ON;
SET enable_bitmapscan=OFF;
explain (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
@@SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
SET enable_indexscan=OFF;
SET enable_bitmapscan=ON;
explain (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
@@SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
CREATE INDEX wowidx ON test_tsvector USING gin (a);
SET enable_seqscan=OFF;
explain (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'wr&qh';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq&yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'eq|yt';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq&yt)|(wr&qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '(eq|yt)&(wr|qh)';
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'w:*|q:*';
@@SELECT count(*) FROM test_tsvector WHERE a @@ any ('{wr,qh}');
@@SELECT count(*) FROM test_tsvector WHERE a @@ 'no_such_lexeme';
@@SELECT count(*) FROM test_tsvector WHERE a @@ '!no_such_lexeme';
RESET enable_seqscan;
SELECT * FROM ts_stat('SELECT a FROM test_tsvector') ORDER BY ndoc DESC, nentry DESC, word LIMIT 10;
SELECT * FROM ts_stat('SELECT a FROM test_tsvector', 'AB') ORDER BY ndoc DESC, nentry DESC, word;
SELECT token, alias,  dictionaries, dictionaries is null as dnull, array_dims(dictionaries) as ddims,  lexemes, lexemes is null as lnull, array_dims(lexemes) as ldimsfrom ts_debug('english', 'a title');
&&SELECT plainto_tsquery('english', 'foo bar') && plainto_tsquery('english', 'asd');
||SELECT plainto_tsquery('english', 'foo bar') || plainto_tsquery('english', 'asd fg');
||!!SELECT plainto_tsquery('english', 'foo bar') || !!plainto_tsquery('english', 'asd fg');
&&SELECT plainto_tsquery('english', 'foo bar') && 'asd | fg';
SELECT ts_rank_cd(to_tsvector('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)'), to_tsquery('english', 'paint&water'));
SELECT ts_rank_cd(to_tsvector('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)'), to_tsquery('english', 'breath&motion&water'));
SELECT ts_rank_cd(to_tsvector('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)'), to_tsquery('english', 'ocean'));
SELECT ts_rank_cd(to_tsvector('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)'), to_tsquery('english', 'painted <-> Ship'));
||SELECT ts_rank_cd(to_tsvector('unstripped') || strip(to_tsvector('stripped')),                  to_tsquery('unstripped & stripped'));
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'paint&water'));
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'breath&motion&water'));
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'ocean'));
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', phraseto_tsquery('english', 'painted Ocean'));
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', phraseto_tsquery('english', 'idle as a painted Ship'));
SELECT ts_headline('english', '<html><!-- some comment --><body>Sea view wow <u>foo bar</u> <i>qq</i><a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a>ff-bg<script>       document.write(15);
</script></body></html>',to_tsquery('english', 'sea&foo'), 'HighlightAll=true');
::SELECT ts_headline('simple', '1 2 3 1 3'::text, '1 <-> 3', 'MaxWords=2, MinWords=1');
::SELECT ts_headline('simple', '1 2 3 1 3'::text, '1 & 3', 'MaxWords=4, MinWords=1');
::SELECT ts_headline('simple', '1 2 3 1 3'::text, '1 <-> 3', 'MaxWords=4, MinWords=1');
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'ocean'), 'MaxFragments=1');
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2');
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'ocean & seahorse'), 'MaxFragments=1');
SELECT ts_headline('english', 'Day after day, day after day,  We stuck, nor breath nor motion,As idle as a painted Ship  Upon a painted Ocean.Water, water, every where  And all the boards did shrink;
Water, water, every where,  Nor any drop to drink.S. T. Coleridge (1772-1834)', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2,FragmentDelimiter=***');
\\set ECHO none\copy test_tsquery from stdin'New York'	new & york | big & apple | nycMoscow	moskva | moscow'Sanct Peter'	Peterburg | peter | 'Sanct Peterburg''foo bar qq'	foo & (bar | qq) & city1 & (2 <-> 3)	2 <-> 45 <-> 6	5 <-> 7\.\set ECHO allALTER TABLE test_tsquery ADD COLUMN keyword tsquery;
ALTER TABLE test_tsquery ADD COLUMN sample tsquery;
::UPDATE test_tsquery SET sample = to_tsquery('english', txtsample::text);
SET enable_seqscan=OFF;
RESET enable_seqscan;
::::SELECT ts_rewrite('moscow', 'SELECT keyword, sample FROM test_tsquery'::text );
::SELECT ts_rewrite('moscow & hotel', 'SELECT keyword, sample FROM test_tsquery'::text );
::SELECT ts_rewrite('bar & new & qq & foo & york', 'SELECT keyword, sample FROM test_tsquery'::text );
::SELECT ts_rewrite('1 & (2 <-> 3)', 'SELECT keyword, sample FROM test_tsquery'::text );
::SELECT ts_rewrite('1 & (2 <2> 3)', 'SELECT keyword, sample FROM test_tsquery'::text );
::SELECT ts_rewrite('5 <-> (1 & (2 <-> 3))', 'SELECT keyword, sample FROM test_tsquery'::text );
::SELECT ts_rewrite('5 <-> (6 | 8)', 'SELECT keyword, sample FROM test_tsquery'::text );
@@@@CREATE INDEX qq ON test_tsquery USING gist (keyword tsquery_ops);
SET enable_seqscan=OFF;
@@@@@@SELECT to_tsvector('foo bar') @@  ts_rewrite(tsquery_phrase('foo', 'foo'), 'foo', 'bar | baz');
@@SELECT to_tsvector('bar baz') @@  ts_rewrite(tsquery_phrase('foo', 'foo'), 'foo', 'bar | baz');
RESET enable_seqscan;
SET default_text_search_config=simple;
SET default_text_search_config=english;
CREATE TRIGGER tsvectorupdateBEFORE UPDATE OR INSERT ON test_tsvectorFOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(a, 'pg_catalog.english', t);
@@SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
@@SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
UPDATE test_tsvector SET t = null WHERE t = '345 qwerty';
@@SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
@@SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
explain (costs off)select * from test_tsquery, to_tsquery('new') q where txtsample @@ q;
explain (costs off)select * from test_tsquery, to_tsquery('english', 'new') q where txtsample @@ q;
create temp table pendtest (ts tsvector);
create index pendtest_idx on pendtest using gin(ts);
::select * from pendtest where 'ipsu:*'::tsquery @@ ts;
::select * from pendtest where 'ipsa:*'::tsquery @@ ts;
::select * from pendtest where 'ips:*'::tsquery @@ ts;
::select * from pendtest where 'ipt:*'::tsquery @@ ts;
::select * from pendtest where 'ipi:*'::tsquery @@ ts;
create temp table phrase_index_test(fts tsvector);
create index phrase_index_test_idx on phrase_index_test using gin(fts);
set enable_seqscan = off;
@@select * from phrase_index_test where fts @@ phraseto_tsquery('english', 'fat cat');
set enable_seqscan = on;
@@select to_tsvector('english', 'A fat cat ate a rat') @@	websearch_to_tsquery('english', '"a fat cat" ate a rat');
@@select to_tsvector('english', 'A fat grey cat ate a rat') @@	websearch_to_tsquery('english', '"a fat cat" ate a rat');
CREATE TABLE LINE_TBL (s line);
INSERT INTO LINE_TBL VALUES ('{0,-1,5}');	-- A == 0INSERT INTO LINE_TBL VALUES ('{1,0,5}');	-- B == 0INSERT INTO LINE_TBL VALUES ('{0,3,0}');	-- A == C == 0INSERT INTO LINE_TBL VALUES (' (0,0), (6,6)');
INSERT INTO LINE_TBL VALUES (line(point '(3,1)', point '(3,2)'));
INSERT INTO LINE_TBL VALUES (line(point '(1,0)', point '(1,0)'));
::select '{nan, 1, nan}'::line = '{nan, 1, nan}'::line as true,	   '{nan, 1, nan}'::line = '{nan, 2, nan}'::line as false;
SELECT * FROM hash_i4_heap   WHERE hash_i4_heap.random = 843938989;
SELECT * FROM hash_i4_heap   WHERE hash_i4_heap.random = 66766766;
SELECT * FROM hash_name_heap   WHERE hash_name_heap.random = '1505703298'::name;
SELECT * FROM hash_name_heap   WHERE hash_name_heap.random = '7777777'::name;
SELECT * FROM hash_txt_heap   WHERE hash_txt_heap.random = '1351610853'::text;
SELECT * FROM hash_txt_heap   WHERE hash_txt_heap.random = '111111112222222233333333'::text;
SELECT * FROM hash_f8_heap   WHERE hash_f8_heap.random = '444705537'::float8;
SELECT * FROM hash_f8_heap   WHERE hash_f8_heap.random = '88888888'::float8;
UPDATE hash_i4_heap   SET random = 1   WHERE hash_i4_heap.seqno = 1492;
SELECT h.seqno AS i1492, h.random AS i1   FROM hash_i4_heap h   WHERE h.random = 1;
UPDATE hash_i4_heap   SET seqno = 20000   WHERE hash_i4_heap.random = 1492795354;
SELECT h.seqno AS i20000   FROM hash_i4_heap h   WHERE h.random = 1492795354;
::UPDATE hash_name_heap   SET random = '0123456789abcdef'::name   WHERE hash_name_heap.seqno = 6543;
SELECT h.seqno AS i6543, h.random AS c0_to_f   FROM hash_name_heap h   WHERE h.random = '0123456789abcdef'::name;
UPDATE hash_name_heap   SET seqno = 20000   WHERE hash_name_heap.random = '76652222'::name;
SELECT h.seqno AS emptyset   FROM hash_name_heap h   WHERE h.random = '76652222'::name;
::UPDATE hash_txt_heap   SET random = '0123456789abcdefghijklmnop'::text   WHERE hash_txt_heap.seqno = 4002;
SELECT h.seqno AS i4002, h.random AS c0_to_p   FROM hash_txt_heap h   WHERE h.random = '0123456789abcdefghijklmnop'::text;
UPDATE hash_txt_heap   SET seqno = 20000   WHERE hash_txt_heap.random = '959363399'::text;
SELECT h.seqno AS t20000   FROM hash_txt_heap h   WHERE h.random = '959363399'::text;
::UPDATE hash_f8_heap   SET random = '-1234.1234'::float8   WHERE hash_f8_heap.seqno = 8906;
SELECT h.seqno AS i8096, h.random AS f1234_1234   FROM hash_f8_heap h   WHERE h.random = '-1234.1234'::float8;
UPDATE hash_f8_heap   SET seqno = 20000   WHERE hash_f8_heap.random = '488912369'::float8;
SELECT h.seqno AS f20000   FROM hash_f8_heap h   WHERE h.random = '488912369'::float8;
CREATE INDEX hash_split_index on hash_split_heap USING HASH (keycol);
BEGIN;
SET enable_seqscan = OFF;
SET enable_bitmapscan = OFF;
DECLARE c CURSOR FOR SELECT * from hash_split_heap WHERE keycol = 1;
MOVE FORWARD ALL FROM c;
MOVE BACKWARD 10000 FROM c;
MOVE BACKWARD ALL FROM c;
CLOSE c;
END;
DELETE FROM hash_split_heap WHERE keycol = 1;
VACUUM hash_split_heap;
ALTER INDEX hash_split_index SET (fillfactor = 10);
CREATE INDEX hash_idx ON hash_temp_heap USING hash (x);
DROP TABLE hash_temp_heap CASCADE;
CREATE TABLE hash_heap_float4 (x float4, y int);
CREATE INDEX hash_idx ON hash_heap_float4 USING hash (x);
DROP TABLE hash_heap_float4 CASCADE;
CREATE INDEX hash_f8_index2 ON hash_f8_heap USING hash (random float8_ops)	WITH (fillfactor=9);
CREATE INDEX hash_f8_index2 ON hash_f8_heap USING hash (random float8_ops)	WITH (fillfactor=101);
\\set invalid/name foo\set AUTOCOMMIT foo\set FETCH_COUNT foo\echo :ON_ERROR_ROLLBACK\set ON_ERROR_ROLLBACK\echo :ON_ERROR_ROLLBACK\set ON_ERROR_ROLLBACK foo\echo :ON_ERROR_ROLLBACK\set ON_ERROR_ROLLBACK on\echo :ON_ERROR_ROLLBACK\unset ON_ERROR_ROLLBACK\echo :ON_ERROR_ROLLBACKSELECT 1 as one, 2 as two \g\gxSELECT 3 as three, 4 as four \gx\g\set FETCH_COUNT 1SELECT 1 as one, 2 as two \g\gxSELECT 3 as three, 4 as four \gx\g\unset FETCH_COUNTselect 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_\echo :pref01_test01 :pref01_test02 :pref01_test03select 10 as "bad name"\gsetselect 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_xselect 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_yselect 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_yselect 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y\set var2 xyzselect 1 as var1, NULL as var2, 3 as var3 \gset\echo :var1 :var2 :var3select 10 as test01, 20 as test02 from generate_series(1,3) \gsetselect 10 as test01, 20 as test02 from generate_series(1,0) \gset\set FETCH_COUNT 1select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_xselect 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_yselect 10 as test01, 20 as test02 from generate_series(1,3) \gsetselect 10 as test01, 20 as test02 from generate_series(1,0) \gset\unset FETCH_COUNTSELECT    NULL AS zero,    1 AS one,    2.0 AS two,    'three' AS three,    $1 AS four,    sin($2) as five,    'foo'::varchar(4) as six,    CURRENT_DATE AS now\gdescPREPARE test AS SELECT 1 AS first, 2 AS second;
EXECUTE test \gdescEXPLAIN EXECUTE test \gdescSELECT 1 + \gdescSELECT \gdescCREATE TABLE bububu(a int) \gdescTABLE bububu;  -- failSELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"\gdesc\gSELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \gcreate temporary table gexec_test(a int, b text, c date, d float);
select format('create index on gexec_test(%I)', attname)from pg_attributewhere attrelid = 'gexec_test'::regclass and attnum > 0order by attnum\gexec\set FETCH_COUNT 1select 'select 1 as ones', 'select x.y, x.y*2 as double from generate_series(1,4) as x(y)'union allselect 'drop table gexec_test', NULLunion allselect 'drop table gexec_test', 'select ''2000-01-01''::date as party_over'\gexec\unset FETCH_COUNT\psetprepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "abc", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "abc" from generate_series(1,10) as n(n) group by n>1 order by n>1;
\\pset linestyle ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset linestyle old-ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
deallocate q;
prepare q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
\\pset linestyle ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset expanded on\pset columns 30\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset linestyle old-ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset expanded on\pset border 0\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 1\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
\\pset border 2\pset format unalignedexecute q;
\\pset format alignedexecute q;
\\pset format wrappedexecute q;
deallocate q;
\\pset linestyle ascii\pset border 1create table psql_serial_tab (id serial);
\\pset format aligned\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseselect 1 where false;
\\pset format unaligned\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only false\pset format wrapped\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseCREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
CREATE TABLE tbl_heap_psql(f1 int, f2 char(100)) using heap_psql;
CREATE TABLE tbl_heap(f1 int, f2 char(100)) using heap;
\\set HIDE_TABLEAM off\set HIDE_TABLEAM onDROP TABLE tbl_heap, tbl_heap_psql;
DROP ACCESS METHOD heap_psql;
\\pset format aligned\pset expanded off\pset numericlocale trueselect n, -n as m, n * 111 as x, '1e90'::float8 as ffrom generate_series(0,3) n;
\\pset numericlocale false\pset format asciidoc\pset border 1\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseprepare q as  select 'some|text' as "a|title", '        ' as "empty ", n as int  from generate_series(1,2) as n;
\\pset expanded off\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
\\pset expanded on\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
deallocate q;
\\pset format csv\pset border 1\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseprepare q as  select 'some"text' as "a""title", E'  <foo>\n<bar>' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\\pset expanded offexecute q;
\\pset expanded onexecute q;
deallocate q;
\\pset expanded offselect 'comma,comma' as comma, 'semi;semi' as semi;
\\pset csv_fieldsep ';'select 'comma,comma' as comma, 'semi;semi' as semi;
\\pset csv_fieldsep '.'select '\' as d1, '' as d2;
\\pset csv_fieldsep ''\pset csv_fieldsep '\0'\pset csv_fieldsep '\n'\pset csv_fieldsep '\r'\pset csv_fieldsep '"'\pset csv_fieldsep ',,'\pset csv_fieldsep ','\pset format html\pset border 1\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseprepare q as  select 'some"text' as "a&title", E'  <foo>\n<bar>' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\\pset expanded off\pset border 0execute q;
\\pset border 1execute q;
\\pset tableattr foobarexecute q;
\\pset tableattr\pset expanded on\pset border 0execute q;
\\pset border 1execute q;
\\pset tableattr foobarexecute q;
\\pset tableattrdeallocate q;
\\pset format latex\pset border 1\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseprepare q as  select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\\pset expanded off\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
\\pset border 3execute q;
\\pset expanded on\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
\\pset border 3execute q;
deallocate q;
\\pset format latex-longtable\pset border 1\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseprepare q as  select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\\pset expanded off\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
\\pset border 3execute q;
\\pset tableattr lrexecute q;
\\pset tableattr\pset expanded on\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
\\pset border 3execute q;
\\pset tableattr lrexecute q;
\\pset tableattrdeallocate q;
\\pset format troff-ms\pset border 1\pset expanded off\pset tuples_only true\pset tuples_only false\pset expanded on\pset tuples_only true\pset tuples_only falseprepare q as  select 'some\text' as "a\title", E'  <foo>\n<bar>' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\\pset expanded off\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
\\pset expanded on\pset border 0execute q;
\\pset border 1execute q;
\\pset border 2execute q;
deallocate q;
\\pset format a\pset format ldrop table psql_serial_tab;
\\pset format aligned\pset expanded off\pset border 1\echo this is a test\echo -n without newline\echo with -n newline\echo '-n' with newline\set foo bar\echo foo = :foo\qecho this is a test\qecho foo = :foo\warn this is a test\warn foo = :foo\if true  select 'okay';
\\else  not okay;
  still not okay\endif\gselect  \if true    42  \else    (bogus  \endif  forty_two;
\select \if false \\ (bogus \else \\ 42 \endif \\ forty_two;
\\if true	\if 1		\if yes			\if on				\echo 'all true'			\else				\echo 'should not print #1-1'			\endif		\else			\echo 'should not print #1-2'		\endif	\else		\echo 'should not print #1-3'	\endif\else	\echo 'should not print #1-4'\endif\if false	\echo 'should not print #2-1'\elif 0	\echo 'should not print #2-2'\elif no	\echo 'should not print #2-3'\elif off	\echo 'should not print #2-4'\else	\echo 'all false'\endif\if true	\echo 'should print #2-5'\elif true	\echo 'should not print #2-6'\elif false	\echo 'should not print #2-7'\else	\echo 'should not print #2-8'\endif\if true	\echo 'first thing true'\else	\echo 'should not print #3-1'\endif\if false	\echo 'should not print #4-1'\elif true	\echo 'second thing true'\else	\echo 'should not print #5-1'\endif\if invalid boolean expression	\echo 'will not print #6-1'\else	\echo 'will print anyway #6-2'\endif\endif\else\elif\if true\else\else\endif\if false\else\elif\endif\if false    \if false        \echo 'should not print #7-1'    \else        \echo 'should not print #7-2'    \endif    \echo 'should not print #7-3'\else    \echo 'should print #7-4'\endif\set foo bar\echo :foo :'foo' :"foo"\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"\set try_to_quit '\\q'\if false	:try_to_quit	\echo `nosuchcommand` :foo :'foo' :"foo"	\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"	\a	\C arg1	\c arg1 arg2 arg3 arg4	\cd arg1	\conninfo	\copy arg1 arg2 arg3 arg4 arg5 arg6	\copyright	SELECT 1 as one, 2, 3 \crosstabview	\e arg1 arg2	\ef whole_line	\ev whole_line	\echo arg1 arg2 arg3 arg4 arg5	\echo arg1	\encoding arg1	\errverbose	\f arg1	\g arg1	\gx arg1	\gexec	SELECT 1 AS one \gset	\h	\?	\html	\i arg1	\ir arg1	\l arg1	\lo arg1 arg2	\lo_list	\o arg1	\p	\password arg1	\prompt arg1 arg2	\pset arg1 arg2	\q	\reset	\s arg1	\set arg1 arg2 arg3 arg4 arg5 arg6 arg7	\setenv arg1 arg2	\sf whole_line	\sv whole_line	\t arg1	\T arg1	\timing arg1	\unset arg1	\w arg1	\watch arg1	\x arg1	-- \else here is eaten as part of OT_FILEPIPE argument	\w |/no/such/file \else	-- \endif here is eaten as part of whole-line argument	\! whole_line \endif	\z\else	\echo 'should print #8-1'\endif\set i 1\if :{?i}  \echo '#9-1 ok, variable i is defined'\else  \echo 'should not print #9-2'\endif\if :{?no_such_variable}  \echo 'should not print #10-1'\else  \echo '#10-2 ok, variable no_such_variable is not defined'\endifSELECT :{?i} AS i_is_defined;
:{?}\\set SHOW_CONTEXT neverdo $$begin  raise notice 'foo';
  raise exception 'bar';
end $$;
\\set SHOW_CONTEXT errorsdo $$begin  raise notice 'foo';
  raise exception 'bar';
end $$;
\\set SHOW_CONTEXT alwaysdo $$begin  raise notice 'foo';
  raise exception 'bar';
end $$;
\\pSELECT 2 \r\pSELECT 3 \pUNION SELECT 4 \pUNION SELECT 5ORDER BY 1;
\\r\pSELECT 1 AS stuff UNION SELECT 2;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTSELECT 1 UNION;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATEDROP TABLE this_table_does_not_exist;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\set VERBOSITY terseSELECT 1 UNION;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'last error message:' :LAST_ERROR_MESSAGE\set VERBOSITY sqlstateSELECT 1/0;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'last error message:' :LAST_ERROR_MESSAGE\set VERBOSITY defaultSELECT 3 AS three, 4 AS four \gdesc\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTSELECT 4 AS \gdesc\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\set FETCH_COUNT 10select unique2 from tenk1 order by unique2 limit 19;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTselect 1/(15-unique2) from tenk1 order by unique2 limit 19;
\\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\unset FETCH_COUNTcreate schema testpart;
create role regress_partitioning_role;
alter schema testpart owner to regress_partitioning_role;
set role to regress_partitioning_role;
set search_path to testpart;
create table testtable_apple(logdate date);
create table testtable_orange(logdate date);
create table testpart_apple(logdate date) partition by range(logdate);
create table testpart_orange(logdate date) partition by range(logdate);
create table parent_tab (id int) partition by range (id);
create table child_0_10 partition of parent_tab  for values from (0) to (10);
create table child_10_20 partition of parent_tab  for values from (10) to (20);
create table child_20_30 partition of parent_tab  for values from (20) to (30);
create table child_30_40 partition of parent_tabfor values from (30) to (40)  partition by range(id);
create table child_30_35 partition of child_30_40  for values from (30) to (35);
create table child_35_40 partition of child_30_40   for values from (35) to (40);
drop table parent_tab cascade;
drop schema testpart;
set search_path to default;
set role to default;
drop role regress_partitioning_role;
CREATE TABLE brintest (byteacol bytea,	charcol "char",	namecol name,	int8col bigint,	int2col smallint,	int4col integer,	textcol text,	oidcol oid,	tidcol tid,	float4col real,	float8col double precision,	macaddrcol macaddr,	inetcol inet,	cidrcol cidr,	bpcharcol character,	datecol date,	timecol time without time zone,	timestampcol timestamp without time zone,	timestamptzcol timestamp with time zone,	intervalcol interval,	timetzcol time with time zone,	bitcol bit(10),	varbitcol bit varying(16),	numericcol numeric,	uuidcol uuid,	int4rangecol int4range,	lsncol pg_lsn,	boxcol box) WITH (fillfactor=10);
::::::::::::INSERT INTO brintest SELECT	repeat(stringu1, 8)::bytea,	substr(stringu1, 1, 1)::"char",	stringu1::name, 142857 * tenthous,	thousand,	twothousand,	repeat(stringu1, 8),	unique1::oid,	format('(%s,%s)', tenthous, twenty)::tid,	(four + 1.0)/(hundred+1),	odd::float8 / (tenthous + 1),	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,	inet '10.2.3.4/24' + tenthous,	cidr '10.2.3/24' + tenthous,	substr(stringu1, 1, 1)::bpchar,	date '1995-08-15' + tenthous,	time '01:20:30' + thousand * interval '18.5 second',	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',	justify_days(justify_hours(tenthous * interval '12 minutes')),	timetz '01:30:20+02' + hundred * interval '15 seconds',	thousand::bit(10),	tenthous::bit(16)::varbit,	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,	int4range(thousand, twothousand),	format('%s/%s%s', odd, even, tenthous)::pg_lsn,	box(point(odd, even), point(thousand, twothousand))FROM tenk1 ORDER BY unique2 LIMIT 100;
INSERT INTO brintest (inetcol, cidrcol, int4rangecol) SELECT	inet 'fe80::6e40:8ff:fea9:8c46' + tenthous,	cidr 'fe80::6e40:8ff:fea9:8c46' + tenthous,	'empty'::int4rangeFROM tenk1 ORDER BY thousand, tenthous LIMIT 25;
CREATE INDEX brinidx ON brintest USING brin (	byteacol,	charcol,	namecol,	int8col,	int2col,	int4col,	textcol,	oidcol,	tidcol,	float4col,	float8col,	macaddrcol,	inetcol inet_inclusion_ops,	inetcol inet_minmax_ops,	cidrcol inet_inclusion_ops,	cidrcol inet_minmax_ops,	bpcharcol,	datecol,	timecol,	timestampcol,	timestamptzcol,	intervalcol,	timetzcol,	bitcol,	varbitcol,	numericcol,	uuidcol,	int4rangecol,	lsncol,	boxcol) with (pages_per_range = 1);
CREATE TABLE brinopers (colname name, typ text,	op text[], value text[], matches int[],	check (cardinality(op) = cardinality(value)),	check (cardinality(op) = cardinality(matches)));
DO $x$DECLARE	r record;
	r2 record;
	cond text;
	idx_ctids tid[];
	ss_ctids tid[];
	count int;
	plan_ok bool;
	plan_line text;
BEGIN	FOR r IN SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper LOOP		-- prepare the condition		IF r.value IS NULL THEN			cond := format('%I %s %L', r.colname, r.oper, r.value);
		ELSE			cond := format('%I %s %L::%s', r.colname, r.oper, r.value, r.typ);
		END IF;
		-- run the query using the brin index		SET enable_seqscan = 0;
		SET enable_bitmapscan = 1;
		plan_ok := false;
		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP			IF plan_line LIKE '%Bitmap Heap Scan on brintest%' THEN				plan_ok := true;
			END IF;
		END LOOP;
		IF NOT plan_ok THEN			RAISE WARNING 'did not get bitmap indexscan plan for %', r;
		END IF;
		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)			INTO idx_ctids;
		-- run the query using a seqscan		SET enable_seqscan = 1;
		SET enable_bitmapscan = 0;
		plan_ok := false;
		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP			IF plan_line LIKE '%Seq Scan on brintest%' THEN				plan_ok := true;
			END IF;
		END LOOP;
		IF NOT plan_ok THEN			RAISE WARNING 'did not get seqscan plan for %', r;
		END IF;
		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)			INTO ss_ctids;
		-- make sure both return the same results		count := array_length(idx_ctids, 1);
		IF NOT (count = array_length(ss_ctids, 1) AND				idx_ctids @> ss_ctids AND				idx_ctids <@ ss_ctids) THEN			-- report the results of each scan to make the differences obvious			RAISE WARNING 'something not right in %: count %', r, count;
			SET enable_seqscan = 1;
			SET enable_bitmapscan = 0;
			FOR r2 IN EXECUTE 'SELECT ' || r.colname || ' FROM brintest WHERE ' || cond LOOP				RAISE NOTICE 'seqscan: %', r2;
			END LOOP;
			SET enable_seqscan = 0;
			SET enable_bitmapscan = 1;
			FOR r2 IN EXECUTE 'SELECT ' || r.colname || ' FROM brintest WHERE ' || cond LOOP				RAISE NOTICE 'bitmapscan: %', r2;
			END LOOP;
		END IF;
		-- make sure we found expected number of matches		IF count != r.matches THEN RAISE WARNING 'unexpected number of results % for %', count, r; END IF;
	END LOOP;
END;
$$x$;
RESET enable_seqscan;
RESET enable_bitmapscan;
::::::::::::INSERT INTO brintest SELECT	repeat(stringu1, 42)::bytea,	substr(stringu1, 1, 1)::"char",	stringu1::name, 142857 * tenthous,	thousand,	twothousand,	repeat(stringu1, 42),	unique1::oid,	format('(%s,%s)', tenthous, twenty)::tid,	(four + 1.0)/(hundred+1),	odd::float8 / (tenthous + 1),	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,	inet '10.2.3.4' + tenthous,	cidr '10.2.3/24' + tenthous,	substr(stringu1, 1, 1)::bpchar,	date '1995-08-15' + tenthous,	time '01:20:30' + thousand * interval '18.5 second',	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',	justify_days(justify_hours(tenthous * interval '12 minutes')),	timetz '01:30:20' + hundred * interval '15 seconds',	thousand::bit(10),	tenthous::bit(16)::varbit,	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,	int4range(thousand, twothousand),	format('%s/%s%s', odd, even, tenthous)::pg_lsn,	box(point(odd, even), point(thousand, twothousand))FROM tenk1 ORDER BY unique2 LIMIT 5 OFFSET 5;
VACUUM brintest;  -- force a summarization cycle in brinidxUPDATE brintest SET int8col = int8col * int4col;
SELECT brin_summarize_new_values('brintest'); -- error, not an indexSELECT brin_summarize_new_values('tenk1_unique1'); -- error, not a BRIN indexSELECT brin_summarize_new_values('brinidx'); -- ok, no change expectedSELECT brin_desummarize_range('brinidx', -1); -- error, invalid rangeSELECT brin_desummarize_range('brinidx', 0);
CREATE TABLE brin_summarize (    value int) WITH (fillfactor=10, autovacuum_enabled=false);
CREATE INDEX brin_summarize_idx ON brin_summarize USING brin (value) WITH (pages_per_range=2);
DO $$DECLARE curtid tid;
BEGIN  LOOP    INSERT INTO brin_summarize VALUES (1) RETURNING ctid INTO curtid;
    EXIT WHEN curtid > tid '(2, 0)';
  END LOOP;
END;
$$;
INSERT INTO brin_test SELECT x/100,x%100 FROM generate_series(1,10000) x(x);
CREATE INDEX brin_test_a_idx ON brin_test USING brin (a) WITH (pages_per_range = 2);
CREATE INDEX brin_test_b_idx ON brin_test USING brin (b) WITH (pages_per_range = 2);
VACUUM ANALYZE brin_test;
EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE a = 1;
EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE b = 1;
begin;
set local min_parallel_table_scan_size = 0;
set local parallel_setup_cost = 0;
set local enable_hashjoin = on;
create or replace function find_hash(node json)returns json language plpgsqlas$$declare  x json;
  child json;
begin  if node->>'Node Type' = 'Hash' then    return node;
  else    for child in select json_array_elements(node->'Plans')    loop      x := find_hash(child);
      if x is not null then        return x;
      end if;
    end loop;
    return null;
  end if;
end;
$$;
create or replace function hash_join_batches(query text)returns table (original int, final int) language plpgsqlas$$declare  whole_plan json;
  hash_node json;
begin  for whole_plan in    execute 'explain (analyze, format ''json'') ' || query  loop    hash_node := find_hash(json_extract_path(whole_plan, '0', 'Plan'));
    original := hash_node->>'Original Hash Batches';
    final := hash_node->>'Hash Batches';
    return next;
  end loop;
end;
$$;
create table simple as  select generate_series(1, 20000) AS id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
alter table simple set (parallel_workers = 2);
analyze simple;
alter table bigger_than_it_looks set (autovacuum_enabled = 'false');
alter table bigger_than_it_looks set (parallel_workers = 2);
analyze bigger_than_it_looks;
alter table extremely_skewed set (autovacuum_enabled = 'false');
alter table extremely_skewed set (parallel_workers = 2);
analyze extremely_skewed;
alter table wide set (parallel_workers = 2);
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '4MB';
explain (costs off)  select count(*) from simple r join simple s using (id);
select count(*) from simple r join simple s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '4MB';
set local enable_parallel_hash = off;
explain (costs off)  select count(*) from simple r join simple s using (id);
select count(*) from simple r join simple s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '4MB';
set local enable_parallel_hash = on;
explain (costs off)  select count(*) from simple r join simple s using (id);
select count(*) from simple r join simple s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '128kB';
explain (costs off)  select count(*) from simple r join simple s using (id);
select count(*) from simple r join simple s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '128kB';
set local enable_parallel_hash = off;
explain (costs off)  select count(*) from simple r join simple s using (id);
select count(*) from simple r join simple s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '192kB';
set local enable_parallel_hash = on;
explain (costs off)  select count(*) from simple r join simple s using (id);
select count(*) from simple r join simple s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '128kB';
explain (costs off)  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '128kB';
set local enable_parallel_hash = off;
explain (costs off)  select count(*) from simple r join bigger_than_it_looks s using (id);
select count(*) from simple r join bigger_than_it_looks s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join bigger_than_it_looks s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 1;
set local work_mem = '192kB';
set local enable_parallel_hash = on;
explain (costs off)  select count(*) from simple r join bigger_than_it_looks s using (id);
select count(*) from simple r join bigger_than_it_looks s using (id);
select original > 1 as initially_multibatch, final > original as increased_batches  from hash_join_batches($$  select count(*) from simple r join bigger_than_it_looks s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '128kB';
explain (costs off)  select count(*) from simple r join extremely_skewed s using (id);
select count(*) from simple r join extremely_skewed s using (id);
select * from hash_join_batches($$  select count(*) from simple r join extremely_skewed s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '128kB';
set local enable_parallel_hash = off;
explain (costs off)  select count(*) from simple r join extremely_skewed s using (id);
select count(*) from simple r join extremely_skewed s using (id);
select * from hash_join_batches($$  select count(*) from simple r join extremely_skewed s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 1;
set local work_mem = '128kB';
set local enable_parallel_hash = on;
explain (costs off)  select count(*) from simple r join extremely_skewed s using (id);
select count(*) from simple r join extremely_skewed s using (id);
select * from hash_join_batches($$  select count(*) from simple r join extremely_skewed s using (id);
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '4MB';
set local parallel_leader_participation = off;
select * from hash_join_batches($$  select count(*) from simple r join simple s using (id);
$$);
rollback to settings;
::create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t;
alter table join_foo set (parallel_workers = 0);
::create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t;
alter table join_bar set (parallel_workers = 2);
savepoint settings;
set enable_parallel_hash = off;
set parallel_leader_participation = off;
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '64kB';
explain (costs off)  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select count(*) from join_foo  left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss  on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select final > 1 as multibatch  from hash_join_batches($$  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
$$);
rollback to settings;
savepoint settings;
set enable_parallel_hash = off;
set parallel_leader_participation = off;
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '4MB';
explain (costs off)  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select count(*) from join_foo  left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss  on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select final > 1 as multibatch  from hash_join_batches($$  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
$$);
rollback to settings;
savepoint settings;
set enable_parallel_hash = on;
set parallel_leader_participation = off;
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '64kB';
explain (costs off)  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select count(*) from join_foo  left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss  on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select final > 1 as multibatch  from hash_join_batches($$  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
$$);
rollback to settings;
savepoint settings;
set enable_parallel_hash = on;
set parallel_leader_participation = off;
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '4MB';
explain (costs off)  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select count(*) from join_foo  left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss  on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
select final > 1 as multibatch  from hash_join_batches($$  select count(*) from join_foo    left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss    on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
$$);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 0;
explain (costs off)     select  count(*) from simple r full outer join simple s using (id);
select  count(*) from simple r full outer join simple s using (id);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
explain (costs off)     select  count(*) from simple r full outer join simple s using (id);
select  count(*) from simple r full outer join simple s using (id);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 0;
explain (costs off)     select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
rollback to settings;
savepoint settings;
set local max_parallel_workers_per_gather = 2;
explain (costs off)     select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
rollback to settings;
savepoint settings;
set max_parallel_workers_per_gather = 2;
set enable_parallel_hash = on;
set work_mem = '128kB';
explain (costs off)  select length(max(s.t))  from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
select length(max(s.t))from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
select final > 1 as multibatch  from hash_join_batches($$  select length(max(s.t))  from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
$$);
rollback to settings;
rollback;
BEGIN;
SET LOCAL enable_sort = OFF; -- avoid mergejoinsSET LOCAL from_collapse_limit = 1; -- allows easy changing of join orderCREATE TABLE hjtest_1 (a text, b int, id int, c bool);
CREATE TABLE hjtest_2 (a bool, id int, b text, c int);
INSERT INTO hjtest_1(a, b, id, c) VALUES ('text', 2, 1, false); -- matchesINSERT INTO hjtest_1(a, b, id, c) VALUES ('text', 1, 2, false); -- fails id join conditionINSERT INTO hjtest_1(a, b, id, c) VALUES ('text', 20, 1, false); -- fails < 50INSERT INTO hjtest_1(a, b, id, c) VALUES ('text', 1, 1, false); -- fails (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)INSERT INTO hjtest_2(a, id, b, c) VALUES (true, 1, 'another', 2); -- matchesINSERT INTO hjtest_2(a, id, b, c) VALUES (true, 3, 'another', 7); -- fails id join conditionINSERT INTO hjtest_2(a, id, b, c) VALUES (true, 1, 'another', 90);  -- fails < 55INSERT INTO hjtest_2(a, id, b, c) VALUES (true, 1, 'another', 3); -- fails (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)INSERT INTO hjtest_2(a, id, b, c) VALUES (true, 1, 'text', 1); --  fails hjtest_1.a <> hjtest_2.b;
EXPLAIN (COSTS OFF, VERBOSE)SELECT hjtest_1.a a1, hjtest_2.a a2,hjtest_1.tableoid::regclass t1, hjtest_2.tableoid::regclass t2FROM hjtest_1, hjtest_2WHERE    hjtest_1.id = (SELECT 1 WHERE hjtest_2.id = 1)    AND (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)    AND (SELECT hjtest_1.b * 5) < 50    AND (SELECT hjtest_2.c * 5) < 55    AND hjtest_1.a <> hjtest_2.b;
SELECT hjtest_1.a a1, hjtest_2.a a2,hjtest_1.tableoid::regclass t1, hjtest_2.tableoid::regclass t2FROM hjtest_1, hjtest_2WHERE    hjtest_1.id = (SELECT 1 WHERE hjtest_2.id = 1)    AND (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)    AND (SELECT hjtest_1.b * 5) < 50    AND (SELECT hjtest_2.c * 5) < 55    AND hjtest_1.a <> hjtest_2.b;
EXPLAIN (COSTS OFF, VERBOSE)SELECT hjtest_1.a a1, hjtest_2.a a2,hjtest_1.tableoid::regclass t1, hjtest_2.tableoid::regclass t2FROM hjtest_2, hjtest_1WHERE    hjtest_1.id = (SELECT 1 WHERE hjtest_2.id = 1)    AND (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)    AND (SELECT hjtest_1.b * 5) < 50    AND (SELECT hjtest_2.c * 5) < 55    AND hjtest_1.a <> hjtest_2.b;
SELECT hjtest_1.a a1, hjtest_2.a a2,hjtest_1.tableoid::regclass t1, hjtest_2.tableoid::regclass t2FROM hjtest_2, hjtest_1WHERE    hjtest_1.id = (SELECT 1 WHERE hjtest_2.id = 1)    AND (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)    AND (SELECT hjtest_1.b * 5) < 50    AND (SELECT hjtest_2.c * 5) < 55    AND hjtest_1.a <> hjtest_2.b;
ROLLBACK;
CREATE TABLE money_data (m money);
::::::SELECT 2::int2 * m FROM money_data;
::::::SELECT 2::int8 * m FROM money_data;
::::::SELECT 2::float8 * m FROM money_data;
::::::SELECT 2::float4 * m FROM money_data;
::DELETE FROM money_data;
DELETE FROM money_data;
DELETE FROM money_data;
DELETE FROM money_data;
DELETE FROM money_data;
DELETE FROM money_data;
::::::::::::::::::::::::::::::::::::SELECT '878.08'::money / 11::float8;
::SELECT '878.08'::money / 11::float4;
::SELECT '878.08'::money / 11::bigint;
::SELECT '878.08'::money / 11::int;
::SELECT '878.08'::money / 11::smallint;
::SELECT '90000000000000099.00'::money / 10::bigint;
::SELECT '90000000000000099.00'::money / 10::int;
::SELECT '90000000000000099.00'::money / 10::smallint;
::::::::::::::SELECT 1234567890::int4::money;
::::SELECT 12345678901234567::int8::money;
::SELECT 12345678901234567::numeric::money;
::::SELECT (-1234567890)::int4::money;
::::SELECT (-12345678901234567)::int8::money;
::SELECT (-12345678901234567)::numeric::money;
::::SELECT '12345678901234567'::money::numeric;
::::SELECT '-12345678901234567'::money::numeric;
::::SELECT '92233720368547758.07'::money::numeric;
::::SELECT '-92233720368547758.08'::money::numeric;
WITH RECURSIVE t(n) AS (    VALUES (1)UNION ALL    SELECT n+1 FROM t WHERE n < 100SELECT sum(n) FROM t;
WITH RECURSIVE t(n) AS (    SELECT (VALUES(1))UNION ALL    SELECT n+1 FROM t WHERE n < 5SELECT * FROM t;
CREATE RECURSIVE VIEW nums (n) AS    VALUES (1)UNION ALL    SELECT n+1 FROM nums WHERE n < 5;
CREATE OR REPLACE RECURSIVE VIEW nums (n) AS    VALUES (1)UNION ALL    SELECT n+1 FROM nums WHERE n < 6;
WITH RECURSIVE t(n) AS (    VALUES (1)UNION ALL    SELECT n+1 FROM t)SELECT * FROM t LIMIT 10;
WITH q AS (SELECT 'foo' AS x)SELECT x, x IS OF (text) AS is_text FROM q;
WITH RECURSIVE t(n) AS (    SELECT 'foo'UNION ALL    SELECT n || ' bar' FROM t WHERE length(n) < 20SELECT n, n IS OF (text) AS is_text FROM t;
WITH RECURSIVE t(n) AS (    SELECT '7'UNION ALL    SELECT n+1 FROM t WHERE n < 10SELECT n, n IS OF (int) AS is_int FROM t;
CREATE TEMP TABLE department (	id INTEGER PRIMARY KEY,  -- department ID	parent_department INTEGER REFERENCES department, -- upper department ID	name TEXT -- department name);
INSERT INTO department VALUES (0, NULL, 'ROOT');
WITH RECURSIVE subdepartment AS	-- non recursive term	SELECT name as root_name, * FROM department WHERE name = 'A'	UNION ALL	-- recursive term	SELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd		WHERE d.parent_department = sd.idSELECT * FROM subdepartment ORDER BY name;
WITH RECURSIVE subdepartment(level, id, parent_department, name) AS	-- non recursive term	SELECT 1, * FROM department WHERE name = 'A'	UNION ALL	-- recursive term	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd		WHERE d.parent_department = sd.idSELECT * FROM subdepartment ORDER BY name;
WITH RECURSIVE subdepartment(level, id, parent_department, name) AS	-- non recursive term	SELECT 1, * FROM department WHERE name = 'A'	UNION ALL	-- recursive term	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd		WHERE d.parent_department = sd.idSELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;
WITH RECURSIVE subdepartment AS	-- note lack of recursive UNION structure	SELECT * FROM department WHERE name = 'A'SELECT * FROM subdepartment ORDER BY name;
SELECT count(*) FROM (    WITH RECURSIVE t(n) AS (        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500    )    SELECT * FROM t) AS t WHERE n < (        SELECT count(*) FROM (            WITH RECURSIVE t(n) AS (                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100                )            SELECT * FROM t WHERE n < 50000         ) AS t WHERE n < 100);
CREATE TEMPORARY VIEW vsubdepartment AS	WITH RECURSIVE subdepartment AS	(		 -- non recursive term		SELECT * FROM department WHERE name = 'A'		UNION ALL		-- recursive term		SELECT d.* FROM department AS d, subdepartment AS sd			WHERE d.parent_department = sd.id	)	SELECT * FROM subdepartment;
::::CREATE VIEW sums_1_100 ASWITH RECURSIVE t(n) AS (    VALUES (1)UNION ALL    SELECT n+1 FROM t WHERE n < 100SELECT sum(n) FROM t;
with recursive q as (      select * from department    union all      (with x as (select * from q)       select * from x)    )select * from q limit 24;
with recursive q as (      select * from department    union all      (with recursive x as (           select * from department         union all           (select * from q union all select * from x)        )       select * from x)    )select * from q limit 32;
WITH RECURSIVE t(i,j) AS (	VALUES (1,2)	UNION ALL	SELECT t2.i, t.j+1 FROM		(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2		JOIN t ON (t2.i = t.i+1))	SELECT * FROM t;
INSERT INTO treeVALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);
WITH RECURSIVE t(id, path) AS (    VALUES(1,ARRAY[]::integer[])UNION ALL    SELECT tree.id, t.path || tree.id    FROM tree JOIN t ON (tree.parent_id = t.id)SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON	(t1.path[1] = t2.path[1] AND	array_upper(t1.path,1) = 1 AND	array_upper(t2.path,1) > 1)	ORDER BY t1.id, t2.id;
WITH RECURSIVE t(id, path) AS (    VALUES(1,ARRAY[]::integer[])UNION ALL    SELECT tree.id, t.path || tree.id    FROM tree JOIN t ON (tree.parent_id = t.id)SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON	(t1.path[1] = t2.path[1] AND	array_upper(t1.path,1) = 1 AND	array_upper(t2.path,1) > 1)	GROUP BY t1.id	ORDER BY t1.id;
WITH RECURSIVE t(id, path) AS (    VALUES(1,ARRAY[]::integer[])UNION ALL    SELECT tree.id, t.path || tree.id    FROM tree JOIN t ON (tree.parent_id = t.id)SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON(t1.id=t2.id);
with recursive search_graph(f, t, label, path, cycle) as (	select *, array[row(g.f, g.t)], false from graph g	union all	select g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)	from graph g, search_graph sg	where g.f = sg.t and not cycleselect * from search_graph;
with recursive search_graph(f, t, label, path, cycle) as (	select *, array[row(g.f, g.t)], false from graph g	union all	select g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)	from graph g, search_graph sg	where g.f = sg.t and not cycleselect * from search_graph order by path;
WITH RECURSIVE  y (id) AS (VALUES (1)),  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)SELECT * FROM x;
WITH RECURSIVE    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),    y(id) AS (values (1)) SELECT * FROM x;
WITH RECURSIVE   x(id) AS     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),   y(id) AS     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10) SELECT y.*, x.* FROM y LEFT JOIN x USING (id);
WITH RECURSIVE   x(id) AS     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),   y(id) AS     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10) SELECT y.*, x.* FROM y LEFT JOIN x USING (id);
WITH RECURSIVE   x(id) AS     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),   y(id) AS     (SELECT * FROM x UNION ALL SELECT * FROM x),   z(id) AS     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10) SELECT * FROM z;
WITH RECURSIVE   x(id) AS     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),   y(id) AS     (SELECT * FROM x UNION ALL SELECT * FROM x),   z(id) AS     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10) SELECT * FROM z;
WITH t AS (	SELECT a FROM yINSERT INTO ySELECT a+20 FROM t RETURNING *;
WITH t AS (	SELECT a FROM yUPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;
WITH RECURSIVE t(a) AS (	SELECT 11	UNION ALL	SELECT a+1 FROM t WHERE a < 50DELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;
WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)	SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)	SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)	SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1	UNION ALL	SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1	UNION ALL	SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1	UNION ALL	SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x                          WHERE n IN (SELECT * FROM x))  SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) FROM x)  SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FROM x)  SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)  SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)  SELECT * FROM x;
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x FOR UPDATE)  SELECT * FROM x;
WITH RECURSIVE x(id) AS (values (1)    UNION ALL    SELECT (SELECT * FROM x) FROM x WHERE id < 5) SELECT * FROM x;
WITH RECURSIVE  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)SELECT * FROM x;
WITH RECURSIVE foo(i) AS    (values (1)    UNION ALL       (SELECT i+1 FROM foo WHERE i < 10          UNION ALL       SELECT i+1 FROM foo WHERE i < 5)) SELECT * FROM foo;
WITH RECURSIVE foo(i) AS    (values (1)    UNION ALL	   SELECT * FROM       (SELECT i+1 FROM foo WHERE i < 10          UNION ALL       SELECT i+1 FROM foo WHERE i < 5) AS t) SELECT * FROM foo;
WITH RECURSIVE foo(i) AS    (values (1)    UNION ALL       (SELECT i+1 FROM foo WHERE i < 10          EXCEPT       SELECT i+1 FROM foo WHERE i < 5)) SELECT * FROM foo;
WITH RECURSIVE foo(i) AS    (values (1)    UNION ALL       (SELECT i+1 FROM foo WHERE i < 10          INTERSECT       SELECT i+1 FROM foo WHERE i < 5)) SELECT * FROM foo;
WITH RECURSIVE foo(i) AS   (SELECT i FROM (VALUES(1),(2)) t(i)   UNION ALL   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)SELECT * FROM foo;
::WITH RECURSIVE foo(i) AS   (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)   UNION ALL   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)SELECT * FROM foo;
CREATE RULE r2 AS ON UPDATE TO x DO INSTEAD    WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;
with cte(foo) as ( values(42) ) values((select foo from cte));
select ( with cte(foo) as ( values(f1) )         select (select foo from cte) )from int4_tbl;
select ( with cte(foo) as ( values(f1) )          values((select foo from cte)) )from int4_tbl;
WITH RECURSIVE t(j) AS (    WITH RECURSIVE s(i) AS (        VALUES (1)        UNION ALL        SELECT i+1 FROM s WHERE i < 10    )    SELECT i FROM s    UNION ALL    SELECT j+1 FROM t WHERE j < 10SELECT * FROM t;
WITH outermost(x) AS (  SELECT 1  UNION (WITH innermost as (SELECT 2)         SELECT * FROM innermost         UNION SELECT 3)SELECT * FROM outermost ORDER BY 1;
WITH outermost(x) AS (  SELECT 1  UNION (WITH innermost as (SELECT 2)         SELECT * FROM outermost  -- fail         UNION SELECT * FROM innermost)SELECT * FROM outermost ORDER BY 1;
WITH RECURSIVE outermost(x) AS (  SELECT 1  UNION (WITH innermost as (SELECT 2)         SELECT * FROM outermost         UNION SELECT * FROM innermost)SELECT * FROM outermost ORDER BY 1;
WITH RECURSIVE outermost(x) AS (  WITH innermost as (SELECT 2 FROM outermost) -- fail    SELECT * FROM innermost    UNION SELECT * from outermostSELECT * FROM outermost ORDER BY 1;
withA as ( select q2 as id, (select q1) as x from int8_tbl ),B as ( select id, row_number() over (partition by id) as r from A ),C as ( select A.id, array(select B.id from B where B.id = A.id) from A )select * from C;
WITH RECURSIVE  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),  iter (id_key, row_type, link) AS (      SELECT 0, 'base', 17    UNION ALL (      WITH remaining(id_key, row_type, link, min) AS (        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()        FROM tab INNER JOIN iter USING (link)        WHERE tab.id_key > iter.id_key      ),      first_remaining AS (        SELECT id_key, row_type, link        FROM remaining        WHERE id_key=min      ),      effect AS (        SELECT tab.id_key, 'new'::text, tab.link        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key        WHERE e.row_type = 'false'      )      SELECT * FROM first_remaining      UNION ALL SELECT * FROM effect    )  )SELECT * FROM iter;
WITH RECURSIVE  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),  iter (id_key, row_type, link) AS (      SELECT 0, 'base', 17    UNION (      WITH remaining(id_key, row_type, link, min) AS (        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()        FROM tab INNER JOIN iter USING (link)        WHERE tab.id_key > iter.id_key      ),      first_remaining AS (        SELECT id_key, row_type, link        FROM remaining        WHERE id_key=min      ),      effect AS (        SELECT tab.id_key, 'new'::text, tab.link        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key        WHERE e.row_type = 'false'      )      SELECT * FROM first_remaining      UNION ALL SELECT * FROM effect    )  )SELECT * FROM iter;
WITH t AS (    INSERT INTO y    VALUES        (11),        (12),        (13),        (14),        (15),        (16),        (17),        (18),        (19),        (20)    RETURNING *SELECT * FROM t;
WITH t AS (    UPDATE y    SET a=a+1    RETURNING *SELECT * FROM t;
WITH t AS (    DELETE FROM y    WHERE a <= 10    RETURNING *SELECT * FROM t;
WITH RECURSIVE t AS (	INSERT INTO y		SELECT a+5 FROM t2 WHERE a > 5	RETURNING *), t2 AS (	UPDATE y SET a=a-11 RETURNING *SELECT * FROM tUNION ALLSELECT * FROM t2;
CREATE RULE y_rule AS ON DELETE TO y DO INSTEAD  INSERT INTO y VALUES(42) RETURNING *;
WITH t AS (	DELETE FROM y RETURNING *SELECT * FROM t;
DROP RULE y_rule ON y;
CREATE TEMP TABLE bug6051 AS  select i from generate_series(1,3) as t(i);
WITH t1 AS ( DELETE FROM bug6051 RETURNING * )INSERT INTO bug6051 SELECT * FROM t1;
CREATE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD INSERT INTO bug6051_2 SELECT NEW.i;
WITH t1 AS ( DELETE FROM bug6051 RETURNING * )INSERT INTO bug6051 SELECT * FROM t1;
WITH RECURSIVE t(a) AS (	SELECT 0		UNION ALL	SELECT a+1 FROM t WHERE a+1 < 5), t2 as (	INSERT INTO y		SELECT * FROM t RETURNING *SELECT * FROM t2 JOIN y USING (a) ORDER BY a;
WITH t AS (    DELETE FROM y    WHERE a <= 10    RETURNING *INSERT INTO y SELECT -a FROM t RETURNING *;
WITH t AS (    UPDATE y SET a = a * 100 RETURNING *SELECT * FROM t LIMIT 10;
||CREATE TABLE withz AS SELECT i AS k, (i || ' v')::text v FROM generate_series(1, 16, 3) i;
ALTER TABLE withz ADD UNIQUE (k);
WITH t AS (    INSERT INTO withz SELECT i, 'insert'    FROM generate_series(0, 16) i    ON CONFLICT (k) DO UPDATE SET v = withz.v || ', now update'    RETURNING *SELECT * FROM t JOIN y ON t.k = y.a ORDER BY a, k;
WITH aa AS (    INSERT INTO withz VALUES(1, 5) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v    WHERE withz.k != EXCLUDED.k    RETURNING *SELECT * FROM aa;
WITH aa AS (SELECT 1 a, 2 b)INSERT INTO withz VALUES(1, 'insert')ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
WITH aa AS (SELECT 1 a, 2 b)INSERT INTO withz VALUES(1, 'insert')ON CONFLICT (k) DO UPDATE SET v = ' update' WHERE withz.k = (SELECT a FROM aa);
WITH aa AS (SELECT 1 a, 2 b)INSERT INTO withz VALUES(1, 'insert')ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
WITH aa AS (SELECT 'a' a, 'b' b UNION ALL SELECT 'a' a, 'b' b)INSERT INTO withz VALUES(1, 'insert')ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 'a' LIMIT 1);
||WITH aa AS (SELECT 1 a, 2 b)INSERT INTO withz VALUES(1, (SELECT b || ' insert' FROM aa WHERE a = 1 ))ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
WITH simpletup AS (  SELECT 2 k, 'Green' v),upsert_cte AS (  INSERT INTO withz VALUES(2, 'Blue') ON CONFLICT (k) DO    UPDATE SET (k, v) = (SELECT k, v FROM simpletup WHERE simpletup.k = withz.k)    RETURNING k, v)INSERT INTO withz VALUES(2, 'Red') ON CONFLICT (k) DOUPDATE SET (k, v) = (SELECT k, v FROM upsert_cte WHERE upsert_cte.k = withz.k)RETURNING k, v;
TRUNCATE TABLE y;
WITH RECURSIVE t1 AS (  INSERT INTO y SELECT * FROM y RETURNING *), t2 AS (  INSERT INTO yy SELECT * FROM t1 RETURNING *SELECT 1;
WITH RECURSIVE t1 AS (  INSERT INTO yy SELECT * FROM t2 RETURNING *), t2 AS (  INSERT INTO y SELECT * FROM y RETURNING *SELECT 1;
TRUNCATE TABLE y;
CREATE FUNCTION y_trigger() RETURNS trigger AS $$begin  raise notice 'y_trigger: a = %', new.a;
  return new;
end;
$$ LANGUAGE plpgsql;
WITH t AS (    INSERT INTO y    VALUES        (21),        (22),        (23)    RETURNING *SELECT * FROM t;
DROP TRIGGER y_trig ON y;
WITH t AS (    INSERT INTO y    VALUES        (31),        (32),        (33)    RETURNING *SELECT * FROM t LIMIT 1;
DROP TRIGGER y_trig ON y;
CREATE OR REPLACE FUNCTION y_trigger() RETURNS trigger AS $$begin  raise notice 'y_trigger';
  return null;
end;
$$ LANGUAGE plpgsql;
CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH STATEMENT    EXECUTE PROCEDURE y_trigger();
WITH t AS (    INSERT INTO y    VALUES        (41),        (42),        (43)    RETURNING *SELECT * FROM t;
DROP TRIGGER y_trig ON y;
DROP FUNCTION y_trigger();
CREATE TEMP TABLE child1 ( ) INHERITS ( parent );
CREATE TEMP TABLE child2 ( ) INHERITS ( parent );
WITH rcte AS ( SELECT sum(id) AS totalid FROM parent )UPDATE parent SET id = id + totalid FROM rcte;
WITH wcte AS ( INSERT INTO child1 VALUES ( 42, 'new' ) RETURNING id AS newid )UPDATE parent SET id = id + newid FROM wcte;
WITH rcte AS ( SELECT max(id) AS maxid FROM parent )DELETE FROM parent USING rcte WHERE id = maxid;
WITH wcte AS ( INSERT INTO child2 VALUES ( 42, 'new2' ) RETURNING id AS newid )DELETE FROM parent USING wcte WHERE id = newid;
EXPLAIN (VERBOSE, COSTS OFF)WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )DELETE FROM a USING wcte WHERE aa = q2;
WITH RECURSIVE t AS (	INSERT INTO y		SELECT * FROM tVALUES(FALSE);
WITH t AS (	INSERT INTO y VALUES(0)SELECT * FROM t;
SELECT * FROM (	WITH t AS (UPDATE y SET a=a+1 RETURNING *)	SELECT * FROM t) ss;
CREATE RULE y_rule AS ON INSERT TO y WHERE a=0 DO INSTEAD DELETE FROM y;
WITH t AS (	INSERT INTO y VALUES(0)VALUES(FALSE);
DROP RULE y_rule ON y;
create table foo (with baz);  -- fail, WITH is a reserved wordcreate table foo (with ordinality);  -- fail, WITH is a reserved wordwith ordinality as (select 1 as x) select * from ordinality;
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_seclabel_user1;
DROP ROLE IF EXISTS regress_seclabel_user2;
RESET client_min_messages;
CREATE USER regress_seclabel_user1 WITH CREATEROLE;
CREATE USER regress_seclabel_user2;
CREATE FUNCTION seclabel_four() RETURNS integer AS $$SELECT 4$$ language sql;
CREATE DOMAIN seclabel_domain AS text;
ALTER TABLE seclabel_tbl1 OWNER TO regress_seclabel_user1;
ALTER TABLE seclabel_tbl2 OWNER TO regress_seclabel_user2;
SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';			-- failSECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'classified';		-- failSECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';		-- failSECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';			-- failSECURITY LABEL ON ROLE regress_seclabel_user1 IS 'classified';			-- failSECURITY LABEL FOR 'dummy' ON ROLE regress_seclabel_user1 IS 'classified';		-- failSECURITY LABEL ON ROLE regress_seclabel_user1 IS '...invalid label...';		-- failSECURITY LABEL ON ROLE regress_seclabel_user3 IS 'unclassified';			-- failDROP FUNCTION seclabel_four();
DROP DOMAIN seclabel_domain;
DROP USER regress_seclabel_user1;
DROP USER regress_seclabel_user2;
CREATE FUNCTION rngfunct(int) returns setof rngfunc2 as 'SELECT * FROM rngfunc2 WHERE rngfuncid = $1 ORDER BY f2;' LANGUAGE SQL;
select * from rngfunct(1) with ordinality as z(a,b,ord);
select * from rngfunct(1) with ordinality as z(a,b,ord) where b > 100;   -- ordinal 2, not 1select a,b,ord from rngfunct(1) with ordinality as z(a,b,ord);
select a,ord from unnest(array['a','b']) with ordinality as z(a,ord);
select * from unnest(array['a','b']) with ordinality as z(a,ord);
::select a,ord from unnest(array[1.0::float8]) with ordinality as z(a,ord);
::select * from unnest(array[1.0::float8]) with ordinality as z(a,ord);
select row_to_json(s.*) from generate_series(11,14) with ordinality s;
create temporary view vw_ord as select * from (values (1)) v(n) join rngfunct(1) with ordinality as z(a,b,ord) on (n=ord);
select * from rows from(rngfunct(1),rngfunct(2)) with ordinality as z(a,b,c,d,ord);
create temporary view vw_ord as select * from (values (1)) v(n) join rows from(rngfunct(1),rngfunct(2)) with ordinality as z(a,b,c,d,ord) on (n=ord);
select * from unnest(array[10,20],array['foo','bar'],array[1.0]) with ordinality as z(a,b,c,ord);
select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
create temporary view vw_ord as select * from unnest(array[10,20],array['foo','bar'],array[1.0]) as z(a,b,c);
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
begin;
declare rf_cur scroll cursor for select * from rows from(generate_series(1,5),generate_series(1,2)) with ordinality as g(i,j,o);
fetch all from rf_cur;
fetch backward all from rf_cur;
fetch all from rf_cur;
fetch next from rf_cur;
fetch next from rf_cur;
fetch prior from rf_cur;
fetch absolute 1 from rf_cur;
fetch next from rf_cur;
fetch next from rf_cur;
fetch next from rf_cur;
fetch prior from rf_cur;
fetch prior from rf_cur;
fetch prior from rf_cur;
commit;
select * from rngfunc2, rngfunct(rngfunc2.rngfuncid) z where rngfunc2.f2 = z.f2;
select * from rngfunc2, rngfunct(rngfunc2.rngfuncid) with ordinality as z(rngfuncid,f2,ord) where rngfunc2.f2 = z.f2;
select * from rngfunc2 where f2 in (select f2 from rngfunct(rngfunc2.rngfuncid) z where z.rngfuncid = rngfunc2.rngfuncid) ORDER BY 1,2;
select * from rngfunc2 where f2 in (select f2 from rngfunct(1) z where z.rngfuncid = rngfunc2.rngfuncid) ORDER BY 1,2;
select * from rngfunc2 where f2 in (select f2 from rngfunct(rngfunc2.rngfuncid) z where z.rngfuncid = 1) ORDER BY 1,2;
select rngfunct.rngfuncid, rngfunct.f2 from rngfunct(sin(pi()/2)::int) ORDER BY 1,2;
CREATE TABLE rngfunc (rngfuncid int, rngfuncsubid int, rngfuncname text, primary key(rngfuncid,rngfuncsubid));
CREATE FUNCTION getrngfunc1(int) RETURNS int AS 'SELECT $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc1(1) WITH ORDINALITY AS t1(v,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc1(1) WITH ORDINALITY as t1(v,o);
CREATE FUNCTION getrngfunc2(int) RETURNS setof int AS 'SELECT rngfuncid FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc2(1) WITH ORDINALITY AS t1(v,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc2(1) WITH ORDINALITY AS t1(v,o);
CREATE FUNCTION getrngfunc3(int) RETURNS setof text AS 'SELECT rngfuncname FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc3(1) WITH ORDINALITY AS t1(v,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc3(1) WITH ORDINALITY AS t1(v,o);
CREATE FUNCTION getrngfunc4(int) RETURNS rngfunc AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc4(1) WITH ORDINALITY AS t1(a,b,c,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc4(1) WITH ORDINALITY AS t1(a,b,c,o);
CREATE FUNCTION getrngfunc5(int) RETURNS setof rngfunc AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc5(1) WITH ORDINALITY AS t1(a,b,c,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc5(1) WITH ORDINALITY AS t1(a,b,c,o);
CREATE FUNCTION getrngfunc6(int) RETURNS RECORD AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc6(1) AS t1(rngfuncid int, rngfuncsubid int, rngfuncname text);
SELECT * FROM ROWS FROM( getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) ) WITH ORDINALITY;
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc6(1) AS(rngfuncid int, rngfuncsubid int, rngfuncname text);
CREATE VIEW vw_getrngfunc AS  SELECT * FROM ROWS FROM( getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) )                WITH ORDINALITY;
CREATE FUNCTION getrngfunc7(int) RETURNS setof record AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
SELECT * FROM getrngfunc7(1) AS t1(rngfuncid int, rngfuncsubid int, rngfuncname text);
SELECT * FROM ROWS FROM( getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) ) WITH ORDINALITY;
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc7(1) AS(rngfuncid int, rngfuncsubid int, rngfuncname text);
CREATE VIEW vw_getrngfunc AS  SELECT * FROM ROWS FROM( getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) )                WITH ORDINALITY;
CREATE FUNCTION getrngfunc8(int) RETURNS int AS 'DECLARE rngfuncint int; BEGIN SELECT rngfuncid into rngfuncint FROM rngfunc WHERE rngfuncid = $1; RETURN rngfuncint; END;' LANGUAGE plpgsql;
SELECT * FROM getrngfunc8(1) WITH ORDINALITY AS t1(v,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc8(1) WITH ORDINALITY AS t1(v,o);
CREATE FUNCTION getrngfunc9(int) RETURNS rngfunc AS 'DECLARE rngfunctup rngfunc%ROWTYPE; BEGIN SELECT * into rngfunctup FROM rngfunc WHERE rngfuncid = $1; RETURN rngfunctup; END;' LANGUAGE plpgsql;
SELECT * FROM getrngfunc9(1) WITH ORDINALITY AS t1(a,b,c,o);
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc9(1) WITH ORDINALITY AS t1(a,b,c,o);
select * from rows from(getrngfunc1(1),getrngfunc2(1),getrngfunc3(1),getrngfunc4(1),getrngfunc5(1),                    getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                    getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                    getrngfunc8(1),getrngfunc9(1))              with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
select * from rows from(getrngfunc9(1),getrngfunc8(1),                    getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                    getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                    getrngfunc5(1),getrngfunc4(1),getrngfunc3(1),getrngfunc2(1),getrngfunc1(1))              with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
create temporary view vw_rngfunc as  select * from rows from(getrngfunc9(1),                      getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                      getrngfunc1(1))                with ordinality as t1(a,b,c,d,e,f,g,n);
DROP FUNCTION getrngfunc1(int);
DROP FUNCTION getrngfunc2(int);
DROP FUNCTION getrngfunc3(int);
DROP FUNCTION getrngfunc4(int);
DROP FUNCTION getrngfunc5(int);
DROP FUNCTION getrngfunc6(int);
DROP FUNCTION getrngfunc7(int);
DROP FUNCTION getrngfunc8(int);
DROP FUNCTION getrngfunc9(int);
DROP FUNCTION rngfunct(int);
CREATE TEMPORARY SEQUENCE rngfunc_rescan_seq1;
CREATE TEMPORARY SEQUENCE rngfunc_rescan_seq2;
CREATE TYPE rngfunc_rescan_t AS (i integer, s bigint);
CREATE FUNCTION rngfunc_sql(int,int) RETURNS setof rngfunc_rescan_t AS 'SELECT i, nextval(''rngfunc_rescan_seq1'') FROM generate_series($1,$2) i;' LANGUAGE SQL;
CREATE FUNCTION rngfunc_mat(int,int) RETURNS setof rngfunc_rescan_t AS 'begin for i in $1..$2 loop return next (i, nextval(''rngfunc_rescan_seq2'')); end loop; end;' LANGUAGE plpgsql;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_sql(11,13) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_sql(11,13) WITH ORDINALITY AS f(i,s,o) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_mat(11,13) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_mat(11,13) WITH ORDINALITY AS f(i,s,o) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN ROWS FROM( rngfunc_sql(11,13), rngfunc_mat(11,13) ) WITH ORDINALITY AS f(i1,s1,i2,s2,o) ON (r+i1+i2)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN generate_series(11,13) f(i) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN generate_series(11,13) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) f(i) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(10+r,13);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(10+r,13) WITH ORDINALITY AS f(i,s,o);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(11,10+r);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(11,10+r) WITH ORDINALITY AS f(i,s,o);
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_sql(r1,r2);
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_sql(r1,r2) WITH ORDINALITY AS f(i,s,o);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(10+r,13);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(10+r,13) WITH ORDINALITY AS f(i,s,o);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(11,10+r);
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(11,10+r) WITH ORDINALITY AS f(i,s,o);
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_mat(r1,r2);
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_mat(r1,r2) WITH ORDINALITY AS f(i,s,o);
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(11,11), rngfunc_mat(10+r,13) );
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(10+r,13), rngfunc_mat(11,11) );
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(10+r,13), rngfunc_mat(10+r,13) );
SELECT * FROM generate_series(1,2) r1, generate_series(r1,3) r2, ROWS FROM( rngfunc_sql(10+r1,13), rngfunc_mat(10+r2,13) );
SELECT * FROM (VALUES (1),(2),(3)) v(r), generate_series(10+r,20-r) f(i);
SELECT * FROM (VALUES (1),(2),(3)) v(r), generate_series(10+r,20-r) WITH ORDINALITY AS f(i,o);
SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) f(i);
SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) WITH ORDINALITY AS f(i,o);
SELECT * FROM (VALUES (1),(2),(3)) v1(r1),              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)                                         LEFT JOIN generate_series(21,23) f(i) ON ((r2+i)<100) OFFSET 0) s1;
SELECT * FROM (VALUES (1),(2),(3)) v1(r1),              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)                                         LEFT JOIN generate_series(20+r1,23) f(i) ON ((r2+i)<100) OFFSET 0) s1;
SELECT * FROM (VALUES (1),(2),(3)) v1(r1),              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)                                         LEFT JOIN generate_series(r2,r2+3) f(i) ON ((r2+i)<100) OFFSET 0) s1;
SELECT * FROM (VALUES (1),(2),(3)) v1(r1),              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)                                         LEFT JOIN generate_series(r1,2+r2/5) f(i) ON ((r2+i)<100) OFFSET 0) s1;
SELECT *FROM (VALUES (1),(2)) v1(r1)    LEFT JOIN LATERAL (        SELECT *        FROM generate_series(1, v1.r1) AS gs1        LEFT JOIN LATERAL (            SELECT *            FROM generate_series(1, gs1) AS gs2            LEFT JOIN generate_series(1, gs2) AS gs3 ON TRUE        ) AS ss1 ON TRUE        FULL JOIN generate_series(1, v1.r1) AS gs4 ON FALSE    ) AS ss0 ON TRUE;
DROP FUNCTION rngfunc_sql(int,int);
DROP FUNCTION rngfunc_mat(int,int);
DROP SEQUENCE rngfunc_rescan_seq1;
DROP SEQUENCE rngfunc_rescan_seq2;
CREATE FUNCTION rngfunc(in f1 int, out f2 int)AS 'select $1+1' LANGUAGE sql;
SELECT * FROM rngfunc(42) AS p(x);
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int) RETURNS intAS 'select $1+1' LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int) RETURNS floatAS 'select $1+1' LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int, out f3 text) RETURNS intAS 'select $1+1' LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int, out f3 text)RETURNS recordAS 'select $1+1' LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfuncr(in f1 int, out f2 int, out text)AS $$select $1-1, $1::text || 'z'$$ LANGUAGE sql;
SELECT * FROM rngfuncr(42) AS p(a,b);
CREATE OR REPLACE FUNCTION rngfuncb(in f1 int, inout f2 int, out text)AS $$select $2-1, $1::text || 'z'$$ LANGUAGE sql;
SELECT * FROM rngfuncb(42, 99) AS p(a,b);
DROP FUNCTION rngfunc(int);
DROP FUNCTION rngfuncr(in f2 int, out f1 int, out text);
DROP FUNCTION rngfuncb(in f1 int, inout f2 int);
CREATE FUNCTION dup (f1 anyelement, f2 out anyelement, f3 out anyarray)AS 'select $1, array[$1,$1]' LANGUAGE sql;
SELECT dup('xyz');	-- failsSELECT dup('xyz'::text);
::SELECT * FROM dup('xyz'::text);
CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)AS 'select $1, array[$1,$1]' LANGUAGE sql;
DROP FUNCTION dup(anyelement);
CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)AS 'select $1, array[$1,$1]' LANGUAGE sql;
DROP FUNCTION dup(anyelement);
CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)AS 'select $1, array[$1,$1]' LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfunc()RETURNS TABLE(a int)AS $$ SELECT a FROM generate_series(1,5) a(a) $$ LANGUAGE sql;
SELECT * FROM rngfunc();
DROP FUNCTION rngfunc();
CREATE OR REPLACE FUNCTION rngfunc(int)RETURNS TABLE(a int, b int)AS $$ SELECT a, b         FROM generate_series(1,$1) a(a),              generate_series(1,$1) b(b) $$ LANGUAGE sql;
DROP FUNCTION rngfunc(int);
CREATE OR REPLACE FUNCTION rngfunc()RETURNS TABLE(a varchar(5))AS $$ SELECT 'hello'::varchar(5) $$ LANGUAGE sql STABLE;
SELECT * FROM rngfunc() GROUP BY 1;
DROP FUNCTION rngfunc();
create temp table tt(f1 serial, data text);
create function insert_tt(text) returns int as$$ insert into tt(data) values($1) returning f1 $$language sql;
create or replace function insert_tt(text) returns int as$$ insert into tt(data) values($1),($1||$1) returning f1 $$language sql;
create or replace function insert_tt2(text,text) returns setof int as$$ insert into tt(data) values($1),($2) returning f1 $$language sql;
create function noticetrigger() returns trigger as $$begin  raise notice 'noticetrigger % %', new.f1, new.data;
  return null;
end $$ language plpgsql;
create trigger tnoticetrigger after insert on tt for each rowexecute procedure noticetrigger();
create rule insert_tt_rule as on insert to tt do also  insert into tt_log values(new.*);
create function rngfunc1(n integer, out a text, out b text)  returns setof record  language sql  as $$ select 'foo ' || i, 'bar ' || i from generate_series(1,$1) i $$;
set work_mem='64kB';
select t.a, t, t.a from rngfunc1(10000) t limit 1;
reset work_mem;
select t.a, t, t.a from rngfunc1(10000) t limit 1;
drop function rngfunc1(n integer);
create function array_to_set(anyarray) returns setof record as $$  select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i$$ language sql strict immutable;
select * from array_to_set(array['one', 'two']) as t(f1 int,f2 text);
select * from array_to_set(array['one', 'two']); -- failcreate temp table rngfunc(f1 int8, f2 int8);
create function testrngfunc() returns record as $$  insert into rngfunc values (1,2) returning *;
$$ language sql;
select * from testrngfunc() as t(f1 int8,f2 int8);
select * from testrngfunc(); -- faildrop function testrngfunc();
create function testrngfunc() returns setof record as $$  insert into rngfunc values (1,2), (3,4) returning *;
$$ language sql;
select * from testrngfunc() as t(f1 int8,f2 int8);
select * from testrngfunc(); -- faildrop function testrngfunc();
create temp table users (userid text, seq int, email text, todrop bool, moredrop int, enabled bool);
alter table users drop column todrop;
create or replace function get_first_user() returns users as$$ SELECT * FROM users ORDER BY userid LIMIT 1; $$language sql stable;
SELECT * FROM get_first_user();
create or replace function get_users() returns setof users as$$ SELECT * FROM users ORDER BY userid; $$language sql stable;
SELECT * FROM get_users();
SELECT * FROM get_users() WITH ORDINALITY;   -- make sure ordinality copesSELECT * FROM ROWS FROM(generate_series(10,11), get_users()) WITH ORDINALITY;
SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
create temp view usersview asSELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
begin;
alter table users drop column moredrop;
select * from usersview;  -- expect clean failurerollback;
alter table users alter column seq type numeric;
select * from usersview;  -- expect clean failuredrop view usersview;
drop function get_first_user();
drop function get_users();
create or replace function rngfuncbar() returns setof text as$$ select 'foo'::varchar union all select 'bar'::varchar ; $$language sql stable;
select * from rngfuncbar();
drop function rngfuncbar();
create or replace function rngfuncbar(out integer, out numeric) as$$ select (1, 2.1) $$ language sql;
select * from rngfuncbar();
create or replace function rngfuncbar(out integer, out numeric) as$$ select (1, 2) $$ language sql;
select * from rngfuncbar();  -- failcreate or replace function rngfuncbar(out integer, out numeric) as$$ select (1, 2.1, 3) $$ language sql;
select * from rngfuncbar();  -- faildrop function rngfuncbar();
create function extractq2(t int8_tbl) returns int8 as $$  select t.q2$$ language sql immutable;
explain (verbose, costs off)select x from int8_tbl, extractq2(int8_tbl) f(x);
select x from int8_tbl, extractq2(int8_tbl) f(x);
create function extractq2_2(t int8_tbl) returns table(ret1 int8) as $$  select extractq2(t) offset 0$$ language sql immutable;
explain (verbose, costs off)select x from int8_tbl, extractq2_2(int8_tbl) f(x);
select x from int8_tbl, extractq2_2(int8_tbl) f(x);
create function extractq2_2_opt(t int8_tbl) returns table(ret1 int8) as $$  select extractq2(t)$$ language sql immutable;
explain (verbose, costs off)select x from int8_tbl, extractq2_2_opt(int8_tbl) f(x);
select x from int8_tbl, extractq2_2_opt(int8_tbl) f(x);
create type rngfunc2 as (a integer, b text);
::select *, row_to_json(u) from unnest(array[(1,'foo')::rngfunc2, null::rngfunc2]) u;
select *, row_to_json(u) from unnest(array[null::rngfunc2, null::rngfunc2]) u;
select *, row_to_json(u) from unnest(array[null::rngfunc2, (1,'foo')::rngfunc2, null::rngfunc2]) u;
select *, row_to_json(u) from unnest(array[]::rngfunc2[]) u;
drop type rngfunc2;
CREATE FUNCTION stfp(anyarray) RETURNS anyarray AS'select $1' LANGUAGE SQL;
CREATE FUNCTION stfnp(int[]) RETURNS int[] AS'select $1' LANGUAGE SQL;
CREATE FUNCTION tfp(anyarray,anyelement) RETURNS anyarray AS'select $1 || $2' LANGUAGE SQL;
CREATE FUNCTION tfnp(int[],int) RETURNS int[] AS'select $1 || $2' LANGUAGE SQL;
CREATE FUNCTION tf1p(anyarray,int) RETURNS anyarray AS'select $1' LANGUAGE SQL;
CREATE FUNCTION tf2p(int[],anyelement) RETURNS int[] AS'select $1' LANGUAGE SQL;
CREATE FUNCTION sum3(anyelement,anyelement,anyelement) returns anyelement AS'select $1+$2+$3' language sql strict;
CREATE FUNCTION ffp(anyarray) RETURNS anyarray AS'select $1' LANGUAGE SQL;
CREATE FUNCTION ffnp(int[]) returns int[] as'select $1' LANGUAGE SQL;
CREATE AGGREGATE myaggp01a(*) (SFUNC = stfnp, STYPE = int4[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp03a(*) (SFUNC = stfp, STYPE = int4[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp03b(*) (SFUNC = stfp, STYPE = int4[],  INITCOND = '{}');
CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,  INITCOND = '{}');
CREATE AGGREGATE myaggp05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp09b(BASETYPE = int, SFUNC = tf1p, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggp10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp10b(BASETYPE = int, SFUNC = tfp, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggp11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp11b(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggp12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp12b(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp15a(BASETYPE = anyelement, SFUNC = tfnp,  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp16a(BASETYPE = anyelement, SFUNC = tf2p,  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,  INITCOND = '{}');
CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,  INITCOND = '{}');
CREATE AGGREGATE myaggp19a(BASETYPE = anyelement, SFUNC = tf1p,  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp19b(BASETYPE = anyelement, SFUNC = tf1p,  STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggp20a(BASETYPE = anyelement, SFUNC = tfp,  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp20b(BASETYPE = anyelement, SFUNC = tfp,  STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggn01a(*) (SFUNC = stfnp, STYPE = int4[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn01b(*) (SFUNC = stfnp, STYPE = int4[],  INITCOND = '{}');
CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,  INITCOND = '{}');
CREATE AGGREGATE myaggn03a(*) (SFUNC = stfp, STYPE = int4[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn05b(BASETYPE = int, SFUNC = tfnp, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggn06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn06b(BASETYPE = int, SFUNC = tf2p, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggn07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn07b(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggn08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn08b(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],  INITCOND = '{}');
CREATE AGGREGATE myaggn09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,  INITCOND = '{}');
CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,  INITCOND = '{}');
CREATE AGGREGATE myaggn15a(BASETYPE = anyelement, SFUNC = tfnp,  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn15b(BASETYPE = anyelement, SFUNC = tfnp,  STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggn16a(BASETYPE = anyelement, SFUNC = tf2p,  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn16b(BASETYPE = anyelement, SFUNC = tf2p,  STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn19a(BASETYPE = anyelement, SFUNC = tf1p,  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn20a(BASETYPE = anyelement, SFUNC = tfp,  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE mysum2(anyelement,anyelement) (SFUNC = sum3,  STYPE = anyelement, INITCOND = '0');
create temp table t(f1 int, f2 int[], f3 text);
create function bleat(int) returns int as $$begin  raise notice 'bleat %', $1;
  return $1;
end$$ language plpgsql;
create function sql_if(bool, anyelement, anyelement) returns anyelement as $$select case when $1 then $2 else $3 end $$ language sql;
CREATE AGGREGATE array_cat_accum (anyarray)    sfunc = array_cat,    stype = anyarray,    initcond = '{}');
SELECT array_cat_accum(i)FROM (VALUES (ARRAY[1,2]), (ARRAY[3,4])) as t(i);
SELECT array_cat_accum(i)FROM (VALUES (ARRAY[row(1,2),row(3,4)]), (ARRAY[row(5,6),row(7,8)])) as t(i);
create function add_group(grp anyarray, ad anyelement, size integer)  returns anyarray  as $$begin  if grp is null then    return array[ad];
  end if;
  if array_upper(grp, 1) < size then    return grp || ad;
  end if;
  return grp;
end;
$$  language plpgsql immutable;
create aggregate build_group(anyelement, integer) (  SFUNC = add_group,  STYPE = anyarray);
create aggregate build_group(int8, integer) (  SFUNC = add_group,  STYPE = int2[]);
create aggregate build_group(int8, integer) (  SFUNC = add_group,  STYPE = int8[]);
create function first_el(anyarray) returns anyelement as'select $1[1]' language sql strict immutable;
create aggregate first_el_agg_f8(float8) (  SFUNC = array_append,  STYPE = float8[],  FINALFUNC = first_el);
create aggregate first_el_agg_any(anyelement) (  SFUNC = array_append,  STYPE = anyarray,  FINALFUNC = first_el);
::::select distinct array_ndims(histogram_bounds) from pg_statswhere histogram_bounds is not null;
create function myleast(variadic anyarray) returns anyelement as $$  select min($1[i]) from generate_subscripts($1,1) g(i)$$ language sql immutable strict;
::select myleast('z'::text);
select myleast(); -- failselect myleast(variadic array[1,2,3,4,-1]);
select myleast(variadic array[1.1, -5.5]);
select myleast(variadic array[]::int[]);
create function concat(text, variadic anyarray) returns text as $$  select array_to_string($2, $1);
$$ language sql immutable strict;
::select concat('|', 'a'::text, 'b', 'c');
select concat('|', variadic array[1,2,33]);
select concat('|', variadic array[]::int[]);
drop function concat(text, anyarray);
create function formarray(anyelement, variadic anyarray) returns anyarray as $$  select array_prepend($1, $2);
$$ language sql immutable strict;
select formarray(1.1, variadic array[1.2,55.5]);
select formarray(1.1, array[1.2,55.5]); -- fail without variadicselect formarray(1, 'x'::text); -- fail, type mismatchselect formarray(1, variadic array['x'::text]); -- fail, type mismatchdrop function formarray(anyelement, variadic anyarray);
select pg_typeof(null);           -- unknownselect pg_typeof(0);              -- integerselect pg_typeof(0.0);            -- numericselect pg_typeof(1+1 = 2);        -- booleanselect pg_typeof('x');            -- unknownselect pg_typeof('' || '');       -- textselect pg_typeof(pg_typeof(0));   -- regtypeselect pg_typeof(array[1.2,55.5]); -- numeric[]select pg_typeof(myleast(10, 1, 20, 33));  -- polymorphic inputcreate function dfunc(a int = 1, int = 2) returns int as $$  select $1 + $2;
$$ language sql;
select dfunc(10, 20, 30);  -- faildrop function dfunc();  -- faildrop function dfunc(int);  -- faildrop function dfunc(int, int);  -- okcreate function dfunc(a int = 1, b int) returns int as $$  select $1 + $2;
$$ language sql;
create function dfunc(a int = 1, out sum int, b int = 2) as $$  select $1 + $2;
$$ language sql;
drop function dfunc(int, int);
create function dfunc(a int DEFAULT 1.0, int DEFAULT '-1') returns int as $$  select $1 + $2;
$$ language sql;
create function dfunc(a text DEFAULT 'Hello', b text DEFAULT 'World') returns text as $$  select $1 || ', ' || $2;
$$ language sql;
select dfunc();  -- fail: which dfunc should be called? int or textselect dfunc('Hi');  -- okselect dfunc('Hi', 'City');  -- okselect dfunc(0);  -- okselect dfunc(10, 20);  -- okdrop function dfunc(int, int);
drop function dfunc(text, text);
create function dfunc(int = 1, int = 2) returns int as $$  select 2;
$$ language sql;
create function dfunc(int = 1, int = 2, int = 3, int = 4) returns int as $$  select 4;
$$ language sql;
select dfunc();  -- failselect dfunc(1);  -- failselect dfunc(1, 2);  -- failselect dfunc(1, 2, 3);  -- okselect dfunc(1, 2, 3, 4);  -- okdrop function dfunc(int, int);
drop function dfunc(int, int, int, int);
create function dfunc(out int = 20) returns int as $$  select 1;
$$ language sql;
create function dfunc(anyelement = 'World'::text) returns text as $$  select 'Hello, ' || $1::text;
$$ language sql;
::select dfunc('City'::text);
drop function dfunc(anyelement);
create function dfunc(a variadic int[]) returns int as$$ select array_upper($1, 1) $$ language sql;
select dfunc();  -- failselect dfunc(10);
create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as$$ select array_upper($1, 1) $$ language sql;
select dfunc();  -- now okselect dfunc(10);
create or replace function dfunc(a variadic int[]) returns int as$$ select array_upper($1, 1) $$ language sql;
drop function dfunc(a variadic int[]);
create function dfunc(int = 1, int = 2, int = 3) returns int as $$  select 3;
$$ language sql;
create function dfunc(int = 1, int = 2) returns int as $$  select 2;
$$ language sql;
create function dfunc(text) returns text as $$  select $1;
$$ language sql;
select dfunc(1);  -- failselect dfunc('Hi');
drop function dfunc(int, int, int);
drop function dfunc(int, int);
drop function dfunc(text);
create function dfunc(a int, b int, c int = 0, d int = 0)  returns table (a int, b int, c int, d int) as $$  select $1, $2, $3, $4;
$$ language sql;
select (dfunc(10,20,30)).*;
:::select (dfunc(a := 10, b := 20, c := 30)).*;
::::select * from dfunc(0);  -- failselect * from dfunc(1,2);
:::::select * from dfunc(x := 20, b := 10, x := 30);  -- fail, duplicate nameselect * from dfunc(10, b := 20, 30);  -- fail, named args must be lastselect * from dfunc(x := 10, b := 20, c := 30);  -- fail, unknown paramselect * from dfunc(10, 10, a := 20);  -- fail, a overlaps positional parameterselect * from dfunc(1,c := 2,d := 3); -- fail, no value for bdrop function dfunc(int, int, int, int);
create function dfunc(a varchar, b numeric, c date = current_date)  returns table (a varchar, b numeric, c date) as $$  select $1, $2, $3;
$$ language sql;
::select (dfunc('Hello World', 20, '2009-07-25'::date)).*;
:::::::::::::::::::select * from dfunc('Hello World', c := 20, b := '2009-07-25'::date);  -- faildrop function dfunc(varchar, numeric, date);
create function dfunc(a varchar = 'def a', out _a varchar, c numeric = NULL, out _c numeric)returns record as $$  select $1, $2;
$$ language sql;
select (dfunc()).*;
select * from dfunc();
::::::create or replace function dfunc(a varchar = 'def a', out _a varchar, x numeric = NULL, out _c numeric)returns record as $$  select $1, $2;
$$ language sql;
create or replace function dfunc(a varchar = 'def a', out _a varchar, numeric = NULL, out _c numeric)returns record as $$  select $1, $2;
$$ language sql;
drop function dfunc(varchar, numeric);
create function testpolym(a int, a int) returns int as $$ select 1;$$ language sql;
create function testpolym(int, out a int, out a int) returns int as $$ select 1;$$ language sql;
create function testpolym(out a int, inout a int) returns int as $$ select 1;$$ language sql;
create function testpolym(a int, inout a int) returns int as $$ select 1;$$ language sql;
create function testpolym(a int, out a int) returns int as $$ select $1;$$ language sql;
drop function testpolym(int);
create function testpolym(a int) returns table(a int) as $$ select $1;$$ language sql;
drop function testpolym(int);
create function dfunc(a anyelement, b anyelement = null, flag bool = true)returns anyelement as $$  select case when $3 then $1 else $2 end;
$$ language sql;
::select dfunc('a'::text, 'b'); -- positional notation with defaultselect dfunc(a := 1, b := 2);
:::select dfunc(a := 'a'::text, b := 'b');
:::select dfunc(a := 'a'::text, b := 'b', flag := false); -- named notationselect dfunc(b := 'b'::text, a := 'a'); -- named notation with defaultselect dfunc(a := 'a'::text, flag := true); -- named notation with defaultselect dfunc(a := 'a'::text, flag := false); -- named notation with defaultselect dfunc(b := 'b'::text, a := 'a', flag := true); -- named notationselect dfunc('a'::text, 'b', false); -- full positional notationselect dfunc('a'::text, 'b', flag := false); -- mixed notationselect dfunc('a'::text, 'b', true); -- full positional notationselect dfunc('a'::text, 'b', flag := true); -- mixed notationselect dfunc(a => 1, b => 2);
select dfunc(a => 'a'::text, b => 'b');
select dfunc(a => 'a'::text, b => 'b', flag => false); -- named notationselect dfunc(b => 'b'::text, a => 'a'); -- named notation with defaultselect dfunc(a => 'a'::text, flag => true); -- named notation with defaultselect dfunc(a => 'a'::text, flag => false); -- named notation with defaultselect dfunc(b => 'b'::text, a => 'a', flag => true); -- named notationselect dfunc('a'::text, 'b', false); -- full positional notationselect dfunc('a'::text, 'b', flag => false); -- mixed notationselect dfunc('a'::text, 'b', true); -- full positional notationselect dfunc('a'::text, 'b', flag => true); -- mixed notationselect dfunc(a =>-1);
select dfunc(a =>+1);
select dfunc(a =>/**/1);
select dfunc(a =>--comment to be removed by psql  1);
do $$  declare r integer;
  begin    select dfunc(a=>-- comment      1) into r;
    raise info 'r = %', r;
  end;
$$;
:::drop function dfunc(anyelement, anyelement, bool);
::SELECT '""'::jsonb;				-- OK.SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowedSELECT '"abc"'::jsonb;			-- OKSELECT '"abc'::jsonb;			-- ERROR, quotes not closedSELECT '"abcdef"'::jsonb;					-- ERROR, unescaped newline in string constantSELECT '"\n\"\\"'::jsonb;		-- OK, legal escapesSELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escapeSELECT '1'::jsonb;				-- OKSELECT '0'::jsonb;				-- OKSELECT '01'::jsonb;				-- ERROR, not valid according to JSON specSELECT '0.1'::jsonb;				-- OKSELECT '9223372036854775808'::jsonb;	-- OK, even though it's too large for int8SELECT '1e100'::jsonb;			-- OKSELECT '1.3e100'::jsonb;			-- OKSELECT '1f2'::jsonb;				-- ERRORSELECT '0.x1'::jsonb;			-- ERRORSELECT '1.3ex100'::jsonb;		-- ERRORSELECT '[]'::jsonb;				-- OKSELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::jsonb;  -- OKSELECT '[1,2]'::jsonb;			-- OKSELECT '[1,2,]'::jsonb;			-- ERROR, trailing commaSELECT '[1,2'::jsonb;			-- ERROR, no closing bracketSELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracketSELECT '{}'::jsonb;				-- OKSELECT '{"abc"}'::jsonb;			-- ERROR, no valueSELECT '{"abc":1}'::jsonb;		-- OKSELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be stringsSELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separatorSELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separatorSELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separatorSELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::jsonb; -- OKSELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spotSELECT '{"abc":1,3}'::jsonb;		-- ERROR, no valueSET max_stack_depth = '100kB';
::::RESET max_stack_depth;
::SELECT 'true'::jsonb;			-- OKSELECT 'false'::jsonb;			-- OKSELECT 'null'::jsonb;			-- OKSELECT ' true '::jsonb;			-- OK, even with extra whitespaceSELECT 'true false'::jsonb;		-- ERROR, too many valuesSELECT 'true, false'::jsonb;		-- ERROR, too many valuesSELECT 'truf'::jsonb;			-- ERROR, not a keywordSELECT 'trues'::jsonb;			-- ERROR, not a keywordSELECT ''::jsonb;				-- ERROR, no valueSELECT '    '::jsonb;			-- ERROR, no valueSELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
CREATE TEMP TABLE rows ASSELECT x, 'txt' || x as yFROM generate_series(1,3) AS x;
analyze rows;
select attname, to_jsonb(histogram_bounds) histogram_boundsfrom pg_statswhere tablename = 'rows' and      schemaname = pg_my_temp_schema()::regnamespace::textorder by 1;
select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
BEGIN;
SET LOCAL TIME ZONE 10.5;
select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
SET LOCAL TIME ZONE -8;
select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
COMMIT;
select to_jsonb(date '2014-05-28');
select to_jsonb(date 'Infinity');
select to_jsonb(date '-Infinity');
select to_jsonb(timestamp 'Infinity');
select to_jsonb(timestamp '-Infinity');
select to_jsonb(timestamptz 'Infinity');
select to_jsonb(timestamptz '-Infinity');
SELECT jsonb_agg(q)  FROM ( SELECT $$a$$ || x AS b, y AS c,               ARRAY[ROW(x.*,ARRAY[1,2,3]),               ROW(y.*,ARRAY[4,5,6])] AS z         FROM generate_series(1,2) x,              generate_series(4,5) y) q;
SELECT jsonb_agg(q ORDER BY x, y)  FROM rows q;
UPDATE rows SET x = NULL WHERE x = 1;
SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)  FROM rows q;
CREATE TEMP TABLE test_jsonb (       json_type text,       test_json jsonb);
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'scalar';
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'object';
SELECT test_json -> 'field2' FROM test_jsonb WHERE json_type = 'object';
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'scalar';
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'object';
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'scalar';
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'object';
SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
SELECT test_json ->> 'field4' FROM test_jsonb WHERE json_type = 'object';
SELECT test_json ->> 'field5' FROM test_jsonb WHERE json_type = 'object';
SELECT test_json ->> 'field6' FROM test_jsonb WHERE json_type = 'object';
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'scalar';
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'object';
SELECT (test_json->'field3') IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'object';
SELECT (test_json->>'field3') IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'object';
SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::text;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::int;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 1;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 'z';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> '';
::select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 1;
::select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 3;
::select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 'z';
::select '{"a": "c", "b": null}'::jsonb -> 'b';
::select '"foo"'::jsonb -> 1;
::select '"foo"'::jsonb -> 'z';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::text;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::int;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 1;
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 'z';
::select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> '';
::select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 1;
::select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 3;
::select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 'z';
::select '{"a": "c", "b": null}'::jsonb ->> 'b';
::select '"foo"'::jsonb ->> 1;
::select '"foo"'::jsonb ->> 'z';
::SELECT '{"x":"y"}'::jsonb = '{"x":"y"}'::jsonb;
::SELECT '{"x":"y"}'::jsonb = '{"x":"z"}'::jsonb;
::SELECT '{"x":"y"}'::jsonb <> '{"x":"y"}'::jsonb;
::SELECT '{"x":"y"}'::jsonb <> '{"x":"z"}'::jsonb;
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":null}';
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "g":null}';
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"g":null}';
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"c"}';
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
::@SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":"q"}';
::@SELECT '[1,2]'::jsonb @> '[1,2,2]'::jsonb;
::@SELECT '[1,1,2]'::jsonb @> '[1,2,2]'::jsonb;
::@SELECT '[[1,2]]'::jsonb @> '[[1,2,2]]'::jsonb;
::SELECT '[1,2,2]'::jsonb <@ '[1,2]'::jsonb;
::SELECT '[1,2,2]'::jsonb <@ '[1,1,2]'::jsonb;
::SELECT '[[1,2,2]]'::jsonb <@ '[[1,2]]'::jsonb;
::SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::SELECT '{"a":"b", "c":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::SELECT '{"a":"b", "g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::SELECT '{"g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::SELECT '{"a":"c"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::SELECT '{"a":"b", "c":"q"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
::@SELECT '[5]'::jsonb @> '[5]';
::@SELECT '5'::jsonb @> '5';
::@SELECT '[5]'::jsonb @> '5';
::@SELECT '5'::jsonb @> '[5]';
::@SELECT '["9", ["7", "3"], 1]'::jsonb @> '["9", ["7", "3"], 1]'::jsonb;
::@SELECT '["9", ["7", "3"], ["1"]]'::jsonb @> '["9", ["7", "3"], ["1"]]'::jsonb;
::@SELECT '{ "name": "Bob", "tags": [ "enim", "qui"]}'::jsonb @> '{"tags":["qu"]}';
::::::::SELECT jsonb '{"a":null, "b":"qq"}' ? 'a';
SELECT jsonb '{"a":null, "b":"qq"}' ? 'b';
SELECT jsonb '{"a":null, "b":"qq"}' ? 'c';
SELECT jsonb '{"a":"null", "b":"qq"}' ? 'a';
SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
::SELECT jsonb_exists_any('{"a":null, "b":"qq"}', '{}'::text[]);
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['a','b'];
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['b','a'];
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','a'];
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','d'];
SELECT jsonb '{"a":null, "b":"qq"}' ?| '{}'::text[];
::SELECT jsonb_exists_all('{"a":null, "b":"qq"}', '{}'::text[]);
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','b'];
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['b','a'];
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','a'];
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','d'];
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','a', 'b', 'b', 'b'];
SELECT jsonb '{"a":null, "b":"qq"}' ?& '{}'::text[];
SELECT jsonb_typeof('[]') AS array;
SELECT jsonb_typeof('["a", 1]') AS array;
SELECT jsonb_typeof('true') AS boolean;
SELECT jsonb_typeof('false') AS boolean;
SELECT jsonb_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
SELECT jsonb_build_array('a', NULL); -- okSELECT jsonb_build_array(VARIADIC NULL::text[]); -- okSELECT jsonb_build_array(VARIADIC '{}'::text[]); -- okSELECT jsonb_build_array(VARIADIC '{a,b,c}'::text[]); -- okSELECT jsonb_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- okSELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::text[]); -- okSELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::int[]); -- okSELECT jsonb_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- okSELECT jsonb_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
::SELECT jsonb_build_object(       'a', jsonb_build_object('b',false,'c',99),       'd', jsonb_build_object('e',array[9,8,7]::int[],           'f', (select row_to_json(r) from ( select relkind, oid::regclass as name from pg_class where relname = 'pg_class') r)));
::SELECT jsonb_build_object('{a,b,c}'::text[]); -- errorSELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be arraySELECT jsonb_build_object('a', 'b', 'c'); -- errorSELECT jsonb_build_object(NULL, 'a'); -- error, key cannot be NULLSELECT jsonb_build_object('a', NULL); -- okSELECT jsonb_build_object(VARIADIC NULL::text[]); -- okSELECT jsonb_build_object(VARIADIC '{}'::text[]); -- okSELECT jsonb_build_object(VARIADIC '{a,b,c}'::text[]); -- errorSELECT jsonb_build_object(VARIADIC ARRAY['a', NULL]::text[]); -- okSELECT jsonb_build_object(VARIADIC ARRAY[NULL, 'a']::text[]); -- error, key cannot be NULLSELECT jsonb_build_object(VARIADIC '{1,2,3,4}'::text[]); -- okSELECT jsonb_build_object(VARIADIC '{1,2,3,4}'::int[]); -- okSELECT jsonb_build_object(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- okSELECT jsonb_build_array();
SELECT jsonb_build_object(null,2);
SELECT jsonb_build_object(json '{"a":1,"b":2}', 3);
::SELECT jsonb_build_object('{1,2,3}'::int[], 3);
SELECT jsonb_object_agg(1, NULL::jsonb);
SELECT jsonb_object_agg(NULL, '{"a":1}');
INSERT INTO foo VALUES (999999, NULL, 'bar');
::SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
::SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
::SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
::SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
::#SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
::#SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
::#SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
::#SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
::#SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
::#SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
::#SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
::#SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> '{}';
::#select '[1,2,3]'::jsonb #> '{}';
::#select '"foo"'::jsonb #> '{}';
::#select '42'::jsonb #> '{}';
::#select 'null'::jsonb #> '{}';
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
::#select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
::#select '"foo"'::jsonb #> array['z'];
::#select '42'::jsonb #> array['f2'];
::#select '42'::jsonb #> array['0'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
::#select '[1,2,3]'::jsonb #>> '{}';
::#select '"foo"'::jsonb #>> '{}';
::#select '42'::jsonb #>> '{}';
::#select 'null'::jsonb #>> '{}';
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
::#select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
::#select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
::#select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
::#select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
::#select '"foo"'::jsonb #>> array['z'];
::#select '42'::jsonb #>> array['f2'];
::#select '42'::jsonb #>> array['0'];
CREATE TYPE jbpop AS (a text, b int, c timestamp);
CREATE DOMAIN jsb_int_not_null  AS int     NOT NULL;
CREATE DOMAIN jsb_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
CREATE DOMAIN jsb_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
create type jb_unordered_pair as (x int, y int);
create domain jb_ordered_pair as jb_unordered_pair check((value).x <= (value).y);
CREATE TYPE jsbrec AS (	i	int,	ia	_int4,	ia1	int[],	ia2	int[][],	ia3	int[][][],	ia1d	jsb_int_array_1d,	ia2d	jsb_int_array_2d,	t	text,	ta	text[],	c	char(10),	ca	char(10)[],	ts	timestamp,	js	json,	jsb	jsonb,	jsa	json[],	rec	jbpop,	reca	jbpop[]);
CREATE TYPE jsbrec_i_not_null AS (	i	jsb_int_not_null);
SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":[100,200,false],"x":43.2}') q;
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":[100,200,false],"x":43.2}') q;
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"c":[100,200,false],"x":43.2}') q;
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop, '{}') q;
SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"x": 43.2}') q;
SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": null}') q;
SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": 12345}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": null}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": 123}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [1, "2", null, 4]}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1, 2], [3, 4]]}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], 2]}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], [2, 3]]}') q;
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": "{1,2,3}"}') q;
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": null}') q;
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": 123}') q;
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": [1, "2", null, 4]}') q;
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": [[1, 2, 3]]}') q;
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": null}') q;
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": 123}') q;
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null, 4]}') q;
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null]}') q;
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [1, "2", null, 4]}') q;
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [null, 4]]}') q;
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[], []]}') q;
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [3]]}') q;
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], 3, 4]}') q;
SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2"], [null, 4]]}') q;
SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2", 3], [null, 5, 6]]}') q;
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [1, "2", null, 4]}') q;
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [[1, 2], [null, 4]]}') q;
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[], []], [[], []], [[], []] ]}') q;
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2]], [[3, 4]] ]}') q;
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]}') q;
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]] ]}') q;
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": null}') q;
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": 123}') q;
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [1, "2", null, 4]}') q;
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [[1, 2, 3], {"k": "v"}]}') q;
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": null}') q;
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaa"}') q;
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaa"}') q;
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaaaaa"}') q;
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": null}') q;
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": 123}') q;
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [1, "2", null, 4]}') q;
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": ["aaaaaaaaaaaaaaaa"]}') q;
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [[1, 2, 3], {"k": "v"}]}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": null}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": true}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": 123.45}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": "123.45"}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": "abc"}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": [123, "123", null, {"key": "value"}]}') q;
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": {"a": "bbb", "b": null, "c": 123.45}}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": null}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": true}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": 123.45}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": "123.45"}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": "abc"}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": [123, "123", null, {"key": "value"}]}') q;
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": {"a": "bbb", "b": null, "c": 123.45}}') q;
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": null}') q;
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": 123}') q;
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": [1, "2", null, 4]}') q;
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": ["aaa", null, [1, 2, "3", {}], { "k" : "v" }]}') q;
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": 123}') q;
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": [1, 2]}') q;
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}') q;
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": "(abc,42,01.02.2003)"}') q;
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": 123}') q;
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [1, 2]}') q;
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]}') q;
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": ["(abc,42,01.02.2003)"]}') q;
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": "{\"(abc,42,01.02.2003)\"}"}') q;
SELECT rec FROM jsonb_populate_record(	row(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,		row('x',3,'2012-12-31 15:30:56')::jbpop,NULL)::jsbrec,	'{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}') q;
SELECT jsonb_populate_record(null::record, '{"x": 0, "y": 1}');
SELECT jsonb_populate_record(row(1,2), '{"f1": 0, "f2": 1}');
SELECT * FROM  jsonb_populate_record(null::record, '{"x": 776}') AS (x int, y int);
SELECT jsonb_populate_record(null::jb_ordered_pair, '{"x": 0, "y": 1}');
SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 0}');
SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 1, "y": 0}');
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
SELECT jsonb_populate_recordset(null::record, '[{"x": 0, "y": 1}]');
SELECT jsonb_populate_recordset(row(1,2), '[{"f1": 0, "f2": 1}]');
SELECT i, jsonb_populate_recordset(row(i,50), '[{"f1":"42"},{"f2":"43"}]')FROM (VALUES (1),(2)) v(i);
SELECT * FROM  jsonb_populate_recordset(null::record, '[{"x": 776}]') AS (x int, y int);
SELECT jsonb_populate_recordset(null::record, '[]');
SELECT jsonb_populate_recordset(row(1,2), '[]');
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[]') q;
SELECT * FROM  jsonb_populate_recordset(null::record, '[]') AS (x int, y int);
SELECT jsonb_populate_recordset(null::jb_ordered_pair, '[{"x": 0, "y": 1}]');
SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 0}, {"y": 3}]');
SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 1, "y": 0}]');
select * from jsonb_populate_recordset(row(0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
select * from jsonb_populate_recordset(row(0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
select * from jsonb_populate_recordset(row(0::int,0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
select * from jsonb_populate_recordset(row(1000000000::int,50::int),'[{"b":"2"},{"a":"3"}]') q (a text, b text);
select * from jsonb_to_record('{"a":1,"b":"foo","c":"bar"}')    as x(a int, b text, d text);
select * from jsonb_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')    as x(a int, b text, c boolean);
select *, c is null as c_is_nullfrom jsonb_to_record('{"a":1, "b":{"c":16, "d":2}, "x":8, "ca": ["1 2", 3], "ia": [[1,2],[3,4]], "r": {"a": "aaa", "b": 123}}'::jsonb)    as t(a int, b jsonb, c text, x int, ca char(5)[], ia int[][], r jbpop);
select *, c is null as c_is_nullfrom jsonb_to_recordset('[{"a":1, "b":{"c":16, "d":2}, "x":8}]'::jsonb)    as t(a int, b jsonb, c text, x int);
select * from jsonb_to_record('{"ia": null}') as x(ia _int4);
select * from jsonb_to_record('{"ia": 123}') as x(ia _int4);
select * from jsonb_to_record('{"ia": [1, "2", null, 4]}') as x(ia _int4);
select * from jsonb_to_record('{"ia": [[1, 2], [3, 4]]}') as x(ia _int4);
select * from jsonb_to_record('{"ia": [[1], 2]}') as x(ia _int4);
select * from jsonb_to_record('{"ia": [[1], [2, 3]]}') as x(ia _int4);
select * from jsonb_to_record('{"ia2": [1, 2, 3]}') as x(ia2 int[][]);
select * from jsonb_to_record('{"ia2": [[1, 2], [3, 4]]}') as x(ia2 int4[][]);
select * from jsonb_to_record('{"ia2": [[[1], [2], [3]]]}') as x(ia2 int4[][]);
select * from jsonb_to_record('{"out": {"key": 1}}') as x(out json);
select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out json);
select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out json);
select * from jsonb_to_record('{"out": {"key": 1}}') as x(out jsonb);
select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out jsonb);
select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out jsonb);
CREATE TEMP TABLE jsbpoptest (js jsonb);
INSERT INTO jsbpoptestSELECT '{	"jsa": [1, "2", null, 4],	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2},	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]}'::jsonbFROM generate_series(1, 3);
SELECT (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest;
DROP TYPE jsbrec;
DROP TYPE jsbrec_i_not_null;
DROP DOMAIN jsb_int_not_null;
DROP DOMAIN jsb_int_array_1d;
DROP DOMAIN jsb_int_array_2d;
DROP DOMAIN jb_ordered_pair;
DROP TYPE jb_unordered_pair;
@@@@@?SELECT count(*) FROM testjsonb WHERE j ? 'public';
?SELECT count(*) FROM testjsonb WHERE j ? 'bar';
?|SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
?&SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
@@SELECT count(*) FROM testjsonb WHERE j @@ '"CC" == $.wait';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == "CC" && true == $.public';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25.0';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.bar)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) || exists($.disabled)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) && exists($.disabled)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? ("CC" == @)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.wait == "CC" && true == @.public)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.age ? (@ == 25)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.age == 25.0)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.public';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.bar';
CREATE INDEX jidx ON testjsonb USING gin (j);
SET enable_seqscan = off;
@@@@@@@@?SELECT count(*) FROM testjsonb WHERE j ? 'public';
?SELECT count(*) FROM testjsonb WHERE j ? 'bar';
?|SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
?&SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
EXPLAIN (COSTS OFF)SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.wait == null))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.wait ? (@ == null))';
@@SELECT count(*) FROM testjsonb WHERE j @@ '"CC" == $.wait';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == "CC" && true == $.public';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25.0';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "foo"';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "bar"';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.array[*] == "bar"))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array ? (@[*] == "bar"))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array[*] ? (@ == "bar"))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.bar)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) || exists($.disabled)';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) && exists($.disabled)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? ("CC" == @)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.wait == "CC" && true == @.public)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.age ? (@ == 25)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.age == 25.0)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.array[*] == "bar")';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.array ? (@[*] == "bar")';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.array[*] ? (@ == "bar")';
@?SELECT count(*) FROM testjsonb WHERE j @? '$';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.public';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.bar';
CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
RESET enable_seqscan;
SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
SET enable_hashagg = off;
SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
SET enable_hashagg = on;
SET enable_sort = off;
SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
SET enable_sort = on;
RESET enable_hashagg;
RESET enable_sort;
CREATE INDEX jidx ON testjsonb USING btree (j);
SET enable_seqscan = off;
CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
SET enable_seqscan = off;
@@@@@@@@SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.wait == null))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.wait ? (@ == null))';
@@SELECT count(*) FROM testjsonb WHERE j @@ '"CC" == $.wait';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == "CC" && true == $.public';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25.0';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "foo"';
@@SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "bar"';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.array[*] == "bar"))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array ? (@[*] == "bar"))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array[*] ? (@ == "bar"))';
@@SELECT count(*) FROM testjsonb WHERE j @@ 'exists($)';
EXPLAIN (COSTS OFF)SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? ("CC" == @)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.wait == "CC" && true == @.public)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.age ? (@ == 25)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.age == 25.0)';
@?SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.array[*] == "bar")';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.array ? (@[*] == "bar")';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.array[*] ? (@ == "bar")';
@?SELECT count(*) FROM testjsonb WHERE j @? '$';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.public';
@?SELECT count(*) FROM testjsonb WHERE j @? '$.bar';
RESET enable_seqscan;
::::::::::::::SELECT  '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'ff',  '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'qq',  ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'Y') IS NULL AS f,  ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb ->> 'Y') IS NULL AS t,   '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'x';
::@SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1,2]}';
::@SELECT '{"a":[2,1],"c":"b"}'::jsonb @> '{"a":[1,2]}';
::@SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":[1,2]}';
::@SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":[1,2]}';
::@SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
::@SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
::@SELECT '["a","b"]'::jsonb @> '["a","b","c","b"]';
::@SELECT '["a","b","c","b"]'::jsonb @> '["a","b"]';
::@SELECT '["a","b","c",[1,2]]'::jsonb @> '["a",[1,2]]';
::@SELECT '["a","b","c",[1,2]]'::jsonb @> '["b",[1,2]]';
::@SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1]}';
::@SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[2]}';
::@SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[3]}';
::@SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"c":3}]}';
::@SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4}]}';
::@SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},3]}';
::@SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},1]}';
create temp table nestjsonb (j jsonb);
create index on nestjsonb using gin(j jsonb_path_ops);
set enable_seqscan = on;
set enable_bitmapscan = off;
@::select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
@@set enable_seqscan = off;
set enable_bitmapscan = on;
@::select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
@@reset enable_seqscan;
reset enable_bitmapscan;
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'n';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'a';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'b';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'c';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd' -> '1';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'e';
::SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 0; --expecting errorSELECT '["a","b","c",[1,2],null]'::jsonb -> 0;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> 1;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> 2;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> 3;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> 3 -> 1;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> 4;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> 5;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> -1;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> -5;
::SELECT '["a","b","c",[1,2],null]'::jsonb -> -6;
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{0}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-3}';
::#SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-4}';
::#SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
::#SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
::#SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
::#SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
::?SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'n';
::?SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'a';
::?SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'b';
::?SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'c';
::?SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'd';
::?SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'e';
select jsonb_strip_nulls(null);
::||select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{"cq":"l", "b":"g", "fg":false}';
::||select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{"aq":"l"}';
::||select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{"aa":"l"}';
::||select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{}';
::||select '["a", "b"]'::jsonb || '["c"]';
::||select '["a", "b"]'::jsonb || '["c", "d"]';
||select '["c"]' || '["a", "b"]'::jsonb;
::||select '["a", "b"]'::jsonb || '"c"';
||select '"c"' || '["a", "b"]'::jsonb;
::||select '[]'::jsonb || '["a"]'::jsonb;
::||select '[]'::jsonb || '"a"'::jsonb;
::||select '"b"'::jsonb || '"a"'::jsonb;
::||select '{}'::jsonb || '{"a":"b"}'::jsonb;
::||select '[]'::jsonb || '{"a":"b"}'::jsonb;
::||select '{"a":"b"}'::jsonb || '[]'::jsonb;
::||select '"a"'::jsonb || '{"a":1}';
||select '{"a":1}' || '"a"'::jsonb;
::||select '["a", "b"]'::jsonb || '{"c":1}';
::||select '{"c": 1}'::jsonb || '["a", "b"]';
::||select '{}'::jsonb || '{"cq":"l", "b":"g", "fg":false}';
::||select pg_column_size('{}'::jsonb || '{}'::jsonb) = pg_column_size('{}'::jsonb);
::||select pg_column_size('{"aa":1}'::jsonb || '{"b":2}'::jsonb) = pg_column_size('{"aa":1, "b":2}'::jsonb);
::||select pg_column_size('{"aa":1, "b":2}'::jsonb || '{}'::jsonb) = pg_column_size('{"aa":1, "b":2}'::jsonb);
::||select pg_column_size('{}'::jsonb || '{"aa":1, "b":2}'::jsonb) = pg_column_size('{"aa":1, "b":2}'::jsonb);
::::::::::::select '{"a":1 , "b":2, "c":3}'::jsonb - 'a';
::select '{"a":null , "b":2, "c":3}'::jsonb - 'a';
::select '{"a":1 , "b":2, "c":3}'::jsonb - 'b';
::select '{"a":1 , "b":2, "c":3}'::jsonb - 'c';
::select '{"a":1 , "b":2, "c":3}'::jsonb - 'd';
::select pg_column_size('{"a":1 , "b":2, "c":3}'::jsonb - 'b') = pg_column_size('{"a":1, "b":2}'::jsonb);
::select '["a","b","c"]'::jsonb - 3;
::select '["a","b","c"]'::jsonb - 2;
::select '["a","b","c"]'::jsonb - 1;
::select '["a","b","c"]'::jsonb - 0;
::select '["a","b","c"]'::jsonb - -1;
::select '["a","b","c"]'::jsonb - -2;
::select '["a","b","c"]'::jsonb - -3;
::select '["a","b","c"]'::jsonb - -4;
::select '{"a":1 , "b":2, "c":3}'::jsonb - '{b}'::text[];
::select '{"a":1 , "b":2, "c":3}'::jsonb - '{c,b}'::text[];
::select '{"a":1 , "b":2, "c":3}'::jsonb - '{}'::text[];
::::::::::::::::::::::#select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{n}';
::#select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1}';
::#select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}'; -- invalid array subscriptselect '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{d,1,0}';
::select '"a"'::jsonb - 'a'; -- errorselect '{}'::jsonb - 'a';
::select '[]'::jsonb - 'a';
::select '"a"'::jsonb - 1; -- errorselect '{}'::jsonb -  1; -- errorselect '[]'::jsonb - 1;
::#select '"a"'::jsonb #- '{a}'; -- errorselect '{}'::jsonb #- '{a}';
::#select '[]'::jsonb #- '{a}';
select jsonb_set('"a"','{a}','"b"'); --errorselect jsonb_set('{}','{a}','"b"', false);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::select 'true'::jsonb::bool;
::::select '[]'::jsonb::bool;
::::select '1.0'::jsonb::float;
::::select '[1.0]'::jsonb::float;
::::select '12345'::jsonb::int4;
::::select '"hello"'::jsonb::int4;
::::select '12345'::jsonb::numeric;
::::select '{}'::jsonb::numeric;
::::select '12345.05'::jsonb::numeric;
::::select '12345.05'::jsonb::float4;
::::select '12345.05'::jsonb::float8;
::::select '12345.05'::jsonb::int2;
::::select '12345.05'::jsonb::int4;
::::select '12345.05'::jsonb::int8;
::::select '12345.0000000000000000000000000000000000000000000005'::jsonb::numeric;
::::select '12345.0000000000000000000000000000000000000000000005'::jsonb::float4;
::::select '12345.0000000000000000000000000000000000000000000005'::jsonb::float8;
::::select '12345.0000000000000000000000000000000000000000000005'::jsonb::int2;
::::select '12345.0000000000000000000000000000000000000000000005'::jsonb::int4;
::::select '12345.0000000000000000000000000000000000000000000005'::jsonb::int8;
create table pkeys (pkey1 int4 not null, pkey2 text not null);
create table fkeys (fkey1 int4, fkey2 text, fkey3 int);
create table fkeys2 (fkey21 int4, fkey22 text, pkey23 int not null);
create trigger check_fkeys_pkey_exist	before insert or update on fkeys	for each row	execute function	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
create trigger check_fkeys_pkey2_exist	before insert or update on fkeys	for each row	execute function check_primary_key ('fkey3', 'fkeys2', 'pkey23');
create trigger check_fkeys2_pkey_exist	before insert or update on fkeys2	for each row	execute procedure	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
create trigger check_pkeys_fkey_cascade	before delete or update on pkeys	for each row	execute procedure	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2',	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
create trigger check_fkeys2_fkey_restrict	before delete or update on fkeys2	for each row	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
delete from pkeys where pkey1 = 30 and pkey2 = '3';
delete from pkeys where pkey1 = 40 and pkey2 = '4';
SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,       action_order, action_condition, action_orientation, action_timing,       action_reference_old_table, action_reference_new_table  FROM information_schema.triggers  WHERE event_object_table in ('pkeys', 'fkeys', 'fkeys2')  ORDER BY trigger_name COLLATE "C", 2;
create trigger trigger_return_old	before insert or delete or update on trigtest	for each row execute procedure trigger_return_old();
||update trigtest set f2 = f2 || 'bar';
delete from trigtest;
create function f1_times_10() returns trigger as$$ begin new.f1 := new.f1 * 10; return new; end $$ language plpgsql;
create trigger trigger_alpha	before insert or update on trigtest	for each row execute procedure f1_times_10();
||update trigtest set f2 = f2 || 'bar';
delete from trigtest;
create trigger trigger_zed	before insert or update on trigtest	for each row execute procedure f1_times_10();
||update trigtest set f2 = f2 || 'bar';
delete from trigtest;
drop trigger trigger_alpha on trigtest;
||update trigtest set f2 = f2 || 'bar';
delete from trigtest;
create sequence ttdummy_seq increment 10 start 0 minvalue 0;
create table tttest (	price_id	int4,	price_val	int4,	price_on	int4,	price_off	int4 default 999999);
create trigger ttdummy	before delete or update on tttest	for each row	execute procedure	ttdummy (price_on, price_off);
create trigger ttserial	before insert or update on tttest	for each row	execute procedure	autoinc (price_on, ttdummy_seq);
insert into tttest values (1, 1, null);
insert into tttest values (2, 2, null);
delete from tttest where price_id = 2;
delete from tttest where price_id = 5;
select * from tttest where price_on <= 35 and price_off > 35 and price_id = 5;
drop sequence ttdummy_seq;
CREATE TABLE log_table (tstamp timestamp default timeofday()::timestamp);
COPY main_table (a,b) FROM stdin;
5	1020	2030	1050	3580	15\.CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS 'BEGIN	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
	RETURN NULL;
END;';
CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_tableFOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_tableFOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_tableEXECUTE PROCEDURE trigger_func('after_upd_stmt');
INSERT INTO main_table (a, b) VALUES (5, 10) ON CONFLICT (a)  DO UPDATE SET b = EXCLUDED.b;
CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
ALTER TABLE main_table DROP CONSTRAINT main_table_a_key;
COPY main_table (a, b) FROM stdin;
30	4050	60\.SELECT * FROM main_table ORDER BY a, b;
CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_tableFOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_tableFOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
CREATE TRIGGER insert_a AFTER INSERT ON main_tableFOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
CREATE TRIGGER delete_a AFTER DELETE ON main_tableFOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
CREATE TRIGGER insert_when BEFORE INSERT ON main_tableFOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
CREATE TRIGGER delete_when AFTER DELETE ON main_tableFOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,       action_order, action_condition, action_orientation, action_timing,       action_reference_old_table, action_reference_new_table  FROM information_schema.triggers  WHERE event_object_table IN ('main_table')  ORDER BY trigger_name COLLATE "C", 2;
COPY main_table FROM stdin;
123	999456	999\.DELETE FROM main_table WHERE a IN (123, 456);
SELECT * FROM main_table ORDER BY a, b;
::SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
::SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
::SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
ALTER TRIGGER modified_a ON main_table RENAME TO modified_modified_a;
::SELECT count(*) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
::SELECT count(*) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_modified_a';
DROP TRIGGER modified_modified_a ON main_table;
DROP TRIGGER modified_any ON main_table;
DROP TRIGGER insert_a ON main_table;
DROP TRIGGER delete_a ON main_table;
DROP TRIGGER insert_when ON main_table;
DROP TRIGGER delete_when ON main_table;
create trigger oid_unchanged_trig after update on table_with_oids	for each row	when (new.tableoid = old.tableoid AND new.tableoid <> 0)	execute procedure trigger_func('after_upd_oid_unchanged');
DROP TRIGGER after_upd_row_trig ON main_table;
CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_tableFOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_tableFOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
::SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
CREATE FUNCTION dummy_update_func() RETURNS trigger AS $$BEGIN  RAISE NOTICE 'dummy_update_func(%) called: action = %, old = %, new = %',    TG_ARGV[0], TG_OP, OLD, NEW;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW  EXECUTE PROCEDURE dummy_update_func('before');
CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW  WHEN (NOT OLD.some_col AND NEW.some_col)  EXECUTE PROCEDURE dummy_update_func('aftera');
CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW  WHEN (NOT NEW.some_col)  EXECUTE PROCEDURE dummy_update_func('afterb');
CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_tableFOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_tableFOR EACH ROW WHEN (OLD.a <> NEW.a)EXECUTE PROCEDURE trigger_func('error_ins_old');
CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_tableFOR EACH ROW WHEN (OLD.a <> NEW.a)EXECUTE PROCEDURE trigger_func('error_del_new');
CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_tableFOR EACH ROW WHEN (NEW.tableoid <> 0)EXECUTE PROCEDURE trigger_func('error_when_sys_column');
CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_tableFOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)EXECUTE PROCEDURE trigger_func('error_stmt_when');
ALTER TABLE main_table DROP COLUMN b;
begin;
DROP TRIGGER after_upd_a_b_row_trig ON main_table;
DROP TRIGGER after_upd_b_row_trig ON main_table;
DROP TRIGGER after_upd_b_stmt_trig ON main_table;
ALTER TABLE main_table DROP COLUMN b;
rollback;
create table trigtest (i serial primary key);
create function trigtest() returns trigger as $$begin	raise notice '% % % %', TG_RELNAME, TG_OP, TG_WHEN, TG_LEVEL;
	return new;
end;$$ language plpgsql;
create trigger trigtest_b_row_tg before insert or update or delete on trigtestfor each row execute procedure trigtest();
create trigger trigtest_a_row_tg after insert or update or delete on trigtestfor each row execute procedure trigtest();
create trigger trigtest_b_stmt_tg before insert or update or delete on trigtestfor each statement execute procedure trigtest();
create trigger trigtest_a_stmt_tg after insert or update or delete on trigtestfor each statement execute procedure trigtest();
alter table trigtest disable trigger trigtest_b_row_tg;
alter table trigtest disable trigger user;
alter table trigtest enable trigger trigtest_a_stmt_tg;
set session_replication_role = replica;
insert into trigtest default values;  -- does not triggeralter table trigtest enable always trigger trigtest_a_stmt_tg;
insert into trigtest default values;  -- now it doesreset session_replication_role;
delete from trigtest where i=2;
alter table trigtest disable trigger all;
delete from trigtest where i=1;
CREATE OR REPLACE FUNCTION trigger_data()  RETURNS triggerLANGUAGE plpgsql AS $$declare	argstr text;
	relid text;
begin	relid := TG_relid::regclass;
	-- plpgsql can't discover its trigger data in a hash like perl and python	-- can, or by a sort of reflection like tcl can,	-- so we have to hard code the names.	raise NOTICE 'TG_NAME: %', TG_name;
	raise NOTICE 'TG_WHEN: %', TG_when;
	raise NOTICE 'TG_LEVEL: %', TG_level;
	raise NOTICE 'TG_OP: %', TG_op;
	raise NOTICE 'TG_RELID::regclass: %', relid;
	raise NOTICE 'TG_RELNAME: %', TG_relname;
	raise NOTICE 'TG_TABLE_NAME: %', TG_table_name;
	raise NOTICE 'TG_TABLE_SCHEMA: %', TG_table_schema;
	raise NOTICE 'TG_NARGS: %', TG_nargs;
	argstr := '[';
	for i in 0 .. TG_nargs - 1 loop		if i > 0 then			argstr := argstr || ', ';
		end if;
		argstr := argstr || TG_argv[i];
	end loop;
	argstr := argstr || ']';
	raise NOTICE 'TG_ARGV: %', argstr;
	if TG_OP != 'INSERT' then		raise NOTICE 'OLD: %', OLD;
	end if;
	if TG_OP != 'DELETE' then		raise NOTICE 'NEW: %', NEW;
	end if;
	if TG_OP = 'DELETE' then		return OLD;
	else		return NEW;
	end if;
end;
$$;
CREATE TRIGGER show_trigger_data_trigBEFORE INSERT OR UPDATE OR DELETE ON trigger_testFOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
delete from trigger_test;
DROP TRIGGER show_trigger_data_trig on trigger_test;
DROP FUNCTION trigger_data();
CREATE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$begin	if row(old.*) = row(new.*) then		raise notice 'row % not changed', new.f1;
	else		raise notice 'row % changed', new.f1;
	end if;
	return new;
end$$;
CREATE TRIGGER tBEFORE UPDATE ON trigger_testFOR EACH ROW EXECUTE PROCEDURE mytrigger();
UPDATE trigger_test SET f3 = NULL;
UPDATE trigger_test SET f3 = NULL;
CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$begin	if row(old.*) is distinct from row(new.*) then		raise notice 'row % changed', new.f1;
	else		raise notice 'row % not changed', new.f1;
	end if;
	return new;
end$$;
UPDATE trigger_test SET f3 = NULL;
UPDATE trigger_test SET f3 = NULL;
DROP FUNCTION mytrigger();
CREATE FUNCTION serializable_update_trig() RETURNS trigger LANGUAGE plpgsql AS$$declare	rec record;
begin	new.description = 'updated in trigger';
	return new;
end;
$$;
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
COMMIT;
INSERT INTO min_updates_test VALUES ('a',1,2),('b','2',null);
CREATE TRIGGER z_min_updateBEFORE UPDATE ON min_updates_testFOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
\\set QUIET falseUPDATE min_updates_test SET f1 = f1;
\\set QUIET trueSELECT * FROM min_updates_test;
CREATE OR REPLACE FUNCTION view_trigger() RETURNS triggerLANGUAGE plpgsql AS $$declare    argstr text := '';
begin    for i in 0 .. TG_nargs - 1 loop        if i > 0 then            argstr := argstr || ', ';
        end if;
        argstr := argstr || TG_argv[i];
    end loop;
    raise notice '% % % % (%)', TG_RELNAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;
    if TG_LEVEL = 'ROW' then        if TG_OP = 'INSERT' then            raise NOTICE 'NEW: %', NEW;
            INSERT INTO main_table VALUES (NEW.a, NEW.b);
            RETURN NEW;
        end if;
        if TG_OP = 'UPDATE' then            raise NOTICE 'OLD: %, NEW: %', OLD, NEW;
            UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;
            if NOT FOUND then RETURN NULL; end if;
            RETURN NEW;
        end if;
        if TG_OP = 'DELETE' then            raise NOTICE 'OLD: %', OLD;
            DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;
            if NOT FOUND then RETURN NULL; end if;
            RETURN OLD;
        end if;
    end if;
    RETURN NULL;
end;
$$;
CREATE TRIGGER invalid_trig BEFORE INSERT ON main_viewFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_viewFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
CREATE TRIGGER invalid_trig BEFORE DELETE ON main_viewFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
CREATE TRIGGER invalid_trig AFTER INSERT ON main_viewFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
CREATE TRIGGER invalid_trig AFTER UPDATE ON main_viewFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
CREATE TRIGGER invalid_trig AFTER DELETE ON main_viewFOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_viewEXECUTE PROCEDURE trigger_func('before_tru_row');
CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_viewEXECUTE PROCEDURE trigger_func('before_tru_row');
CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_tableFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_tableFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_tableFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_viewFOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_viewFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_viewEXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_viewFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_viewFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_viewFOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_viewFOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_viewFOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_viewFOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_viewFOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_viewFOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_viewFOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
\\set QUIET falseINSERT INTO main_view VALUES (20, 30);
INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
DROP TRIGGER before_upd_a_row_trig ON main_table;
UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
DELETE FROM main_view WHERE a IN (20,21);
DELETE FROM main_view WHERE a = 31 RETURNING a, b;
\\set QUIET trueDROP TRIGGER instead_of_insert_trig ON main_view;
DROP TRIGGER instead_of_delete_trig ON main_view;
CREATE TABLE country_table (    country_id        serial primary key,    country_name    text unique not null,    continent        text not null);
INSERT INTO country_table (country_name, continent)    VALUES ('Japan', 'Asia'),           ('UK', 'Europe'),           ('USA', 'North America')    RETURNING *;
CREATE TABLE city_table (    city_id        serial primary key,    city_name    text not null,    population    bigint,    country_id    int references country_table);
CREATE VIEW city_view AS    SELECT city_id, city_name, population, country_name, continent    FROM city_table ci    LEFT JOIN country_table co ON co.country_id = ci.country_id;
CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$declare    ctry_id int;
begin    if NEW.country_name IS NOT NULL then        SELECT country_id, continent INTO ctry_id, NEW.continent            FROM country_table WHERE country_name = NEW.country_name;
        if NOT FOUND then            raise exception 'No such country: "%"', NEW.country_name;
        end if;
    else        NEW.continent := NULL;
    end if;
    if NEW.city_id IS NOT NULL then        INSERT INTO city_table            VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
    else        INSERT INTO city_table(city_name, population, country_id)            VALUES(NEW.city_name, NEW.population, ctry_id)            RETURNING city_id INTO NEW.city_id;
    end if;
    RETURN NEW;
end;
$$;
CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_viewFOR EACH ROW EXECUTE PROCEDURE city_insert();
CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$begin    DELETE FROM city_table WHERE city_id = OLD.city_id;
    if NOT FOUND then RETURN NULL; end if;
    RETURN OLD;
end;
$$;
CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_viewFOR EACH ROW EXECUTE PROCEDURE city_delete();
CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$declare    ctry_id int;
begin    if NEW.country_name IS DISTINCT FROM OLD.country_name then        SELECT country_id, continent INTO ctry_id, NEW.continent            FROM country_table WHERE country_name = NEW.country_name;
        if NOT FOUND then            raise exception 'No such country: "%"', NEW.country_name;
        end if;
        UPDATE city_table SET city_name = NEW.city_name,                              population = NEW.population,                              country_id = ctry_id            WHERE city_id = OLD.city_id;
    else        UPDATE city_table SET city_name = NEW.city_name,                              population = NEW.population            WHERE city_id = OLD.city_id;
        NEW.continent := OLD.continent;
    end if;
    if NOT FOUND then RETURN NULL; end if;
    RETURN NEW;
end;
$$;
CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_viewFOR EACH ROW EXECUTE PROCEDURE city_update();
\\set QUIET falseINSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo'; -- errorUPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo'; -- no matchUPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *; -- OKUPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2    WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
\\set QUIET trueCREATE VIEW european_city_view AS    SELECT * FROM city_view WHERE continent = 'Europe';
CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsqlAS 'begin RETURN NULL; end';
CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETEON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
\\set QUIET falseINSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
DELETE FROM european_city_view;
\\set QUIET trueCREATE RULE european_city_insert_rule AS ON INSERT TO european_city_viewDO INSTEAD INSERT INTO city_viewVALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)RETURNING *;
CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_viewDO INSTEAD UPDATE city_view SET    city_name = NEW.city_name,    population = NEW.population,    country_name = NEW.country_nameWHERE city_id = OLD.city_idRETURNING NEW.*;
CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_viewDO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
\\set QUIET falseINSERT INTO european_city_view(city_name, country_name)    VALUES ('Cambridge', 'USA') RETURNING *;
DELETE FROM european_city_view WHERE city_name = 'Cambridge';
UPDATE city_view SET country_name = 'UK'    WHERE city_name = 'Cambridge' RETURNING *;
UPDATE european_city_view SET population = 122800    WHERE city_name = 'Cambridge' RETURNING *;
DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
UPDATE city_view v SET population = 599657    FROM city_table ci, country_table co    WHERE ci.city_name = 'Washington DC' and co.country_name = 'USA'    AND v.city_id = ci.city_id AND v.country_name = co.country_name    RETURNING co.country_id, v.country_name,              v.city_id, v.city_name, v.population;
\\set QUIET trueSELECT * FROM city_view;
DROP TABLE city_table CASCADE;
create function depth_a_tf() returns trigger  language plpgsql as $$begin  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  insert into depth_b values (new.id);
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  return new;
end;
$$;
create function depth_b_tf() returns trigger  language plpgsql as $$begin  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  begin    execute 'insert into depth_c values (' || new.id::text || ')';
  exception    when sqlstate 'U9999' then      raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();
  end;
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  if new.id = 1 then    execute 'insert into depth_c values (' || new.id::text || ')';
  end if;
  return new;
end;
$$;
create function depth_c_tf() returns trigger  language plpgsql as $$begin  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  if new.id = 1 then    raise exception sqlstate 'U9999';
  end if;
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  return new;
end;
$$;
drop table depth_a, depth_b, depth_c;
drop function depth_a_tf();
drop function depth_b_tf();
drop function depth_c_tf();
create temp table parent (    aid int not null primary key,    val1 text,    val2 text,    val3 text,    val4 text,    bcnt int not null default 0);
create function parent_upd_func()  returns trigger language plpgsql as$$begin  if old.val1 <> new.val1 then    new.val2 = new.val1;
    delete from child where child.aid = new.aid and child.val1 = new.val1;
  end if;
  return new;
end;
$$;
create function parent_del_func()  returns trigger language plpgsql as$$begin  delete from child where aid = old.aid;
  return old;
end;
$$;
create function child_ins_func()  returns trigger language plpgsql as$$begin  update parent set bcnt = bcnt + 1 where aid = new.aid;
  return new;
end;
$$;
create function child_del_func()  returns trigger language plpgsql as$$begin  update parent set bcnt = bcnt - 1 where aid = old.aid;
  return old;
end;
$$;
update parent set val1 = 'b' where aid = 1; -- should failselect * from parent; select * from child;
delete from parent where aid = 1; -- should failselect * from parent; select * from child;
create or replace function parent_del_func()  returns trigger language plpgsql as$$begin  delete from child where aid = old.aid;
  if found then    delete from parent where aid = old.aid;
    return null; -- cancel outer deletion  end if;
  return old;
end;
$$;
delete from parent where aid = 1;
drop table parent, child;
drop function parent_upd_func();
drop function parent_del_func();
drop function child_ins_func();
drop function child_del_func();
create temp table self_ref_trigger (    id int primary key,    parent int references self_ref_trigger,    data text,    nchildren int not null default 0);
create function self_ref_trigger_ins_func()  returns trigger language plpgsql as$$begin  if new.parent is not null then    update self_ref_trigger set nchildren = nchildren + 1      where id = new.parent;
  end if;
  return new;
end;
$$;
create function self_ref_trigger_del_func()  returns trigger language plpgsql as$$begin  if old.parent is not null then    update self_ref_trigger set nchildren = nchildren - 1      where id = old.parent;
  end if;
  return old;
end;
$$;
insert into self_ref_trigger values (1, null, 'root');
delete from self_ref_trigger;
drop function self_ref_trigger_ins_func();
drop function self_ref_trigger_del_func();
create table stmt_trig_on_empty_upd1 () inherits (stmt_trig_on_empty_upd);
create function update_stmt_notice() returns trigger as $$begin	raise notice 'updating %', TG_TABLE_NAME;
	return null;
end;
$$ language plpgsql;
update stmt_trig_on_empty_upd set a = a where false returning a+1 as aa;
update stmt_trig_on_empty_upd1 set a = a where false returning a+1 as aa;
drop table stmt_trig_on_empty_upd cascade;
drop function update_stmt_notice();
create function trigger_ddl_func() returns trigger as $$begin  alter table trigger_ddl_table add primary key (col1);
  return new;
end$$ language plpgsql;
insert into trigger_ddl_table values (1, 42);  -- failcreate or replace function trigger_ddl_func() returns trigger as $$begin  create index on trigger_ddl_table (col2);
  return new;
end$$ language plpgsql;
insert into trigger_ddl_table values (1, 42);  -- faildrop table trigger_ddl_table;
drop function trigger_ddl_func();
create table upsert (key int4 primary key, color text);
create function upsert_before_func()  returns trigger language plpgsql as$$begin  if (TG_OP = 'UPDATE') then    raise warning 'before update (old): %', old.*::text;
    raise warning 'before update (new): %', new.*::text;
  elsif (TG_OP = 'INSERT') then    raise warning 'before insert (new): %', new.*::text;
    if new.key % 2 = 0 then      new.key := new.key + 1;
      new.color := new.color || ' trig modified';
      raise warning 'before insert (new, modified): %', new.*::text;
    end if;
  end if;
  return new;
end;
$$;
create trigger upsert_before_trig before insert or update on upsert  for each row execute procedure upsert_before_func();
create function upsert_after_func()  returns trigger language plpgsql as$$begin  if (TG_OP = 'UPDATE') then    raise warning 'after update (old): %', old.*::text;
    raise warning 'after update (new): %', new.*::text;
  elsif (TG_OP = 'INSERT') then    raise warning 'after insert (new): %', new.*::text;
  end if;
  return null;
end;
$$;
create trigger upsert_after_trig after insert or update on upsert  for each row execute procedure upsert_after_func();
insert into upsert values(1, 'black') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(2, 'red') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(3, 'orange') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(4, 'green') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(5, 'purple') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(6, 'white') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(7, 'pink') on conflict (key) do update set color = 'updated ' || upsert.color;
insert into upsert values(8, 'yellow') on conflict (key) do update set color = 'updated ' || upsert.color;
drop function upsert_before_func();
drop function upsert_after_func();
create function my_trigger_function() returns trigger as $$ begin end; $$ language plpgsql;
create trigger my_trigger after update on my_view referencing old table as old_table   for each statement execute procedure my_trigger_function();
drop function my_trigger_function();
create table parted_trig (a int) partition by list (a);
create function trigger_nothing() returns trigger  language plpgsql as $$ begin end; $$;
create trigger failed before insert or update or delete on parted_trig  for each row execute procedure trigger_nothing();
create trigger failed after update on parted_trig  referencing old table as old_table  for each row execute procedure trigger_nothing();
create table trigpart (a int, b int) partition by range (a);
create table trigpart1 partition of trigpart for values from (0) to (1000);
create table trigpart2 partition of trigpart for values from (1000) to (2000);
create table trigpart3 (like trigpart);
alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
::::::select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
drop trigger trg1 on trigpart1;	-- faildrop trigger trg1 on trigpart2;	-- faildrop trigger trg1 on trigpart3;	-- faildrop table trigpart2;			-- ok, trigger should be gone in that partitionselect tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
drop trigger trg1 on trigpart;		-- ok, all goneselect tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
drop function trigger_nothing();
create table parted_stmt_trig (a int) partition by list (a);
create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1);
create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2);
create table parted2_stmt_trig (a int) partition by list (a);
create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1);
create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2);
create or replace function trigger_notice() returns trigger as $$  begin    raise notice 'trigger % on % % % for %', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
    if TG_LEVEL = 'ROW' then       return NEW;
    end if;
    return null;
  end;
  $$ language plpgsql;
create trigger trig_ins_before before insert on parted_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_ins_after after insert on parted_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_upd_before before update on parted_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_upd_after after update on parted_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_del_before before delete on parted_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_del_after after delete on parted_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_ins_before_3 before insert on parted2_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_ins_after_3 after insert on parted2_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_upd_before_3 before update on parted2_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_upd_after_3 after update on parted2_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_del_before_3 before delete on parted2_stmt_trig  for each statement execute procedure trigger_notice();
create trigger trig_del_after_3 after delete on parted2_stmt_trig  for each statement execute procedure trigger_notice();
with ins (a) as (  insert into parted2_stmt_trig values (1), (2) returning a) insert into parted_stmt_trig select a from ins returning tableoid::regclass, a;
with upd as (  update parted2_stmt_trig set a = a) update parted_stmt_trig  set a = a;
delete from parted_stmt_trig;
copy parted_stmt_trig(a) from stdin;
\\.copy parted_stmt_trig1(a) from stdin;
\\.alter table parted_stmt_trig disable trigger trig_ins_after_parent;
alter table parted_stmt_trig enable trigger trig_ins_after_parent;
drop table parted_stmt_trig, parted2_stmt_trig;
create table parted_trig (a int) partition by range (a);
create table parted_trig_1 partition of parted_trig for values from (0) to (1000)   partition by range (a);
create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
create table parted_trig (a int) partition by list (a);
create table parted_trig1 partition of parted_trig for values in (1);
create or replace function trigger_notice() returns trigger as $$  declare    arg1 text = TG_ARGV[0];
    arg2 integer = TG_ARGV[1];
  begin    raise notice 'trigger % on % % % for % args % %',		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, arg1, arg2;
    return null;
  end;
  $$ language plpgsql;
create trigger aaa after insert on parted_trig   for each row execute procedure trigger_notice('quirky', 1);
create table parted_trig2 partition of parted_trig for values in (2);
create table parted_trig3 (like parted_trig);
alter table parted_trig attach partition parted_trig3 for values in (3);
create function bark(text) returns bool language plpgsql immutable  as $$ begin raise notice '% <- woof!', $1; return true; end; $$;
create or replace function trigger_notice_ab() returns trigger as $$  begin    raise notice 'trigger % on % % % for %: (a,b)=(%,%)',		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL,		NEW.a, NEW.b;
    if TG_LEVEL = 'ROW' then       return NEW;
    end if;
    return null;
  end;
  $$ language plpgsql;
create table parted_irreg_ancestor (fd text, b text, fd2 int, fd3 int, a int)  partition by range (b);
alter table parted_irreg_ancestor drop column fd,  drop column fd2, drop column fd3;
create table parted_irreg (fd int, a int, fd2 int, b text)  partition by range (b);
alter table parted_irreg drop column fd, drop column fd2;
alter table parted_irreg_ancestor attach partition parted_irreg  for values from ('aaaa') to ('zzzz');
alter table parted1_irreg drop column fd;
alter table parted_irreg attach partition parted1_irreg  for values from ('aaaa') to ('bbbb');
create trigger parted_trig_odd after insert on parted_irreg for each row  when (bark(new.b) AND new.a % 2 = 1) execute procedure trigger_notice_ab();
create table parted_constr_ancestor (a int, b text)  partition by range (b);
create table parted_constr (a int, b text)  partition by range (b);
alter table parted_constr_ancestor attach partition parted_constr  for values from ('aaaa') to ('zzzz');
alter table parted_constr attach partition parted1_constr  for values from ('aaaa') to ('bbbb');
create constraint trigger parted_trig after insert on parted_constr_ancestor  deferrable  for each row execute procedure trigger_notice_ab();
create constraint trigger parted_trig_two after insert on parted_constr  deferrable initially deferred  for each row when (bark(new.b) AND new.a % 2 = 1)  execute procedure trigger_notice_ab();
begin;
commit;
begin;
set constraints parted_trig deferred;
commit;
drop function bark(text);
create table parted_trigger (a int, b text) partition by range (a);
create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
alter table parted_trigger_2 drop column drp;
alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
create trigger parted_trigger after update on parted_trigger  for each row when (new.a % 2 = 1 and length(old.b) >= 2) execute procedure trigger_notice_ab();
create table parted_trigger_3 (b text, a int) partition by range (length(b));
create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
update parted_trigger set a = a + 2; -- notice for odd 'a' values, long 'b' valuesdrop table parted_trigger;
create table unparted_trigger (a int, b text);	-- for comparison purposescreate table parted_trigger (a int, b text) partition by range (a);
create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
alter table parted_trigger_2 drop column drp;
alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
create constraint trigger parted_trigger after update on parted_trigger  from parted_referenced  for each row execute procedure trigger_notice_ab();
create constraint trigger parted_trigger after update on unparted_trigger  from parted_referenced  for each row execute procedure trigger_notice_ab();
create table parted_trigger_3 (b text, a int) partition by range (length(b));
create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
select tgname, conname, t.tgrelid::regclass, t.tgconstrrelid::regclass,  c.conrelid::regclass, c.confrelid::regclass  from pg_trigger t join pg_constraint c on (t.tgconstraint = c.oid)  where tgname = 'parted_trigger'  order by t.tgrelid::regclass::text;
drop table parted_referenced, parted_trigger, unparted_trigger;
create table parted_trigger (a int, b text) partition by range (a);
create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
alter table parted_trigger_2 drop column drp;
alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
create table parted_trigger_3 (b text, a int) partition by range (length(b));
create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (4);
create table parted_trigger_3_2 partition of parted_trigger_3 for values from (4) to (8);
alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
update parted_trigger set a = a + 2;	-- no notices hereupdate parted_trigger set b = b || 'b';	-- all triggers should firedrop table parted_trigger;
drop function trigger_notice_ab();
create table trg_clone (a int) partition by range (a);
create table trg_clone1 partition of trg_clone for values from (0) to (1000);
alter table trg_clone add constraint uniq unique (a) deferrable;
create table trg_clone2 partition of trg_clone for values from (1000) to (2000);
create table trg_clone3 partition of trg_clone for values from (2000) to (3000)  partition by range (a);
create table trg_clone_3_3 partition of trg_clone3 for values from (2000) to (2100);
::::select tgrelid::regclass, count(*) from pg_trigger  where tgrelid::regclass in ('trg_clone', 'trg_clone1', 'trg_clone2',	'trg_clone3', 'trg_clone_3_3')  group by tgrelid::regclass order by tgrelid::regclass;
create or replace function dump_insert() returns trigger language plpgsql as$$  begin    raise notice 'trigger = %, new table = %',                 TG_NAME,                 (select string_agg(new_table::text, ', ' order by a) from new_table);
    return null;
  end;
$$;
create or replace function dump_update() returns trigger language plpgsql as$$  begin    raise notice 'trigger = %, old table = %, new table = %',                 TG_NAME,                 (select string_agg(old_table::text, ', ' order by a) from old_table),                 (select string_agg(new_table::text, ', ' order by a) from new_table);
    return null;
  end;
$$;
create or replace function dump_delete() returns trigger language plpgsql as$$  begin    raise notice 'trigger = %, old table = %',                 TG_NAME,                 (select string_agg(old_table::text, ', ' order by a) from old_table);
    return null;
  end;
$$;
create table parent (a text, b int) partition by list (a);
create table child1 partition of parent for values in ('AAA');
alter table child2 drop column x;
alter table parent attach partition child2 for values in ('BBB');
alter table parent attach partition child3 for values in ('CCC');
create trigger parent_insert_trig  after insert on parent referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger parent_update_trig  after update on parent referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger parent_delete_trig  after delete on parent referencing old table as old_table  for each statement execute procedure dump_delete();
create trigger child1_insert_trig  after insert on child1 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger child1_update_trig  after update on child1 referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger child1_delete_trig  after delete on child1 referencing old table as old_table  for each statement execute procedure dump_delete();
create trigger child2_insert_trig  after insert on child2 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger child2_update_trig  after update on child2 referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger child2_delete_trig  after delete on child2 referencing old table as old_table  for each statement execute procedure dump_delete();
create trigger child3_insert_trig  after insert on child3 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger child3_update_trig  after update on child3 referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger child3_delete_trig  after delete on child3 referencing old table as old_table  for each statement execute procedure dump_delete();
SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,       action_order, action_condition, action_orientation, action_timing,       action_reference_old_table, action_reference_new_table  FROM information_schema.triggers  WHERE event_object_table IN ('parent', 'child1', 'child2', 'child3')  ORDER BY trigger_name COLLATE "C", 2;
delete from parent;
delete from child1;
delete from child2;
delete from child3;
copy parent (a, b) from stdin;
AAA	42BBB	42CCC	42\.drop trigger child1_insert_trig on child1;
drop trigger child1_update_trig on child1;
drop trigger child1_delete_trig on child1;
drop trigger child2_insert_trig on child2;
drop trigger child2_update_trig on child2;
drop trigger child2_delete_trig on child2;
drop trigger child3_insert_trig on child3;
drop trigger child3_update_trig on child3;
drop trigger child3_delete_trig on child3;
delete from parent;
copy parent (a, b) from stdin;
AAA	42BBB	42CCC	42\.create or replace function intercept_insert() returns trigger language plpgsql as$$  begin    new.b = new.b + 1000;
    return new;
  end;
$$;
copy parent (a, b) from stdin;
AAA	42BBB	42CCC	234\.drop table child1, child2, child3, parent;
drop function intercept_insert();
create table parent (a text, b int) partition by list (a);
create table child partition of parent for values in ('AAA');
create trigger child_row_trig  after insert on child referencing new table as new_table  for each row execute procedure dump_insert();
alter table parent detach partition child;
create trigger child_row_trig  after insert on child referencing new table as new_table  for each row execute procedure dump_insert();
alter table parent attach partition child for values in ('AAA');
drop trigger child_row_trig on child;
alter table parent attach partition child for values in ('AAA');
drop table child, parent;
create table child1 () inherits (parent);
alter table child2 inherit parent;
create table child3 (c text) inherits (parent);
create trigger parent_insert_trig  after insert on parent referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger parent_update_trig  after update on parent referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger parent_delete_trig  after delete on parent referencing old table as old_table  for each statement execute procedure dump_delete();
create trigger child1_insert_trig  after insert on child1 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger child1_update_trig  after update on child1 referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger child1_delete_trig  after delete on child1 referencing old table as old_table  for each statement execute procedure dump_delete();
create trigger child2_insert_trig  after insert on child2 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger child2_update_trig  after update on child2 referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger child2_delete_trig  after delete on child2 referencing old table as old_table  for each statement execute procedure dump_delete();
create trigger child3_insert_trig  after insert on child3 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger child3_update_trig  after update on child3 referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger child3_delete_trig  after delete on child3 referencing old table as old_table  for each statement execute procedure dump_delete();
delete from parent;
delete from child1;
delete from child2;
delete from child3;
copy parent (a, b) from stdin;
AAA	42BBB	42CCC	42\.create index on parent(b);
copy parent (a, b) from stdin;
DDD	42\.drop trigger child1_insert_trig on child1;
drop trigger child1_update_trig on child1;
drop trigger child1_delete_trig on child1;
drop trigger child2_insert_trig on child2;
drop trigger child2_update_trig on child2;
drop trigger child2_delete_trig on child2;
drop trigger child3_insert_trig on child3;
drop trigger child3_update_trig on child3;
drop trigger child3_delete_trig on child3;
delete from parent;
drop table child1, child2, child3, parent;
create table child () inherits (parent);
create trigger child_row_trig  after insert on child referencing new table as new_table  for each row execute procedure dump_insert();
alter table child no inherit parent;
create trigger child_row_trig  after insert on child referencing new table as new_table  for each row execute procedure dump_insert();
alter table child inherit parent;
drop trigger child_row_trig on child;
alter table child inherit parent;
drop table child, parent;
create trigger table1_trig  after insert on table1 referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger table2_trig  after insert on table2 referencing new table as new_table  for each statement execute procedure dump_insert();
with wcte as (insert into table1 values (42))  insert into table2 values ('hello world');
with wcte as (insert into table1 values (43))  insert into table1 values (44);
create trigger my_table_insert_trig  after insert on my_table referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger my_table_update_trig  after update on my_table referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
insert into my_table values (1, 'AAA'), (2, 'BBB')  on conflict (a) do  update set b = my_table.b || ':' || excluded.b;
insert into my_table values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')  on conflict (a) do  update set b = my_table.b || ':' || excluded.b;
insert into my_table values (3, 'CCC'), (4, 'DDD')  on conflict (a) do  update set b = my_table.b || ':' || excluded.b;
create table iocdu_tt_parted (a int primary key, b text) partition by list (a);
create table iocdu_tt_parted1 partition of iocdu_tt_parted for values in (1);
create table iocdu_tt_parted2 partition of iocdu_tt_parted for values in (2);
create table iocdu_tt_parted3 partition of iocdu_tt_parted for values in (3);
create table iocdu_tt_parted4 partition of iocdu_tt_parted for values in (4);
create trigger iocdu_tt_parted_insert_trig  after insert on iocdu_tt_parted referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger iocdu_tt_parted_update_trig  after update on iocdu_tt_parted referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB')  on conflict (a) do  update set b = iocdu_tt_parted.b || ':' || excluded.b;
insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')  on conflict (a) do  update set b = iocdu_tt_parted.b || ':' || excluded.b;
insert into iocdu_tt_parted values (3, 'CCC'), (4, 'DDD')  on conflict (a) do  update set b = iocdu_tt_parted.b || ':' || excluded.b;
create trigger my_table_multievent_trig  after insert or update on my_table referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger my_table_col_update_trig  after update of b on my_table referencing new table as new_table  for each statement execute procedure dump_insert();
create table trig_table (a int, b text,  foreign key (a) references refd_table on update cascade on delete cascade);
create trigger trig_table_before_trig  before insert or update or delete on trig_table  for each statement execute procedure trigger_func('trig_table');
create trigger trig_table_insert_trig  after insert on trig_table referencing new table as new_table  for each statement execute procedure dump_insert();
create trigger trig_table_update_trig  after update on trig_table referencing old table as old_table new table as new_table  for each statement execute procedure dump_update();
create trigger trig_table_delete_trig  after delete on trig_table referencing old table as old_table  for each statement execute procedure dump_delete();
delete from refd_table where length(b) = 3;
drop table refd_table, trig_table;
create trigger self_ref_before_trig  before delete on self_ref  for each statement execute procedure trigger_func('self_ref');
create trigger self_ref_r_trig  after delete on self_ref referencing old table as old_table  for each row execute procedure dump_delete();
create trigger self_ref_s_trig  after delete on self_ref referencing old table as old_table  for each statement execute procedure dump_delete();
insert into self_ref values (1, null), (2, 1), (3, 2);
delete from self_ref where a = 1;
drop trigger self_ref_r_trig on self_ref;
insert into self_ref values (1, null), (2, 1), (3, 2), (4, 3);
delete from self_ref where a = 1;
drop function dump_insert();
drop function dump_update();
drop function dump_delete();
::SELECT '"\u"'::json;			-- ERROR, incomplete escapeSELECT '"\u00"'::json;			-- ERROR, incomplete escapeSELECT '"\u000g"'::json;		-- ERROR, g is not a hex digitSELECT '"\u0000"'::json;		-- OK, legal escapeSELECT '"\uaBcD"'::json;		-- OK, uppercase and lower case both OKselect json '{ "a":  "\ud83d\ude04\ud83d\udc36" }' -> 'a' as correct_in_utf8;
select json '{ "a":  "\ud83d\ud83d" }' -> 'a'; -- 2 high surrogates in a rowselect json '{ "a":  "\ude04\ud83d" }' -> 'a'; -- surrogates in wrong orderselect json '{ "a":  "\ud83dX" }' -> 'a'; -- orphan high surrogateselect json '{ "a":  "\ude04X" }' -> 'a'; -- orphan low surrogateselect json '{ "a":  "the Copyright \u00a9 sign" }' as correct_in_utf8;
select json '{ "a":  "dollar \u0024 character" }' as correct_everywhere;
select json '{ "a":  "dollar \\u0024 character" }' as not_an_escape;
select json '{ "a":  "null \u0000 escape" }' as not_unescaped;
select json '{ "a":  "null \\u0000 escape" }' as not_an_escape;
select json '{ "a":  "the Copyright \u00a9 sign" }' ->> 'a' as correct_in_utf8;
select json '{ "a":  "dollar \u0024 character" }' ->> 'a' as correct_everywhere;
select json '{ "a":  "dollar \\u0024 character" }' ->> 'a' as not_an_escape;
select json '{ "a":  "null \u0000 escape" }' ->> 'a' as fails;
select json '{ "a":  "null \\u0000 escape" }' ->> 'a' as not_an_escape;
::SELECT '"\u"'::jsonb;			-- ERROR, incomplete escapeSELECT '"\u00"'::jsonb;			-- ERROR, incomplete escapeSELECT '"\u000g"'::jsonb;		-- ERROR, g is not a hex digitSELECT '"\u0045"'::jsonb;		-- OK, legal escapeSELECT '"\u0000"'::jsonb;		-- ERROR, we don't support U+0000SELECT octet_length('"\uaBcD"'::jsonb::text); -- OK, uppercase and lower case both OKSELECT octet_length((jsonb '{ "a":  "\ud83d\ude04\ud83d\udc36" }' -> 'a')::text) AS correct_in_utf8;
SELECT jsonb '{ "a":  "\ud83d\ud83d" }' -> 'a'; -- 2 high surrogates in a rowSELECT jsonb '{ "a":  "\ude04\ud83d" }' -> 'a'; -- surrogates in wrong orderSELECT jsonb '{ "a":  "\ud83dX" }' -> 'a'; -- orphan high surrogateSELECT jsonb '{ "a":  "\ude04X" }' -> 'a'; -- orphan low surrogateSELECT jsonb '{ "a":  "the Copyright \u00a9 sign" }' as correct_in_utf8;
SELECT jsonb '{ "a":  "dollar \u0024 character" }' as correct_everywhere;
SELECT jsonb '{ "a":  "dollar \\u0024 character" }' as not_an_escape;
SELECT jsonb '{ "a":  "null \u0000 escape" }' as fails;
SELECT jsonb '{ "a":  "null \\u0000 escape" }' as not_an_escape;
SELECT jsonb '{ "a":  "the Copyright \u00a9 sign" }' ->> 'a' as correct_in_utf8;
SELECT jsonb '{ "a":  "dollar \u0024 character" }' ->> 'a' as correct_everywhere;
SELECT jsonb '{ "a":  "dollar \\u0024 character" }' ->> 'a' as not_an_escape;
SELECT jsonb '{ "a":  "null \u0000 escape" }' ->> 'a' as fails;
SELECT jsonb '{ "a":  "null \\u0000 escape" }' ->> 'a' as not_an_escape;
CREATE TABLE TEMP_FLOAT (f1 FLOAT8);
CREATE TABLE TEMP_INT4 (f1 INT4);
CREATE TABLE TEMP_INT2 (f1 INT2);
CREATE TABLE TEMP_GROUP (f1 INT4, f2 INT4, f3 FLOAT8);
INSERT INTO TEMP_GROUP  SELECT 1, (- i.f1), (- f.f1)  FROM INT4_TBL i, FLOAT8_TBL f;
INSERT INTO TEMP_GROUP  SELECT 2, i.f1, f.f1  FROM INT4_TBL i, FLOAT8_TBL f;
SELECT f1 AS two, max(f3) AS max_float, min(f3) as min_float  FROM TEMP_GROUP  GROUP BY f1  ORDER BY two, max_float, min_float;
SELECT f1 AS two, max(f3) AS max_float, min(f3) AS min_float  FROM TEMP_GROUP  GROUP BY two  ORDER BY two, max_float, min_float;
SELECT f1 AS two, (max(f3) + 1) AS max_plus_1, (min(f3) - 1) AS min_minus_1  FROM TEMP_GROUP  GROUP BY f1  ORDER BY two, min_minus_1;
SELECT f1 AS two,       max(f2) + min(f2) AS max_plus_min,       min(f3) - 1 AS min_minus_1  FROM TEMP_GROUP  GROUP BY f1  ORDER BY two, min_minus_1;
