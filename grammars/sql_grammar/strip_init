CREATE ROLE x LOGIN SUPERUSER ; 
CREATE ROLE x ; 
CREATE ROLE x LOGIN NOSUPERUSER ; 
SET SESSION AUTHORIZATION 'x' ; 
SET client_min_messages = 'x' ; 
CREATE PUBLICATION testpub_default ; 
RESET client_min_messages ; 
COMMENT ON PUBLICATION testpub_default IS 'x' ; 
SELECT x ( x . x , 'x' ) FROM x p ; 
CREATE PUBLICATION testpub_xxx WITH ( foo ) ; 
CREATE PUBLICATION testpub_xxx WITH ( publish = 'x' ) ; 
ALTER PUBLICATION testpub_default SET ( publish = 'x' ) ; 
CREATE SCHEMA x ; 
CREATE TABLE x . testpub_nopk ( x INT , x INT ) ; 
CREATE VIEW x AS SELECT 1 ; 
CREATE TABLE x ( x INT ) PARTITION BY LIST ( a ) ; 
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES WITH ( publish = 'x' ) ; 
ALTER PUBLICATION testpub_foralltables SET ( publish = 'x' ) ; 
ALTER PUBLICATION testpub_foralltables ADD TABLE x ; 
ALTER PUBLICATION testpub_foralltables DROP TABLE x ; 
ALTER PUBLICATION testpub_foralltables SET TABLE x . testpub_nopk ; 
SELECT x , x FROM x WHERE x = 'x' ; 
DROP TABLE x ; 
DROP PUBLICATION testpub_foralltables ; 
CREATE TABLE x ( x INT ) ; 
CREATE TABLE x ( x TEXT ) INHERITS ( x ) ; 
CREATE PUBLICATION testpub3 FOR TABLE x ; 
CREATE PUBLICATION testpub4 FOR TABLE ONLY x ; 
DROP TABLE x , x ; 
DROP PUBLICATION testpub3 , testpub4 ; 
CREATE PUBLICATION testpub_fortbl FOR TABLE x ; 
CREATE PUBLICATION testpub_fortbl FOR TABLE x , x . testpub_nopk ; 
ALTER PUBLICATION testpub_fortbl ADD TABLE x ; 
ALTER PUBLICATION testpub_default ADD TABLE x ; 
ALTER PUBLICATION testpub_default SET TABLE x ; 
ALTER PUBLICATION testpub_default ADD TABLE x . testpub_nopk ; 
ALTER PUBLICATION testpib_ins_trunct ADD TABLE x . testpub_nopk , x ; 
ALTER PUBLICATION testpub_default DROP TABLE x , x . testpub_nopk ; 
ALTER PUBLICATION testpub_default DROP TABLE x . testpub_nopk ; 
SET ROLE regress_publication_user2 ; 
GRANT CREATE ON DATABASE regression TO x ; 
GRANT regress_publication_user TO x ; 
SET ROLE regress_publication_user ; 
REVOKE CREATE ON DATABASE regression FROM x ; 
DROP VIEW x ; 
SET ROLE regress_publication_user_dummy ; 
ALTER PUBLICATION testpub_default RENAME TO testpub_dummy ; 
ALTER PUBLICATION testpub_default RENAME TO testpub_foo ; 
ALTER PUBLICATION testpub_foo RENAME TO testpub_default ; 
ALTER PUBLICATION testpub_default OWNER TO x ; 
DROP PUBLICATION testpub_default ; 
DROP PUBLICATION testpib_ins_trunct ; 
DROP PUBLICATION testpub_fortbl ; 
DROP SCHEMA pub_test CASCADE ; 
RESET SESSION AUTHORIZATION ; 
DROP ROLE x , x ; 
DROP ROLE x ; 
SET extra_float_digits TO 1 ; 
SELECT 'x' AS four , x ( x ) AS center FROM x ; 
@@SELECT 'x' AS four , ( x ) AS center FROM x ; 
SELECT 'x' AS six , x ( x ) AS center FROM x ; 
@@SELECT 'x' AS six , ( x ) AS center FROM x ; 
@@#SELECT 'x' AS two , ( x ) AS center FROM x WHERE ( x ) > 1 ; 
SELECT 'x' AS two , x . x FROM x p1 WHERE x ( x . x , x 'x' ) ; 
SELECT 'x' AS two , x . x FROM x p1 WHERE x . x ? - x 'x' ; 
SELECT 'x' AS one , x . x FROM x p1 WHERE x ( x . x , x 'x' ) ; 
SELECT 'x' AS one , x . x FROM x p1 WHERE x . x ? | x 'x' ; 
SELECT x . x , x . x , x ( x . x , x . x ) FROM x p1 , x p2 ; 
SELECT x . x , x . x , x . x + x . x FROM x p1 , x p2 ; 
SELECT x . x , x . x , x . x - x . x FROM x p1 , x p2 ; 
SELECT x . x , x . x , x . x * x . x FROM x p1 , x p2 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x * x . x FROM x p1 , x p2 WHERE x . x [ 1 ] < 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x p1 , x p2 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x p1 , x p2 WHERE x . x [ 1 ] > 1 ; 
~######@SELECT x . x , x . x FROM x p , x l WHERE x . x < x . x ; 
@@SELECT x . x , x . x FROM x p , x p1 WHERE x . x < x . x ; 
SELECT x FROM x WHERE ? | x ; 
SELECT x FROM x WHERE ? - x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x = x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? || x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? - | x . x ; 
#SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? x . x ; 
#SELECT x . x , x . x FROM x l , x b WHERE x . x ? x . x ; 
######@@SELECT x , - x FROM x ; 
@@SELECT x , x FROM x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x < x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x <= x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x >= x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x > x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x != x . x ; 
#SELECT x . x , x . x FROM x l , x l1 WHERE x . x ? x . x ; 
########@SELECT x . x , x . x FROM x l , x l1 WHERE x . x < x . x ; 
@SELECT x . x , x . x FROM x l , x b WHERE x . x < x . x ; 
SELECT 'x' AS six , x ( x ) AS box FROM x ; 
SELECT 'x' AS twentyfour , x . x + x . x AS translation FROM x b , x p ; 
SELECT 'x' AS twentyfour , x . x - x . x AS translation FROM x b , x p ; 
SELECT x . x , x . x , x . x * x . x FROM x b , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x * x . x FROM x b , x p WHERE x . x [ 1 ] > 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x b , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x ( x . x , x . x ) FROM x a , x b ; 
#SELECT x , x ( x ) FROM x ; 
@@@@SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x < x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x <= x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x = x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x >= x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x > x . x ; 
SELECT x . x , x . x , x . x + x . x FROM x p , x p1 ; 
SELECT x . x , x . x , x . x - x . x FROM x p , x p1 ; 
SELECT x . x , x . x , x . x * x . x FROM x p , x p1 ; 
SELECT x . x , x . x , x . x / x . x FROM x p , x p1 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
~@SELECT 'x' AS twentyfour , x . x , x . x , x . x > x . x AS contains FROM x poly , x p ; 
@SELECT 'x' AS twentyfour , x . x , x . x , x . x < x . x AS contained FROM x poly , x p ; 
SELECT 'x' AS four , x ( x ) AS npoints , x AS polygon FROM x ; 
SELECT 'x' AS four , x ( x ) FROM x ; 
SELECT 'x' AS four , x ( x ) FROM x WHERE x ( x ) ; 
SELECT 'x' AS four , x AS open_path , x ( x ( x ) ) AS polygon FROM x WHERE x ( x ) ; 
~@@SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x && x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & < x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & > x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & < | x . x ; 
SELECT 'x' AS six , x ( x , 1.000000 ) FROM x ; 
#SELECT 'x' AS two , x ( x ) FROM x WHERE ( x ) >= 1 ; 
SELECT x , x ( 1 , x ) FROM x WHERE x >= 'x' ; 
SELECT x , x ( 1 , x ) FROM x WHERE x < 'x' ; 
~SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x = x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x && x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & < x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & > x . x ; 
@SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x < x . x ; 
@SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x > x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & < | x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x != x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x <= x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x >= x . x ; 
SELECT x . x , x . x , x . x + x . x FROM x c , x p ; 
SELECT x . x , x . x , x . x - x . x FROM x c , x p ; 
SELECT x . x , x . x , x . x * x . x FROM x c , x p ; 
SELECT x . x , x . x , x . x / x . x FROM x c , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x c , x p WHERE x . x [ 1 ] > 1 ; 
~CREATE TABLE x ( x int4 , x point ) ; 
CREATE INDEX x ON x USING spgist ( x ) WITH ( fillfactor = 1 ) ; 
INSERT INTO x ( x , x ) SELECT x , x ( x * 1 , x * 1 ) FROM x ( 1 , 1 ) g ; 
DELETE FROM x WHERE x < 1 ; 
VACUUM x ; 
INSERT INTO x ( x , x ) SELECT x + 1 , x ( x * 1 + 1 , x * 1 + 1 ) FROM x ( 1 , 1 ) g ; 
DELETE FROM x WHERE x % 1 = 1 ; 
CREATE TABLE x ( x serial , x box ) ; 
INSERT INTO x ( x ) SELECT x ( x ( x , x ) , x ( x + x , x + x ) ) FROM x ( 1 , 1 , 1 ) i , x ( 1 , 1 , 1 ) j , x ( 1 , 1 ) s ; 
CREATE INDEX x ON x USING spgist ( x ) ; 
SELECT x ( * ) FROM ( VALUES ( x ( 1 , 1 ) ) , ( x ( 1 , 1 ) ) , ( x ( 1 , 1 ) ) ) v ( p ) WHERE EXISTS ( SELECT * FROM x b WHERE x . x && x ( x . x , x . x ) ) ; 
CREATE TABLE x ( x int4 , x TEXT ) ; 
INSERT INTO x ( x , x ) SELECT - x , 'x' || x ( 'x' , 1 - x ) || 'x' FROM x ( 1 , 1 ) g ; 
ALTER INDEX x SET ( fillfactor = 1 ) ; 
REINDEX INDEX x ; 
BEGIN ; 
DECLARE foo13 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo14 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo15 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo16 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo17 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo18 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo19 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo20 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo21 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo22 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo23 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo24 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo25 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
FETCH ALL IN foo13 ; 
FETCH ALL IN foo14 ; 
FETCH ALL IN foo15 ; 
FETCH ALL IN foo16 ; 
FETCH ALL IN foo17 ; 
FETCH ALL IN foo18 ; 
FETCH ALL IN foo19 ; 
FETCH ALL IN foo20 ; 
FETCH ALL IN foo21 ; 
FETCH ALL IN foo22 ; 
FETCH ALL IN foo23 ; 
FETCH ALL IN foo24 ; 
FETCH ALL IN foo25 ; 
CLOSE foo13 ; 
CLOSE foo14 ; 
CLOSE foo15 ; 
CLOSE foo16 ; 
CLOSE foo17 ; 
CLOSE foo18 ; 
CLOSE foo19 ; 
CLOSE foo20 ; 
CLOSE foo21 ; 
CLOSE foo22 ; 
CLOSE foo23 ; 
CLOSE foo24 ; 
CLOSE foo25 ; 
END ; 
DECLARE c1 CURSOR FOR SELECT * FROM x LIMIT 1 ; 
FETCH ALL IN c1 ; 
FETCH 1 IN c1 ; 
FETCH BACKWARD 1 IN c1 ; 
FETCH BACKWARD ALL IN c1 ; 
DECLARE c2 CURSOR FOR SELECT * FROM x LIMIT 1 ; 
FETCH ALL IN c2 ; 
FETCH 1 IN c2 ; 
FETCH BACKWARD 1 IN c2 ; 
FETCH BACKWARD ALL IN c2 ; 
DECLARE c3 CURSOR FOR SELECT * FROM x OFFSET 1 ; 
FETCH ALL IN c3 ; 
FETCH 1 IN c3 ; 
FETCH BACKWARD 1 IN c3 ; 
FETCH BACKWARD ALL IN c3 ; 
DECLARE c4 CURSOR FOR SELECT * FROM x OFFSET 1 ; 
FETCH ALL IN c4 ; 
FETCH 1 IN c4 ; 
FETCH BACKWARD 1 IN c4 ; 
FETCH BACKWARD ALL IN c4 ; 
ROLLBACK ; 
CREATE TEMP SEQUENCE x ; 
SELECT x , x , x ( 'x' ) FROM x ORDER BY x LIMIT 1 ; 
SELECT x ( 'x' ) ; 
SELECT x , x , x ( 1 , 1 ) FROM x ORDER BY x LIMIT 1 ; 
SELECT x ( x ) AS s1 , x ( x ) + x ( ) * 1 AS s2 FROM x GROUP BY x ORDER BY x LIMIT 1 ; 
SET client_min_messages TO 'x' ; 
DROP ROLE IF EXISTS x ; 
CREATE USER x ; 
SET search_path TO 'x' ; 
CREATE FOREIGN DATA WRAPPER addr_fdw ; 
CREATE SERVER addr_fserv FOREIGN DATA WRAPPER addr_fdw ; 
CREATE TEXT SEARCH TEMPLATE addr_ts_temp ( lexize = dsimple_lexize ) ; 
CREATE TABLE x . gentable ( x serial PRIMARY KEY CONSTRAINT a_chk CHECK ( x > 1 ) , x TEXT DEFAULT 'x' ) ; 
CREATE VIEW x . genview AS SELECT * FROM x . gentable ; 
CREATE MATERIALIZED VIEW x . genmatview AS SELECT * FROM x . gentable ; 
CREATE TYPE addr_nsp . gencomptype AS ( a INT ) ; 
CREATE TYPE addr_nsp . genenum AS ENUM ( 'x' , 'x' ) ; 
CREATE FOREIGN TABLE x . genftable ( x INT ) SERVER addr_fserv ; 
CREATE AGGREGATE addr_nsp . genaggr ( int4 ) ( sfunc = int4pl , stype = int4 ) ; 
CREATE TRIGGER x BEFORE INSERT ON x . gentable FOR EACH ROW EXECUTE PROCEDURE addr_nsp . trig ( ) ; 
CREATE POLICY genpol ON x . gentable ; 
CREATE SERVER integer" FOREIGN DATA WRAPPER addr_fdw ; 
CREATE USER MAPPING FOR x SERVER integer" ; 
ALTER DEFAULT PRIVILEGES FOR ROLE x IN SCHEMA public GRANT ALL ON TABLES TO x ; 
CREATE PUBLICATION addr_pub FOR TABLE x . gentable ; 
CREATE STATISTICS addr_nsp . gentable_stat ON x , x FROM x . gentable ; 
SELECT x ( 'x' , 'x' , 'x' ) ; 
$$$$SELECT * FROM x ( 'x' , 'x' , 'x' ) ; 
$$$$DROP FOREIGN DATA WRAPPER addr_fdw CASCADE ; 
DROP PUBLICATION addr_pub ; 
DROP SUBSCRIPTION regress_addr_sub ; 
DROP SCHEMA addr_nsp CASCADE ; 
DROP OWNED BY x ; 
DROP USER x ; 
DROP TABLE IF EXISTS x ; 
CREATE TABLE x ( x INT , x TEXT ) ; 
DROP VIEW IF EXISTS x ; 
CREATE VIEW x AS SELECT * FROM x ; 
DROP INDEX x ; 
DROP INDEX IF EXISTS x ; 
CREATE INDEX x ON x ( x ) ; 
DROP SEQUENCE x ; 
DROP SEQUENCE IF EXISTS x ; 
CREATE SEQUENCE x ; 
DROP SCHEMA test_schema_exists ; 
DROP SCHEMA IF EXISTS test_schema_exists ; 
DROP TYPE test_type_exists ; 
DROP TYPE IF EXISTS test_type_exists ; 
CREATE TYPE test_type_exists AS ( a INT , b TEXT ) ; 
DROP DOMAIN test_domain_exists ; 
DROP DOMAIN IF EXISTS test_domain_exists ; 
CREATE GROUP x ; 
DROP USER IF EXISTS x , x ; 
DROP ROLE IF EXISTS x , x ; 
DROP GROUP x ; 
DROP GROUP IF EXISTS x , x ; 
DROP COLLATION IF EXISTS x ; 
DROP CONVERSION x ; 
DROP CONVERSION IF EXISTS x ; 
CREATE CONVERSION test_conversion_exists FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
DROP TEXT SEARCH PARSER x ; 
DROP TEXT SEARCH PARSER IF EXISTS x ; 
DROP TEXT SEARCH DICTIONARY x ; 
DROP TEXT SEARCH DICTIONARY IF EXISTS x ; 
DROP TEXT SEARCH TEMPLATE x ; 
DROP TEXT SEARCH TEMPLATE IF EXISTS x ; 
DROP TEXT SEARCH CONFIGURATION x ; 
DROP TEXT SEARCH CONFIGURATION IF EXISTS x ; 
DROP EXTENSION test_extension_exists ; 
DROP EXTENSION IF EXISTS test_extension_exists ; 
DROP FUNCTION x ( ) ; 
DROP FUNCTION IF EXISTS x ( ) ; 
DROP FUNCTION x ( INT , TEXT , INT [ ] ) ; 
DROP FUNCTION IF EXISTS x ( INT , TEXT , INT [ ] ) ; 
DROP AGGREGATE x ( * ) ; 
DROP AGGREGATE IF EXISTS x ( * ) ; 
DROP AGGREGATE x ( INT ) ; 
DROP AGGREGATE IF EXISTS x ( INT ) ; 
@#@@#@@#@@#@DROP LANGUAGE test_language_exists ; 
DROP LANGUAGE IF EXISTS test_language_exists ; 
DROP CAST ( TEXT AS TEXT ) ; 
DROP CAST IF EXISTS ( TEXT AS TEXT ) ; 
DROP TRIGGER test_trigger_exists ON test_exists ; 
DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists ; 
DROP TRIGGER test_trigger_exists ON no_such_table ; 
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table ; 
DROP TRIGGER test_trigger_exists ON no_such_schema . no_such_table ; 
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema . no_such_table ; 
CREATE TRIGGER x BEFORE UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP RULE test_rule_exists ON test_exists ; 
DROP RULE IF EXISTS test_rule_exists ON test_exists ; 
DROP RULE test_rule_exists ON no_such_table ; 
DROP RULE IF EXISTS test_rule_exists ON no_such_table ; 
DROP RULE test_rule_exists ON no_such_schema . no_such_table ; 
DROP RULE IF EXISTS test_rule_exists ON no_such_schema . no_such_table ; 
DROP FOREIGN DATA WRAPPER test_fdw_exists ; 
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists ; 
DROP SERVER test_server_exists ; 
DROP SERVER IF EXISTS test_server_exists ; 
DROP OPERATOR CLASS test_operator_class USING btree ; 
DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree ; 
DROP OPERATOR CLASS test_operator_class USING no_such_am ; 
DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am ; 
DROP OPERATOR FAMILY test_operator_family USING btree ; 
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree ; 
DROP OPERATOR FAMILY test_operator_family USING no_such_am ; 
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am ; 
DROP ACCESS METHOD no_such_am ; 
DROP ACCESS METHOD IF EXISTS no_such_am ; 
DROP AGGREGATE IF EXISTS no_such_schema . foo ( INT ) ; 
DROP AGGREGATE IF EXISTS x ( no_such_type ) ; 
DROP AGGREGATE IF EXISTS x ( no_such_schema . no_such_type ) ; 
DROP CAST IF EXISTS ( INTEGER AS no_such_type2 ) ; 
DROP CAST IF EXISTS ( no_such_type1 AS INTEGER ) ; 
DROP CAST IF EXISTS ( INTEGER AS no_such_schema . bar ) ; 
DROP CAST IF EXISTS ( no_such_schema . foo AS INTEGER ) ; 
DROP COLLATION IF EXISTS x . foo ; 
DROP CONVERSION IF EXISTS x . foo ; 
DROP DOMAIN IF EXISTS no_such_schema . foo ; 
DROP FOREIGN TABLE IF EXISTS x . foo ; 
DROP FUNCTION IF EXISTS no_such_schema . foo ( ) ; 
DROP FUNCTION IF EXISTS x ( no_such_type ) ; 
DROP FUNCTION IF EXISTS x ( no_such_schema . no_such_type ) ; 
DROP INDEX IF EXISTS x . foo ; 
DROP MATERIALIZED VIEW IF EXISTS x . foo ; 
DROP OPERATOR IF EXISTS no_such_schema . + ( INT , INT ) ; 
DROP OPERATOR IF EXISTS + ( no_such_type , no_such_type ) ; 
DROP OPERATOR IF EXISTS + ( no_such_schema . no_such_type , no_such_schema . no_such_type ) ; 
#DROP OPERATOR CLASS IF EXISTS no_such_schema . widget_ops USING btree ; 
DROP OPERATOR FAMILY IF EXISTS no_such_schema . float_ops USING btree ; 
DROP RULE IF EXISTS foo ON no_such_schema . bar ; 
DROP SEQUENCE IF EXISTS x . foo ; 
DROP TABLE IF EXISTS x . foo ; 
DROP TEXT SEARCH CONFIGURATION IF EXISTS x . foo ; 
DROP TEXT SEARCH DICTIONARY IF EXISTS x . foo ; 
DROP TEXT SEARCH PARSER IF EXISTS x . foo ; 
DROP TEXT SEARCH TEMPLATE IF EXISTS x . foo ; 
DROP TRIGGER IF EXISTS foo ON no_such_schema . bar ; 
DROP TYPE IF EXISTS no_such_schema . foo ; 
DROP VIEW IF EXISTS x . foo ; 
$$$$DROP FUNCTION test_ambiguous_funcname ; 
DROP FUNCTION IF EXISTS test_ambiguous_funcname ; 
DROP FUNCTION x ( INT ) ; 
DROP FUNCTION x ( TEXT ) ; 
$$$$DROP PROCEDURE test_ambiguous_procname ; 
DROP PROCEDURE IF EXISTS test_ambiguous_procname ; 
DROP ROUTINE IF EXISTS test_ambiguous_procname ; 
DROP PROCEDURE x ( INT ) ; 
DROP PROCEDURE x ( TEXT ) ; 
DROP DATABASE x ( FORCE ) ; 
DROP DATABASE x WITH ( FORCE ) ; 
DROP DATABASE IF EXISTS x ( FORCE ) ; 
DROP DATABASE IF EXISTS x WITH ( FORCE ) ; 
CREATE TYPE mood AS ENUM ( 'x' , 'x' , 'x' ) ; 
DROP TYPE mood ; 
CREATE TABLE x ( x int8 , x int8 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) ; 
INSERT INTO x VALUES ( + 1 , 'x' ) ; 
INSERT INTO x ( x ) VALUES ( 'x' ) ; 
SELECT * FROM x ; 
SELECT * FROM x WHERE x = 1 ; 
SELECT * FROM x WHERE x < 1 ; 
SELECT * FROM x WHERE x > 1 ; 
SELECT * FROM x WHERE x <= 1 ; 
SELECT * FROM x WHERE x >= 1 ; 
SELECT * FROM x WHERE 1 = x ; 
SELECT * FROM x WHERE 1 < x ; 
SELECT * FROM x WHERE 1 > x ; 
SELECT * FROM x WHERE 1 <= x ; 
SELECT * FROM x WHERE 1 >= x ; 
SELECT 'x' AS five , x AS plus , - x AS minus FROM x ; 
SELECT 'x' AS five , x , x , x + x AS plus FROM x ; 
SELECT 'x' AS five , x , x , x - x AS minus FROM x ; 
SELECT 'x' AS three , x , x , x * x AS multiply FROM x ; 
SELECT 'x' AS three , x , x , x * x AS multiply FROM x WHERE x < 1 OR ( x > 1 AND x < 1 ) ; 
SELECT 'x' AS five , x , x , x / x AS divide , x % x AS mod FROM x ; 
SELECT 'x' AS five , x , x ( x ) FROM x ; 
SELECT 1 + x AS plus4 FROM x ; 
SELECT 1 - x AS minus4 FROM x ; 
SELECT 'x' AS five , 1 * x AS twice int4" FROM x ; 
SELECT 'x' AS five , x * 1 AS twice int4" FROM x ; 
SELECT x ( x ) , x ( x ) FROM x ; 
SELECT 'x' AS to_char_1 , x ( x , 'x' ) , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_2 , x ( x , 'x' ) , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_3 , x ( ( x * 1 ) , 'x' ) , x ( ( x * 1 ) , 'x' ) FROM x ; 
SELECT 'x' AS to_char_4 , x ( ( x * 1 ) , 'x' ) , x ( ( x * 1 ) , 'x' ) FROM x ; 
SELECT 'x' AS to_char_5 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_6 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_7 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_8 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_9 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_10 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_11 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_12 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_13 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_14 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_15 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_16 , x ( x , x 'x' ) FROM x ; 
SELECT 'x' AS to_char_17 , x ( x , 'x' ) FROM x ; 
SELECT CAST ( x AS int4 ) FROM x WHERE x = 1 ; 
SELECT CAST ( x AS int2 ) FROM x WHERE x = 1 ; 
SELECT CAST ( x AS float4 ) , CAST ( x AS float8 ) FROM x ; 
SELECT CAST ( x AS oid ) FROM x ; 
#ANALYZE x ; 
SELECT x , EXTRACT ( YEAR FROM x ) , x ( * ) FROM x GROUP BY 1 , 1 ORDER BY 1 , 1 ; 
\CREATE TABLE x ( x INT , x INT , x TEXT ) ; 
INSERT INTO x SELECT 1 , x , 'x' || x FROM x ( 1 , 1 ) x ; 
\CREATE TYPE complex AS ( r float8 , i float8 ) ; 
CREATE TYPE quad AS ( c1 complex , c2 complex ) ; 
INSERT INTO x VALUES ( 1 , ( ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) ) ) ; 
INSERT INTO x VALUES ( 1 , ( ( NULL , 1.000000 ) , ( 1.000000 , 1.000000 ) ) ) ; 
CREATE TEMP TABLE x ( x fullname , x date ) ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT NULL ; 
UPDATE x SET x . suffix = 'x' ; 
INSERT INTO x ( x , x . c1 . r , x . c2 . i ) VALUES ( 1 , 1 , 1 ) ; 
CREATE TEMP TABLE x ( x TEXT ) ; 
INSERT INTO x VALUES ( x ( 'x' , 1 ) ) ; 
~~~~~~SELECT ROW ( 1 , 1 ) IN ( ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ) ; 
CREATE TEMP TABLE x ( x TEXT , x TEXT ) ; 
INSERT INTO x SELECT 'x' , NULL FROM x ( 1 , 1 ) ; 
CREATE INDEX ON x ( x , x ) ; 
SET enable_sort = off ; 
EXPLAIN ( costs off ) SELECT x , x FROM x WHERE ( x , x ) > ( 'x' , 'x' ) ORDER BY x , x ; 
SELECT x , x FROM x WHERE ( x , x ) > ( 'x' , 'x' ) ORDER BY x , x ; 
RESET enable_sort ; 
SELECT ( ROW ( 1 , 1.000000 ) ) . f1 ; 
SELECT ( ROW ( 1 , 1.000000 ) ) . f2 ; 
SELECT ( x ) . f1 FROM ( SELECT ROW ( 1 , 1.000000 ) AS r ) ss ; 
SELECT ROW ( ) ; 
SELECT ROW ( ) IS NULL ; 
SELECT ROW ( ) = ROW ( ) ; 
SELECT ARRAY [ ROW ( 1 , 1 ) , ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ] ; 
SELECT ROW ( 1 , 1.000000 ) = ANY ( ARRAY [ ROW ( 1 , 1.000000 ) , ROW ( 1 , 1.000000 ) , ROW ( 1 , 1.000000 ) ] ) ; 
CREATE TYPE cantcompare AS ( p point , r float8 ) ; 
CREATE TEMP TABLE x ( x cantcompare ) ; 
INSERT INTO x VALUES ( 'x' ) ; 
CREATE TYPE testtype3 AS ( a INT , b TEXT ) ; 
CREATE TYPE testtype5 AS ( a INT ) ; 
CREATE TYPE testtype6 AS ( a INT , b point ) ; 
DROP TYPE testtype1 , testtype3 , testtype5 , testtype6 ; 
CREATE TYPE testtype1 AS ( a INT , b INT ) ; 
SELECT x . x , x . x = ROW ( 1 ) , x . x = ARRAY [ ROW ( 1 ) ] , x . x = ROW ( ROW ( 1 ) ) FROM x ( ARRAY [ ROW ( 1 , ROW ( 1 ) , ARRAY [ ROW ( 1 ) ] , ROW ( ROW ( 1 ) ) ) , ROW ( 1 , ROW ( 1 ) , ARRAY [ ROW ( 1 ) ] , ROW ( ROW ( 1 ) ) ) ] ) AS q ( a INT , b record , c record [ ] , d record ) ; 
DROP TYPE testtype1 , testtype2 , testtype3 , testtype4 , testtype5 , testtype6 ; 
CREATE TABLE x ( x SERIAL PRIMARY KEY , x BOOLEAN NOT NULL , x NUMERIC ) ; 
CREATE TYPE price_input AS ( id INTEGER , price NUMERIC ) ; 
CREATE TYPE price_key AS ( id INTEGER ) ; 
$$$$INSERT INTO x VALUES ( 1 , FALSE , 1 ) , ( 1 , FALSE , 1 ) , ( 1 , TRUE , 1.000000 ) ; 
CREATE TEMP TABLE x ( x INT , x TEXT ) ; 
$$$$$$$$$$$$$$SELECT x ( ROW ( 1 , 'x' ) ) ; 
SELECT CAST ( x AS TEXT ) FROM x ; 
$$SELECT x . x FROM x f ; 
SELECT x ( x ) FROM x f ; 
ALTER TABLE x ADD COLUMN x TEXT ; 
SELECT x ( x ) FROM x i ; 
SELECT x ( x ) FROM x i ( x , y ) ; 
CREATE TEMP VIEW x AS SELECT * FROM x ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x OFFSET 1 ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x OFFSET 1 ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x ) AS ss ( x , y ) ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x OFFSET 1 ) AS ss ( x , y ) ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM ( SELECT x , x FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ; 
SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ; 
SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ( a , b ) ; 
CREATE TEMP TABLE x AS SELECT * FROM x LIMIT 1 ; 
CREATE TEMP TABLE x ( ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 1 , 1 ) ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x OFFSET 1 ) r ; 
CREATE TABLE x ( x TEXT , x TEXT ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 'x' ) ; 
SELECT x . x FROM ( SELECT x AS d FROM x ) s ; 
SELECT ( x ) . a , ( x ) . b FROM ( SELECT x AS d FROM x ) s ; 
SELECT ( x ) . ctid FROM ( SELECT x AS d FROM x ) s ; 
SELECT x ( * ) AS should_be_1 FROM x ; 
SELECT x ( * ) AS should_be_2 FROM x ; 
SELECT x ( * ) AS should_be_3 FROM x ; 
COPY x TO 'x' ; 
\BEGIN TRANSACTION READ ONLY ; 
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ ; 
COMMIT ; 
ABORT ; 
START TRANSACTION ; 
SAVEPOINT s ; 
RELEASE SAVEPOINT s ; 
ROLLBACK TO SAVEPOINT s ; 
SET synchronous_commit = ON ; 
SHOW synchronous_commit ; 
RESET synchronous_commit ; 
DISCARD TEMP ; 
DISCARD ALL ; 
DECLARE hsc CURSOR FOR SELECT * FROM x ; 
FETCH NEXT FROM hsc ; 
FETCH FIRST FROM hsc ; 
FETCH LAST FROM hsc ; 
FETCH 1 FROM hsc ; 
CLOSE hsc ; 
PREPARE hsp AS SELECT x ( * ) FROM x ; 
$PREPARE hsp_noexec ( INTEGER ) AS INSERT INTO x VALUES ( 1 ) ; 
EXECUTE hsp ; 
DEALLOCATE hsp ; 
LOCK x IN ACCESS SHARE MODE ; 
LOCK x IN ROW SHARE MODE ; 
LOCK x IN ROW EXCLUSIVE MODE ; 
UNLISTEN a ; 
UNLISTEN * ; 
CHECKPOINT ; 
SELECT x ( ) ; 
SELECT x ( x ( ) ) ; 
_CREATE AGGREGATE x ( sfunc = int4_avg_accum , basetype = int4 , stype = int8 , finalfunc = int8_avg , initcond1 = 'x' ) ; 
COMMENT ON AGGREGATE x ( int4 ) IS 'x' ; 
COMMENT ON AGGREGATE x ( int4 ) IS NULL ; 
CREATE AGGREGATE x ( sfunc1 = int4pl , basetype = int4 , stype1 = int4 , initcond1 = 'x' ) ; 
CREATE AGGREGATE x ( sfunc = int8inc , basetype = 'x' , stype = int8 , initcond = 'x' ) ; 
CREATE AGGREGATE x ( any" ) ( sfunc = int8inc_any , stype = int8 , initcond = 'x' ) ; 
COMMENT ON AGGREGATE x ( * ) IS 'x' ; 
COMMENT ON AGGREGATE x ( any" ) IS 'x' ; 
CREATE AGGREGATE x ( int8 , int8 ) ( sfunc = sum3 , stype = int8 , initcond = 'x' ) ; 
CREATE TYPE aggtype AS ( a INTEGER , b INTEGER , c TEXT ) ; 
CREATE AGGREGATE x ( INTEGER , INTEGER , TEXT ) ( sfunc = aggf_trans , stype = aggtype [ ] , initcond = 'x' ) ; 
CREATE AGGREGATE x ( INTEGER , INTEGER , TEXT ) ( sfunc = aggfns_trans , stype = aggtype [ ] , sspace = 1 , initcond = 'x' ) ; 
CREATE AGGREGATE x ( VARIADIC items anyarray ) ( stype = anyelement , sfunc = least_accum ) ; 
ALTER AGGREGATE x ( float8 ORDER BY anyelement ) RENAME TO test_percentile_disc ; 
ALTER AGGREGATE x ( VARIADIC any" ORDER BY VARIADIC any" ) RENAME TO test_rank ; 
DROP AGGREGATE x ( NUMERIC ) ; 
DROP FUNCTION x ( int8 , int8 , int8 , int8 ) ; 
$$$$CREATE TABLE x ( x INTEGER PRIMARY KEY ) ; 
INSERT INTO x VALUES ( 1 ) ; 
@SELECT x 'x' ? 'x' ; 
@@@@@@@@@@@@@@@@@@@SELECT x ( 'x' , 'x' ) ; 
SELECT x ( 'x' , 'x' , silent => TRUE ) ; 
@@@@@@@@@@@@@@@@SELECT x ( 'x' , 'x' , silent => FALSE ) ; 
SELECT * FROM x ( 'x' , 'x' ) ; 
@@@@@@@@@@@@@SELECT x , x , x ( 'x' , 'x' , x ( 'x' , x , 'x' , x ) ) AS x && y" FROM ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) x ( x ) , ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) y ( y ) ; 
SELECT x , x , x ( 'x' , 'x' , x ( 'x' , x , 'x' , x ) ) AS x || y" FROM ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) x ( x ) , ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) y ( y ) ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SET TIME ZONE 'x' ; 
SET TIME ZONE DEFAULT ; 
SELECT x ( 'x' , 'x' , vars => 'x' ) ; 
@@@@@@CREATE TABLE x ( x TEXT ) ; 
SELECT 'x' AS two , * FROM x ; 
SELECT x ( 1 ) ; 
SELECT 'x' || 1 + 1 ; 
SELECT 1 || 1.000000 ; 
SELECT x ( 1 , 1 , 1 , 'x' , TRUE , FALSE , x ( 'x' , 'x' ) ) ; 
SELECT x ( 'x' , 1 , 1 , 1 , 'x' , TRUE , FALSE , x ( 'x' , 'x' ) ) ; 
SELECT x ( 'x' , 1 , 1 , NULL , 1 ) ; 
SELECT x ( NULL , 1 , 1 , NULL , 1 ) IS NULL ; 
SELECT x ( x 'x' ) ; 
SELECT x ( VARIADIC ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT x ( 'x' , VARIADIC 1 ) ; 
SELECT x ( 'x' , 1 ) ; 
SELECT x ( 'x' , 'x' , 1 , 'x' ) ; 
SELECT x ( 'x' , 'x' , NULL , 'x' ) ; 
SELECT x ( 'x' , 'x' , 1 , NULL ) ; 
SELECT x ( 'x' , NULL , 1 , 'x' ) ; 
SELECT x ( 'x' , 1 , 1 , 1 ) ; 
SELECT x ( 'x' , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ 'x' , 'x' ] ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ 1 , 1 ] ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ TRUE , FALSE ] ) ; 
SELECT x ( x ( 'x' , 'x' ) , VARIADIC x ( x ) ) FROM x ( 1 , 1 ) g ( i ) ; 
SELECT x ( 'x' , NULL ) ; 
SELECT x ( 'x' , 1 , 'x' ) ; 
SELECT x ( 'x' , 1 , NULL ) ; 
SELECT x ( 'x' , NULL , 'x' ) ; 
CREATE TYPE shell ; 
CREATE TYPE int42 ; 
CREATE TYPE text_w_default ; 
CREATE FUNCTION x ( cstring ) RETURNS int42 AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( int42 ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( cstring ) RETURNS text_w_default AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( text_w_default ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE TABLE x ( x text_w_default , x int42 ) ; 
INSERT INTO x DEFAULT VALUES ; 
CREATE TYPE case_int42 ( Internallength" = 1 , Input" = int42_in , Output" = int42_out , Alignment" = int4 , Default" = 1 , Passedbyvalue" ) ; 
CREATE TYPE default_test_row AS ( f1 text_w_default , f2 int42 ) ; 
SELECT * FROM x ( ) ; 
COMMENT ON TYPE bad IS 'x' ; 
COMMENT ON TYPE default_test_row IS 'x' ; 
COMMENT ON TYPE default_test_row IS NULL ; 
COMMENT ON COLUMN default_test_row . nope IS 'x' ; 
COMMENT ON COLUMN default_test_row . f1 IS 'x' ; 
COMMENT ON COLUMN default_test_row . f1 IS NULL ; 
CREATE FUNCTION x ( cstring ) RETURNS opaque AS 'x' LANGUAGE internal IMMUTABLE STRICT ; 
CREATE FUNCTION x ( opaque ) RETURNS opaque AS 'x' LANGUAGE internal IMMUTABLE STRICT ; 
INSERT INTO x VALUES ( 'x' ) , ( 'x' ) ; 
TABLE x ; 
CREATE DOMAIN domaindroptest int4 ; 
COMMENT ON DOMAIN domaindroptest IS 'x' ; 
CREATE DOMAIN dependenttypetest domaindroptest ; 
DROP DOMAIN domaindroptest ; 
DROP DOMAIN domaindroptest CASCADE ; 
CREATE DOMAIN domainvarchar VARCHAR ( 1 ) ; 
CREATE DOMAIN domainnumeric NUMERIC ( 1 , 1 ) ; 
CREATE DOMAIN domainint4 int4 ; 
CREATE DOMAIN domaintext TEXT ; 
SELECT CAST ( 'x' AS domainvarchar ) ; 
CREATE TABLE x ( x domainint4 , x domaintext , x domainvarchar , x domainnumeric ) ; 
DROP DOMAIN domainvarchar RESTRICT ; 
DROP DOMAIN domainnumeric RESTRICT ; 
DROP DOMAIN domainint4 RESTRICT ; 
DROP DOMAIN domaintext ; 
CREATE DOMAIN domainint4arr int4 [ 1 ] ; 
CREATE DOMAIN domainchar4arr VARCHAR ( 1 ) [ 1 ] [ 1 ] ; 
CREATE TABLE x ( x domainint4arr , x domainchar4arr ) ; 
INSERT INTO x VALUES ( NULL , 'x' ) ; 
INSERT INTO x ( x [ 1 ] , x [ 1 ] ) VALUES ( 1 , 1 ) ; 
SELECT x [ 1 ] , x [ 1 : 1 ] FROM x ; 
COPY x FROM STDIN ; 
{UPDATE x SET x [ 1 ] = x [ 1 ] + 1 , x [ 1 ] = x [ 1 ] - 1 WHERE x IS NULL ; 
SELECT * FROM x WHERE x IS NULL ; 
DROP DOMAIN domainint4arr RESTRICT ; 
DROP DOMAIN domainchar4arr RESTRICT ; 
CREATE DOMAIN dia AS INT [ ] ; 
CREATE TYPE comptype AS ( r float8 , i float8 ) ; 
CREATE DOMAIN dcomptype AS comptype ; 
CREATE TABLE x ( x dcomptype UNIQUE ) ; 
SELECT ( x ) . r , ( x ) . i , ( x ) . * FROM x ; 
UPDATE x SET x . r = ( x ) . r + 1 WHERE ( x ) . i > 1 ; 
INSERT INTO x ( x . r , x . i ) VALUES ( 1 , 1 ) ; 
CREATE RULE silly AS ON DELETE TO x DO INSTEAD UPDATE x SET x . r = ( x ) . r - 1 , x . i = ( x ) . i + 1 WHERE ( x ) . i > 1 ; 
DROP TYPE comptype CASCADE ; 
COMMENT ON CONSTRAINT c1 ON DOMAIN dcomptype IS 'x' ; 
CREATE DOMAIN dcomptypea AS comptype [ ] ; 
CREATE TABLE x ( x dcomptypea UNIQUE ) ; 
INSERT INTO x ( x [ 1 ] . r ) VALUES ( 1 ) ; 
SELECT x [ 1 ] , x [ 1 ] . x , x [ 1 ] . x FROM x ; 
UPDATE x SET x [ 1 ] = ROW ( x [ 1 ] . x , x [ 1 ] . x ) ; 
UPDATE x SET x [ 1 ] . r = x [ 1 ] . x + 1 WHERE x [ 1 ] . x > 1 ; 
INSERT INTO x ( x [ 1 ] . r , x [ 1 ] . i ) VALUES ( 1 , 1 ) ; 
CREATE RULE silly AS ON DELETE TO x DO INSTEAD UPDATE x SET x [ 1 ] . r = x [ 1 ] . x - 1 , x [ 1 ] . i = x [ 1 ] . x + 1 WHERE x [ 1 ] . x > 1 ; 
CREATE TABLE x ( x posint [ ] ) ; 
INSERT INTO x VALUES ( ARRAY [ 1 ] ) ; 
CREATE DOMAIN vc4 AS VARCHAR ( 1 ) ; 
CREATE TABLE x ( x vc4 [ ] ) ; 
DROP TYPE vc4 ; 
CREATE DOMAIN dposinta AS posint [ ] ; 
CREATE TABLE x ( x dposinta [ ] ) ; 
SELECT x ( x ) FROM x ; 
SELECT x ( x [ 1 ] ) FROM x ; 
SELECT x ( x [ 1 ] [ 1 ] ) FROM x ; 
SELECT x ( ( x [ 1 ] ) [ 1 ] ) FROM x ; 
UPDATE x SET x [ 1 ] = ARRAY [ 1 ] ; 
SELECT x , x [ 1 ] , ( x [ 1 ] ) [ 1 ] FROM x ; 
UPDATE x SET x [ 1 ] [ 1 ] = ARRAY [ 1 ] ; 
DROP DOMAIN posint CASCADE ; 
CREATE DOMAIN dnotnull VARCHAR ( 1 ) NOT NULL ; 
CREATE DOMAIN dnull VARCHAR ( 1 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( NULL , 'x' , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 'x' , NULL , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , NULL , 'x' , 'x' ) ; 
SELECT CAST ( 'x' AS dnotnull ) ; 
DROP DOMAIN dnotnull RESTRICT ; 
DROP DOMAIN dnull RESTRICT ; 
DROP DOMAIN dcheck RESTRICT ; 
CREATE DOMAIN ddef1 int4 DEFAULT 1 ; 
CREATE DOMAIN ddef2 oid DEFAULT 'x' ; 
CREATE DOMAIN ddef3 TEXT DEFAULT 1 ; 
CREATE DOMAIN ddef4 int4 DEFAULT x ( 'x' ) ; 
CREATE DOMAIN ddef5 NUMERIC ( 1 , 1 ) NOT NULL DEFAULT 'x' ; 
CREATE TABLE x ( x ddef1 , x ddef2 , x ddef3 , x ddef4 PRIMARY KEY , x ddef1 NOT NULL DEFAULT NULL , x ddef2 DEFAULT 'x' , x ddef4 DEFAULT 1 , x ddef5 ) ; 
COPY x ( x ) FROM STDIN ; 
DROP TABLE x CASCADE ; 
CREATE DOMAIN dnotnulltest INTEGER ; 
CREATE TABLE x ( x dnotnulltest , x dnotnulltest ) ; 
ALTER DOMAIN dnotnulltest SET NOT NULL ; 
UPDATE x SET x = NULL ; 
DROP DOMAIN dnotnulltest CASCADE ; 
CREATE TABLE x ( x ddef1 ) ; 
ALTER DOMAIN ddef1 SET DEFAULT 'x' ; 
ALTER DOMAIN ddef1 DROP DEFAULT ; 
CREATE DOMAIN con AS INTEGER ; 
CREATE TABLE x ( x con ) ; 
ALTER DOMAIN con DROP CONSTRAINT t ; 
ALTER DOMAIN con DROP CONSTRAINT nonexistent ; 
ALTER DOMAIN con DROP CONSTRAINT IF EXISTS nonexistent ; 
CREATE DOMAIN things AS INT ; 
CREATE TABLE x ( x things ) ; 
INSERT INTO x ( x ) VALUES ( 1 ) ; 
ALTER DOMAIN things VALIDATE CONSTRAINT meow ; 
UPDATE x SET x = 1 ; 
CREATE TABLE x ( x INTEGER ) ; 
CREATE DOMAIN dom AS INTEGER ; 
CREATE VIEW x AS SELECT CAST ( x AS dom ) FROM x ; 
INSERT INTO x ( x ) VALUES ( NULL ) ; 
ALTER DOMAIN dom SET NOT NULL ; 
DROP DOMAIN ddef1 RESTRICT ; 
DROP DOMAIN ddef2 RESTRICT ; 
DROP DOMAIN ddef3 RESTRICT ; 
DROP DOMAIN ddef4 RESTRICT ; 
DROP DOMAIN ddef5 RESTRICT ; 
CREATE DOMAIN vchar4 VARCHAR ( 1 ) ; 
DROP DOMAIN vchar4 CASCADE ; 
CREATE DOMAIN str_domain AS TEXT NOT NULL ; 
CREATE TABLE x ( x INT , x INT ) ; 
ALTER TABLE x ADD COLUMN x str_domain ; 
ALTER TABLE x ADD COLUMN x str_domain2 ; 
$EXECUTE s1 ( 1 ) ; 
$$$$$$CREATE TYPE ddtest1 AS ( f1 posint ) ; 
CREATE TABLE x ( x ddtest1 ) ; 
INSERT INTO x VALUES ( ROW ( 1 ) ) ; 
CREATE TABLE x ( x ddtest1 [ ] ) ; 
CREATE DOMAIN ddtest1d AS ddtest1 ; 
CREATE TABLE x ( x ddtest1d ) ; 
DROP DOMAIN ddtest1d ; 
CREATE DOMAIN ddtest1d AS ddtest1 [ ] ; 
CREATE TYPE rposint AS RANGE ( subtype = posint ) ; 
CREATE TABLE x ( x rposint ) ; 
DROP TYPE rposint ; 
CREATE TABLE x ( x posint2 ) ; 
DROP TYPE ddtest1 ; 
$$$$SELECT x ( 1.000000 ) ; 
CREATE DOMAIN mynums AS NUMERIC ( 1 , 1 ) [ 1 ] ; 
$$$$CREATE DOMAIN mynums2 AS mynums ; 
$$$$DROP FUNCTION x ( NUMERIC ) ; 
$$$$CREATE DOMAIN di AS INT ; 
$$$$$$$$DROP DOMAIN di ; 
CREATE TABLE x ( x inotnull ) ; 
INSERT INTO x VALUES ( NULL ) ; 
DROP DOMAIN inotnull ; 
DROP FUNCTION x ( anyelement , anyelement ) ; 
CREATE DOMAIN testdomain1 AS INT ; 
ALTER DOMAIN testdomain1 RENAME TO testdomain2 ; 
ALTER DOMAIN testdomain1 RENAME CONSTRAINT unsigned TO unsigned_foo ; 
ALTER DOMAIN testdomain1 DROP CONSTRAINT unsigned_foo ; 
DROP DOMAIN testdomain1 ; 
INSERT INTO x VALUES ( x ) ; 
$$$$$$SELECT x ( * ) > 1 FROM x ; 
CREATE TABLE x ( x float8 ) ; 
SELECT 'x' AS five , * FROM x ; 
SELECT 'x' AS one , x . * FROM x f WHERE x . x = 'x' ; 
SELECT 'x' AS three , x . * FROM x f WHERE 'x' > x . x ; 
SELECT 'x' AS three , x . * FROM x f WHERE x . x < 'x' ; 
SELECT 'x' AS four , x . * FROM x f WHERE 'x' >= x . x ; 
SELECT 'x' AS four , x . * FROM x f WHERE x . x <= 'x' ; 
SELECT 'x' AS three , x . x , x . x * 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS three , x . x , x . x + 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS three , x . x , x . x / 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS three , x . x , x . x - 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS one , x . x ^ 'x' AS square_f1 FROM x f WHERE x . x = 'x' ; 
@SELECT 'x' AS five , x . x , x . x AS abs_f1 FROM x f ; 
SELECT 'x' AS five , x . x , x ( x . x ) AS trunc_f1 FROM x f ; 
SELECT 'x' AS five , x . x , x ( x . x ) AS round_f1 FROM x f ; 
SELECT x ( x ) AS ceil_f1 FROM x f ; 
SELECT x ( x ) AS ceiling_f1 FROM x f ; 
SELECT x ( x ) AS floor_f1 FROM x f ; 
SELECT x ( x ) AS sign_f1 FROM x f ; 
SET extra_float_digits = 1 ; 
SELECT x ( x 'x' ) AS eight ; 
SELECT x ( x 'x' , x 'x' ) ; 
SELECT 'x' AS three , x . x , x ( x ( x . x ) ) AS exp_ln_f1 FROM x f WHERE x . x > 'x' ; 
UPDATE x SET x = x . x * 'x' WHERE x . x > 'x' ; 
SELECT 'x' AS bad , x . x * 'x' FROM x f ; 
SELECT 'x' AS bad , x . x ^ 'x' FROM x f ; 
SELECT 1 ^ 1 + 1 ^ 1 + 1 ^ 1.000000 + 1 ^ 1.000000 ; 
SELECT 'x' AS bad , x ( x . x ) FROM x f WHERE x . x = 'x' ; 
SELECT 'x' AS bad , x ( x . x ) FROM x f WHERE x . x < 'x' ; 
SELECT 'x' AS bad , x ( x . x ) FROM x f ; 
SELECT 'x' AS bad , x . x / 'x' FROM x f ; 
RESET extra_float_digits ; 
DELETE FROM x ; 
CREATE TYPE xfloat8 ; 
CREATE FUNCTION x ( cstring ) RETURNS xfloat8 IMMUTABLE STRICT LANGUAGE internal AS 'x' ; 
CREATE FUNCTION x ( xfloat8 ) RETURNS cstring IMMUTABLE STRICT LANGUAGE internal AS 'x' ; 
CREATE CAST ( xfloat8 AS float8 ) WITHOUT FUNCTION ; 
CREATE CAST ( float8 AS xfloat8 ) WITHOUT FUNCTION ; 
CREATE CAST ( xfloat8 AS BIGINT ) WITHOUT FUNCTION ; 
CREATE CAST ( BIGINT AS xfloat8 ) WITHOUT FUNCTION ; 
DROP TYPE xfloat8 CASCADE ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) ; 
REFRESH MATERIALIZED VIEW x ; 
CREATE MATERIALIZED VIEW x AS SELECT x ( x ) AS grandtot FROM x ; 
CREATE UNIQUE INDEX x ON x ( ( x > 1 ) ) ; 
CREATE UNIQUE INDEX x ON x ( x ) WHERE x < 1 ; 
CREATE VIEW x AS SELECT x ( x ) AS grandtot FROM x ; 
EXPLAIN ( costs off ) CREATE MATERIALIZED VIEW x AS SELECT * FROM x ; 
CREATE MATERIALIZED VIEW x AS SELECT * FROM x ; 
ALTER MATERIALIZED VIEW x SET SCHEMA mvtest_mvschema ; 
SET search_path = mvtest_mvschema , public ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ; 
REFRESH MATERIALIZED VIEW CONCURRENTLY x ; 
RESET search_path ; 
EXPLAIN ( costs off ) SELECT * FROM x ; 
DROP MATERIALIZED VIEW IF EXISTS x ; 
REFRESH MATERIALIZED VIEW CONCURRENTLY x WITH NO DATA ; 
SELECT * FROM x FOR SHARE ; 
CREATE VIEW x AS SELECT 1 moo ; 
CREATE VIEW x AS SELECT x , 1 * x FROM x UNION ALL SELECT x , 1 * x FROM x ; 
CREATE MATERIALIZED VIEW x AS SELECT x , 1 * x FROM x UNION ALL SELECT x , 1 * x FROM x ; 
CREATE MATERIALIZED VIEW x AS SELECT * FROM x WHERE x = 1 ; 
DROP VIEW x CASCADE ; 
CREATE TABLE x ( x , x ) AS VALUES ( 1 , 1 ) ; 
CREATE UNIQUE INDEX ON x ( x ) ; 
INSERT INTO x SELECT * FROM x ; 
CREATE TABLE x ( x , x , x ) AS VALUES ( 1 , 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 ) ; 
CREATE MATERIALIZED VIEW x AS SELECT 1 AS col1 WITH NO DATA ; 
CREATE MATERIALIZED VIEW x AS SELECT * FROM x WHERE x = ( SELECT LEAST ( x ) FROM x ) WITH NO DATA ; 
DROP MATERIALIZED VIEW x CASCADE ; 
CREATE TABLE x ( x serial PRIMARY KEY , x box ) ; 
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ; 
CREATE UNIQUE INDEX x ON x ( x ) ; 
UPDATE x SET x = 'x' WHERE x = 1 ; 
SELECT * FROM x ORDER BY x ; 
UPDATE x SET x = 1 WHERE x = 1 ; 
DROP MATERIALIZED VIEW x ; 
CREATE TABLE x AS SELECT x ( 1 , 1 ) AS a ; 
CREATE MATERIALIZED VIEW x AS SELECT x FROM x WHERE x <= 1 ; 
DELETE FROM x WHERE EXISTS ( SELECT * FROM x WHERE x . x = x . x ) ; 
SET ROLE regress_user_mvtest ; 
CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT * FROM x ; 
DROP OWNED BY x CASCADE ; 
$$CREATE MATERIALIZED VIEW x AS SELECT 1 AS x WITH NO DATA ; 
$$SELECT x FROM x TABLESAMPLE x ( 1 ) REPEATABLE ( 1 ) ; 
SELECT x FROM x TABLESAMPLE x ( 1.000000 ) REPEATABLE ( 1 ) ; 
FETCH FIRST FROM tablesample_cur ; 
FETCH NEXT FROM tablesample_cur ; 
CLOSE tablesample_cur ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x TABLESAMPLE x ( 1 ) ; 
SELECT x ( * ) FROM x TABLESAMPLE x ( 1 ) ; 
SELECT x ( * ) FROM x ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT x ( * ) FROM x TABLESAMPLE x ( x ) ) ss ; 
EXPLAIN ( costs off ) SELECT x , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT * FROM x TABLESAMPLE x ( x ) ) ss GROUP BY x ; 
SELECT x , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT * FROM x TABLESAMPLE x ( x ) ) ss GROUP BY x ; 
SELECT x FROM x TABLESAMPLE x ( 1 ) ; 
WITH query_select AS ( SELECT * FROM x ) SELECT * FROM x TABLESAMPLE x ( 1.000000 ) REPEATABLE ( 1 ) ; 
CREATE TABLE x ( x INT ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x TABLESAMPLE x ( 1 ) ; 
DROP TABLE x , x , x ; 
$$$$SELECT * INTO TABLE x FROM x ; 
SELECT * INTO TABLE x FROM x WHERE x < 1 ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' ) ; 
UPDATE x SET x = 'x' ; 
CREATE TABLE x ( x int4 , x float4 , x polygon ) ; 
SET DateStyle = 'x' ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' ; 
SET datestyle TO dmy ; 
RESET datestyle ; 
SELECT TIME WITHOUT TIME ZONE 'x' ; 
SELECT TIME WITH TIME ZONE 'x' ; 
SELECT x 'x' AS Confucius' Birthday" ; 
SELECT x 'x' AS Julian Epoch" ; 
SELECT x 'x' + TIME 'x' AS Date + Time" ; 
SELECT x 'x' + TIME WITH TIME ZONE 'x' AS Date + Time PST" ; 
SELECT x 'x' + TIME WITH TIME ZONE 'x' AS Date + Time UTC" ; 
SELECT x 'x' + INTERVAL 'x' AS Add Two Years" ; 
SELECT x 'x' - INTERVAL 'x' AS Subtract Two Years" ; 
SELECT x 'x' - TIME 'x' AS Subtract Time" ; 
SELECT x 'x' - TIME WITH TIME ZONE 'x' AS Subtract Time UTC" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' AS Feb 29" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' AS Feb 28" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Dec 31" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Feb 23, 285506" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Jan 20, 288244" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Dec 31, 294276" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - TIMESTAMP WITHOUT TIME ZONE 'x' AS 106751991 Days" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' = ( TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' = ( TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' > 'x' ) AS True" ; 
SELECT x 'x' + TIME 'x' AS Jan_01_1994_11am" ; 
SELECT x 'x' + TIME 'x' AS Jan_01_1994_10am" ; 
SELECT x 'x' + x 'x' AS Jan_01_1994_8am" ; 
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_8am" ; 
SELECT 'x' AS 64" , x + INTERVAL 'x' AS one_year FROM x ; 
SELECT 'x' AS 64" , x - INTERVAL 'x' AS one_year FROM x ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Feb 29" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Feb 28" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Dec 31" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' = ( TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' = ( TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' > 'x' ) AS True" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Apr 3, 12:00" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Apr 3, 13:00" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Apr 2, 12:00" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Apr 2, 11:00" ; 
RESET TIME ZONE ; 
SELECT x ( x 'x' , TIME 'x' ) AS Jan_01_1994_10am" ; 
SELECT x ( x 'x' , TIME 'x' ) AS Jan_01_1994_9am" ; 
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_11am" ; 
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_10am" ; 
SELECT CAST ( TIME 'x' AS INTERVAL ) AS +01:02" ; 
SELECT CAST ( INTERVAL 'x' AS TIME ) AS 02:03:00" ; 
SELECT TIME 'x' + INTERVAL 'x' AS 03:31:00" ; 
SELECT TIME 'x' - INTERVAL 'x' AS 23:29:00" ; 
SELECT TIME 'x' + INTERVAL 'x' AS 14:31:00" ; 
SELECT TIME 'x' + INTERVAL 'x' AS 07:31:00" ; 
SELECT CAST ( TIME WITH TIME ZONE 'x' AS INTERVAL ) AS +00:01" ; 
SELECT CAST ( INTERVAL 'x' AS TIME WITH TIME ZONE ) AS 02:03:00-08" ; 
SELECT TIME WITH TIME ZONE 'x' - INTERVAL 'x' AS 23:29:00-08" ; 
SELECT TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS 14:31:00-08" ; 
SELECT CAST ( CAST ( x 'x' + TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS TIME WITH TIME ZONE ) AS TIME ) AS 07:31:00" ; 
SELECT CAST ( CAST ( x 'x' + TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS TIMESTAMP WITHOUT TIME ZONE ) AS TIME ) AS 07:31:00" ; 
SELECT x . x AS t , x . x AS i , x . x + x . x AS add" , x . x - x . x AS subtract" FROM x t , x i WHERE x . x BETWEEN 'x' AND 'x' AND x . x BETWEEN 'x' AND 'x' ORDER BY 1 , 1 ; 
SELECT x . x AS t , x . x AS i , x . x + x . x AS add" , x . x - x . x AS subtract" FROM x t , x i ORDER BY 1 , 1 ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS False" ; 
SELECT ( TIME 'x' , TIME 'x' ) OVERLAPS ( TIME 'x' , TIME 'x' ) AS True" ; 
SELECT ( TIME 'x' , INTERVAL 'x' ) OVERLAPS ( TIME 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIME 'x' , INTERVAL 'x' ) OVERLAPS ( TIME 'x' , INTERVAL 'x' ) AS False" ; 
CREATE TABLE x ( x TIMESTAMP WITH TIME ZONE ) ; 
INSERT INTO x ( x ) SELECT x FROM x WHERE x BETWEEN 'x' AND 'x' OR x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS 16" , x AS timestamp" FROM x ORDER BY x ; 
SELECT 'x' AS 160" , x . x AS timestamp" , x . x AS interval" , x . x + x . x AS plus FROM x d , x t ORDER BY x , x , x ; 
SELECT 'x' AS 160" , x . x AS timestamp" , x . x AS interval" , x . x - x . x AS minus FROM x d , x t WHERE x ( x . x ) ORDER BY x , x , x ; 
SELECT 'x' AS 16" , x . x AS timestamp" , TIMESTAMP WITH TIME ZONE 'x' AS gpstime_zero , x . x - TIMESTAMP WITH TIME ZONE 'x' AS difference FROM x d ORDER BY x ; 
SELECT 'x' AS 226" , x . x AS timestamp1 , x . x AS timestamp2 , x . x - x . x AS difference FROM x d1 , x d2 ORDER BY x , x , x ; 
SET DateStyle TO 'x' ; 
SHOW DateStyle ; 
SELECT 'x' AS 64" , x AS us_postgres FROM x ; 
SELECT 'x' AS 64" , x AS us_iso FROM x ; 
SELECT 'x' AS 64" , x AS us_sql FROM x ; 
SELECT x ( * ) AS one FROM x WHERE x = 'x' ; 
SELECT 'x' AS 65" , x AS european_postgres FROM x ; 
SELECT 'x' AS 65" , x AS european_iso FROM x ; 
SELECT 'x' AS 65" , x AS european_sql FROM x ; 
RESET DateStyle ; 
SELECT x ( 'x' , x 'x' ) ; 
SELECT x , x ( 'x' , 'x' || x ) FROM x ( 1 , 1 ) i ; 
SHOW TIME ZONE ; 
CREATE TEMP TABLE x ( x INT ) ; 
CREATE TEMP TABLE x ( x FLOAT ) ; 
INSERT INTO x VALUES ( 1.000000 ) ; 
\CREATE TEMP TABLE x ( x INT ) ON COMMIT DELETE ROWS ; 
CREATE INDEX ON x ( x ( 'x' ) ) ; 
CREATE TEMP TABLE x ( x ) ON COMMIT DELETE ROWS AS SELECT 1 ; 
CREATE TEMP TABLE x ( x INT ) ON COMMIT DROP ; 
CREATE TEMP TABLE x ( x ) ON COMMIT DROP AS SELECT 1 ; 
CREATE TABLE x ( x INT ) ON COMMIT DELETE ROWS ; 
CREATE TABLE x ( x ) ON COMMIT DELETE ROWS AS SELECT 1 ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY ) ; 
CREATE TEMP TABLE x ( x INT REFERENCES x ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x ( x INT REFERENCES x ) ; 
CREATE TABLE x . whereami ( x TEXT ) ; 
INSERT INTO x . whereami VALUES ( 'x' ) ; 
$$$$SET search_path = pg_temp , public ; 
SET search_path = public , pg_temp ; 
SELECT pg_temp . whoami ( ) ; 
DROP TABLE x . whereami ; 
SELECT pg_temp . nonempty ( 'x' ) ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ON COMMIT DROP ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT DROP ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) ; 
~SELECT x FROM x WHERE x 'x' ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT PRESERVE ROWS ; 
~SELECT x FROM x WHERE x 'x' ORDER BY x ; 
CREATE TEMP TABLE x ( ) INHERITS ( x ) ON COMMIT DELETE ROWS ; 
~CREATE TEMP TABLE x ( ) INHERITS ( x ) ON COMMIT DROP ; 
~$$PREPARE TRANSACTION 'x' ; 
$$DROP FUNCTION pg_temp . twophase_func ( ) ; 
@@CREATE TYPE pg_temp . twophase_type AS ( a INT ) ; 
CREATE VIEW x . twophase_view AS SELECT 1 ; 
CREATE SEQUENCE x . twophase_seq ; 
SELECT x FROM x ; 
LOCK x IN ACCESS EXCLUSIVE MODE ; 
\CREATE TABLE x ( x INT DEFAULT 1 , x INT , x TEXT ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x TEXT ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 1 ) ; 
UPDATE x SET x = DEFAULT , x = DEFAULT ; 
UPDATE x AS x SET x = 1 WHERE x . x = 1 ; 
UPDATE x x SET x = x . x + 1 WHERE x . x = 1 ; 
UPDATE x SET x = x . x FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
UPDATE x SET x = x . * FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
INSERT INTO x SELECT x , x + 1 , x FROM x ; 
UPDATE x SET ( x , x , x ) = ( 'x' , x + 1 , DEFAULT ) WHERE x = 'x' ; 
UPDATE x SET ( x , x ) = ( 'x' , x + x ) , x = x + 1 WHERE x = 1 ; 
UPDATE x SET ( x , x ) = ( SELECT x , x FROM x WHERE x = 1 AND x = 'x' ) WHERE x = 1 AND x = 1 ; 
UPDATE x x SET ( x , x ) = ( SELECT x + 1 , x FROM x i WHERE x . x = x . x AND x . x = x . x AND x . x IS NOT DISTINCT FROM x . x ) ; 
UPDATE x SET ( x , x ) = ( SELECT x + 1 , x FROM x ) ; 
UPDATE x SET ( x , x ) = ( SELECT x + 1 , x FROM x WHERE x = 1 ) WHERE x = 1 ; 
UPDATE x SET ( x , x ) = ROW ( x . * ) FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
UPDATE x SET ( x , x ) = ( x . * ) FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
UPDATE x AS x SET x = x . x + 1 WHERE x . x = 1 ; 
UPDATE x SET x = x ( 'x' , 1 ) WHERE x = 'x' ; 
SELECT x , x , x ( x ) FROM x ; 
UPDATE x x SET ( x , x ) = ( SELECT x , x FROM x s WHERE x . x = x . x ) WHERE CURRENT_USER = SESSION_USER ; 
INSERT INTO x VALUES ( 1 , 'x' ) ; 
WITH aaa AS ( SELECT 1 AS a , 'x' AS b ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET ( x , x ) = ( SELECT x , x FROM x ) RETURNING * ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET ( x , x ) = ( SELECT x || 'x' , x FROM x i WHERE x . x = x . x ) RETURNING * ; 
CREATE TABLE x ( x VARCHAR , x NUMERIC , x TEXT , x BIGINT , x INT ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' , 1 ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' , 1 ) ; 
UPDATE x SET x = x - 1 ; 
ALTER TABLE x DROP COLUMN x , DROP COLUMN x , DROP COLUMN x ; 
ALTER TABLE x ADD COLUMN x NUMERIC , ADD COLUMN x VARCHAR , ADD COLUMN x TEXT ; 
ALTER TABLE x DROP COLUMN x ; 
ALTER TABLE x ADD COLUMN x BIGINT ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
CREATE TABLE x ( x VARCHAR , x INT , x NUMERIC , x BIGINT , x TEXT ) ; 
\EXPLAIN ( costs off ) UPDATE x SET x = x - 1 WHERE x > 1 ; 
UPDATE x SET x = x - 1 , x = x WHERE x = 1 ; 
UPDATE x SET x = x - 1 WHERE x > 1 ; 
UPDATE x SET x = x ; 
UPDATE x SET x = x + 1 WHERE x = 1 ; 
UPDATE x SET x = x + 1 RETURNING x , x , x ; 
UPDATE x SET x = x - 1 WHERE x > 1 RETURNING * ; 
UPDATE x SET x = x - 1 WHERE x > 1 RETURNING x , x + x ; 
CREATE VIEW x AS SELECT * FROM x WHERE ( SELECT x > x FROM x ) WITH CHECK OPTION ; 
UPDATE x SET x = 'x' , x = 1 , x = 1 WHERE x = 1 ; 
UPDATE x SET x = 'x' , x = 1 WHERE x = 1 ; 
UPDATE x SET x = 1 WHERE x = 'x' AND x > 1 AND x > 1 RETURNING ( x ) , * ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = ( CASE WHEN x = 1 THEN 1 ELSE x + 1 END ) WHERE x = 'x' AND x > 1 AND x >= 1 ; 
CREATE TRIGGER x AFTER DELETE ON x REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER INSERT ON x REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = x + 1 WHERE x = 'x' AND x > 1 AND x >= 1 ; 
DROP TRIGGER trans_deletetrig ON range_parted ; 
DROP TRIGGER trans_inserttrig ON range_parted ; 
$$CREATE TRIGGER x BEFORE UPDATE OR INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER trans_updatetrig ON range_parted ; 
DROP TRIGGER trig_c1_100 ON part_c_1_100 ; 
DROP TRIGGER trig_d1_15 ON part_d_1_15 ; 
DROP TRIGGER trig_d15_20 ON part_d_15_20 ; 
ALTER TABLE x ENABLE ROW LEVEL SECURITY ; 
GRANT ALL ON x , x TO x ; 
CREATE POLICY seeall ON x AS PERMISSIVE FOR SELECT USING ( TRUE ) ; 
CREATE POLICY policy_range_parted ON x FOR UPDATE USING ( TRUE ) WITH CHECK ( x % 1 = 1 ) ; 
SET SESSION AUTHORIZATION regress_range_parted_user ; 
UPDATE x SET x = 'x' , x = 1 WHERE x = 'x' AND x = 1 ; 
$$CREATE TRIGGER x BEFORE INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER trig_d_1_15 ON part_d_1_15 ; 
CREATE POLICY policy_range_parted_subplan ON x AS RESTRICTIVE FOR UPDATE USING ( TRUE ) WITH CHECK ( ( SELECT x . x <= x FROM x ) ) ; 
DROP POLICY policy_range_parted ON range_parted ; 
DROP POLICY policy_range_parted_subplan ON range_parted ; 
DROP POLICY policy_range_parted_wholerow ON range_parted ; 
REVOKE ALL ON x , x FROM x ; 
$$CREATE TRIGGER x AFTER DELETE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER INSERT ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER parent_delete_trig ON range_parted ; 
DROP TRIGGER parent_update_trig ON range_parted ; 
DROP TRIGGER parent_insert_trig ON range_parted ; 
DROP TRIGGER c1_delete_trig ON part_c_1_100 ; 
DROP TRIGGER c1_update_trig ON part_c_1_100 ; 
DROP TRIGGER c1_insert_trig ON part_c_1_100 ; 
DROP TRIGGER d1_delete_trig ON part_d_1_15 ; 
DROP TRIGGER d1_update_trig ON part_d_1_15 ; 
DROP TRIGGER d1_insert_trig ON part_d_1_15 ; 
DROP TRIGGER d15_delete_trig ON part_d_15_20 ; 
DROP TRIGGER d15_update_trig ON part_d_15_20 ; 
DROP TRIGGER d15_insert_trig ON part_d_15_20 ; 
CREATE TABLE x PARTITION OF x DEFAULT ; 
INSERT INTO x VALUES ( 'x' , 1 ) ; 
UPDATE x SET x = 'x' WHERE x = 'x' ; 
CREATE TABLE x ( x TEXT , x INT ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' ) ; 
CREATE TABLE x ( x NUMERIC , x INT , x int8 ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( b ) ; 
CREATE TABLE x ( x INT , x int8 , x NUMERIC ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 ) ; 
CREATE TABLE x ( x NUMERIC , x INT , x int8 ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 , 1 ) ; 
UPDATE x SET x = x + x WHERE x = 1 ; 
$$DROP TRIGGER parted_mod_b ON sub_part1 ; 
$$CREATE TRIGGER x BEFORE DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER trig_skip_delete ON sub_part2 ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ; 
UPDATE x x SET x = 1 FROM x t2 WHERE x . x = x . x AND x = 1 ; 
$$CREATE TABLE x ( x INT , x INT ) PARTITION BY hash ( a custom_opclass , b custom_opclass ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES WITH ( modulus 1 , remainder 1 ) ; 
UPDATE x SET x = 1 , x = 1 WHERE x = 1 ; 
UPDATE x SET x = x - 1 WHERE x = 1 ; 
DROP OPERATOR CLASS custom_opclass USING hash ; 
DROP FUNCTION x ( a int4 , seed int8 ) ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO NOTHING ; 
CREATE UNIQUE INDEX x ON x ( x ( x ) COLLATE C" , x ( x ) text_pattern_ops ) ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) text_pattern_ops , x ( x ) COLLATE C" ) DO NOTHING ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) COLLATE C" , x ( x ) text_pattern_ops ) DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) ) DO UPDATE SET x = x . x ; 
CREATE UNIQUE INDEX x ON x ( x ( x ) ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) , x ( x ) ) DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) WHERE x LIKE 'x' DO UPDATE SET x = x . x ; 
CREATE TABLE x ( x BIGINT , x BIGINT ) ; 
CREATE UNIQUE INDEX x ON x ( COALESCE ( x , 1 ) ) ; 
CREATE UNIQUE INDEX x ON x ( x ) WHERE COALESCE ( x , 1 ) > 1 ; 
INSERT INTO x VALUES ( 1 , 1 ) ON CONFLICT ( COALESCE ( x , 1 ) ) DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 1 ) ON CONFLICT ( x ) WHERE COALESCE ( x , 1 ) > 1 DO NOTHING ; 
CREATE VIEW x AS SELECT * FROM x WITH CASCADED CHECK OPTION ; 
CREATE TABLE x ( x CHAR ( 1 ) ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 1 ) ; 
ALTER TABLE x DROP COLUMN x , DROP COLUMN x ; 
CREATE TABLE x ( x INT UNIQUE , x box , EXCLUDE USING gist ( x WITH && ) ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT ) ; 
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ON CONFLICT DO NOTHING ; 
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 1 ; 
CREATE TABLE x ( x INT UNIQUE , x CHAR ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x ( x UNIQUE ) FOR VALUES IN ( 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO NOTHING ; 
CREATE TABLE x ( x CHAR , x INT UNIQUE ) ; 
TRUNCATE x ; 
ALTER TABLE x DROP x , ADD x CHAR ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x = 'x' ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( a ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x = 'x' ; 
CREATE UNIQUE INDEX ON ONLY x ( x ) ; 
ALTER INDEX x ATTACH PARTITION x ; 
CREATE TABLE x ( x TEXT , x INT , x INT , x TEXT ) ; 
CREATE UNIQUE INDEX ON x ( x , x ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ON CONFLICT ( x , x ) DO UPDATE SET ( x , x , x ) = ROW ( x . * ) WHERE x = ( 1 , TEXT 'x' , 1 ) AND x = ( 1 , TEXT 'x' , 1 ) ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ON CONFLICT ( x , x ) DO UPDATE SET x = x . x + 1 ; 
##@#@#@#########$$$$SELECT FALSE <= 1 BETWEEN 1 AND 1 ; 
SELECT FALSE >= 1 BETWEEN 1 AND 1 ; 
BEGIN TRANSACTION ; 
GRANT USAGE ON SCHEMA schema_op1 TO x ; 
REVOKE USAGE ON SCHEMA schema_op1 FROM x ; 
SET ROLE regress_rol_op1 ; 
######$$$$#@##@##@#CREATE OPERATOR % ( leftarg = int8 ) ; 
CREATE TYPE type_op3 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$REVOKE USAGE ON TYPE type_op3 FROM x ; 
##CREATE TYPE type_op4 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$REVOKE USAGE ON TYPE type_op4 FROM x ; 
##CREATE TYPE type_op5 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$##CREATE TYPE type_op6 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$REVOKE USAGE ON TYPE type_op6 FROM x ; 
##CREATE SCHEMA x CREATE UNIQUE INDEX x ON x ( x ) CREATE VIEW x AS SELECT x + 1 AS a , x + 1 AS b FROM x CREATE TABLE x ( x serial , x INT UNIQUE ) ; 
SELECT x ( * ) FROM x WHERE x = ( SELECT x FROM x WHERE x = 'x' ) ; 
INSERT INTO x . abc DEFAULT VALUES ; 
SELECT * FROM x . abc ; 
SELECT * FROM x . abc_view ; 
ALTER SCHEMA x RENAME TO x ; 
DROP SCHEMA test_ns_schema_renamed CASCADE ; 
CREATE TABLE x ( x int4 ) ; 
COMMENT ON TABLE attmp_wrong IS 'x' ; 
COMMENT ON TABLE attmp IS 'x' ; 
COMMENT ON TABLE attmp IS NULL ; 
ALTER TABLE x ADD COLUMN x float8 ; 
ALTER TABLE x ADD COLUMN x float4 ; 
ALTER TABLE x ADD COLUMN x int2 ; 
ALTER TABLE x ADD COLUMN x polygon ; 
ALTER TABLE x ADD COLUMN x CHAR ; 
ALTER TABLE x ADD COLUMN x int4 ; 
ALTER TABLE x ADD COLUMN x tid ; 
ALTER TABLE x ADD COLUMN x xid ; 
ALTER TABLE x ADD COLUMN x oidvector ; 
ALTER TABLE x ADD COLUMN x BOOLEAN ; 
ALTER TABLE x ADD COLUMN x point ; 
ALTER TABLE x ADD COLUMN x lseg ; 
ALTER TABLE x ADD COLUMN x path ; 
ALTER TABLE x ADD COLUMN x box ; 
ALTER TABLE x ADD COLUMN x TIMESTAMP ; 
ALTER TABLE x ADD COLUMN x INTERVAL ; 
ALTER TABLE x ADD COLUMN x float8 [ ] ; 
ALTER TABLE x ADD COLUMN x float4 [ ] ; 
ALTER TABLE x ADD COLUMN x int2 [ ] ; 
INSERT INTO x ( x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x ) VALUES ( 1 , 'x' , 'x' , 1.000000 , 1.000000 , 1 , 'x' , 'x' , 1 , 'x' , 'x' , 'x' , TRUE , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
CREATE INDEX x ON x ( x , ( x + x ) , x ) ; 
ALTER INDEX x ALTER COLUMN 1 SET STATISTICS 1 ; 
ALTER TABLE x RENAME TO x ; 
ALTER INDEX x RENAME TO x ; 
SET ROLE regress_alter_table_user1 ; 
______ALTER INDEX IF EXISTS x RENAME TO x ; 
__CREATE VIEW x ( x ) AS SELECT x FROM x ; 
SET enable_seqscan TO off ; 
SET enable_bitmapscan TO off ; 
SELECT x FROM x WHERE x < 1 ; 
RESET enable_seqscan ; 
RESET enable_bitmapscan ; 
ALTER TABLE x ADD CONSTRAINT onek_unique1_constraint UNIQUE ( x ) ; 
ALTER TABLE x DROP CONSTRAINT onek_unique1_constraint_foo ; 
ALTER TABLE x ADD CONSTRAINT onek_check_constraint CHECK ( x >= 1 ) ; 
ALTER TABLE x RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo ; 
ALTER TABLE x DROP CONSTRAINT onek_check_constraint_foo ; 
CREATE TABLE x ( x INT CONSTRAINT con1 CHECK ( x > 1 ) , x INT , x INT ) ; 
CREATE TABLE x ( x INT CONSTRAINT con1 CHECK ( x > 1 ) , x INT ) INHERITS ( x ) ; 
CREATE TABLE x ( x INT , CONSTRAINT chk_a CHECK ( x > 1 ) , PRIMARY KEY ( x ) ) ; 
ALTER TABLE x RENAME CONSTRAINT chk_a TO chk_a_new ; 
ALTER TABLE x RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new ; 
CREATE TABLE x ( LIKE x INCLUDING ALL ) ; 
CREATE TABLE x ( x INT PRIMARY KEY ) ; 
CREATE TABLE x ( x INT , x INT , UNIQUE ( x , x ) ) ; 
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x MATCH FULL ; 
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x ( x ) MATCH FULL ; 
DELETE FROM x WHERE x = 1 ; 
ALTER TABLE x DROP CONSTRAINT attmpconstr ; 
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x MATCH FULL NOT VALID ; 
ALTER TABLE x VALIDATE CONSTRAINT attmpconstr ; 
CREATE TABLE x ( ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ; 
ALTER TABLE x ADD CONSTRAINT b_le_20 CHECK ( x <= 1 ) NOT VALID ; 
ALTER TABLE x ADD CONSTRAINT check_a_is_2 CHECK ( x = 1 ) NO INHERIT NOT VALID ; 
ALTER TABLE x VALIDATE CONSTRAINT check_a_is_2 ; 
DELETE FROM ONLY x ; 
SET constraint_exclusion TO 'x' ; 
CREATE TABLE x ( x date , CHECK ( FALSE ) NO INHERIT NOT VALID ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x BETWEEN 'x' AND 'x' ; 
ALTER TABLE x VALIDATE CONSTRAINT nv_child_2011_d_check ; 
CREATE TEMP TABLE x ( x inet ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ( x ) ; 
CREATE TEMP TABLE x ( x int8 ) ; 
CREATE TEMP TABLE x ( x NUMERIC ) ; 
CREATE TEMP TABLE x ( x NUMERIC PRIMARY KEY ) ; 
CREATE TEMP TABLE x ( x INT , x inet , PRIMARY KEY ( x , x ) ) ; 
CREATE TEMP TABLE x ( x cidr , x TIMESTAMP ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ; 
CREATE TEMP TABLE x ( x INT , x inet ) ; 
ALTER TABLE x ADD CONSTRAINT fknd FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ; 
ALTER TABLE x ADD CONSTRAINT fkdd FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED ; 
ALTER TABLE x ADD CONSTRAINT fkdi FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE ; 
ALTER TABLE x ADD CONSTRAINT fknd2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED ; 
ALTER TABLE x ALTER CONSTRAINT fknd2 NOT DEFERRABLE ; 
ALTER TABLE x ADD CONSTRAINT fkdd2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ; 
ALTER TABLE x ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED ; 
ALTER TABLE x ADD CONSTRAINT fkdi2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ; 
ALTER TABLE x ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 CHECK ( x > 1 ) ; 
CREATE TABLE x ( x INT , x INT , x INT ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 CHECK ( x + x < x * 1 ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 1 , 1 , 1 ) ; 
CREATE TABLE x ( x INT CHECK ( x > 1 ) , x INT ) ; 
ALTER TABLE x ADD CHECK ( x > x ) ; 
CREATE TABLE x ( x INT ) INHERITS ( x , x ) ; 
ALTER TABLE x ADD CONSTRAINT foo CHECK ( x > 1 ) ; 
ALTER TABLE x NO INHERIT x ; 
ALTER TABLE x INHERIT x ; 
ALTER TABLE x RENAME x TO x ; 
ALTER TABLE x ADD x bool ; 
ALTER TABLE x DROP x ; 
ALTER TABLE x ADD x INT ; 
UPDATE x SET x = 1 WHERE x IS NULL ; 
CREATE TABLE x ( x INT ) INHERITS ( x ) ; 
ALTER TABLE x ADD CONSTRAINT foo CHECK ( x > 1 ) NO INHERIT ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 UNIQUE ( x ) ; 
ALTER TABLE x ALTER COLUMN x TYPE INTEGER USING 1 ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 UNIQUE ( x , x ) ; 
CREATE TABLE x ( x INT , x INT , UNIQUE ( x ) ) ; 
ALTER TABLE x ADD UNIQUE ( x ) ; 
CREATE TABLE x ( x serial , x INT ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 PRIMARY KEY ( x ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_oid1 PRIMARY KEY ( x ) ; 
ALTER TABLE x DROP CONSTRAINT atacc_test1 RESTRICT ; 
ALTER TABLE x ADD COLUMN x INT PRIMARY KEY ; 
ALTER TABLE x ADD COLUMN x INT DEFAULT 1 PRIMARY KEY ; 
ALTER TABLE x ADD COLUMN x float8 NOT NULL DEFAULT x ( ) , ADD PRIMARY KEY ( x ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 PRIMARY KEY ( x , x ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test2 PRIMARY KEY ( x ) ; 
INSERT INTO x ( x , x ) VALUES ( NULL , 1 ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , NULL ) ; 
INSERT INTO x ( x , x ) VALUES ( NULL , NULL ) ; 
CREATE TABLE x ( x INT , x INT , PRIMARY KEY ( x ) ) ; 
ALTER TABLE x ALTER COLUMN x DROP NOT NULL ; 
ALTER TABLE x ALTER x SET NOT NULL ; 
ALTER TABLE x ALTER COLUMN x SET NOT NULL ; 
CREATE TABLE x ( x INT NOT NULL ) ; 
ALTER TABLE x ADD CONSTRAINT atacc1_pkey" PRIMARY KEY ( x ) ; 
ALTER TABLE x DROP CONSTRAINT atacc1_pkey" ; 
ALTER TABLE x ALTER x DROP NOT NULL ; 
INSERT INTO x VALUES ( NULL , 1 ) ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_or CHECK ( x IS NOT NULL OR x < 1 ) ; 
ALTER TABLE x DROP CONSTRAINT atacc1_constr_or ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_invalid CHECK ( x IS NOT NULL ) NOT VALID ; 
ALTER TABLE x DROP CONSTRAINT atacc1_constr_invalid ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_a_valid CHECK ( x IS NOT NULL ) ; 
INSERT INTO x VALUES ( 1 , NULL ) ; 
ALTER TABLE x ALTER x SET NOT NULL , ALTER x SET NOT NULL ; 
ALTER TABLE x ALTER x DROP NOT NULL , ALTER x DROP NOT NULL ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_b_valid CHECK ( x IS NOT NULL ) ; 
CREATE TABLE x ( x VARCHAR ( 1 ) ) INHERITS ( x ) ; 
INSERT INTO x ( x , x ) VALUES ( NULL , 'x' ) ; 
ALTER TABLE ONLY x ALTER x SET NOT NULL ; 
CREATE TABLE x ( x int4 DEFAULT 1 , x TEXT DEFAULT 'x' ) ; 
ALTER TABLE x ALTER COLUMN x DROP DEFAULT ; 
ALTER TABLE x ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' ; 
DROP RULE def_view_test_ins ON def_view_test ; 
CREATE TABLE x ( x int4 NOT NULL , x int4 , x int4 NOT NULL , x int4 ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 1 ) ; 
SELECT * FROM x GROUP BY x ; 
SELECT x . * FROM x ; 
SELECT x . x FROM x ; 
SELECT x , x , x FROM x ; 
SELECT x , x , x , x FROM x ; 
INSERT INTO x VALUES ( DEFAULT , 1 , 1 , 1 ) ; 
INSERT INTO x ( x ) VALUES ( DEFAULT ) ; 
INSERT INTO x ( x , x , x , x ) VALUES ( 1 , 1 , 1 , 1 ) ; 
INSERT INTO x ( x , x , x , x ) VALUES ( DEFAULT , 1 , 1 , 1 ) ; 
ALTER TABLE x SET WITHOUT OIDS ; 
ANALYZE x ( a ) ; 
ANALYZE x ( ........pg.dropped.1........" ) ; 
VACUUM ANALYZE x ( a ) ; 
VACUUM ANALYZE x ( ........pg.dropped.1........" ) ; 
COMMENT ON COLUMN atacc1 . a IS 'x' ; 
COMMENT ON COLUMN atacc1 . ........pg.dropped.1........" IS 'x' ; 
ALTER TABLE x ALTER x SET STATISTICS 1 ; 
ALTER TABLE x ALTER x SET DEFAULT 1 ; 
ALTER TABLE x ALTER x DROP DEFAULT ; 
ALTER TABLE x ADD PRIMARY KEY ( x ) ; 
ALTER TABLE x ADD CHECK ( x > 1 ) ; 
CREATE TABLE x ( x int4 UNIQUE ) ; 
CREATE TABLE x AS SELECT * FROM x ; 
SELECT * INTO x FROM x ; 
CREATE TABLE x ( x float8 , x NUMERIC ( 1 , 1 ) , x TEXT COLLATE C" ) ; 
CREATE TABLE x ( x int4 , x int4 , x int4 ) ; 
COPY x TO STDOUT ; 
COPY x ( x ) TO STDOUT ; 
COPY x ( x , x ) FROM STDIN ; 
ALTER TABLE ONLY x DROP COLUMN x ; 
ALTER TABLE x RENAME COLUMN x TO x ; 
ALTER TABLE ONLY x RENAME COLUMN x TO x ; 
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x ; 
ALTER TABLE x ADD COLUMN x INT ; 
ALTER TABLE ONLY x ADD COLUMN x INT ; 
CREATE TABLE x ( x INT NOT NULL ) INHERITS ( x ) ; 
CREATE TABLE x ( ) ; 
DROP TABLE x , x CASCADE ; 
ALTER TABLE x ADD x TEXT ; 
CREATE TABLE x ( x TEXT , x INT ) INHERITS ( x ) ; 
ALTER TABLE x ADD COLUMN x INT CHECK ( x > 1 ) ; 
UPDATE x SET x = x + 1 , x = x ( x ) ; 
CREATE DOMAIN mytype AS TEXT ; 
CREATE TEMP TABLE x ( x TEXT , x mytype , x TEXT ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' ) ; 
DROP DOMAIN mytype CASCADE ; 
SELECT x , x ( x ) FROM x GROUP BY x ; 
CREATE TABLE x ( x serial8 , x BOOLEAN , CONSTRAINT anothertab_chk CHECK ( x <= 1 ) ) ; 
INSERT INTO x ( x , x ) VALUES ( DEFAULT , TRUE ) ; 
INSERT INTO x ( x , x ) VALUES ( DEFAULT , FALSE ) ; 
ALTER TABLE x ALTER COLUMN x TYPE TEXT USING CASE WHEN x IS TRUE THEN 'x' WHEN x IS FALSE THEN 'x' ELSE 'x' END ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT UNIQUE , x INT , x INT , x INT ) ; 
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) ; 
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) WHERE ( x IS NOT NULL ) ; 
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) WHERE ( x > 1 ) ; 
ALTER TABLE x ADD UNIQUE ( x , x ) ; 
ALTER TABLE x ALTER COLUMN x TYPE BIGINT ; 
ALTER TABLE x ALTER COLUMN x TYPE BIGINT , ALTER COLUMN x TYPE BIGINT , ALTER COLUMN x TYPE BIGINT ; 
ALTER TABLE x ALTER x TYPE TEXT USING x || 'x' , ALTER x TYPE BIGINT USING x * 1 ; 
CREATE TABLE x ( x INT , x tab1 ) ; 
CREATE TABLE x ( x TEXT , x INT ) ; 
CREATE INDEX ON x ( x ) ; 
COMMENT ON CONSTRAINT at_partitioned_id_name_key ON at_partitioned IS 'x' ; 
COMMENT ON INDEX at_partitioned_id_name_key IS 'x' ; 
COMMENT ON CONSTRAINT at_partitioned_0_id_name_key ON at_partitioned_0 IS 'x' ; 
COMMENT ON INDEX at_partitioned_0_id_name_key IS 'x' ; 
COMMENT ON CONSTRAINT at_partitioned_1_id_name_key ON at_partitioned_1 IS 'x' ; 
COMMENT ON INDEX at_partitioned_1_id_name_key IS 'x' ; 
CREATE TEMP TABLE x AS SELECT x , x AS oldoid , x AS oldfilenode FROM x WHERE x LIKE 'x' ; 
CREATE TABLE x ( x FLOAT CHECK ( x > 1.000000 ) , x FLOAT ) ; 
SELECT x , x , x , x , x FROM x c , x r WHERE x LIKE 'x' AND x . x = x . x ORDER BY 1 , 1 ; 
ALTER TABLE x ALTER COLUMN x TYPE NUMERIC ; 
ALTER TABLE x ADD CONSTRAINT bnoinherit CHECK ( x > 1 ) NO INHERIT ; 
ALTER TABLE x ADD CONSTRAINT blocal CHECK ( x < 1 ) ; 
ALTER TABLE x ADD CONSTRAINT bmerged CHECK ( x > 1 ) ; 
CREATE TABLE x ( x SMALLINT ) INHERITS ( x ) ; 
CREATE TABLE x ( x int2 , x int4 , x int8 ) ; 
CREATE TABLE x ( x int4 , x int8 , x int2 ) ; 
CREATE TABLE x ( x int8 , x int2 , x int4 ) ; 
ALTER TABLE x ALTER COLUMN x TYPE int4 USING ( x ( x ) ) ; 
CREATE TABLE x ( x INT REFERENCES x , x TEXT ) ; 
ALTER TABLE x DROP CONSTRAINT check_fk_presence_2_id_fkey ; 
CREATE VIEW x AS SELECT * FROM x bt ; 
CREATE VIEW x AS SELECT * , x ( x ) AS j FROM x v1 ; 
CREATE OR REPLACE VIEW x AS SELECT * , 1 + 1 AS more FROM x bt ; 
EXECUTE p_ddl ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$DROP FUNCTION x ( regclass , TEXT ) ; 
DROP TYPE lockmodes ; 
CREATE TYPE lockmodes AS ENUM ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
BEGIN ; ALTER TABLE x ALTER COLUMN x SET STATISTICS 1 ; 
SELECT * FROM x ORDER BY 1 ; 
BEGIN ; ALTER TABLE x CLUSTER ON alterlock_pkey ; 
BEGIN ; ALTER TABLE x SET WITHOUT CLUSTER ; 
BEGIN ; ALTER TABLE x SET ( fillfactor = 1 ) ; 
BEGIN ; ALTER TABLE x RESET ( fillfactor ) ; 
BEGIN ; ALTER TABLE x SET ( toast . autovacuum_enabled = off ) ; 
BEGIN ; ALTER TABLE x SET ( autovacuum_enabled = off ) ; 
BEGIN ; ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 ) ; 
BEGIN ; ALTER TABLE x SET ( autovacuum_enabled = off , fillfactor = 1 ) ; 
BEGIN ; ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' ; 
CREATE TRIGGER x BEFORE DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 1 , 1 ) ; 
ALTER TABLE x VALIDATE CONSTRAINT alterlock2nv ; 
ALTER TABLE x RESET ( autovacuum_enabled ) ; 
ALTER VIEW x RESET ( autovacuum_enabled ) ; 
ALTER VIEW x SET ( security_barrier = off ) ; 
ALTER VIEW x RESET ( security_barrier ) ; 
ALTER TABLE x SET ( security_barrier = off ) ; 
ALTER TABLE x RESET ( security_barrier ) ; 
SELECT x ( NULL ) ; 
ALTER FUNCTION x ( TEXT ) CALLED ON NULL INPUT ; 
ALTER FUNCTION x ( TEXT ) RETURNS NULL ON NULL INPUT ; 
CREATE TABLE x . t1 ( x serial PRIMARY KEY , x INT CHECK ( x > 1 ) ) ; 
CREATE VIEW x . v1 AS SELECT * FROM x . t1 ; 
CREATE TYPE alter1 . ctype AS ( f1 INT , f2 TEXT ) ; 
CREATE OPERATOR CLASS alter1 . ctype_hash_ops DEFAULT FOR TYPE alter1 . ctype USING hash AS OPERATOR 1 alter1 . = ( alter1 . ctype , alter1 . ctype ) ; 
CREATE CONVERSION alter1 . latin1_to_utf8 FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
CREATE TEXT SEARCH TEMPLATE alter1 . tmpl ( init = dsimple_init , lexize = dsimple_lexize ) ; 
INSERT INTO x . t1 ( x ) VALUES ( 1 ) ; 
ALTER TABLE x . v1 SET SCHEMA alter2 ; 
ALTER FUNCTION alter1 . plus1 ( INT ) SET SCHEMA alter2 ; 
ALTER DOMAIN alter1 . posint SET SCHEMA alter2 ; 
ALTER OPERATOR CLASS alter1 . ctype_hash_ops USING hash SET SCHEMA alter2 ; 
ALTER OPERATOR FAMILY alter1 . ctype_hash_ops USING hash SET SCHEMA alter2 ; 
ALTER OPERATOR alter1 . = ( alter1 . ctype , alter1 . ctype ) SET SCHEMA alter2 ; 
ALTER FUNCTION alter1 . same ( alter1 . ctype , alter1 . ctype ) SET SCHEMA alter2 ; 
ALTER CONVERSION alter1 . latin1_to_utf8 SET SCHEMA alter2 ; 
ALTER TEXT SEARCH PARSER alter1 . prs SET SCHEMA alter2 ; 
ALTER TEXT SEARCH CONFIGURATION alter1 . cfg SET SCHEMA alter2 ; 
ALTER TEXT SEARCH TEMPLATE alter1 . tmpl SET SCHEMA alter2 ; 
ALTER TEXT SEARCH DICTIONARY alter1 . dict SET SCHEMA alter2 ; 
DROP SCHEMA alter1 ; 
SELECT * FROM x . t1 ; 
SELECT * FROM x . v1 ; 
SELECT alter2 . plus1 ( 1 ) ; 
DROP SCHEMA alter2 CASCADE ; 
CREATE TYPE test_type AS ( a INT ) ; 
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE INTEGER ; 
ALTER TYPE test_type DROP ATTRIBUTE b ; 
ALTER TYPE test_type DROP ATTRIBUTE a , ADD ATTRIBUTE d BOOLEAN ; 
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa ; 
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd ; 
DROP TYPE test_type ; 
CREATE TYPE test_type1 AS ( a INT , b TEXT ) ; 
CREATE TABLE x ( x INT , x test_type1 ) ; 
CREATE TABLE x OF test_type2 ; 
CREATE TYPE test_typex AS ( a INT , b TEXT ) ; 
CREATE TABLE x ( x INT , x test_typex CHECK ( ( x ) . a > 1 ) ) ; 
DROP TYPE test_typex ; 
CREATE TYPE test_type3 AS ( a INT ) ; 
ALTER TYPE test_type3 DROP ATTRIBUTE a , ADD ATTRIBUTE b INT ; 
CREATE TYPE test_type_empty AS ( ) ; 
DROP TYPE test_type_empty ; 
CREATE TYPE tt_t0 AS ( z inet , x INT , y NUMERIC ( 1 , 1 ) ) ; 
ALTER TYPE tt_t0 DROP ATTRIBUTE z ; 
ALTER TABLE x OF tt_t0 ; 
CREATE TYPE tt_t1 AS ( x INT , y NUMERIC ( 1 , 1 ) ) ; 
CREATE TABLE x ( x TEXT CHECK ( x IS NOT NULL ) ) ; 
ALTER TABLE ONLY x DROP CONSTRAINT test_drop_constr_parent_c_check" ; 
ALTER TABLE IF EXISTS x ADD COLUMN x INT ; 
ALTER TABLE IF EXISTS x ADD CONSTRAINT xxx PRIMARY KEY ( x ) ; 
ALTER TABLE IF EXISTS x ADD CHECK ( x BETWEEN 1 AND 1 ) ; 
ALTER TABLE IF EXISTS x ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE IF EXISTS x SET SCHEMA alter2 ; 
DROP TABLE x . tt8 ; 
DROP SCHEMA alter2 ; 
CREATE TABLE x ( x INT , x INT CHECK ( x > 1 ) , x INT , CONSTRAINT comment_test_pk PRIMARY KEY ( x ) ) ; 
COMMENT ON COLUMN comment_test . id IS 'x' ; 
COMMENT ON INDEX comment_test_index IS 'x' ; 
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'x' ; 
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'x' ; 
COMMENT ON INDEX comment_test_pk IS 'x' ; 
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT ; 
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT ; 
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT ; 
CREATE TABLE x ( x TEXT CONSTRAINT comment_test_child_fk REFERENCES x ) ; 
COMMENT ON COLUMN comment_test_child . id IS 'x' ; 
COMMENT ON INDEX comment_test_child_fk IS 'x' ; 
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'x' ; 
SHOW allow_system_table_mods ; 
CREATE TABLE x . new_system_table ( ) ; 
CREATE TABLE x ( x serial PRIMARY KEY , x TEXT ) ; 
ALTER TABLE x SET SCHEMA pg_catalog ; 
ALTER TABLE x SET SCHEMA public ; 
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) ; 
UPDATE x SET x = - x ; 
DELETE FROM x WHERE x = 'x' ; 
ALTER TABLE x DROP CONSTRAINT new_system_table_pkey ; 
CREATE UNLOGGED TABLE x ( x SERIAL PRIMARY KEY , x TEXT ) ; 
~~CREATE TABLE x ( x SERIAL PRIMARY KEY , x TEXT ) ; 
~ALTER TABLE x SET UNLOGGED ; 
~ALTER TABLE x ADD COLUMN x INTEGER ; 
ALTER TABLE x ADD EXCLUDE USING gist ( x WITH && ) ; 
ALTER TABLE x ALTER COLUMN x TYPE CHAR ( 1 ) ; 
ALTER TABLE x ADD CONSTRAINT chk_a CHECK ( x > 1 ) NO INHERIT ; 
CREATE TABLE x ( LIKE x ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 'x' ) ; 
CREATE TABLE x ( x INT NOT NULL , x CHAR ( 1 ) COLLATE C" , CONSTRAINT check_a CHECK ( x > 1 ) ) PARTITION BY LIST ( a ) ; 
ALTER TABLE x OWNER TO x ; 
SET SESSION AUTHORIZATION regress_test_me ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY LIST ( a ) ; 
CREATE TYPE mytype AS ( a INT ) ; 
CREATE TABLE x OF mytype ; 
DROP TYPE mytype CASCADE ; 
CREATE TABLE x ( LIKE x , x INT ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x INT NOT NULL ) ; 
ALTER TABLE x ALTER x TYPE CHAR ( 1 ) COLLATE POSIX" ; 
CREATE TABLE x ( x CHAR ( 1 ) COLLATE C" , x INT NOT NULL ) ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x >= 1 ) ; 
CREATE TABLE x ( x INT NOT NULL , x CHAR ( 1 ) COLLATE C" , CONSTRAINT check_a CHECK ( x > 1 ) ) ; 
CREATE TABLE x ( LIKE x INCLUDING CONSTRAINTS ) ; 
ALTER TABLE x ATTACH PARTITION x DEFAULT ; 
CREATE TABLE x ( x INT , x CHAR ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( LIKE x , CONSTRAINT check_a CHECK ( x IN ( 1 ) ) ) ; 
ALTER TABLE x DETACH PARTITION x ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IN ( 1 , 1 ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 , 1 ) ; 
CREATE TABLE x ( x INT NOT NULL CHECK ( x = 1 ) , x INT NOT NULL CHECK ( x >= 1 AND x <= 1 ) ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 1 , 1 ) TO ( 1 , 1 ) ; 
CREATE TABLE x ( x INT NOT NULL CHECK ( x = 1 ) , x INT NOT NULL CHECK ( x >= 1 AND x < 1 ) ) ; 
CREATE TABLE x ( LIKE x ) PARTITION BY LIST ( b ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ; 
DELETE FROM x WHERE x NOT IN ( 1 ) ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ; 
ALTER TABLE x DROP CONSTRAINT check_a ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IN ( 1 ) ) , ALTER x SET NOT NULL ; 
CREATE TABLE x ( x INT , LIKE x , CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ) ; 
CREATE TABLE x ( LIKE x , CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ) PARTITION BY LIST ( b ) ; 
ALTER TABLE x DROP x , DROP x , DROP x ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 'x' , NULL ) ; 
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x INT , x TEXT ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY LIST ( b ) ; 
CREATE TABLE x PARTITION OF x ( CONSTRAINT check_1 CHECK ( x IS NOT NULL AND x = 1 ) ) FOR VALUES IN ( 'x' ) ; 
CREATE TABLE x ( x INT , x INT ) PARTITION BY HASH ( a part_test_int4_ops ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES WITH ( MODULUS 1 , REMAINDER 1 ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES WITH ( MODULUS 1 , REMAINDER 1 ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' , 'x' ) ; 
ALTER TABLE x ALTER COLUMN x TYPE TEXT ; 
ALTER TABLE ONLY x ALTER x DROP NOT NULL ; 
ALTER TABLE ONLY x DROP CONSTRAINT check_b ; 
ALTER TABLE ONLY x ADD CONSTRAINT check_a CHECK ( x > 1 ) ; 
ALTER TABLE ONLY x DROP CONSTRAINT check_a ; 
ALTER TABLE x ALTER x SET NOT NULL , ADD CONSTRAINT check_a2 CHECK ( x > 1 ) ; 
ALTER TABLE x DROP CONSTRAINT check_a2 ; 
ALTER TABLE x ADD x INT NOT NULL ; 
ALTER TABLE x ADD CONSTRAINT parted_validate_test_chka CHECK ( x > 1 ) NOT VALID ; 
ALTER TABLE x VALIDATE CONSTRAINT parted_validate_test_chka ; 
ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 , n_distinct_inherited = 1 ) ; 
ALTER TABLE x ALTER COLUMN x RESET ( n_distinct_inherited ) ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ; 
$$CREATE TRIGGER x BEFORE INSERT ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$CREATE OPERATOR CLASS at_test_sql_partop FOR TYPE int4 USING btree AS OPERATOR 1 < ( int4 , int4 ) , OPERATOR 1 <= ( int4 , int4 ) , OPERATOR 1 = ( int4 , int4 ) , OPERATOR 1 >= ( int4 , int4 ) , OPERATOR 1 > ( int4 , int4 ) , FUNCTION 1 x ( int4 , int4 ) ; 
DROP OPERATOR CLASS at_test_sql_partop USING btree ; 
DROP FUNCTION at_test_sql_partop ; 
RESET max_stack_depth ; 
SELECT x ( x ( x ) , FALSE ) FROM ( SELECT x AS b , x * 1 AS c FROM x ( 1 , 1 ) x ) q ; 
SELECT x ( x ( x ) , TRUE ) FROM ( SELECT x AS b , x * 1 AS c FROM x ( 1 , 1 ) x ) q ; 
$$$$SELECT x ( x ( x ) , FALSE ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ; 
SELECT x ( x ( x ) , FALSE ) FROM x ( 1 , 1 ) x ; 
$$$$SELECT x ( x ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ; 
$$$$SELECT x ( x , TRUE ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ; 
SELECT x ( ROW ( ( SELECT x ( x ) AS d FROM x ( 1 , 1 ) x ) ) , FALSE ) ; 
SELECT x ( TIMESTAMP 'x' ) ; 
SET LOCAL TIME ZONE 1.000000 ; 
SET LOCAL TIME ZONE 1 ; 
$$$$CREATE TEMP TABLE x ( x TEXT , x json ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) , ( 'x' , 'x' ) ; 
SELECT * FROM x ( 'x' ) q ; 
SELECT x ( 'x' , 'x' , 'x' ) IS NULL AS expect_false ; 
SELECT x ( 'x' , 'x' , 'x' ) IS NULL AS expect_true ; 
CREATE TYPE jpop AS ( a TEXT , b INT , c TIMESTAMP ) ; 
CREATE DOMAIN js_int_not_null AS INT NOT NULL ; 
CREATE TYPE j_unordered_pair AS ( x INT , y INT ) ; 
_CREATE TYPE jsrec AS ( i INT , ia int4 , ia1 INT [ ] , ia2 INT [ ] [ ] , ia3 INT [ ] [ ] [ ] , ia1d js_int_array_1d , ia2d js_int_array_2d , t TEXT , ta TEXT [ ] , c CHAR ( 1 ) , ca CHAR ( 1 ) [ ] , ts TIMESTAMP , js json , jsb jsonb , jsa json [ ] , rec jpop , reca jpop [ ] ) ; 
CREATE TYPE jsrec_i_not_null AS ( i js_int_not_null ) ; 
SELECT x ( ROW ( 1 , 1 ) , 'x' ) ; 
CREATE TYPE jpop2 AS ( a INT , b json , c INT , d INT ) ; 
SELECT x , x ( ROW ( x , 1 ) , 'x' ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( i ) ; 
CREATE TEMP TABLE x ( x json ) ; 
DROP TYPE jsrec ; 
DROP TYPE jsrec_i_not_null ; 
DROP DOMAIN js_int_not_null ; 
DROP DOMAIN js_int_array_1d ; 
DROP DOMAIN js_int_array_2d ; 
DROP DOMAIN j_ordered_pair ; 
DROP TYPE j_unordered_pair ; 
SELECT x ( 'x' , 1 , 'x' , 1.000000 , 'x' , TRUE , 'x' , NULL , 'x' , x 'x' ) ; 
SELECT x ( 1 , 1 ) ; 
SELECT x ( NULL , 1 ) ; 
SELECT x ( x , 1 ) FROM ( SELECT 1 AS a , 1 AS b ) r ; 
SELECT x ( x 'x' , 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 1 , NULL , 'x' ) ; 
SELECT * FROM x ( 'x' ) AS x ( a INT , b TEXT , d TEXT ) ; 
SELECT * FROM x ( 'x' ) AS x ( a INT , b TEXT , c BOOLEAN ) ; 
SELECT * FROM x ( 'x' ) AS x ( a INT , b json , c BOOLEAN ) ; 
_SELECT * FROM x ( 'x' ) AS x ( ia int4 ) ; 
_____SELECT * FROM x ( 'x' ) AS x ( ia2 INT [ ] [ ] ) ; 
SELECT * FROM x ( 'x' ) AS x ( ia2 int4 [ ] [ ] ) ; 
CREATE TABLE x ( x INT , x macaddr8 ) ; 
CREATE INDEX x ON x USING btree ( x ) ; 
CREATE INDEX x ON x USING hash ( x ) ; 
SELECT x , x , x ( x ) FROM x ORDER BY 1 , 1 ; 
SELECT x & 'x' FROM x ; 
SELECT x | 'x' FROM x ; 
GRANT ALL ON SCHEMA temp_func_test TO x ; 
SET search_path TO temp_func_test , public ; 
CREATE FUNCTION x ( TEXT , date ) RETURNS bool LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( TEXT [ ] ) RETURNS INT LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( ) RETURNS bool LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' IMMUTABLE AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' STABLE AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' VOLATILE AS 'x' ; 
ALTER FUNCTION x ( INT ) VOLATILE ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' SECURITY DEFINER AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' SECURITY INVOKER AS 'x' ; 
ALTER FUNCTION x ( INT ) SECURITY DEFINER ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' LEAKPROOF AS 'x' ; 
ALTER FUNCTION x ( INT ) LEAKPROOF ; 
ALTER FUNCTION x ( INT ) OWNER TO x ; 
SET SESSION AUTHORIZATION regress_unpriv_user ; 
ALTER FUNCTION x ( INT ) NOT LEAKPROOF ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' CALLED ON NULL INPUT AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' RETURNS NULL ON NULL INPUT AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' STRICT AS 'x' ; 
ALTER FUNCTION x ( INT ) CALLED ON NULL INPUT ; 
DROP FUNCTION x ( INT , INT , TEXT ) , x ( INT ) , x ( INT ) ; 
CREATE FUNCTION x ( BIGINT ) RETURNS bool LANGUAGE 'x' IMMUTABLE AS 'x' ; 
DROP FUNCTION functest_b_1 ; 
DROP FUNCTION x ( a INT ) ; 
SELECT * FROM x ( 1 ) ; 
DROP SCHEMA temp_func_test CASCADE ; 
SELECT x ( x ) AS avg_1 FROM x ; 
SELECT x ( x ) AS avg_32 FROM x WHERE x < 1 ; 
SELECT x ( x ) AS avg_3_4 FROM ONLY x ; 
SELECT x ( x ) AS sum_1500 FROM x ; 
SELECT x ( x ) AS sum_198 FROM x ; 
SELECT x ( x ) AS avg_431_773 FROM x ; 
SELECT x ( x ) AS avg_6_8 FROM ONLY x ; 
SELECT x ( x ) AS max_3 FROM x ; 
SELECT x ( x ) AS max_100 FROM x ; 
SELECT x ( x . x ) AS max_324_78 FROM x ; 
SELECT x ( x . x ) AS max_3_7 FROM x ; 
SELECT x ( 1.000000 ) , x ( 1.000000 ) ; 
SELECT x ( x , x ) FROM x ; 
SELECT x ( x , x ) , x ( x , x ) FROM x ; 
CREATE TABLE x ( x float8 , x float8 ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 , 1 , 1 ) ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 , 1 ) ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 ) ; 
SELECT x ( x ) AS cnt_1000 FROM x ; 
SELECT x ( DISTINCT x ) AS cnt_4 FROM x ; 
SELECT x ( * ) AS cnt_1000 FROM x ; 
SELECT ( SELECT x ( ( SELECT x . x FROM x i WHERE x . x = x . x ) ) ) FROM x o ; 
SELECT ARRAY ( SELECT x ( x + x ) s FROM x ( 1 , 1 ) y GROUP BY x ORDER BY x ) FROM x ( 1 , 1 ) x ; 
CREATE TEMPORARY TABLE x ( x INT2 , x INT4 , x INT8 , x INTEGER , x INT2 , x BIT ( 1 ) ) ; 
SELECT x ( x ) AS ?" , x ( x ) AS ?" FROM x ; 
COPY x FROM STDIN NULL 'x' ; 
CREATE TEMPORARY TABLE x ( x BOOL , x BOOL , x BOOL , x BOOL ) ; 
SELECT x ( x ) AS n" , x ( x ) AS n" FROM x ; 
SELECT x ( x ) AS f" , x ( x ) AS t" , x ( x ) AS f" , x ( x ) AS n" , x ( NOT x ) AS f" , x ( NOT x ) AS t" FROM x ; 
SELECT x ( x ) AS t" , x ( x ) AS t" , x ( x ) AS f" , x ( x ) AS n" , x ( NOT x ) AS f" , x ( NOT x ) AS t" FROM x ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x < 1 ; 
SELECT x ( x ) FROM x WHERE x < 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x > 1 ; 
SELECT x ( x ) FROM x WHERE x > 1 ; 
SET LOCAL max_parallel_workers_per_gather = 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x = 1 ; 
SELECT x ( x ) FROM x WHERE x = 1 ; 
EXPLAIN ( costs off ) SELECT x , ( SELECT x ( x ) FROM x WHERE x > x ) AS gt FROM x ; 
SELECT x , ( SELECT x ( x ) FROM x WHERE x > x ) AS gt FROM x ; 
EXPLAIN ( costs off ) SELECT DISTINCT x ( x ) FROM x ; 
SELECT DISTINCT x ( x ) FROM x ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY 1 ; 
SELECT x ( x ) FROM x ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY x ( x ) ; 
SELECT x ( x ) FROM x ORDER BY x ( x ) ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY x ( x ) + 1 ; 
SELECT x ( x ) FROM x ORDER BY x ( x ) + 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) , x ( 1 , 1 ) AS g FROM x ORDER BY x DESC ; 
SELECT x ( x ) , x ( 1 , 1 ) AS g FROM x ORDER BY x DESC ; 
EXPLAIN ( costs off ) SELECT x ( 1 ) FROM x ; 
SELECT x ( 1 ) FROM x ; 
CREATE INDEX x ON x ( x DESC ) ; 
CREATE INDEX x ON x ( x ) WHERE x IS NOT NULL ; 
EXPLAIN ( costs off ) SELECT x ( x ) , x ( x ) FROM x ; 
EXPLAIN ( costs off ) SELECT DISTINCT x ( x ) , x ( x ) FROM x ; 
SELECT DISTINCT x ( x ) , x ( x ) FROM x ; 
SELECT x ( x ( x ) ) FROM x ; 
SELECT ( SELECT x ( x ( x ) ) FROM x ) FROM x ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , PRIMARY KEY ( x , x ) DEFERRABLE ) ; 
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY x , x , x , x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x GROUP BY x , x , x ; 
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY x , x , x ; 
EXPLAIN ( costs off ) SELECT * FROM ONLY x GROUP BY x , x , x , x ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) PARTITION BY list ( a ) ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) ; 
SELECT x ( x ORDER BY x DESC ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) ; 
SELECT x ( DISTINCT x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( DISTINCT x ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( DISTINCT x ORDER BY x DESC ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( DISTINCT x ORDER BY x DESC NULLS LAST ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
SELECT x ( DISTINCT x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x USING < ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
CREATE VIEW x AS SELECT x ( x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x + 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
~~CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x USING < ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
~~CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x , x + 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x , x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( 'x' ) , ( NULL ) , ( 'x' ) , ( 'x' ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( NULL ) , ( NULL ) , ( 'x' ) , ( 'x' ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( NULL ) , ( NULL ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM x ; 
INSERT INTO x VALUES ( x ( 'x' , 'x' ) ) ; 
SELECT x ( x , NULL ) FROM x ; 
SELECT x ( x , x ( 'x' , 'x' ) ) FROM x ; 
SELECT x ( x ) FILTER ( WHERE x > 1 ) FROM x ; 
SELECT x ( 1 / x ) FILTER ( WHERE x > 1 ) FROM x ; 
SELECT x ( x COLLATE C" ) FILTER ( WHERE ( x COLLATE POSIX" ) > 'x' ) FROM ( VALUES ( 'x' , 'x' ) ) AS v ( foo , bar ) ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FILTER ( WHERE x > 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( 1.000000 ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( 1.000000 ) WITHIN GROUP ( ORDER BY x ) , x ( x ) FROM x ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ; 
SELECT x ( ARRAY [ 1 , 1.000000 , 1.000000 , 1.000000 , 1.000000 , 1.000000 , 1 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( ARRAY [ 1 , 1.000000 , 1.000000 , 1.000000 , 1 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( ARRAY [ [ NULL , 1 , 1.000000 ] , [ 1.000000 , 1.000000 , NULL ] ] ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( ARRAY [ 1 , 1 , 1.000000 , 1.000000 , 1.000000 , 1 , 1.000000 , 1.000000 , 1.000000 , 1.000000 , 1.000000 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( x ( 1 ) WITHIN GROUP ( ORDER BY x COLLATE POSIX" ) ) FROM ( VALUES ( 'x' ) , ( 'x' ) ) v ( x ) ; 
SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT ARRAY ( SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1.000000 ) , ( 1.000000 ) ) v ( a ) GROUP BY x ) FROM x ( 1 , 1 ) g ( x ) ; 
SELECT x ( x ( x ) ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 'x' ) , ( 'x' ) ) v ( x ) ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x , x ) FROM x ; 
SELECT x ( 'x' ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( VARIADIC ARRAY [ x , x ] ) FROM x ; 
BEGIN WORK ; 
CREATE TYPE avg_state AS ( total BIGINT , count BIGINT ) ; 
$$$$$$$$$$$$SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( DISTINCT x ) , x ( DISTINCT x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( DISTINCT x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( x ) FILTER ( WHERE x > 1 ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) t ( one , two ) ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) , x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) t ( a ) ; 
$$$$$$$$SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) t ( one ) ; 
$$BEGIN ISOLATION LEVEL REPEATABLE READ ; 
$$ALTER TABLE x SET ( parallel_workers = 1 ) ; 
SET LOCAL parallel_setup_cost = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x ( x ) FROM x ; 
SET parallel_setup_cost = 1 ; 
SET parallel_tuple_cost = 1 ; 
SET min_parallel_table_scan_size = 1 ; 
SET max_parallel_workers_per_gather = 1 ; 
SET enable_indexonlyscan = off ; 
SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) GROUP BY ( x ) ORDER BY 1 ; 
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , NULL ) ) AS d ( x , y ) ; 
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , 1 ) ) AS d ( x , y ) ; 
SELECT x || 'x' , CASE x || 'x' WHEN 'x' THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 'x' , 'x' ] ) u ( v ) GROUP BY x || 'x' ORDER BY 1 ; 
SELECT x || 'x' , CASE WHEN x || 'x' = 'x' THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 'x' , 'x' ] ) u ( v ) GROUP BY x || 'x' ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT 1 FROM x WHERE ( x , x ) IN ( SELECT x , x FROM x ) ; 
~~~~~~~~~~~~~~~~~~~~~~~~~CREATE TABLE x ( x SERIAL PRIMARY KEY , x INT , x TEXT ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , x ( 'x' , 1 ) ) ; 
DELETE FROM x AS x WHERE x . x > 1 ; 
DELETE FROM x x WHERE x . x > 1 ; 
DELETE FROM x WHERE x > 1 ; 
CREATE TABLE x ( x date ) ; 
SELECT x AS Fifteen" FROM x ; 
SELECT x AS Nine" FROM x WHERE x < 'x' ; 
SELECT x AS Three" FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT x 'x' ; 
SET datestyle TO mdy ; 
SELECT x - x 'x' AS Days From 2K" FROM x ; 
SELECT x - x 'x' AS Days From Epoch" FROM x ; 
SELECT x 'x' - x 'x' AS One day" ; 
SELECT x 'x' - x 'x' AS Two days" ; 
SELECT x ( 1 , 1 , 1 ) ; 
SELECT x ( 1 , 1 , 1.000000 ) ; 
CREATE TABLE x ( x INT , x INT , x CHAR ( 1 ) , x CHAR ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' , 'x' ) ; 
SELECT x , x ( * ) FROM x GROUP BY x . x ORDER BY x ; 
SELECT x ( * ) FROM x GROUP BY x . x ORDER BY x ; 
SELECT x ( * ) FROM x GROUP BY x ORDER BY x ; 
SELECT x . x , x ( * ) FROM x GROUP BY x ORDER BY x ; 
SELECT x FROM x ORDER BY x ; 
SELECT x ( * ) FROM x GROUP BY x ORDER BY x DESC ; 
SELECT x ( * ) FROM x ORDER BY 1 DESC ; 
SELECT x , x ( * ) FROM x GROUP BY 1 ORDER BY 1 ; 
SELECT x , x ( * ) FROM x GROUP BY 1 ; 
SELECT x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x ORDER BY x ; 
SELECT x , x FROM x ORDER BY x ; 
SELECT x / 1 , x / 1 FROM x ORDER BY x / 1 ; 
SELECT x / 1 , x / 1 FROM x GROUP BY x / 1 ORDER BY x / 1 ; 
SELECT x . x , x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x ORDER BY x . x ; 
SELECT x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x ORDER BY x . x ; 
SELECT x ( x ) FROM x GROUP BY x ORDER BY x ; 
SELECT x ( x ) FROM x GROUP BY x / 1 ORDER BY x / 1 ; 
SELECT x ( x . x ) , x ( x ) FROM x GROUP BY x ( x ) ORDER BY x ( x ) ; 
SELECT x FROM x ORDER BY x ( x ) ; 
SELECT x ( x ) FROM x GROUP BY ( x + 1 ) / 1 ORDER BY ( x + 1 ) / 1 DESC ; 
SELECT x ( x . x ) FROM x x , x y WHERE x . x = x . x GROUP BY x / 1 ORDER BY x / 1 ; 
SELECT x . x / 1 , x ( x . x ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x / 1 ORDER BY x . x / 1 ; 
SELECT x ( x ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x / 1 ; 
CREATE TABLE x ( x INTEGER , x INTEGER , x TEXT ) ; 
CREATE TABLE x ( x INTEGER , x INTEGER ) ; 
INSERT INTO x VALUES ( NULL , NULL , 'x' ) ; 
INSERT INTO x VALUES ( NULL , 1 , 'x' ) ; 
INSERT INTO x VALUES ( NULL , NULL ) ; 
CREATE TEMP TABLE x ( ) ; 
SELECT 'x' AS xxx" , * FROM x AS tx ; 
SELECT 'x' AS xxx" , * FROM x tx ; 
SELECT 'x' AS xxx" , * FROM x AS t1 ( a , b , c ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) , x t2 ( d , e ) ; 
SELECT 'x' AS xxx" , x . x , x . x FROM x t1 ( a , b , c ) , x t2 ( d , e ) WHERE x . x = x . x ; 
SELECT 'x' AS xxx" , * FROM x CROSS JOIN x ; 
SELECT 'x' AS xxx" , x , x , x FROM x CROSS JOIN x ; 
SELECT 'x' AS xxx" , x . x , x , x FROM x t1 CROSS JOIN x t2 ; 
SELECT 'x' AS xxx" , x , x , x FROM ( x CROSS JOIN x ) AS tx ( ii , jj , tt , ii2 , kk ) ; 
SELECT 'x' AS xxx" , x . x , x . x , x . x FROM ( x t1 ( a , b , c ) CROSS JOIN x t2 ( d , e ) ) AS tx ( ii , jj , tt , ii2 , kk ) ; 
SELECT 'x' AS xxx" , * FROM x CROSS JOIN x a CROSS JOIN x b ; 
SELECT 'x' AS xxx" , * FROM x INNER JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) JOIN x t2 ( a , d ) USING ( a ) ORDER BY x , x ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) JOIN x t2 ( a , b ) USING ( b ) ORDER BY x , x . x ; 
SELECT 'x' AS xxx" , * FROM x NATURAL JOIN x ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) NATURAL JOIN x t2 ( a , d ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) NATURAL JOIN x t2 ( d , a ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b ) NATURAL JOIN x t2 ( a ) ; 
SELECT 'x' AS xxx" , * FROM x JOIN x ON ( x . x = x . x ) ; 
SELECT 'x' AS xxx" , * FROM x JOIN x ON ( x . x <= x . x ) ; 
SELECT 'x' AS xxx" , * FROM x LEFT OUTER JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x LEFT JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x RIGHT OUTER JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x RIGHT JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x FULL OUTER JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x FULL JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x LEFT JOIN x USING ( i ) WHERE ( x = 1 ) ; 
CREATE TEMP TABLE x ( x INT , x INT ) ; 
SELECT * FROM x LEFT JOIN x ON ( x = x AND x IS NOT NULL ) ; 
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x ) ; 
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x AND x IS NOT NULL ) ; 
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x ) WHERE ( x IS NOT NULL ) ; 
SELECT x ( * ) FROM x a WHERE x IN ( SELECT x FROM x b JOIN x c USING ( unique1 ) WHERE x . x = 1 ) ; 
SELECT x ( * ) FROM x x WHERE x . x IN ( SELECT x . x FROM x a , x b WHERE x . x = x . x ) AND x . x = 1 AND x . x IN ( SELECT x . x FROM x aa , x bb WHERE x . x = x . x ) ; 
SET geqo = ON ; 
SET geqo_threshold = 1 ; 
EXPLAIN ( costs off ) SELECT x , x , x , x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL ; 
SELECT x , x , x , x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x FULL JOIN ( SELECT * FROM x ORDER BY x . x DESC , x . x ASC ) j2_tbl ON x . x = x . x AND x . x = x . x ; 
SELECT * FROM x FULL JOIN ( SELECT * FROM x ORDER BY x . x DESC , x . x ASC ) j2_tbl ON x . x = x . x AND x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM ( SELECT * FROM x x ORDER BY x . x , x . x , x . x ) x LEFT JOIN ( SELECT * FROM x y ORDER BY x . x ) y ON x . x = x . x AND x . x = x . x AND x . x = x . x ; 
SELECT x ( * ) FROM ( SELECT * FROM x x ORDER BY x . x , x . x , x . x ) x LEFT JOIN ( SELECT * FROM x y ORDER BY x . x ) y ON x . x = x . x AND x . x = x . x AND x . x = x . x ; 
DELETE FROM x USING x table1 WHERE x . x = x . x ; 
DELETE FROM x USING x JOIN x USING ( a ) WHERE x . x > x . x ; 
DELETE FROM x USING x t3_other WHERE x . x = x . x AND x . x = x . x ; 
SELECT * FROM x LEFT JOIN x ON ( x . x = x . x ) ; 
SELECT x . x FROM x JOIN x ON ( x . x = x . x ) ; 
CREATE TEMP TABLE x ( x int4 , x int4 ) ; 
SET enable_hashjoin TO off ; 
SET enable_nestloop TO off ; 
SELECT x . * , x . * FROM x LEFT JOIN x ON x . x = x . x ; 
SELECT x . * , x . * FROM x RIGHT JOIN x ON x . x = x . x ; 
RESET enable_hashjoin ; 
RESET enable_nestloop ; 
SET work_mem TO 'x' ; 
SET enable_mergejoin TO off ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , x b WHERE x . x = x . x AND ( x . x % 1 ) < 1 ; 
SELECT x ( * ) FROM x a , x b WHERE x . x = x . x AND ( x . x % 1 ) < 1 ; 
RESET work_mem ; 
RESET enable_mergejoin ; 
INSERT INTO x SELECT x , x ( 'x' , 1 ) FROM x ( 1 , 1 ) x ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT ) ; 
SELECT * FROM x , x WHERE x . x = x . x AND x . x = x . x - x . x ; 
SELECT * FROM x LEFT JOIN x ON ( x = x ) LEFT JOIN x ON ( x = x ) WHERE x = 1 ; 
$PREPARE foo ( bool ) AS SELECT x ( * ) FROM x a LEFT JOIN x b ON ( x . x = x . x AND EXISTS ( SELECT 1 FROM x c WHERE x . x = x . x AND 1 ) ) ; 
EXECUTE foo ( TRUE ) ; 
EXECUTE foo ( FALSE ) ; 
SET enable_mergejoin = 1 ; 
SET enable_hashjoin = 1 ; 
SET enable_nestloop = 1 ; 
CREATE TEMP TABLE x ( x INTEGER ) ; 
CREATE TEMP TABLE x ( x INTEGER , x INTEGER ) ; 
SELECT * FROM x LEFT JOIN x ON x = x AND x = x AND x = x ; 
CREATE TYPE mycomptype AS ( id INT , v BIGINT ) ; 
CREATE TEMP TABLE x ( x mycomptype ) ; 
EXPLAIN ( costs off ) SELECT x . x , x . x FROM x a , x b WHERE x . x = x . x ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN x t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT * FROM x ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT * FROM x OFFSET 1 ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT x , CASE WHEN x = 1 THEN 1 ELSE x END AS q2 FROM x ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
CREATE TEMP TABLE x ( x CHAR NOT NULL , CONSTRAINT a_pk PRIMARY KEY ( x ) ) ; 
CREATE TEMP TABLE x ( x CHAR NOT NULL , x INTEGER NOT NULL , CONSTRAINT b_pk PRIMARY KEY ( x , x ) ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ; 
EXPLAIN ( COSTS OFF ) SELECT x , x FROM ( SELECT COALESCE ( x , 1 ) AS qq FROM x a ) AS ss1 FULL OUTER JOIN ( SELECT COALESCE ( x , 1 ) AS qq FROM x b ) AS ss2 USING ( qq ) INNER JOIN x c ON x = x ; 
SELECT x , x FROM ( SELECT COALESCE ( x , 1 ) AS qq FROM x a ) AS ss1 FULL OUTER JOIN ( SELECT COALESCE ( x , 1 ) AS qq FROM x b ) AS ss2 USING ( qq ) INNER JOIN x c ON x = x ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x BOOLEAN , x BOOLEAN ) ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , x BOOLEAN , x BOOLEAN , FOREIGN KEY ( x ) REFERENCES x ( x ) ) ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , x BOOLEAN , FOREIGN KEY ( x ) REFERENCES x ( x ) ) ; 
INSERT INTO x VALUES ( 1 , TRUE , TRUE ) ; 
INSERT INTO x VALUES ( 1 , TRUE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , FALSE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , 1 , TRUE , TRUE ) ; 
INSERT INTO x VALUES ( 1 , 1 , TRUE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , 1 , FALSE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , 1 , TRUE ) ; 
INSERT INTO x VALUES ( 1 , 1 , FALSE ) ; 
SELECT * FROM x a FULL JOIN x b ON TRUE ; 
SELECT * FROM x a FULL JOIN x b ON FALSE ; 
CREATE TEMP TABLE x AS SELECT 1 AS q1 ; 
CREATE TEMP TABLE x AS SELECT 1 AS q2 ; 
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( SELECT 1 , 1 FROM x ) v1 ( x1 , x2 ) LEFT JOIN ( SELECT 1 , 1 FROM x ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( SELECT 1 , 1 FROM x ) v1 ( x1 , x2 ) LEFT JOIN ( SELECT 1 , 1 FROM x ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( VALUES ( 1 , 1 ) ) v1 ( x1 , x2 ) LEFT JOIN ( VALUES ( 1 , 1 ) ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( VALUES ( 1 , 1 ) ) v1 ( x1 , x2 ) LEFT JOIN ( VALUES ( 1 , 1 ) ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
$$EXPLAIN ( costs off ) SELECT x FROM x , x ( 1 ) x WHERE x = x ; 
EXPLAIN ( costs off ) SELECT x FROM x , LATERAL x ( 1 ) x WHERE x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x LEFT JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x RIGHT JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x FULL JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x FROM x , x ( 1 ) x WHERE x = 1 ; 
$$$$SELECT * FROM x ( 1 , 1 ) ; 
DROP FUNCTION x ( BIGINT , BIGINT ) ; 
EXPLAIN ( costs off ) SELECT * FROM x a JOIN x b ON ( x . x = 1 AND x . x = 1 ) OR ( x . x = 1 AND x . x = 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x a JOIN x b ON ( x . x = 1 AND x . x = 1 ) OR ( ( x . x = 1 OR x . x = 1 ) AND x . x = 1 ) ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = x . x AND x . x = x . x JOIN x ON x . x = x ; 
SELECT x ( * ) FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = x . x AND x . x = x . x JOIN x ON x . x = x ; 
EXPLAIN ( costs off ) SELECT x . x FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = 1 AND x . x = x . x JOIN x i1 ON x . x = x RIGHT JOIN x i2 ON x . x = x . x ORDER BY 1 ; 
SELECT x . x FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = 1 AND x . x = x . x JOIN x i1 ON x . x = x RIGHT JOIN x i2 ON x . x = x . x ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT * FROM ( VALUES ( 1 , ARRAY [ 1 , 1 ] ) , ( 1 , ARRAY [ 1 , 1 ] ) ) AS v1 ( v1x , v1ys ) LEFT JOIN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) AS v2 ( v2x , v2y ) ON x = x JOIN x ( x ) AS u1 ( u1y ) ON x = x ; 
SELECT * FROM ( VALUES ( 1 , ARRAY [ 1 , 1 ] ) , ( 1 , ARRAY [ 1 , 1 ] ) ) AS v1 ( v1x , v1ys ) LEFT JOIN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) AS v2 ( v2x , v2y ) ON x = x JOIN x ( x ) AS u1 ( u1y ) ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x , x , x FROM x a LEFT JOIN x b ON x = x WHERE COALESCE ( x , 1 ) = x AND x = COALESCE ( x , 1 ) ; 
SELECT x , x , x , x FROM x a LEFT JOIN x b ON x = x WHERE COALESCE ( x , 1 ) = x AND x = COALESCE ( x , 1 ) ; 
EXPLAIN ( costs off ) SELECT x , x , CASE WHEN x IS NULL THEN x ELSE 1 END FROM x a LEFT JOIN x b ON x = x WHERE ( CASE WHEN x IS NULL THEN x ELSE 1 END ) = 1 ; 
SELECT x , x , CASE WHEN x IS NULL THEN x ELSE 1 END FROM x a LEFT JOIN x b ON x = x WHERE ( CASE WHEN x IS NULL THEN x ELSE 1 END ) = 1 ; 
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , COALESCE ( x . x , x . x ) FROM x a LEFT JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = COALESCE ( x . x , x . x ) WHERE x . x < 1 AND COALESCE ( x . x , x . x ) = 1 ; 
SELECT x . x , x . x , x . x , COALESCE ( x . x , x . x ) FROM x a LEFT JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = COALESCE ( x . x , x . x ) WHERE x . x < 1 AND COALESCE ( x . x , x . x ) = 1 ; 
SELECT * FROM x t1 INNER JOIN x i8 ON x . x = 1 RIGHT JOIN x t2 ON x . x = 'x' LEFT JOIN x i4 ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT 1 AS id ) AS xx LEFT JOIN ( x AS a1 FULL JOIN ( SELECT 1 AS id ) AS yy ON ( x . x = x . x ) ) ON ( x . x = COALESCE ( x . x ) ) ; 
SELECT * FROM ( SELECT 1 AS id ) AS xx LEFT JOIN ( x AS a1 FULL JOIN ( SELECT 1 AS id ) AS yy ON ( x . x = x . x ) ) ON ( x . x = COALESCE ( x . x ) ) ; 
EXPLAIN ( costs off ) SELECT * FROM x a LEFT JOIN x b ON x = x WHERE x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x a FULL JOIN x b USING ( unique2 ) WHERE x = 1 ; 
SELECT x . x , x . x FROM x a LEFT JOIN x b ON x . x = COALESCE ( x . x , 1 ) WHERE COALESCE ( x . x , 1 ) > 1 ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , NULL ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN x ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( x LEFT JOIN x ON x . x = x . x ) ON ( x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x IN ( SELECT x . x FROM x LEFT JOIN x ON x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT * FROM x GROUP BY x . x , x . x ) s ON x . x = x . x AND x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT DISTINCT * FROM x ) s ON x . x = x . x AND x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT * FROM x GROUP BY x . x , x . x ) s ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT DISTINCT * FROM x ) s ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT x FROM x UNION SELECT x FROM x ) s ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x i8 LEFT JOIN ( SELECT x FROM x GROUP BY x ) i4 ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT 1 FROM ( SELECT x . x FROM x LEFT JOIN x ON x . x = x . x ) q , LATERAL x ( 1 , x . x ) gs ( i ) WHERE x . x = x . x ; 
CREATE TEMP TABLE x ( x INT UNIQUE , x INT ) ; 
SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) ; 
SELECT x . * , x FROM x p LEFT JOIN ( SELECT x . * , TRUE AS linked FROM x c ) AS ss ON ( x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x . * , x FROM x p LEFT JOIN ( SELECT x . * , TRUE AS linked FROM x c ) AS ss ON ( x . x = x . x ) ; 
SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) WHERE x . x = 1 AND x . x = 1 ; 
EXPLAIN ( costs off ) SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) WHERE x . x = 1 AND x . x = 1 ; 
SELECT x . * FROM ( x p LEFT JOIN x c ON ( x . x = x . x ) ) JOIN x x ON x . x = x . x WHERE x . x = 1 AND x . x = 1 ; 
EXPLAIN ( costs off ) SELECT x . * FROM ( x p LEFT JOIN x c ON ( x . x = x . x ) ) JOIN x x ON x . x = x . x WHERE x . x = 1 AND x . x = 1 ; 
SELECT * FROM x LEFT JOIN x ON ( x . x = x . x ) WHERE ( x . x IS NULL OR x . x > 1 ) ; 
SELECT x . * FROM x LEFT JOIN x ON ( x . x = x . x ) WHERE ( x . x IS NULL OR x . x > 1 ) ; 
CREATE TEMP TABLE x ( x int8 PRIMARY KEY , x int8 ) ; 
SELECT * FROM ( SELECT 1 AS x ) ss1 LEFT JOIN ( SELECT x , x , COALESCE ( x , x ) AS y FROM x LEFT JOIN x ON x = x ) ss2 ON TRUE ; 
CREATE TEMP TABLE x ( x TEXT UNIQUE ) ; 
SELECT x , x . * FROM x a , LATERAL ( SELECT * FROM x b WHERE x = x . x ) x ; 
EXPLAIN ( costs off ) SELECT x , x . * FROM x a , LATERAL ( SELECT * FROM x b WHERE x = x . x ) x ; 
SELECT x , x . * FROM x x , LATERAL ( SELECT x FROM x WHERE x = x ) ss ; 
EXPLAIN ( costs off ) SELECT x , x . * FROM x x , LATERAL ( SELECT x FROM x WHERE x = x ) ss ; 
EXPLAIN ( costs off ) SELECT x , x . * FROM x x CROSS JOIN LATERAL ( SELECT x FROM x WHERE x = x ) ss ; 
SELECT x , x . * FROM x x LEFT JOIN LATERAL ( SELECT x , x FROM x WHERE x = x ) ss ON TRUE ; 
EXPLAIN ( costs off ) SELECT x , x . * FROM x x LEFT JOIN LATERAL ( SELECT x , x FROM x WHERE x = x ) ss ON TRUE ; 
SELECT * , ( SELECT x FROM ( SELECT x AS q2 ) x , ( SELECT x AS r ) y ) FROM x ; 
SELECT * , ( SELECT x FROM ( SELECT x AS q2 ) x , LATERAL ( SELECT x AS r ) y ) FROM x ; 
SELECT x ( * ) FROM x a , LATERAL x ( 1 , x ) g ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , LATERAL x ( 1 , x ) g ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a CROSS JOIN LATERAL x ( 1 , x ) g ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , x ( 1 , x ) g ; 
EXPLAIN ( costs off ) SELECT * FROM x ( 1 , 1 ) g , LATERAL ( SELECT * FROM x a WHERE x = x UNION ALL SELECT * FROM x b WHERE x = x ) ss ; 
SELECT * FROM x ( 1 , 1 ) g , LATERAL ( SELECT * FROM x a WHERE x = x UNION ALL SELECT * FROM x b WHERE x = x ) ss ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , x b JOIN LATERAL ( VALUES ( x . x ) ) ss ( x ) ON x . x = x . x ; 
SELECT x ( * ) FROM x a , x b JOIN LATERAL ( VALUES ( x . x ) ) ss ( x ) ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , x b JOIN LATERAL ( VALUES ( x . x ) , ( 1 ) ) ss ( x ) ON x . x = x . x ; 
SELECT x ( * ) FROM x a , x b JOIN LATERAL ( VALUES ( x . x ) , ( 1 ) ) ss ( x ) ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT * FROM x a , x x LEFT JOIN LATERAL ( SELECT x . x FROM x y ) ss ( z ) ON x . x = x . x ORDER BY x . x , x . x , x . x , x . x , x . x ; 
SELECT * FROM x a , x x LEFT JOIN LATERAL ( SELECT x . x FROM x y ) ss ( z ) ON x . x = x . x ORDER BY x . x , x . x , x . x , x . x , x . x ; 
SELECT * FROM ( SELECT x / 1 AS x FROM x ) ss1 JOIN x i4 ON x = x , LATERAL ( SELECT x ) ss2 ( y ) ; 
SELECT * FROM ( SELECT x AS x FROM x ) ss1 JOIN x i4 ON x = x , LATERAL ( VALUES ( x ) ) ss2 ( y ) ; 
SELECT * FROM ( ( SELECT x / 1 AS x FROM x ) ss1 JOIN x i4 ON x = x ) j , LATERAL ( SELECT x ) ss2 ( y ) ; 
SELECT * FROM ( VALUES ( 1 ) ) x ( lb ) , LATERAL x ( x , 1 ) x4 ; 
SELECT * FROM ( SELECT x / 1 FROM x ) x ( lb ) , LATERAL x ( x , 1 ) x4 ; 
SELECT * FROM ( VALUES ( 1 ) ) x ( lb ) , LATERAL ( VALUES ( x ) ) y ( lbcopy ) ; 
SELECT * FROM ( VALUES ( 1 ) ) x ( lb ) , LATERAL ( SELECT x FROM x ) y ( lbcopy ) ; 
SELECT * FROM x x LEFT JOIN ( SELECT x , COALESCE ( x , 1 ) q2 FROM x ) y ON x . x = x . x , LATERAL ( VALUES ( x . x , x . x , x . x ) ) v ( xq1 , yq1 , yq2 ) ; 
SELECT * FROM x x LEFT JOIN ( SELECT x , COALESCE ( x , 1 ) q2 FROM x ) y ON x . x = x . x , LATERAL ( SELECT x . x , x . x , x . x ) v ( xq1 , yq1 , yq2 ) ; 
SELECT x . * FROM x x LEFT JOIN ( SELECT x , COALESCE ( x , 1 ) q2 FROM x ) y ON x . x = x . x , LATERAL ( SELECT x . x , x . x , x . x ) v ( xq1 , yq1 , yq2 ) ; 
SELECT x . * FROM ( x x LEFT JOIN ( SELECT x , COALESCE ( x , 1 ) q2 FROM x ) y ON x . x = x . x ) LEFT JOIN x z ON x . x = x . x , LATERAL ( SELECT x . x , x . x UNION ALL SELECT x . x , x . x ) v ( vx , vy ) ; 
SELECT x . * FROM ( x x LEFT JOIN ( SELECT x , ( SELECT COALESCE ( x , 1 ) ) q2 FROM x ) y ON x . x = x . x ) LEFT JOIN x z ON x . x = x . x , LATERAL ( SELECT x . x , x . x UNION ALL SELECT x . x , x . x ) v ( vx , vy ) ; 
SELECT x . * FROM ( x x LEFT JOIN ( SELECT x , ( SELECT COALESCE ( x , 1 ) ) q2 FROM x ) y ON x . x = x . x ) LEFT JOIN x z ON x . x = x . x , LATERAL ( SELECT x . x , x . x FROM x UNION ALL SELECT x . x , x . x FROM x ) v ( vx , vy ) ; 
SELECT * FROM x a LEFT JOIN LATERAL ( SELECT * , x . x AS x FROM x b ) ss ON x . x = x . x ; 
SELECT * FROM x a LEFT JOIN LATERAL ( SELECT * , COALESCE ( x . x , 1 ) AS x FROM x b ) ss ON x . x = x . x ; 
SELECT * FROM x i LEFT JOIN LATERAL ( SELECT * FROM x j WHERE x . x = x . x ) k ON TRUE ; 
SELECT * FROM x i LEFT JOIN LATERAL ( SELECT COALESCE ( x ) FROM x j WHERE x . x = x . x ) k ON TRUE ; 
SELECT * FROM x a , LATERAL ( SELECT * FROM x b LEFT JOIN x c ON ( x . x = x AND x . x = x ) ) ss ; 
SELECT * FROM x a LEFT JOIN LATERAL ( SELECT x . x AS bq1 , x . x AS cq1 , LEAST ( x . x , x . x , x . x ) FROM x b CROSS JOIN x c ) ss ON x . x = x . x ; 
SELECT * FROM ( ( SELECT 1 AS v ) UNION ALL ( SELECT 1 AS v ) ) AS q1 CROSS JOIN LATERAL ( ( SELECT * FROM ( ( SELECT 1 AS v ) UNION ALL ( SELECT 1 AS v ) ) AS q3 ) UNION ALL ( SELECT x . x ) ) AS q2 ; 
SELECT * FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) v ( id , x ) , LATERAL ( SELECT x FROM x WHERE x = ANY ( SELECT x FROM x WHERE x = x . x OFFSET 1 ) ) ss ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( id ) , LATERAL ( SELECT * FROM x t1 , LATERAL ( SELECT * FROM ( SELECT * FROM x t2 WHERE x = ANY ( SELECT x FROM x t3 WHERE x = ( SELECT GREATEST ( x . x , x . x ) ) AND ( SELECT x . x = 1 ) ) OFFSET 1 ) ss2 ) ss WHERE x . x = x . x ) ss0 ; 
SELECT x , x FROM x a , ( SELECT x AS g ) ss ; 
SELECT x , x FROM x a , ( SELECT x . x AS g ) ss ; 
SELECT x , x FROM x a CROSS JOIN ( SELECT x AS g ) ss ; 
SELECT x , x FROM x a CROSS JOIN ( SELECT x . x AS g ) ss ; 
SELECT x , x FROM x a RIGHT JOIN LATERAL x ( 1 , x . x ) g ON TRUE ; 
SELECT x , x FROM x a FULL JOIN LATERAL x ( 1 , x . x ) g ON TRUE ; 
SELECT * FROM x x CROSS JOIN ( x x CROSS JOIN LATERAL ( SELECT x . x ) ss ) ; 
SELECT 1 FROM x a , LATERAL ( SELECT x ( x . x ) FROM x b ) ss ; 
CREATE TEMP TABLE x AS SELECT x AS x1 , - x AS x2 FROM x ; 
UPDATE x SET x = x FROM ( SELECT * FROM x WHERE x = x ) ss ; 
UPDATE x SET x = x FROM ( SELECT * FROM x WHERE x = x . x ) ss ; 
UPDATE x SET x = x FROM LATERAL ( SELECT * FROM x WHERE x = x ) ss ; 
UPDATE x SET x = x FROM x , LATERAL ( SELECT * FROM x WHERE x = x ) ss ; 
DELETE FROM x USING ( SELECT * FROM x WHERE x = x ) ss ; 
DELETE FROM x USING ( SELECT * FROM x WHERE x = x . x ) ss ; 
DELETE FROM x USING LATERAL ( SELECT * FROM x WHERE x = x ) ss ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ; 
CREATE TABLE x ( x INT , x INT , x VARCHAR ) ; 
SELECT x . x , x . x FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x t3a , LEAST ( x . x , x . x , x . x ) phv FROM x t2 JOIN x t3 ON x . x = x . x ) ss ON x . x = x . x ORDER BY x . x ; 
CREATE TABLE x ( x INT , x INT , x INT UNIQUE , PRIMARY KEY ( x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
INSERT INTO x SELECT x / 1 , x % 1 , x FROM x ( 1 , 1 ) x ; 
INSERT INTO x SELECT x / 1 , x % 1 FROM x ( 1 , 1 ) x ; 
ALTER TABLE x ADD CONSTRAINT fkest1_a_b_fkey FOREIGN KEY ( x , x ) REFERENCES x ; 
SET enable_nestloop TO 1 ; 
SET enable_hashjoin TO 1 ; 
SET enable_sort TO 1 ; 
CREATE INDEX x ON x ( x ) WHERE x % 1 = 1 ; 
CREATE TABLE x AS SELECT x , x FROM x ; 
VACUUM ANALYZE x ; 
SELECT * FROM x ( NULL ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) PARTITION BY list ( b ) ; 
CREATE INDEX x ON ONLY x ( x ) ; 
SELECT * FROM x ( 'x' ) ; 
CREATE MATERIALIZED VIEW x AS SELECT 1 ; 
COMMENT ON VIEW noview IS 'x' ; 
COMMENT ON VIEW toyemp IS 'x' ; 
COMMENT ON VIEW toyemp IS NULL ; 
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x > 1 ; 
CREATE OR REPLACE VIEW x AS SELECT x , x FROM x WHERE x > 1 ORDER BY x DESC ; 
CREATE OR REPLACE VIEW x AS SELECT 1 , * FROM x ; 
CREATE OR REPLACE VIEW x AS SELECT x , x , 1 AS c FROM x ; 
CREATE SCHEMA x CREATE TABLE x ( x INT , x INT ) CREATE TABLE x ( x INT , x INT ) ; 
SET search_path TO temp_view_test , public ; 
CREATE TEMPORARY TABLE x ( x INT , x INT ) ; 
CREATE VIEW x . v2 AS SELECT * FROM x ; 
CREATE VIEW x . v3_temp AS SELECT * FROM x ; 
CREATE SCHEMA x CREATE TEMP VIEW x AS SELECT 1 ; 
CREATE VIEW x AS SELECT x . x AS t1_a , x . x AS t2_a FROM x t1 , x t2 WHERE x . x = x . x ; 
CREATE VIEW x AS SELECT x . x AS t1_a , x . x AS t2_a , x . x AS t3_a FROM x t1 , x t2 , x t3 WHERE x . x = x . x AND x . x = x . x ; 
CREATE VIEW x AS SELECT * FROM x WHERE x IN ( SELECT x FROM x ) ; 
CREATE VIEW x AS SELECT x . x , x . x FROM x t1 , ( SELECT * FROM x ) t2 ; 
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS ( SELECT 1 FROM x ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE NOT EXISTS ( SELECT 1 FROM x ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS ( SELECT 1 ) ; 
CREATE VIEW x AS SELECT x . x , x . x FROM x t1 , x t2 ; 
CREATE VIEW x AS SELECT TRUE FROM x ; 
CREATE TEMPORARY SEQUENCE x ; 
CREATE VIEW x AS SELECT x . x FROM x ; 
SELECT x FROM x WHERE x LIKE 'x' AND x = ( SELECT x FROM x WHERE x = 'x' ) ORDER BY x ; 
SELECT x FROM x WHERE x LIKE 'x' AND x IN ( SELECT x FROM x WHERE x LIKE 'x' ) ORDER BY x ; 
SET search_path TO testviewschm2 , public ; 
CREATE VIEW x AS SELECT * FROM x CROSS JOIN x ; 
CREATE VIEW x AS SELECT * FROM x INNER JOIN x ON x . x = x . x ; 
CREATE VIEW x AS SELECT * FROM x LEFT JOIN x ON x . x = x . x ; 
SELECT x ( * ) FROM x WHERE x = 'x' AND x IN ( SELECT x FROM x WHERE x = 'x' ) ; 
SELECT x ( * ) FROM x WHERE x LIKE 'x' AND x IN ( SELECT x FROM x WHERE x LIKE 'x' ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE x = 1 ; 
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x = 1 ; 
CREATE TABLE x . tt1 ( x INT , x INT , x TEXT ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS ( SELECT 1 FROM x WHERE x . x = x . x ) ; 
CREATE VIEW x AS SELECT * FROM x a1 WHERE EXISTS ( SELECT 1 FROM x WHERE x . x = x . x ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS ( SELECT 1 FROM x a2 WHERE x . x = x . x ) ; 
CREATE VIEW x AS SELECT * FROM x . tt1 WHERE EXISTS ( SELECT 1 FROM x WHERE x . x . x = x . x ) ; 
ALTER TABLE x SET SCHEMA temp_view_test ; 
ALTER TABLE x . tt1 RENAME TO x ; 
ALTER TABLE x . tmp1 SET SCHEMA testviewschm2 ; 
CREATE TABLE x ( x int8 , x int2 , x NUMERIC ) ; 
CREATE VIEW x AS SELECT * FROM x NATURAL JOIN x ; 
CREATE VIEW x AS SELECT * FROM ( x NATURAL JOIN x ) j ; 
CREATE VIEW x AS SELECT * FROM x JOIN x USING ( b , c ) JOIN x USING ( b ) ; 
CREATE VIEW x AS SELECT * FROM ( x JOIN x USING ( b , c ) JOIN x USING ( b ) ) j ; 
CREATE VIEW x AS SELECT * FROM x JOIN x USING ( b , c ) FULL JOIN x USING ( b ) ; 
SELECT x ( 'x' , TRUE ) ; 
CREATE VIEW x AS SELECT * FROM ( x CROSS JOIN x ) j ( aa , bb , cc , dd ) ; 
ALTER VIEW x RENAME COLUMN x TO x ; 
CREATE TABLE x ( x date , x INT , x INT ) ; 
CREATE TABLE x ( x timestamptz , x INT ) ; 
CREATE VIEW x AS SELECT x , x , x FROM x JOIN x USING ( x ) ; 
CREATE VIEW x AS SELECT x , x , x , x FROM ( x JOIN x USING ( x ) ) JOIN x USING ( z ) ; 
CREATE TABLE x ( x TEXT , x TEXT , x TEXT , x TEXT ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' , 'x' ) ; 
$$$$CREATE VIEW x AS SELECT x . * FROM x ( ) t ; 
CREATE TYPE nestedcomposite AS ( x int8_tbl ) ; 
CREATE VIEW x AS SELECT * FROM x i , LATERAL ( VALUES ( x ) ) ss ; 
CREATE VIEW x AS SELECT * FROM x i WHERE x IN ( VALUES ( x ) ) ; 
CREATE VIEW x AS SELECT * FROM x xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy UNION ALL SELECT * FROM x xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz ; 
DROP SCHEMA temp_view_test CASCADE ; 
DROP SCHEMA testviewschm2 CASCADE ; 
SELECT XMLCONCAT ( x ( 'x' ) , XMLELEMENT ( NAME qux , 'x' ) , x ( 'x' ) ) ; 
SELECT XMLCONCAT ( 'x' , 'x' ) ; 
SELECT XMLCONCAT ( 1 , 1 ) ; 
SELECT XMLCONCAT ( 'x' , NULL , 'x' ) ; 
SELECT XMLCONCAT ( NULL ) ; 
SELECT XMLCONCAT ( NULL , NULL ) ; 
SELECT XMLELEMENT ( NAME element , XMLATTRIBUTES ( 1 AS one , 'x' AS two ) , 'x' ) ; 
SELECT XMLELEMENT ( NAME element , XMLATTRIBUTES ( 'x' ) ) ; 
SELECT XMLELEMENT ( NAME element , XMLELEMENT ( NAME nested , 'x' ) ) ; 
SELECT XMLELEMENT ( NAME duplicate , XMLATTRIBUTES ( 1 AS a , 1 AS b , 1 AS a ) ) ; 
SELECT XMLELEMENT ( NAME num , 1 ) ; 
SELECT XMLELEMENT ( NAME foo , TEXT 'x' ) ; 
SELECT XMLELEMENT ( NAME foo , ARRAY [ 1 , 1 , 1 ] ) ; 
SET xmlbinary TO base64 ; 
SELECT XMLELEMENT ( NAME foo , x 'x' ) ; 
SET xmlbinary TO hex ; 
SELECT XMLELEMENT ( NAME foo , XMLATTRIBUTES ( TRUE AS bar ) ) ; 
SELECT XMLPARSE ( CONTENT 'x' ) ; 
SELECT XMLPARSE ( DOCUMENT 'x' ) ; 
SELECT XMLPI ( NAME foo ) ; 
SELECT XMLPI ( NAME xmlstuff ) ; 
SELECT XMLPI ( NAME foo , 'x' ) ; 
SELECT XMLPI ( NAME foo , NULL ) ; 
SELECT XMLPI ( NAME xmlstuff , NULL ) ; 
SELECT XMLPI ( NAME xml-stylesheet" , 'x' ) ; 
SELECT XMLROOT ( 'x' , VERSION NO VALUE , STANDALONE NO ) ; 
SELECT XMLROOT ( 'x' , VERSION NO VALUE , STANDALONE NO VALUE ) ; 
SELECT XMLROOT ( 'x' , VERSION NO VALUE ) ; 
SELECT XMLSERIALIZE ( CONTENT 'x' AS CHAR ( 1 ) ) ; 
SELECT XMLSERIALIZE ( DOCUMENT 'x' AS TEXT ) ; 
SELECT 'x' IS NOT DOCUMENT ; 
SELECT XMLPI ( NAME :::_xml_abc135.%-&_" ) ; 
SELECT XMLPI ( NAME 123" ) ; 
SET XML OPTION DOCUMENT ; 
EXECUTE foo ( 'x' ) ; 
SET XML OPTION CONTENT ; 
CREATE VIEW x AS SELECT x ( 'x' ) ; 
CREATE VIEW x AS SELECT XMLCONCAT ( 'x' , 'x' ) ; 
CREATE VIEW x AS SELECT XMLELEMENT ( NAME element , XMLATTRIBUTES ( 1 AS :one:" , 'x' AS two ) , 'x' ) ; 
CREATE VIEW x AS SELECT XMLPARSE ( CONTENT 'x' ) ; 
CREATE VIEW x AS SELECT XMLPI ( NAME foo , 'x' ) ; 
CREATE VIEW x AS SELECT XMLSERIALIZE ( CONTENT 'x' AS CHAR ( 1 ) ) ; 
CREATE VIEW x AS SELECT XMLSERIALIZE ( CONTENT 'x' AS TEXT ) ; 
SELECT x , x FROM x . views WHERE x LIKE 'x' ORDER BY 1 ; 
SELECT x ( NULL , NULL ) IS NULL FROM x ; 
SELECT x ( 'x' , 'x' , ARRAY [ ARRAY [ 'x' , 'x' ] ] ) ; 
$$$$SELECT XMLEXISTS ( 'x' PASSING BY REF 'x' ) ; 
\\\SELECT * FROM XMLTABLE ( XMLNAMESPACES ( 'x' AS zz ) , 'x' PASSING 'x' COLUMNS a INT PATH 'x' ) ; 
CREATE VIEW x AS SELECT * FROM XMLTABLE ( XMLNAMESPACES ( 'x' AS zz ) , 'x' PASSING 'x' COLUMNS a INT PATH 'x' ) ; 
SELECT * FROM XMLTABLE ( XMLNAMESPACES ( DEFAULT 'x' ) , 'x' PASSING 'x' COLUMNS a INT PATH 'x' ) ; 
SELECT * FROM XMLTABLE ( 'x' PASSING 'x' COLUMNS a TEXT PATH 'x' ) ; 
EXECUTE pp ; 
SELECT * FROM XMLTABLE ( 'x' PASSING 'x' COLUMNS element TEXT ) ; 
SELECT * FROM XMLTABLE ( 'x' PASSING 'x' COLUMNS ent TEXT ) ; 
\\CREATE TEMP TABLE x ( x serial , x TEXT , x INT DEFAULT 1 ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , DEFAULT ) , ( 'x' , 1 ) , ( x ( 'x' ) , 1 + 1 ) RETURNING * , x + x AS sum ; 
UPDATE x SET x = x ( x ) , x = DEFAULT RETURNING x . * , x + x AS sum13 ; 
DELETE FROM x WHERE x > 1 RETURNING x , x , x , LEAST ( x , x ) ; 
INSERT INTO x SELECT x + 1 , x , x + 1 FROM x RETURNING * , x + 1 IN ( SELECT x FROM x ) AS subplan , EXISTS ( SELECT * FROM x ) AS initplan ; 
UPDATE x SET x = x * 1 WHERE x > 1 RETURNING * , x + 1 IN ( SELECT x FROM x ) AS subplan , EXISTS ( SELECT * FROM x ) AS initplan ; 
DELETE FROM x WHERE x > 1 RETURNING * , x + 1 IN ( SELECT x FROM x ) AS subplan , EXISTS ( SELECT * FROM x ) AS initplan ; 
UPDATE x SET x = x * 1 FROM x i WHERE x . x + 1 = x . x RETURNING x . * , x . x AS i.f1" ; 
DELETE FROM x USING x i WHERE x . x + 1 = x . x RETURNING x . * , x . x AS i.f1" ; 
CREATE TEMP TABLE x ( x INT ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 , 1 ) ; 
ALTER TABLE x ADD COLUMN x int8 DEFAULT 1 ; 
UPDATE x SET x = x + x WHERE x = 1 RETURNING * ; 
UPDATE x SET x = x * 1 FROM x i WHERE x . x = x . x RETURNING * ; 
DELETE FROM x USING x i WHERE x . x = x . x RETURNING * ; 
CREATE TEMP VIEW x AS SELECT x , x FROM x ; 
INSERT INTO x VALUES ( 1 , 'x' ) RETURNING * , x * 1 ; 
INSERT INTO x VALUES ( 1 , 'x' ) RETURNING * ; 
UPDATE x SET x = x + 1 WHERE x = 'x' ; 
UPDATE x SET x = x + 1 WHERE x = 'x' RETURNING * , x * 1 ; 
DELETE FROM x WHERE x = 'x' RETURNING * ; 
CREATE TEMP TABLE x ( x TEXT , x INT ) ; 
CREATE TEMP VIEW x AS SELECT x . * , x FROM x JOIN x ON ( x = x ) ; 
UPDATE x SET x = x + 1 WHERE x = 1 RETURNING * , x + 1 ; 
BEGIN TRANSACTION READ WRITE ; 
SELECT * FROM x FOR UPDATE ; 
UPDATE x SET x = NULL WHERE x > 1 ; 
CREATE TEMPORARY TABLE x ( x INTEGER ) ; 
COMMIT PREPARED 'x' ; 
ROLLBACK PREPARED 'x' ; 
LOCK x ; 
LOCK x IN SHARE UPDATE EXCLUSIVE MODE ; 
LOCK x IN SHARE MODE ; 
LOCK x IN SHARE ROW EXCLUSIVE MODE ; 
LOCK x IN EXCLUSIVE MODE ; 
LISTEN a ; 
NOTIFY a ; 
CLUSTER x USING x ; 
REINDEX TABLE x ; 
REVOKE SELECT ON x FROM x ; 
GRANT SELECT ON x TO x ; 
CREATE TABLE x ( x TEXT , LIKE x ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , DEFAULT , 'x' ) ; 
CREATE TABLE x ( x BIGINT GENERATED ALWAYS AS IDENTITY , x TEXT ) ; 
CREATE TABLE x ( x INT , x INT GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x ( LIKE x INCLUDING GENERATED ) ; 
CREATE TABLE x ( x INT , x INT DEFAULT 1 , x INT GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x ( LIKE x INCLUDING DEFAULTS ) ; 
CREATE TABLE x ( LIKE x INCLUDING DEFAULTS INCLUDING GENERATED ) ; 
DROP TABLE x , x , x , x , x ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , 1 , 1 ) ; 
CREATE TABLE x ( x TEXT CHECK ( x ( x ) > 1 ) PRIMARY KEY , x TEXT ) ; 
CREATE INDEX x ON x ( ( x || x ) ) ; 
CREATE STATISTICS ctlt1_a_b_stat ON x , x FROM x ; 
COMMENT ON STATISTICS ctlt1_a_b_stat IS 'x' ; 
COMMENT ON COLUMN ctlt1 . a IS 'x' ; 
COMMENT ON COLUMN ctlt1 . b IS 'x' ; 
COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 'x' ; 
COMMENT ON INDEX ctlt1_pkey IS 'x' ; 
COMMENT ON INDEX ctlt1_b_key IS 'x' ; 
COMMENT ON COLUMN ctlt2 . c IS 'x' ; 
CREATE TABLE x ( x TEXT CHECK ( x ( x ) < 1 ) , x TEXT ) ; 
COMMENT ON COLUMN ctlt3 . a IS 'x' ; 
COMMENT ON COLUMN ctlt3 . c IS 'x' ; 
COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 'x' ; 
CREATE TABLE x ( LIKE x INCLUDING STORAGE , LIKE x INCLUDING STORAGE ) ; 
CREATE TABLE x ( LIKE x INCLUDING COMMENTS , LIKE x INCLUDING COMMENTS ) ; 
CREATE TABLE x ( LIKE x INCLUDING CONSTRAINTS INCLUDING COMMENTS ) INHERITS ( x ) ; 
CREATE TABLE x ( ) INHERITS ( x , x ) ; 
CREATE TABLE x ( LIKE x INCLUDING CONSTRAINTS INCLUDING COMMENTS INCLUDING STORAGE ) INHERITS ( x ) ; 
CREATE TABLE x ( LIKE x INCLUDING STORAGE ) INHERITS ( x ) ; 
DROP TABLE x , x , x , x , x , x , x , x , x , x , x , x CASCADE ; 
CREATE TYPE ctlty1 AS ( a INT , b TEXT ) ; 
DROP TYPE ctlty1 ; 
DROP TABLE IF EXISTS x , x , x , x , x ; 
SELECT x ( * ) >= 1 AS ok FROM x ; 
SELECT x ( * ) > 1 AS ok FROM x ; 
SELECT x ( * ) = 1 AS ok FROM x ; 
SELECT x ( DISTINCT x ) >= 1 AS ok FROM x ; 
SET timezone_abbreviations = 'x' ; 
DROP ROLE IF EXISTS x , x , x , x , x , x ; 
CREATE ROLE x SUPERUSER ; 
CREATE FOREIGN DATA WRAPPER dummy ; 
COMMENT ON FOREIGN DATA WRAPPER dummy IS 'x' ; 
CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator ; 
CREATE FOREIGN DATA WRAPPER foo OPTIONS ( testing 'x' ) ; 
DROP FOREIGN DATA WRAPPER foo ; 
SET ROLE regress_test_role ; 
CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator ; 
DROP FOREIGN DATA WRAPPER test_fdw ; 
ALTER FOREIGN DATA WRAPPER foo OPTIONS ( a 'x' , b 'x' ) ; 
ALTER FOREIGN DATA WRAPPER foo OPTIONS ( DROP a , SET b 'x' , ADD c 'x' ) ; 
ALTER FOREIGN DATA WRAPPER foo OPTIONS ( a 'x' ) ; 
ALTER FOREIGN DATA WRAPPER foo OPTIONS ( ADD d 'x' ) ; 
ALTER ROLE x NOSUPERUSER ; 
SET ROLE regress_test_role_super ; 
ALTER FOREIGN DATA WRAPPER foo RENAME TO foo1 ; 
ALTER FOREIGN DATA WRAPPER foo1 RENAME TO foo ; 
CREATE FOREIGN DATA WRAPPER foo ; 
CREATE SERVER s1 FOREIGN DATA WRAPPER foo ; 
COMMENT ON SERVER s1 IS 'x' ; 
CREATE USER MAPPING FOR CURRENT_USER SERVER s1 ; 
DROP FOREIGN DATA WRAPPER foo CASCADE ; 
CREATE SERVER s3 TYPE 'x' FOREIGN DATA WRAPPER foo ; 
CREATE SERVER s4 TYPE 'x' FOREIGN DATA WRAPPER foo OPTIONS ( host 'x' , dbname 'x' ) ; 
CREATE SERVER s5 VERSION 'x' FOREIGN DATA WRAPPER foo ; 
CREATE SERVER s6 VERSION 'x' FOREIGN DATA WRAPPER foo OPTIONS ( host 'x' , dbname 'x' ) ; 
CREATE SERVER s7 TYPE 'x' VERSION 'x' FOREIGN DATA WRAPPER foo OPTIONS ( host 'x' , dbname 'x' ) ; 
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO x ; 
CREATE SERVER t1 FOREIGN DATA WRAPPER foo ; 
REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM x ; 
GRANT regress_test_indirect TO x ; 
CREATE SERVER t2 FOREIGN DATA WRAPPER foo ; 
REVOKE regress_test_indirect FROM x ; 
ALTER SERVER s2 VERSION 'x' ; 
ALTER SERVER s3 OPTIONS ( tns name" 'x' , port 'x' ) ; 
GRANT USAGE ON FOREIGN SERVER s1 TO x ; 
GRANT USAGE ON FOREIGN SERVER s6 TO x WITH GRANT OPTION ; 
ALTER SERVER s1 OWNER TO x ; 
GRANT regress_test_role2 TO x ; 
ALTER SERVER s1 VERSION 'x' ; 
ALTER SERVER s8new RENAME TO s8 ; 
ALTER SERVER s2 OWNER TO x ; 
DROP SERVER s2 ; 
CREATE USER MAPPING FOR CURRENT_USER SERVER s3 ; 
ALTER SERVER s5 OWNER TO x ; 
ALTER SERVER s6 OWNER TO x ; 
CREATE USER MAPPING FOR CURRENT_USER SERVER s5 ; 
CREATE USER MAPPING FOR CURRENT_USER SERVER s6 OPTIONS ( username 'x' ) ; 
ALTER SERVER t1 OWNER TO x ; 
CREATE USER MAPPING FOR x SERVER t1 ; 
ALTER USER MAPPING FOR CURRENT_USER SERVER s5 OPTIONS ( ADD modified 'x' ) ; 
DROP USER MAPPING IF EXISTS FOR USER SERVER ss4 ; 
DROP USER MAPPING IF EXISTS FOR x SERVER s7 ; 
CREATE USER MAPPING FOR x SERVER s8 ; 
DROP SERVER s7 ; 
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy ; 
COMMENT ON FOREIGN TABLE ft1 IS 'x' ; 
COMMENT ON COLUMN ft1 . c1 IS 'x' ; 
CREATE FOREIGN TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) SERVER s0 ; 
CREATE FOREIGN TABLE x ( x INT ) SERVER s0 ; 
DROP FOREIGN TABLE x , x ; 
DROP FOREIGN TABLE x ; 
CREATE FOREIGN TABLE x ( x INT NOT NULL ) SERVER s0 ; 
COMMENT ON FOREIGN TABLE ft1 IS NULL ; 
COMMENT ON COLUMN ft1 . c1 IS NULL ; 
ALTER FOREIGN TABLE x ADD COLUMN x INTEGER ; 
ALTER FOREIGN TABLE x ADD COLUMN x INTEGER DEFAULT 1 ; 
ALTER FOREIGN TABLE x ADD COLUMN x INTEGER NOT NULL ; 
ALTER FOREIGN TABLE x ADD COLUMN x INTEGER OPTIONS ( p1 'x' ) ; 
ALTER FOREIGN TABLE x ALTER COLUMN x SET DEFAULT 1 ; 
ALTER FOREIGN TABLE x ALTER COLUMN x DROP DEFAULT ; 
ALTER FOREIGN TABLE x ALTER COLUMN x SET NOT NULL ; 
ALTER FOREIGN TABLE x ALTER COLUMN x DROP NOT NULL ; 
ALTER FOREIGN TABLE x ALTER COLUMN x SET DATA TYPE TEXT ; 
ALTER FOREIGN TABLE x ALTER COLUMN x OPTIONS ( SET p2 'x' , DROP p1 ) ; 
ALTER FOREIGN TABLE x ALTER COLUMN x SET STATISTICS 1 ; 
ALTER FOREIGN TABLE x ALTER COLUMN x SET ( n_distinct = 1 ) ; 
CREATE TABLE x ( x ft1 ) ; 
ALTER FOREIGN TABLE x OWNER TO x ; 
ALTER FOREIGN TABLE x DROP COLUMN x ; 
ALTER FOREIGN TABLE x SET SCHEMA foreign_schema ; 
ALTER FOREIGN TABLE x . ft1 RENAME TO x ; 
ALTER FOREIGN TABLE IF EXISTS x ADD COLUMN x INTEGER ; 
ALTER FOREIGN TABLE IF EXISTS x ADD COLUMN x INTEGER NOT NULL ; 
ALTER FOREIGN TABLE IF EXISTS x ADD COLUMN x INTEGER OPTIONS ( p1 'x' ) ; 
ALTER FOREIGN TABLE IF EXISTS x ALTER COLUMN x SET NOT NULL ; 
ALTER FOREIGN TABLE IF EXISTS x ALTER COLUMN x DROP NOT NULL ; 
ALTER FOREIGN TABLE IF EXISTS x ALTER COLUMN x TYPE CHAR ( 1 ) ; 
ALTER FOREIGN TABLE IF EXISTS x ALTER COLUMN x SET DATA TYPE TEXT ; 
ALTER FOREIGN TABLE IF EXISTS x ALTER COLUMN x OPTIONS ( ADD p1 'x' , ADD p2 'x' ) , ALTER COLUMN x OPTIONS ( ADD p1 'x' , ADD p2 'x' ) ; 
ALTER FOREIGN TABLE IF EXISTS x ALTER COLUMN x OPTIONS ( SET p2 'x' , DROP p1 ) ; 
ALTER FOREIGN TABLE IF EXISTS x DROP CONSTRAINT IF EXISTS no_const ; 
ALTER FOREIGN TABLE IF EXISTS x DROP CONSTRAINT ft1_c1_check ; 
ALTER FOREIGN TABLE IF EXISTS x OWNER TO x ; 
ALTER FOREIGN TABLE IF EXISTS x DROP COLUMN IF EXISTS x ; 
ALTER FOREIGN TABLE IF EXISTS x DROP COLUMN x ; 
ALTER FOREIGN TABLE IF EXISTS x SET SCHEMA foreign_schema ; 
ALTER FOREIGN TABLE IF EXISTS x RENAME x TO x ; 
ALTER FOREIGN TABLE IF EXISTS x RENAME TO x ; 
SELECT * FROM x . foreign_data_wrappers ORDER BY 1 , 1 ; 
SELECT * FROM x . foreign_data_wrapper_options ORDER BY 1 , 1 , 1 ; 
SELECT * FROM x . foreign_servers ORDER BY 1 , 1 ; 
SELECT * FROM x . foreign_server_options ORDER BY 1 , 1 , 1 ; 
SELECT * FROM x . user_mappings ORDER BY x ( x ) , 1 , 1 ; 
SELECT * FROM x . user_mapping_options ORDER BY x ( x ) , 1 , 1 , 1 ; 
SELECT * FROM x . usage_privileges WHERE x LIKE 'x' AND x IN ( 'x' , 'x' ) ORDER BY 1 , 1 , 1 , 1 , 1 ; 
SELECT * FROM x . role_usage_grants WHERE x LIKE 'x' AND x IN ( 'x' , 'x' ) ORDER BY 1 , 1 , 1 , 1 , 1 ; 
SELECT * FROM x . foreign_tables ORDER BY 1 , 1 , 1 ; 
SELECT * FROM x . foreign_table_options ORDER BY 1 , 1 , 1 , 1 ; 
SELECT * FROM x . user_mapping_options ORDER BY 1 , 1 , 1 , 1 ; 
DROP USER MAPPING FOR CURRENT_USER SERVER t1 ; 
SET ROLE regress_test_role2 ; 
SELECT x ( 'x' , ( SELECT x FROM x WHERE x = 'x' ) , 'x' ) ; 
SELECT x ( ( SELECT x FROM x WHERE x = 'x' ) , ( SELECT x FROM x WHERE x = 'x' ) , 'x' ) ; 
SELECT x ( ( SELECT x FROM x WHERE x = 'x' ) , 'x' ) ; 
SELECT x ( ( SELECT x FROM x WHERE x = 'x' ) , 'x' , 'x' ) ; 
GRANT USAGE ON FOREIGN SERVER s8 TO x ; 
REVOKE USAGE ON FOREIGN SERVER s8 FROM x ; 
GRANT USAGE ON FOREIGN SERVER s4 TO x ; 
DROP USER MAPPING FOR x SERVER s4 ; 
ALTER SERVER s6 OPTIONS ( DROP host , DROP dbname ) ; 
ALTER USER MAPPING FOR x SERVER s6 OPTIONS ( DROP username ) ; 
ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator ; 
SET ROLE regress_unprivileged_role ; 
GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO x ; 
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO x WITH GRANT OPTION ; 
CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql ; 
GRANT USAGE ON FOREIGN SERVER s9 TO x ; 
CREATE USER MAPPING FOR CURRENT_USER SERVER s9 ; 
DROP SERVER s9 CASCADE ; 
CREATE SERVER s9 FOREIGN DATA WRAPPER foo ; 
CREATE SERVER s10 FOREIGN DATA WRAPPER foo ; 
DROP SERVER s10 CASCADE ; 
$$ALTER FOREIGN TABLE x . foreign_table_1 DISABLE TRIGGER trigtest_before_stmt ; 
ALTER FOREIGN TABLE x . foreign_table_1 ENABLE TRIGGER trigtest_before_stmt ; 
DROP TRIGGER trigtest_before_stmt ON foreign_schema . foreign_table_1 ; 
DROP TRIGGER trigtest_before_row ON foreign_schema . foreign_table_1 ; 
DROP TRIGGER trigtest_after_stmt ON foreign_schema . foreign_table_1 ; 
DROP TRIGGER trigtest_after_row ON foreign_schema . foreign_table_1 ; 
CREATE TABLE x ( x INTEGER NOT NULL , x TEXT , x date ) ; 
ALTER FOREIGN TABLE x INHERIT x ; 
CREATE FOREIGN TABLE x ( x INTEGER NOT NULL , x TEXT , x date ) INHERITS ( x ) SERVER s0 ; 
ALTER TABLE x ADD COLUMN x INTEGER DEFAULT 1 ; 
ALTER TABLE x ADD COLUMN x INTEGER NOT NULL ; 
ALTER TABLE x ALTER COLUMN x SET STATISTICS 1 ; 
ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 ) ; 
ALTER TABLE x ADD CONSTRAINT fd_pt1chk1 CHECK ( x > 1 ) NO INHERIT ; 
SELECT x , x , x , x , x , x FROM x AS pc JOIN x AS pgc ON ( x = x . x ) WHERE x . x = 'x' ORDER BY 1 , 1 ; 
ALTER TABLE x DROP CONSTRAINT fd_pt1chk1 CASCADE ; 
ALTER TABLE x DROP CONSTRAINT fd_pt1chk2 CASCADE ; 
ALTER TABLE x VALIDATE CONSTRAINT fd_pt1chk3 ; 
ALTER TABLE x RENAME CONSTRAINT fd_pt1chk3 TO f2_check ; 
DROP FOREIGN TABLE x . foreign_table_1 ; 
REASSIGN OWNED BY x TO x ; 
CREATE TABLE x ( x INTEGER NOT NULL , x TEXT , x date ) PARTITION BY LIST ( c1 ) ; 
ALTER TABLE x ADD x CHAR ; 
ALTER TABLE x ADD CONSTRAINT fd_pt2chk1 CHECK ( x > 1 ) ; 
DROP SCHEMA foreign_schema CASCADE ; 
DROP USER MAPPING FOR x SERVER s6 ; 
DROP SERVER s8 CASCADE ; 
DROP FOREIGN DATA WRAPPER postgresql CASCADE ; 
DROP FOREIGN DATA WRAPPER dummy CASCADE ; 
\SELECT * FROM x WHERE x . x < 1 ORDER BY x . x ; 
SELECT x . x , x . x FROM x WHERE x . x < 1 ORDER BY x USING > ; 
SELECT x . x , x . x FROM x WHERE x . x > 1 ORDER BY x USING < ; 
SELECT x . x , x . x FROM x WHERE x . x > 1 ORDER BY x USING < , x USING > ; 
SELECT x . x , x . x FROM x WHERE x . x > 1 ORDER BY x USING > , x USING < ; 
SELECT x . x , x . x FROM x WHERE x . x < 1 ORDER BY x USING > , x USING < ; 
SELECT x . x , x . x FROM x WHERE x . x < 1 ORDER BY x USING < , x USING > ; 
SET enable_sort TO off ; 
SELECT x . * FROM x WHERE x . x < 1 ; 
SELECT x . x , x . x FROM x WHERE x . x > 1 ; 
SELECT x , x , x , x INTO TABLE x FROM x ; 
SELECT x FROM ( SELECT 1 OFFSET 1 ) AS foo ; 
SELECT x FROM ( SELECT NULL OFFSET 1 ) AS foo ; 
SELECT x FROM ( SELECT 'x' , 1 , NULL OFFSET 1 ) AS foo ; 
SELECT * FROM x , ( VALUES ( 1 , 'x' ) , ( 1 , 'x' ) ) AS v ( i , j ) WHERE x . x = x . x AND x . x = x . x ; 
SELECT * FROM x , ( VALUES ( ( SELECT x FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( ( SELECT 1 ) ) ) AS foo ( i ) ORDER BY x ASC LIMIT 1 ) ) ) bar ( i ) WHERE x . x = x . x ; 
SELECT * FROM x WHERE ( x , x ) IN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) ORDER BY x ; 
VALUES ( 1 , 1 ) , ( 1 , 1 + 1 ) , ( 1 , 1.000000 ) ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( NULL ) , ( 1 ) ; 
SELECT * FROM x ORDER BY x DESC ; 
SELECT * FROM x ORDER BY x DESC NULLS LAST ; 
SET enable_sort = FALSE ; 
SELECT * FROM x ORDER BY x NULLS FIRST ; 
CREATE INDEX x ON x ( x DESC NULLS LAST ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x = 'x' ; 
SELECT * FROM x WHERE x = 1 AND x = 'x' ; 
EXPLAIN ( costs off , ANALYZE ON , timing off , summary off ) SELECT * FROM x WHERE x = 1 AND x = 'x' ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x = 1 AND x = 'x' ; 
SELECT x FROM x WHERE x = 1 AND x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x < 'x' ; 
SELECT * FROM x WHERE x = 1 AND x < 'x' ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x = 1 AND x < 'x' ; 
SELECT x FROM x WHERE x = 1 AND x < 'x' ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x = 1 AND x < 'x' FOR UPDATE ; 
SELECT x FROM x WHERE x = 1 AND x < 'x' FOR UPDATE ; 
SET enable_indexscan TO off ; 
RESET enable_indexscan ; 
EXPLAIN ( costs off ) SELECT x , x FROM x WHERE ( x = 1 OR x = 1 ) AND x < 'x' ; 
SELECT x , x FROM x WHERE ( x = 1 OR x = 1 ) AND x < 'x' ; 
EXPLAIN ( costs off ) SELECT x , x FROM x WHERE ( x = 1 AND x < 'x' ) OR x = 1 ; 
SELECT x , x FROM x WHERE ( x = 1 AND x < 'x' ) OR x = 1 ; 
SELECT 1 AS x ORDER BY x ; 
SELECT x ( 1 ) ORDER BY 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( NULL ) , ( 1 ) ) v ( k ) WHERE x = x ORDER BY x ; 
SELECT * FROM ( VALUES ( 1 ) , ( NULL ) , ( 1 ) ) v ( k ) WHERE x = x ; 
CREATE TABLE x ( x INT , x INT ) PARTITION BY list ( a ) ; 
DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM x ; 
DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
FETCH 1 IN foo1 ; 
FETCH 1 IN foo2 ; 
FETCH 1 IN foo3 ; 
FETCH 1 IN foo4 ; 
FETCH 1 IN foo5 ; 
FETCH 1 IN foo6 ; 
FETCH 1 IN foo7 ; 
FETCH 1 IN foo8 ; 
FETCH 1 IN foo9 ; 
FETCH 1 IN foo10 ; 
FETCH 1 IN foo11 ; 
FETCH 1 IN foo12 ; 
FETCH 1 IN foo13 ; 
FETCH 1 IN foo14 ; 
FETCH 1 IN foo15 ; 
FETCH 1 IN foo16 ; 
FETCH 1 IN foo17 ; 
FETCH 1 IN foo18 ; 
FETCH 1 IN foo19 ; 
FETCH 1 IN foo20 ; 
FETCH 1 IN foo21 ; 
FETCH 1 IN foo22 ; 
FETCH 1 IN foo23 ; 
FETCH BACKWARD 1 IN foo23 ; 
FETCH BACKWARD 1 IN foo22 ; 
FETCH BACKWARD 1 IN foo21 ; 
FETCH BACKWARD 1 IN foo20 ; 
FETCH BACKWARD 1 IN foo19 ; 
FETCH BACKWARD 1 IN foo18 ; 
FETCH BACKWARD 1 IN foo17 ; 
FETCH BACKWARD 1 IN foo16 ; 
FETCH BACKWARD 1 IN foo15 ; 
FETCH BACKWARD 1 IN foo14 ; 
FETCH BACKWARD 1 IN foo13 ; 
FETCH BACKWARD 1 IN foo12 ; 
FETCH BACKWARD 1 IN foo11 ; 
FETCH BACKWARD 1 IN foo10 ; 
FETCH BACKWARD 1 IN foo9 ; 
FETCH BACKWARD 1 IN foo8 ; 
FETCH BACKWARD 1 IN foo7 ; 
FETCH BACKWARD 1 IN foo6 ; 
FETCH BACKWARD 1 IN foo5 ; 
FETCH BACKWARD 1 IN foo4 ; 
FETCH BACKWARD 1 IN foo3 ; 
FETCH BACKWARD 1 IN foo2 ; 
FETCH BACKWARD 1 IN foo1 ; 
CLOSE foo1 ; 
CLOSE foo2 ; 
CLOSE foo3 ; 
CLOSE foo4 ; 
CLOSE foo5 ; 
CLOSE foo6 ; 
CLOSE foo7 ; 
CLOSE foo8 ; 
CLOSE foo9 ; 
CLOSE foo10 ; 
CLOSE foo11 ; 
CLOSE foo12 ; 
DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM x ORDER BY x ; 
FETCH 1 FROM foo24 ; 
DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM x ; 
FETCH FROM foo25 ; 
FETCH BACKWARD FROM foo25 ; 
FETCH ABSOLUTE 1 FROM foo25 ; 
DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM x ORDER BY x ; 
FETCH FROM foo26 ; 
FETCH ALL FROM c ; 
DECLARE c1 CURSOR FOR SELECT x ( ) , x ( ) ; 
FETCH ALL FROM c1 ; 
DECLARE c2 CURSOR WITH HOLD FOR SELECT x ( ) , x ( ) ; 
FETCH ALL FROM c2 ; 
DECLARE bc BINARY CURSOR FOR SELECT * FROM x ; 
EXECUTE cprep ; 
CLOSE ALL ; 
DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1 ; 
DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1 ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ; 
DECLARE c1 CURSOR FOR SELECT * FROM x ; 
FETCH 1 FROM c1 ; 
DELETE FROM x WHERE CURRENT OF c1 ; 
MOVE BACKWARD ALL IN c1 ; 
DECLARE c1 CURSOR FOR SELECT * FROM x FOR UPDATE ; 
FETCH c1 ; 
UPDATE x SET x = 1 WHERE CURRENT OF c1 ; 
UPDATE x SET x = x + 1 WHERE CURRENT OF c1 ; 
FETCH RELATIVE 1 FROM c1 ; 
DECLARE c1 CURSOR FOR SELECT * FROM x a , x b WHERE x . x = x . x + 1 ; 
DECLARE c1 CURSOR FOR SELECT * FROM x a , x b WHERE x . x = x . x + 1 FOR UPDATE ; 
DECLARE c1 CURSOR FOR SELECT * FROM x a , x b WHERE x . x = x . x + 1 FOR SHARE OF x ; 
DECLARE c CURSOR FOR SELECT * FROM x ; 
DECLARE c CURSOR FOR SELECT * FROM x FOR SHARE ; 
DECLARE c CURSOR FOR SELECT * FROM x JOIN x USING ( unique1 ) ; 
DECLARE c CURSOR FOR SELECT x , x ( * ) FROM x GROUP BY x ; 
DECLARE c1 CURSOR FOR SELECT x ( x ) FROM x FOR UPDATE ; 
FETCH FROM c1 ; 
EXPLAIN ( costs off ) DECLARE c1 CURSOR FOR SELECT x FROM x WHERE x = 'x' ; 
DECLARE c1 CURSOR FOR SELECT x FROM x WHERE x = 'x' ; 
SELECT x FROM x WHERE x = 'x' ; 
INSERT INTO x SELECT x , 'x' || x FROM x ( 1 , 1 ) i ; 
DECLARE c1 SCROLL CURSOR FOR SELECT * FROM x ; 
FETCH ABSOLUTE 1 FROM c1 ; 
DELETE FROM x WHERE CURRENT OF c1 RETURNING * ; 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE ; 
DECLARE c CURSOR FOR SELECT * FROM x LIMIT x ( 1 ) ; 
MOVE BACKWARD ALL IN c ; 
EXPLAIN ( costs off ) DECLARE c1 CURSOR FOR SELECT ( SELECT 1 ) AS x ; 
EXPLAIN ( costs off ) DECLARE c1 SCROLL CURSOR FOR SELECT ( SELECT 1 ) AS x ; 
DECLARE c1 SCROLL CURSOR FOR SELECT ( SELECT 1 ) AS x ; 
EXPLAIN ( costs off ) DECLARE c2 CURSOR FOR SELECT x ( 1 , 1 ) AS g ; 
EXPLAIN ( costs off ) DECLARE c2 SCROLL CURSOR FOR SELECT x ( 1 , 1 ) AS g ; 
DECLARE c2 SCROLL CURSOR FOR SELECT x ( 1 , 1 ) AS g ; 
SET enable_partitionwise_join TO TRUE ; 
INSERT INTO x SELECT x , x % 1 , x ( x , 'x' ) FROM x ( 1 , 1 ) i WHERE x % 1 = 1 ; 
INSERT INTO x SELECT x % 1 , x , x ( x , 'x' ) FROM x ( 1 , 1 ) i WHERE x % 1 = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x , x FROM x t1 LEFT JOIN x t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
SELECT x , x FROM x t1 LEFT JOIN x t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 RIGHT JOIN x t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 RIGHT JOIN x t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t2 ON ( x . x = x . x ) WHERE x . x = x . x OR x . x = x . x ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t2 ON ( x . x = x . x ) WHERE x . x = x . x OR x . x = x . x ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x < 1 AND x . x > 1 AND x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x < 1 AND x . x > 1 AND x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x < 1 ) t1 LEFT JOIN ( SELECT * FROM x WHERE x > 1 ) t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x < 1 ) t1 LEFT JOIN ( SELECT * FROM x WHERE x > 1 ) t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x < 1 ) t1 FULL JOIN ( SELECT * FROM x WHERE x > 1 ) t2 ON x . x = x . x WHERE x . x = 1 OR x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x < 1 ) t1 FULL JOIN ( SELECT * FROM x WHERE x > 1 ) t2 ON x . x = x . x WHERE x . x = 1 OR x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . * FROM x t1 WHERE x . x IN ( SELECT x . x FROM x t2 WHERE x . x = 1 ) AND x . x = 1 ORDER BY x . x ; 
SELECT x . * FROM x t1 WHERE x . x IN ( SELECT x . x FROM x t2 WHERE x . x = 1 ) AND x . x = 1 ORDER BY x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x ( x . x ) , x ( x . x ) , x ( x . x ) , x ( x . x ) FROM x t1 WHERE NOT EXISTS ( SELECT 1 FROM x t2 WHERE x . x = x . x ) ; 
SELECT x ( x . x ) , x ( x . x ) , x ( x . x ) , x ( x . x ) FROM x t1 WHERE NOT EXISTS ( SELECT 1 FROM x t2 WHERE x . x = x . x ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x AS t3a , LEAST ( x . x , x . x , x . x ) FROM x t2 JOIN x t3 ON ( x . x = x . x ) ) ss ON x . x = x . x WHERE x . x = 1 ORDER BY x . x ; 
SELECT * FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x AS t3a , LEAST ( x . x , x . x , x . x ) FROM x t2 JOIN x t3 ON ( x . x = x . x ) ) ss ON x . x = x . x WHERE x . x = 1 ORDER BY x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x AS t3a , x . x t2b , x . x t2c , LEAST ( x . x , x . x , x . x ) FROM x t2 JOIN x t3 ON ( x . x = x . x ) ) ss ON x . x = x . x WHERE ( x . x + COALESCE ( x . x , 1 ) ) = 1 ORDER BY x . x ; 
SELECT x . x , x . x , x . x FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x AS t3a , x . x t2b , x . x t2c , LEAST ( x . x , x . x , x . x ) FROM x t2 JOIN x t3 ON ( x . x = x . x ) ) ss ON x . x = x . x WHERE ( x . x + COALESCE ( x . x , 1 ) ) = 1 ORDER BY x . x ; 
SET enable_partitionwise_aggregate TO TRUE ; 
SET enable_hashjoin TO FALSE ; 
EXPLAIN ( COSTS OFF ) SELECT x , x FROM x FULL JOIN x p2 ( b , a , c ) USING ( a , b ) WHERE x BETWEEN 1 AND 1 GROUP BY 1 , 1 ORDER BY 1 , 1 ; 
SELECT x , x FROM x FULL JOIN x p2 ( b , a , c ) USING ( a , b ) WHERE x BETWEEN 1 AND 1 GROUP BY 1 , 1 ORDER BY 1 , 1 ; 
RESET enable_partitionwise_aggregate ; 
INSERT INTO x SELECT x , x , x % 1 FROM x ( 1 , 1 , 1 ) i ; 
CREATE INDEX x ON x ( ( ( x + x ) / 1 ) ) ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE ( x . x + x . x ) / 1 = ( x . x + x . x ) / 1 AND x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE ( x . x + x . x ) / 1 = ( x . x + x . x ) / 1 AND x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM x t1 , x t2 , x t3 WHERE x . x = x . x AND x . x = ( x . x + x . x ) / 1 AND x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM x t1 , x t2 , x t3 WHERE x . x = x . x AND x . x = ( x . x + x . x ) / 1 AND x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM ( x t1 LEFT JOIN x t2 ON x . x = x . x ) LEFT JOIN x t3 ON ( x . x = ( x . x + x . x ) / 1 ) WHERE x . x = 1 ORDER BY x . x , x . x , x . x + x . x ; 
SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM ( x t1 LEFT JOIN x t2 ON x . x = x . x ) LEFT JOIN x t3 ON ( x . x = ( x . x + x . x ) / 1 ) WHERE x . x = 1 ORDER BY x . x , x . x , x . x + x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM ( x t1 LEFT JOIN x t2 ON x . x = x . x ) RIGHT JOIN x t3 ON ( x . x = ( x . x + x . x ) / 1 ) WHERE x . x = 1 ORDER BY x . x , x . x , x . x + x . x ; 
SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM ( x t1 LEFT JOIN x t2 ON x . x = x . x ) RIGHT JOIN x t3 ON ( x . x = ( x . x + x . x ) / 1 ) WHERE x . x = 1 ORDER BY x . x , x . x , x . x + x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM ( ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t2 ON ( x . x = x . x ) ) FULL JOIN ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t3 ON ( x . x = ( x . x + x . x ) / 1 ) WHERE x . x = x . x OR x . x = x . x OR ( x . x + x . x ) / 1 = x . x ORDER BY x . x , x . x , x . x + x . x ; 
SELECT x . x , x . x , x . x , x . x , x . x + x . x , x . x FROM ( ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t2 ON ( x . x = x . x ) ) FULL JOIN ( SELECT 1 phv , * FROM x WHERE x . x = 1 ) t3 ON ( x . x = ( x . x + x . x ) / 1 ) WHERE x . x = x . x OR x . x = x . x OR ( x . x + x . x ) / 1 = x . x ORDER BY x . x , x . x , x . x + x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . * FROM x t1 WHERE x . x IN ( SELECT x . x FROM x t1 , x t2 WHERE x . x = 1 AND x . x = ( x . x + x . x ) / 1 ) AND x . x = 1 ORDER BY x . x ; 
SELECT x . * FROM x t1 WHERE x . x IN ( SELECT x . x FROM x t1 , x t2 WHERE x . x = 1 AND x . x = ( x . x + x . x ) / 1 ) AND x . x = 1 ORDER BY x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . * FROM x t1 WHERE x . x IN ( SELECT x . x FROM x t1 WHERE x . x IN ( SELECT ( x . x + x . x ) / 1 FROM x t1 WHERE x . x = 1 ) ) AND x . x = 1 ORDER BY x . x ; 
SELECT x . * FROM x t1 WHERE x . x IN ( SELECT x . x FROM x t1 WHERE x . x IN ( SELECT ( x . x + x . x ) / 1 FROM x t1 WHERE x . x = 1 ) ) AND x . x = 1 ORDER BY x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x FROM ( SELECT * FROM x WHERE x < 1 ) t1 LEFT JOIN ( SELECT * FROM x WHERE x > 1 ) t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x FROM ( SELECT * FROM x WHERE x < 1 ) t1 LEFT JOIN ( SELECT * FROM x WHERE x > 1 ) t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 , 1 ) TO ( 1 , 1 ) ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT * FROM x WHERE x . x = 1 ) t2 ON ( x . x = ( x . x + x . x ) / 1 AND x . x = ( x . x + x . x ) / 1 ) ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT * FROM x WHERE x . x = 1 ) t2 ON ( x . x = ( x . x + x . x ) / 1 AND x . x = ( x . x + x . x ) / 1 ) ORDER BY x . x , x . x ; 
CREATE TABLE x ( x INT , x INT , x TEXT ) PARTITION BY LIST ( c ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' , 'x' , 'x' ) ; 
INSERT INTO x SELECT x , x , x ( x / 1 , 'x' ) FROM x ( 1 , 1 , 1 ) i ; 
CREATE TABLE x ( x INT , x INT , x TEXT ) PARTITION BY LIST ( x ( x , 'x' ) ) ; 
INSERT INTO x SELECT x , x , 'x' || x ( x / 1 , 'x' ) FROM x ( 1 , 1 , 1 ) i ; 
EXPLAIN ( COSTS OFF ) SELECT x ( x . x ) , x ( x . x ) , x ( x . x + x . x ) , x . x , x . x , x . x FROM x t1 , x t2 , x t3 WHERE x . x = x . x AND x . x = x . x AND x ( x . x , 'x' ) = x . x GROUP BY x . x , x . x , x . x ORDER BY x . x , x . x , x . x ; 
SELECT x ( x . x ) , x ( x . x ) , x ( x . x + x . x ) , x . x , x . x , x . x FROM x t1 , x t2 , x t3 WHERE x . x = x . x AND x . x = x . x AND x ( x . x , 'x' ) = x . x GROUP BY x . x , x . x , x . x ORDER BY x . x , x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x = 1 AND x . x = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x = 1 AND x = 1 ) t1 LEFT JOIN x t2 ON x . x = x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x = 1 AND x = 1 ) t1 RIGHT JOIN x t2 ON x . x = x . x , x t3 WHERE x . x = x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x = 1 AND x = 1 ) t1 FULL JOIN x t2 ON x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
CREATE TABLE x ( x INT , x INT , x TEXT ) PARTITION BY HASH ( c ) ; 
CREATE TABLE x ( x INT , x INT , x TEXT ) PARTITION BY HASH ( x ( x , 'x' ) ) ; 
EXPLAIN ( COSTS OFF ) SELECT x ( x . x ) , x ( x . x ) , x . x , x . x FROM x t1 RIGHT JOIN x t2 ON x . x = x . x WHERE x . x % 1 = 1 GROUP BY x . x , x . x ORDER BY x . x , x . x ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) PARTITION BY LIST ( c ) ; 
INSERT INTO x SELECT x , x % 1 , x ( x % 1 , 'x' ) FROM x ( 1 , 1 , 1 ) i ; 
INSERT INTO x SELECT x % 1 , x , x ( x % 1 , 'x' ) FROM x ( 1 , 1 , 1 ) i ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 LEFT JOIN x t2 ON x . x = x . x AND x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 LEFT JOIN x t2 ON x . x = x . x AND x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 RIGHT JOIN x t2 ON x . x = x . x AND x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 RIGHT JOIN x t2 ON x . x = x . x AND x . x = x . x WHERE x . x = 1 ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT * FROM x WHERE x . x = 1 ) t2 ON ( x . x = x . x AND x . x = x . x ) ORDER BY x . x , x . x ; 
SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x . x = 1 ) t1 FULL JOIN ( SELECT * FROM x WHERE x . x = 1 ) t2 ON ( x . x = x . x AND x . x = x . x ) ORDER BY x . x , x . x ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x AS t2c , x . x AS t2b , x . x AS t3b , LEAST ( x . x , x . x , x . x ) FROM x t2 JOIN x t3 ON ( x . x = x . x AND x . x = x . x ) ) ss ON x . x = x . x AND x . x = x . x WHERE x . x = 1 ORDER BY x . x ; 
SELECT * FROM x t1 LEFT JOIN LATERAL ( SELECT x . x AS t2a , x . x AS t2c , x . x AS t2b , x . x AS t3b , LEAST ( x . x , x . x , x . x ) FROM x t2 JOIN x t3 ON ( x . x = x . x AND x . x = x . x ) ) ss ON x . x = x . x AND x . x = x . x WHERE x . x = 1 ORDER BY x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM ( SELECT * FROM x WHERE x = 1 AND x = 1 ) t1 RIGHT JOIN x t2 ON x . x = x . x AND x . x = x . x AND x . x = x . x ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' ) TO ( 'x' ) ; 
INSERT INTO x SELECT x , x , x ( x , 'x' ) FROM x ( 1 , 1 , 1 ) i ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 , x t3 WHERE x . x = x . x AND x . x = x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 LEFT JOIN x t2 ON ( x . x < x . x ) ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = ( x . x + x . x ) / 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 LEFT JOIN x t2 ON x . x = x . x ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 LEFT JOIN x t2 ON ( x . x = x . x ) ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 JOIN x t2 ON ( x . x = x . x ) JOIN x t3 ON ( x . x = x . x ) ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x . x , x . x FROM x t1 FULL JOIN x t2 ON ( x . x = x . x ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x TEXT DEFAULT 'x' ) ; 
INSERT INTO x SELECT x , 'x' || x FROM x ( 1 , 1 ) g ( i ) ; 
SELECT x , x , x FROM x . views WHERE x LIKE x 'x' ORDER BY x ; 
UPDATE x SET x = x + 1 ; 
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'x' ; 
UPDATE x SET x = x ( x ) ; 
DROP VIEW x , x , x ; 
DROP SEQUENCE x CASCADE ; 
CREATE VIEW x AS SELECT * FROM x WHERE x > 1 ; 
SELECT x , x , x FROM x . views WHERE x = 'x' ; 
EXPLAIN ( costs off ) UPDATE x SET x = 1 WHERE x = 1 ; 
EXPLAIN ( costs off ) DELETE FROM x WHERE x = 1 ; 
CREATE VIEW x AS SELECT x AS bb , x AS aa FROM x WHERE x > 1 ; 
CREATE VIEW x AS SELECT x AS aaa , x AS bbb FROM x WHERE x < 1 ; 
SELECT x , x , x FROM x . views WHERE x LIKE 'x' ORDER BY x ; 
UPDATE x SET x = 'x' WHERE x = 1 RETURNING * ; 
DELETE FROM x WHERE x = 1 RETURNING * ; 
SELECT x , x , x , x , x , x FROM x . views WHERE x LIKE 'x' ORDER BY x ; 
$$CREATE TRIGGER x INSTEAD OF INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x INSTEAD OF UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x INSTEAD OF DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE VIEW x AS SELECT x AS bb , x AS aa FROM x ; 
$$UPDATE x x SET x = 'x' WHERE x ( x ) = 1 RETURNING x ( x ) , x . x ; 
EXPLAIN ( costs off ) UPDATE x x SET x = 'x' WHERE x ( x ) = 1 RETURNING x ( x ) , x . x ; 
SET SESSION AUTHORIZATION regress_view_user1 ; 
CREATE TABLE x ( x INT , x TEXT , x FLOAT ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1.000000 ) ; 
CREATE VIEW x AS SELECT x AS bb , x AS cc , x AS aa FROM x ; 
INSERT INTO x VALUES ( 'x' , 1.000000 , 1 ) ; 
SET SESSION AUTHORIZATION regress_view_user2 ; 
CREATE TABLE x ( x INT PRIMARY KEY , x TEXT DEFAULT 'x' , x serial ) ; 
CREATE VIEW x AS SELECT x AS aa , x AS bb FROM x ; 
$$CREATE TRIGGER x AFTER INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER rw_view1_ins_trig ON base_tbl ; 
CREATE VIEW x AS SELECT * FROM x ORDER BY x + x ; 
UPDATE x SET x = x + 1 RETURNING * ; 
CREATE TABLE x ( x INT , x INT [ ] ) ; 
INSERT INTO x VALUES ( 1 , ARRAY [ 1 ] ) , ( 1 , ARRAY [ 1 ] ) ; 
UPDATE x SET x [ 1 ] = 1 , x [ 1 ] = 1 WHERE x = 1 ; 
CREATE TABLE x ( x FLOAT ) ; 
INSERT INTO x SELECT x / 1.000000 FROM x ( 1 , 1 ) g ( i ) ; 
CREATE VIEW x AS SELECT x , x ( x ) s , x , x ( x ) c FROM x WHERE x != 1 ORDER BY x ( x ) ; 
CREATE TABLE x ( CHECK ( x > 1 ) ) INHERITS ( x ) ; 
INSERT INTO x SELECT * FROM x ( 1 , 1 ) ; 
CREATE VIEW x AS SELECT * FROM ONLY x ; 
SELECT * FROM ONLY x ORDER BY x ; 
EXPLAIN ( costs off ) UPDATE x SET x = x + 1 FROM x WHERE x = x ; 
UPDATE x SET x = x + 1 FROM x WHERE x = x ; 
CREATE TABLE x ( x INT , x INT DEFAULT 1 ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE x < x WITH LOCAL CHECK OPTION ; 
SELECT * FROM x . views WHERE x = 'x' ; 
CREATE VIEW x AS SELECT * FROM x WITH CHECK OPTION ; 
SELECT * FROM x . views WHERE x LIKE x 'x' ORDER BY x ; 
CREATE VIEW x AS SELECT * FROM x WHERE x = ANY ( x ) WITH CHECK OPTION ; 
CREATE VIEW x AS SELECT * FROM x b WHERE EXISTS ( SELECT 1 FROM x r WHERE x . x = x . x ) WITH CHECK OPTION ; 
EXPLAIN ( costs off ) UPDATE x SET x = x + 1 ; 
$$CREATE TRIGGER x BEFORE INSERT OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE x < x WITH CHECK OPTION ; 
CREATE VIEW x AS SELECT x FROM x WHERE x < x ; 
$$CREATE TRIGGER x INSTEAD OF INSERT OR UPDATE OR DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE x > 1 WITH LOCAL CHECK OPTION ; 
DROP TRIGGER rw_view1_trig ON rw_view1 ; 
CREATE VIEW x AS SELECT x , 1 AS b FROM x ; 
CREATE VIEW x AS SELECT * FROM x WHERE x > x WITH LOCAL CHECK OPTION ; 
CREATE VIEW x AS SELECT x FROM x WHERE x = 'x' ; 
$$$$$$SELECT * FROM x WHERE x ( x ) ; 
UPDATE x SET x = x WHERE x ( x ) ; 
DELETE FROM x WHERE NOT x ( x ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x ( x ) ; 
EXPLAIN ( costs off ) UPDATE x SET x = x WHERE x ( x ) ; 
EXPLAIN ( costs off ) DELETE FROM x WHERE NOT x ( x ) ; 
INSERT INTO x VALUES ( 1 , 'x' , FALSE ) , ( 1 , 'x' , TRUE ) ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ; 
CREATE TABLE x ( x INT , x FLOAT , x TEXT ) ; 
CREATE TABLE x ( x INT [ ] ) INHERITS ( x ) ; 
DROP FUNCTION x ( anyelement ) ; 
CREATE VIEW x AS SELECT x FROM x WHERE EXISTS ( SELECT 1 FROM x JOIN x ON x = x ) ; 
CREATE TABLE x ( x INT , x TEXT , x INT ) ; 
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x > 1 WITH CHECK OPTION ; 
CREATE VIEW x AS SELECT * FROM x WHERE x = 1 WITH CHECK OPTION ; 
DROP VIEW x , x ; 
CREATE TABLE x ( x TEXT , x INT , x INT ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) ; 
CREATE VIEW x AS SELECT * FROM x r WHERE x IN ( SELECT x FROM x s WHERE x . x = x . x ) WITH CHECK OPTION ; 
CREATE TABLE x ( x TEXT UNIQUE , x FLOAT ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = CAST ( x . x AS FLOAT ) ; 
EXPLAIN ( costs off ) INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x > 1 ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x > 1 ; 
CREATE TABLE x ( x INT UNIQUE , x TEXT ) ; 
EXPLAIN ( costs off ) INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' || x . * WHERE x . x > 1 AND x . x != 'x' AND x . x IS NOT NULL ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' || x . * WHERE x . x > 1 AND x . x != 'x' AND x . x IS NOT NULL ; 
INSERT INTO x ( x ) VALUES ( 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' || x . * ; 
INSERT INTO x ( x ) VALUES ( 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' ; 
CREATE TABLE x ( x INT UNIQUE , x TEXT , x FLOAT ) ; 
GRANT SELECT ( x , x ) ON x TO x ; 
CREATE VIEW x AS SELECT x , x , x FROM x ; 
CREATE TABLE x ( x INT , x TEXT DEFAULT 'x' , x TEXT DEFAULT 'x' , x TEXT , x TEXT ) ; 
ALTER VIEW x ALTER x SET DEFAULT 'x' ; 
INSERT INTO x VALUES ( 1 , DEFAULT , DEFAULT , DEFAULT , DEFAULT ) ; 
INSERT INTO x VALUES ( 1 , DEFAULT , DEFAULT , DEFAULT , DEFAULT ) , ( 1 , DEFAULT , DEFAULT , DEFAULT , DEFAULT ) ; 
INSERT INTO x VALUES ( 1 ) , ( DEFAULT ) ; 
$$$$CREATE TRIGGER x INSTEAD OF INSERT ON x FOR EACH ROW EXECUTE FUNCTION x ( ) ; 
DROP TRIGGER base_tab_def_view_instrig ON base_tab_def_view ; 
DROP FUNCTION base_tab_def_view_instrig_func ; 
DROP RULE base_tab_def_view_ins_rule ON base_tab_def_view ; 
SELECT * FROM x ORDER BY x , x NULLS LAST ; 
CREATE TABLE x ( x serial , x INT [ ] , x TEXT , x TEXT DEFAULT 'x' ) ; 
INSERT INTO x ( x [ 1 ] , x [ 1 ] , x , x [ 1 ] , x [ 1 ] , x , x [ 1 ] ) VALUES ( 1 , 1 , DEFAULT , 1 , 1 , DEFAULT , 1 ) , ( 1 , 1 , 'x' , 1 , 1 , 1 , 1 ) ; 
CREATE TABLE x ( x cidr , x inet ) ; 
INSERT INTO x ( x , x ) VALUES ( x ( 'x' ) , 'x' ) ; 
SELECT 'x' AS ten , x AS cidr , x AS inet FROM x ; 
SELECT 'x' AS ten , x AS cidr , x ( x ) , x AS inet , x ( x ) FROM x ; 
SELECT 'x' AS ten , x AS cidr , x ( x ) AS network(cidr)" , x AS inet , x ( x ) AS network(inet)" FROM x ; 
SELECT 'x' AS ten , x AS cidr , x ( x ) AS masklen(cidr)" , x AS inet , x ( x ) AS masklen(inet)" FROM x ; 
SELECT 'x' AS four , x AS cidr , x ( x ) AS masklen(cidr)" , x AS inet , x ( x ) AS masklen(inet)" FROM x WHERE x ( x ) <= 1 ; 
SELECT 'x' AS six , x AS cidr , x AS inet FROM x WHERE x = x ; 
SELECT x ( x ) AS max , x ( x ) AS min FROM x ; 
SET enable_seqscan TO ON ; 
CREATE INDEX x ON x USING gist ( x inet_ops ) ; 
~SELECT x , x AS ~i" FROM x ; 
SELECT x , x , x & x AS and" FROM x ; 
SELECT x , x , x | x AS or" FROM x ; 
SELECT x , x + 1 AS i+500" FROM x ; 
SELECT x , x - 1 AS i-500" FROM x ; 
SELECT x , x , x - x AS minus" FROM x ; 
SELECT x ( x , x ) FROM x WHERE x ( x , x ) ; 
SELECT x FROM x ORDER BY x ASC ; 
SELECT x FROM x ORDER BY x DESC ; 
SELECT x ( * ) FROM x WHERE x = 'x' ; 
SELECT x ( * ) FROM x WHERE x < 'x' ; 
SELECT x ( * ) FROM x WHERE x <= 'x' ; 
SELECT x ( * ) FROM x WHERE x > 'x' ; 
SELECT x ( * ) FROM x WHERE x >= 'x' ; 
CREATE INDEX x ON x USING BTREE ( x ) ; 
CREATE INDEX x ON x USING HASH ( x ) ; 
CREATE UNIQUE INDEX x ON x USING BTREE ( x ) ; 
SELECT x ( * ) FROM x WHERE x = 'x' AND x LIKE 'x' ; 
SELECT x ( * ) FROM x g1 INNER JOIN x g2 ON x . x = x . x ; 
SELECT x ( * ) FROM x g1 LEFT JOIN x g2 ON x . x = x . x WHERE x . x IS NULL ; 
INSERT INTO x ( x ) VALUES ( x ( ) ) ; 
SELECT x ( DISTINCT x ) FROM x ; 
SELECT DISTINCT ON ( x ) x , x , x FROM x ORDER BY x USING < , x USING > , x USING < ; 
SELECT DISTINCT ON ( x , x ) x , x , x FROM x ORDER BY x USING < , x USING < , x USING < ; 
SELECT DISTINCT ON ( x , x ) x , x , x FROM x ORDER BY x USING < , x USING > , x USING < ; 
SELECT DISTINCT ON ( 1 ) x ( x ( ) ) AS r , x FROM x ORDER BY 1 , 1 ; 
CREATE TEMP VIEW x ( x , x , x ) AS VALUES ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) ; 
CREATE TEMP TABLE x ( x INTEGER , x INTEGER , x INTEGER , x INTEGER , x INTEGER , x INTEGER , x INTEGER , x INTEGER ) ; 
CREATE TEMP TABLE x ( x INTEGER , x INTEGER , x BIT ( 1 ) , x xid ) ; 
CREATE TEMP TABLE x ( x INTEGER , x INTEGER , x INTEGER ) ; 
$$SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY ROLLUP ( x , x ) ORDER BY x , x ; 
SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY ROLLUP ( x , x ) ORDER BY x DESC , x ; 
SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY ROLLUP ( x , x ) ORDER BY COALESCE ( x , 1 ) + COALESCE ( x , 1 ) ; 
SELECT GROUPING ( x ) , x , x ( x ) , x ( x ) WITHIN GROUP ( ORDER BY x NULLS FIRST ) , x ( x ) WITHIN GROUP ( ORDER BY x NULLS LAST ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) GROUP BY ROLLUP ( x ) ORDER BY x ; 
SELECT x , x , x ( x ) , x ( x ( x ) ) OVER ( ORDER BY x , x ) AS rsum FROM x GROUP BY ROLLUP ( x , x ) ORDER BY x , x , x ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( ( ) , GROUPING SETS ( ( ) , GROUPING SETS ( ( ) ) ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( ( ) , GROUPING SETS ( ( ) , GROUPING SETS ( ( ( x , x ) ) ) ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( GROUPING SETS ( ROLLUP ( x ) , GROUPING SETS ( CUBE ( x ) ) ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( x , GROUPING SETS ( x , CUBE ( x ) ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( GROUPING SETS ( ( x , ( x ) ) ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( GROUPING SETS ( ( x , x ) ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( GROUPING SETS ( x , GROUPING SETS ( x ) , x ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( GROUPING SETS ( x , GROUPING SETS ( x , GROUPING SETS ( x ) , ( ( x ) ) , x , GROUPING SETS ( x ) , ( x ) ) , x ) ) ORDER BY 1 DESC ; 
SELECT x ( x ) FROM x GROUP BY GROUPING SETS ( ( x , ( x , x ) ) , GROUPING SETS ( ( x , ( x , x ) ) , x ) ) ORDER BY 1 DESC ; 
SELECT x , x , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , x ) ; 
SELECT x , x , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( ) ) ; 
SELECT x , x , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( ) , ( ) , ( ) ) ; 
SELECT x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( ) , ( ) , ( ) ) ; 
SELECT x . x , x . x , x ( x . x ) , x ( * ) FROM x t1 , x t2 GROUP BY GROUPING SETS ( ( x . x , x . x ) , ( ) ) ; 
SELECT x . x , x . x , GROUPING ( x . x , x . x ) , x ( x . x ) , x ( x . x ) FROM x t1 , x t2 GROUP BY GROUPING SETS ( ( x . x , x . x ) , ( ) ) ; 
SELECT x . x , x . x , GROUPING ( x . x , x . x ) , x ( x . x ) , x ( x . x ) FROM x t1 JOIN x t2 ON ( x . x = x . x ) GROUP BY GROUPING SETS ( ( x . x , x . x ) , ( ) ) ; 
SELECT x , x , GROUPING ( x , x ) , x ( x . x ) , x ( x . x ) FROM x t1 JOIN x t2 USING ( a , b ) GROUP BY GROUPING SETS ( ( x , x ) , ( ) ) ; 
SELECT x , x , GROUPING ( x , x , x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x , x ) ) ; 
EXPLAIN ( costs off ) SELECT x AS alias1 , x AS alias2 FROM x ( 1 , 1 ) g GROUP BY x , ROLLUP ( x ) ; 
SELECT x AS alias1 , x AS alias2 FROM x ( 1 , 1 ) g GROUP BY x , ROLLUP ( x ) ; 
SELECT ( x + x ) * 1 , x ( x ) FROM ( SELECT 1 AS x , 1 AS y , 1 AS z ) s GROUP BY GROUPING SETS ( x + x , x ) ; 
SELECT x , NOT x AS not_x , x FROM ( SELECT * , x = 1 AS x FROM x i1 ) AS t GROUP BY GROUPING SETS ( x , x ) ORDER BY x , x ; 
SELECT x , x , x ( x . x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , x ( x . x ) GROUP BY ROLLUP ( x , x ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , LATERAL ( SELECT x , x , x ( x . x ) FROM x ( x . x ) GROUP BY ROLLUP ( x , x ) ) s ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x GROUP BY ( ) ; 
CREATE VIEW x AS SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY ROLLUP ( ( x , x , x ) , ( x , x ) ) ; 
SELECT ( SELECT ( SELECT GROUPING ( x , x ) FROM ( VALUES ( 1 ) ) v2 ( c ) ) FROM ( VALUES ( 1 , 1 ) ) v1 ( a , b ) GROUP BY ( x , x ) ) FROM ( VALUES ( 1 , 1 ) ) v3 ( e , f ) GROUP BY ROLLUP ( x , x ) ; 
SELECT ( SELECT ( SELECT GROUPING ( x ) FROM ( VALUES ( 1 ) ) v2 ( c ) GROUP BY x ) FROM ( VALUES ( 1 , 1 ) ) v1 ( a , b ) GROUP BY ( x , x ) ) FROM ( VALUES ( 1 , 1 ) ) v3 ( e , f ) GROUP BY ROLLUP ( x , x ) ; 
SELECT x , x , x , x FROM x GROUP BY ROLLUP ( x , x ) , GROUPING SETS ( x , x ) ; 
SELECT x , x FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) GROUP BY x , x , GROUPING SETS ( x ) ; 
SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x + 1 , x + 1 ) , ( x + 1 , x + 1 ) ) ORDER BY 1 , 1 ; 
SELECT ( SELECT ( SELECT GROUPING ( x , x ) FROM ( VALUES ( 1 ) ) v2 ( c ) ) FROM ( VALUES ( 1 , 1 ) ) v1 ( a , b ) GROUP BY ( x , x ) ) FROM ( VALUES ( 1 , 1 ) ) v3 ( e , f ) GROUP BY ROLLUP ( ( x + 1 ) , ( x + 1 ) ) ; 
SELECT ( SELECT ( SELECT GROUPING ( x , x ) FROM ( VALUES ( 1 ) ) v2 ( c ) ) FROM ( VALUES ( 1 , 1 ) ) v1 ( a , b ) GROUP BY ( x , x ) ) FROM ( VALUES ( 1 , 1 ) ) v3 ( e , f ) GROUP BY CUBE ( ( x + 1 ) , ( x + 1 ) ) ORDER BY ( x + 1 ) , ( x + 1 ) ; 
SELECT x , x , x ( x ) , x ( x ( x ) ) OVER ( ORDER BY x , x ) AS rsum FROM x GROUP BY CUBE ( x , x ) ORDER BY x , x , x ; 
SELECT x , x , x ( x ) FROM ( VALUES ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) ) v ( a , b , c ) GROUP BY ROLLUP ( x , x ) ; 
SELECT x , x , x ( x . x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , x ( x . x ) GROUP BY CUBE ( x , x ) ORDER BY x , x ; 
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY GROUPING SETS ( ( x , x , x ) , ( x ) ) ORDER BY x , x , x ; 
SELECT ( SELECT GROUPING ( x , x ) FROM x ) FROM x GROUP BY x , x ; 
SELECT x , x , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ROLLUP ( x , x ) , x ) ; 
SELECT x , x ( * ) FROM x GROUP BY ROLLUP ( x ) ORDER BY x ; 
SELECT x , x ( * ) FROM x GROUP BY ROLLUP ( x ) HAVING x IS DISTINCT FROM 1 ORDER BY x ; 
EXPLAIN ( costs off ) SELECT x , x ( * ) FROM x GROUP BY ROLLUP ( x ) HAVING x IS DISTINCT FROM 1 ORDER BY x ; 
SELECT x . x , ( SELECT x ( * ) FROM x GROUP BY ( ) HAVING x . x ) FROM ( VALUES ( FALSE ) , ( TRUE ) ) v ( c ) ORDER BY x . x ; 
EXPLAIN ( costs off ) SELECT x . x , ( SELECT x ( * ) FROM x GROUP BY ( ) HAVING x . x ) FROM ( VALUES ( FALSE ) , ( TRUE ) ) v ( c ) ORDER BY x . x ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( a ) LEFT JOIN LATERAL ( SELECT x . x , x , x , x ( * ) FROM x GROUP BY CUBE ( x , x ) ) s ON TRUE ORDER BY x . x , x , x ; 
SELECT ARRAY ( SELECT ROW ( x . x , x . * ) FROM ( SELECT x , x , x ( * ) FROM x GROUP BY CUBE ( x , x ) ORDER BY x , x ) s1 ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( a ) ; 
SET enable_hashagg = TRUE ; 
SELECT x ( * ) FROM x GROUP BY ROLLUP ( x , x ) ; 
SELECT x ( x ORDER BY x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x ) ) ; 
SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x ) , ( x ) ) ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x ) , ( x ) ) ORDER BY 1 , 1 , 1 ; 
SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY CUBE ( x , x ) ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY CUBE ( x , x ) ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x ) , x ( x ORDER BY x ) FROM x GROUP BY CUBE ( x , x ) ; 
SELECT x , x , GROUPING ( x , x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x ) , ( x ) ) ORDER BY 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x ) , ( x ) ) ORDER BY 1 , 1 ; 
SELECT x , x , GROUPING ( x , x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x , x ) ) ORDER BY 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x , x ) ) ORDER BY 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , x ) ; 
EXPLAIN ( costs off ) SELECT x , x , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( ) , ( ) , ( ) ) ; 
EXPLAIN ( costs off ) SELECT x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( ( ) , ( ) , ( ) ) ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x , x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x , x ) ) ; 
SELECT x , x , x ( x . x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , x ( x . x ) GROUP BY GROUPING SETS ( x , x ) ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , x ( x . x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , x ( x . x ) GROUP BY GROUPING SETS ( x , x ) ORDER BY 1 , 1 , 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , LATERAL ( SELECT x , x , x ( x . x ) FROM x ( x . x ) GROUP BY GROUPING SETS ( x , x ) ) s ; 
EXPLAIN ( costs off ) SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , LATERAL ( SELECT x , x , x ( x . x ) FROM x ( x . x ) GROUP BY GROUPING SETS ( x , x ) ) s ; 
EXPLAIN ( costs off ) SELECT x , x , GROUPING ( x , x ) , x ( x ) , x ( * ) , x ( x ) FROM x GROUP BY GROUPING SETS ( ( x , x ) , ( x + 1 , x + 1 ) , ( x + 1 , x + 1 ) ) ORDER BY 1 , 1 ; 
EXPLAIN ( costs off ) SELECT x , x , x ( x ) , x ( x ( x ) ) OVER ( ORDER BY x , x ) AS rsum FROM x GROUP BY CUBE ( x , x ) ORDER BY x , x , x ; 
EXPLAIN ( costs off ) SELECT x , x , x ( x . x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( x ) , x ( x . x ) GROUP BY CUBE ( x , x ) ORDER BY x , x ; 
SET LOCAL enable_hashagg = FALSE ; 
EXPLAIN ( COSTS OFF ) SELECT x , x , x ( * ) , x ( x ) , x ( x ) FROM x GROUP BY GROUPING SETS ( x , x , ( ) ) ORDER BY x , x ; 
SELECT x , x , x ( * ) , x ( x ) , x ( x ) FROM x GROUP BY GROUPING SETS ( x , x , ( ) ) ORDER BY x , x ; 
SET LOCAL enable_seqscan = FALSE ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( a ) LEFT JOIN LATERAL ( SELECT x . x , x , x , x ( * ) FROM x GROUP BY GROUPING SETS ( x , x ) ) s ON TRUE ORDER BY x . x , x , x ; 
SELECT ARRAY ( SELECT ROW ( x . x , x . * ) FROM ( SELECT x , x , x ( * ) FROM x GROUP BY GROUPING SETS ( x , x ) ORDER BY x , x ) s1 ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( a ) ; 
SET enable_indexscan = FALSE ; 
SET work_mem = 'x' ; 
EXPLAIN ( costs off ) SELECT x , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( x , x , x , x , x , x , x ) ; 
EXPLAIN ( costs off ) SELECT x , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY GROUPING SETS ( x , x , x , x , x ) ; 
SELECT x || 'x' , CASE GROUPING ( x || 'x' ) WHEN 1 THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] ) u ( i , v ) GROUP BY ROLLUP ( x , x || 'x' ) ORDER BY 1 , 1 ; 
SELECT x || 'x' , CASE WHEN GROUPING ( x || 'x' ) = 1 THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] ) u ( i , v ) GROUP BY ROLLUP ( x , x || 'x' ) ORDER BY 1 , 1 ; 
SET max_parallel_workers_per_gather TO 1 ; 
CREATE TABLE x ( x INT , x INT , x TEXT , x INT ) PARTITION BY LIST ( c ) ; 
INSERT INTO x SELECT x % 1 , x % 1 , x ( x % 1 , 'x' ) , x % 1 FROM x ( 1 , 1 ) i ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( x ) , x ( * ) , x ( x ) , x ( x ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( x ) , x ( * ) , x ( x ) , x ( x ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x , x ( * ) FROM x GROUP BY x , x ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) FROM x WHERE 1 = 1 GROUP BY x ; 
SELECT x , x ( x ) FROM x WHERE 1 = 1 GROUP BY x ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) FROM x WHERE x = 'x' GROUP BY x ; 
SELECT x , x ( x ) FROM x WHERE x = 'x' GROUP BY x ; 
SET enable_hashagg TO FALSE ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY 1 HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY 1 HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x FROM x GROUP BY x ORDER BY 1 ; 
SELECT x FROM x GROUP BY x ORDER BY 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x FROM x WHERE x < 1 GROUP BY x ORDER BY 1 ; 
SELECT x FROM x WHERE x < 1 GROUP BY x ORDER BY 1 ; 
RESET enable_hashagg ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) FROM x GROUP BY ROLLUP ( x ) ORDER BY 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ORDER BY x ) FROM x GROUP BY x ORDER BY 1 , 1 ; 
INSERT INTO x SELECT x % 1 , x % 1 FROM x ( 1 , 1 , 1 ) i ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x ( x . x ) , x ( * ) FROM x t1 , x t2 WHERE x . x = x . x GROUP BY x . x ORDER BY 1 , 1 , 1 ; 
SELECT x . x , x ( x . x ) , x ( * ) FROM x t1 , x t2 WHERE x . x = x . x GROUP BY x . x ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x ( x . x ) , x ( x ) FROM x t1 , x t2 WHERE x . x = x . x GROUP BY x . x ORDER BY 1 , 1 , 1 ; 
SELECT x . x , x ( x . x ) , x ( x ) FROM x t1 , x t2 WHERE x . x = x . x GROUP BY x . x ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x ( x . x ) , x ( * ) FROM x t1 , x t2 WHERE x . x = x . x GROUP BY x . x HAVING x ( x . x ) > 1 ORDER BY 1 , 1 , 1 ; 
SELECT x . x , x ( x . x ) , x ( * ) FROM x t1 , x t2 WHERE x . x = x . x GROUP BY x . x HAVING x ( x . x ) > 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x ( x . x ) FROM x a LEFT JOIN x b ON x . x = x . x GROUP BY x . x ORDER BY 1 NULLS LAST ; 
SELECT x . x , x ( x . x ) FROM x a LEFT JOIN x b ON x . x = x . x GROUP BY x . x ORDER BY 1 NULLS LAST ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x ( x . x ) FROM x a RIGHT JOIN x b ON x . x = x . x GROUP BY x . x ORDER BY 1 NULLS LAST ; 
SELECT x . x , x ( x . x ) FROM x a RIGHT JOIN x b ON x . x = x . x GROUP BY x . x ORDER BY 1 NULLS LAST ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x ( x . x ) FROM x a FULL OUTER JOIN x b ON x . x = x . x GROUP BY x . x ORDER BY 1 NULLS LAST ; 
SELECT x . x , x ( x . x ) FROM x a FULL OUTER JOIN x b ON x . x = x . x GROUP BY x . x ORDER BY 1 NULLS LAST ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x ( * ) FROM ( SELECT * FROM x WHERE x < 1 ) a LEFT JOIN ( SELECT * FROM x WHERE x > 1 ) b ON x . x = x . x WHERE x . x > 1 OR x . x < 1 GROUP BY x . x , x . x ORDER BY 1 , 1 ; 
SELECT x . x , x . x , x ( * ) FROM ( SELECT * FROM x WHERE x < 1 ) a LEFT JOIN ( SELECT * FROM x WHERE x > 1 ) b ON x . x = x . x WHERE x . x > 1 OR x . x < 1 GROUP BY x . x , x . x ORDER BY 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x ( * ) FROM ( SELECT * FROM x WHERE x < 1 ) a FULL JOIN ( SELECT * FROM x WHERE x > 1 ) b ON x . x = x . x WHERE x . x > 1 OR x . x < 1 GROUP BY x . x , x . x ORDER BY 1 , 1 ; 
SELECT x . x , x . x , x ( * ) FROM ( SELECT * FROM x WHERE x < 1 ) a FULL JOIN ( SELECT * FROM x WHERE x > 1 ) b ON x . x = x . x WHERE x . x > 1 OR x . x < 1 GROUP BY x . x , x . x ORDER BY 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . x , x ( * ) FROM ( SELECT * FROM x WHERE x = 1 AND x = 1 ) a LEFT JOIN x b ON x . x = x . x GROUP BY x . x , x . x ORDER BY 1 , 1 ; 
SELECT x . x , x . x , x ( * ) FROM ( SELECT * FROM x WHERE x = 1 AND x = 1 ) a LEFT JOIN x b ON x . x = x . x GROUP BY x . x , x . x ORDER BY 1 , 1 ; 
INSERT INTO x SELECT x % 1 , x % 1 , x % 1 FROM x ( 1 , 1 ) i ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY x , ( x + x ) / 1 HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY x , ( x + x ) / 1 HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY ( x + x ) / 1 , 1 , 1 HAVING x ( x ) = 1 AND x ( x ) > 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x , x ( x ) , x ( x ) , x ( * ) FROM x GROUP BY ( x + x ) / 1 , 1 , 1 HAVING x ( x ) = 1 AND x ( x ) > 1 ORDER BY 1 , 1 , 1 ; 
INSERT INTO x SELECT x % 1 , x % 1 , x ( x % 1 , 'x' ) FROM x ( 1 , 1 ) i ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( DISTINCT x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( DISTINCT x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( DISTINCT x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( * ) FROM x GROUP BY x HAVING x ( x ) < 1 ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( * ) FROM x GROUP BY x ORDER BY 1 , 1 , 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x ( x ) , x ( * ) FROM x GROUP BY x , x , x HAVING x ( x ) > 1 ORDER BY 1 , 1 , 1 ; 
SELECT x , x ( x ) , x ( * ) FROM x GROUP BY x , x , x HAVING x ( x ) > 1 ORDER BY 1 , 1 , 1 ; 
SET min_parallel_table_scan_size TO 'x' ; 
SET parallel_setup_cost TO 1 ; 
INSERT INTO x SELECT x % 1 , x % 1 FROM x ( 1 , 1 ) i ; 
RESET min_parallel_table_scan_size ; 
RESET parallel_setup_cost ; 
CREATE TEMP TABLE x ( x INT CONSTRAINT articles_pkey PRIMARY KEY , x TEXT , x TEXT UNIQUE NOT NULL , x TEXT UNIQUE , x date ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x date , PRIMARY KEY ( x , x ) ) ; 
ALTER TABLE x DROP CONSTRAINT articles_pkey RESTRICT ; 
PREPARE foo AS SELECT x , x , x , x , x FROM x GROUP BY x ; 
EXECUTE foo ; 
INSERT INTO x SELECT x , 1 * x , 1 * x , x ( 'x' ) FROM x ( 1 , 1 ) AS x ; 
CREATE INDEX x ON x ( x , x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x ( x , x ) INCLUDE ( x , x ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x box ) ; 
CREATE UNIQUE INDEX x ON x USING btree ( x , x ) INCLUDE ( x , x ) ; 
ALTER TABLE x ADD UNIQUE USING INDEX x ; 
ALTER TABLE x ADD UNIQUE ( x , x ) INCLUDE ( x , x ) ; 
INSERT INTO x SELECT 1 , 1 , 1 * x , x ( 'x' ) FROM x ( 1 , 1 ) AS x ; 
INSERT INTO x SELECT 1 , 1 * x , 1 * x , x ( 'x' ) FROM x ( 1 , 1 ) AS x ; 
ALTER TABLE x ADD PRIMARY KEY ( x , x ) INCLUDE ( x , x ) ; 
ALTER TABLE x ADD PRIMARY KEY USING INDEX x ; 
CREATE TABLE x ( x INT , x INT , x INT , x box , CONSTRAINT covering PRIMARY KEY ( x , x ) INCLUDE ( x , x ) ) ; 
INSERT INTO x SELECT 1 , NULL , 1 * x , x ( 'x' ) FROM x ( 1 , 1 ) AS x ; 
INSERT INTO x SELECT x , 1 * x , NULL , NULL FROM x ( 1 , 1 ) AS x ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x , x , x ) < ( 1 , 1 , 1 ) ; 
SELECT * FROM x WHERE ( x , x , x ) < ( 1 , 1 , 1 ) ; 
SET enable_seqscan = off ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x , x , x ) < ( 1 , 1 , 1 ) LIMIT 1 ; 
SELECT * FROM x WHERE ( x , x , x ) < ( 1 , 1 , 1 ) LIMIT 1 ; 
CREATE TABLE x ( x INT , x INT , x INT , x box , UNIQUE ( x , x ) INCLUDE ( x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x box , PRIMARY KEY ( x , x ) INCLUDE ( x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x box , EXCLUDE USING btree ( x WITH = ) INCLUDE ( x , x ) ) ; 
CREATE UNIQUE INDEX x ON x USING btree ( x , x , x , x ) ; 
SELECT x FROM x WHERE x = 'x' ORDER BY x ; 
CREATE INDEX x ON x ( x , ( x + 1 ) ) INCLUDE ( x ) ; 
CREATE UNIQUE INDEX CONCURRENTLY ON x ( x , x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x USING brin ( x , x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x USING gist ( x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x USING spgist ( x ) INCLUDE ( x ) ; 
CREATE INDEX ON x USING gin ( x , x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x USING hash ( x , x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x USING rtree ( x ) INCLUDE ( x , x ) ; 
CREATE INDEX ON x USING btree ( x , x ) INCLUDE ( x , x ) ; 
DELETE FROM x WHERE x = 1 OR x = 1 ; 
ALTER TABLE x ALTER x TYPE BIGINT ; 
CREATE INDEX x ON x USING btree ( x int4_ops ) ; 
CREATE INDEX IF NOT EXISTS x ON x USING btree ( x int4_ops ) ; 
CREATE INDEX x ON x USING btree ( x name_ops ) ; 
CREATE INDEX x ON x ( x , x ) ; 
COMMENT ON INDEX six_wrong IS 'x' ; 
COMMENT ON INDEX six IS 'x' ; 
COMMENT ON INDEX six IS NULL ; 
CREATE INDEX x ON x USING btree ( x text_ops ) ; 
CREATE INDEX x ON x USING btree ( x float8_ops ) ; 
CREATE INDEX x ON x USING btree ( x int4_ops ) WHERE x < 1 OR x > 1 ; 
CREATE INDEX x ON x USING btree ( x int4_ops ) WHERE x < 'x' ; 
CREATE INDEX x ON x USING btree ( x name_ops ) WHERE x . x >= 'x' AND x . x < 'x' ; 
CREATE INDEX x ON x USING gist ( x ) ; 
CREATE TEMP TABLE x AS SELECT x ( x ) AS f1 FROM x ; 
SET enable_seqscan = ON ; 
SET enable_indexscan = OFF ; 
SET enable_bitmapscan = OFF ; 
@SELECT x ( * ) FROM x WHERE x IS NULL ; 
~SELECT * FROM x WHERE x && x ( x ( 1 , 1 ) , 1 ) ORDER BY x ( x ) ; 
@SELECT x ( * ) FROM x WHERE x < x 'x' ; 
@SELECT x ( * ) FROM x WHERE x 'x' > x ; 
@@~SELECT x ( * ) FROM x p WHERE x . x = 'x' ; 
@SET enable_seqscan = OFF ; 
SET enable_indexscan = ON ; 
@@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x IS NULL ; 
~~EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x && x ( x ( 1 , 1 ) , 1 ) ORDER BY x ( x ) ; 
@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x < x 'x' ; 
@@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x 'x' > x ; 
@@@@@~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x p WHERE x . x = 'x' ; 
~EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x IS NULL ; 
@@SET enable_bitmapscan = ON ; 
@@CREATE INDEX x ON x USING gin ( x ) ; 
@EXPLAIN ( costs off ) SELECT * FROM x WHERE x > 'x' ORDER BY x ; 
@SELECT * FROM x WHERE x > 'x' ORDER BY x ; 
SELECT * FROM x WHERE x && 'x' ORDER BY x ; 
@@@SELECT * FROM x WHERE x < 'x' ORDER BY x ; 
SELECT * FROM x WHERE x = 'x' ORDER BY x ; 
@@@@@@@@@@@DROP INDEX x , x ; 
CREATE INDEX x ON x USING gin ( x , x ) ; 
@@@SELECT * FROM x WHERE x > 'x' AND x && 'x' ORDER BY x ; 
@SELECT * FROM x WHERE x && 'x' AND x > 'x' ORDER BY x ; 
@CREATE TABLE x ( x INT [ ] ) ; 
INSERT INTO x SELECT ARRAY [ 1 , x % 1 , x ] FROM x ( 1 , 1 ) g ; 
@CREATE INDEX x ON x USING hash ( x int4_ops ) ; 
CREATE INDEX x ON x USING hash ( x name_ops ) ; 
CREATE INDEX x ON x USING hash ( x text_ops ) ; 
CREATE INDEX x ON x USING hash ( x float8_ops ) WITH ( fillfactor = 1 ) ; 
CREATE UNLOGGED TABLE x ( x int4 ) ; 
SET maintenance_work_mem = 'x' ; 
CREATE INDEX x ON x USING hash ( x name_ops ) WITH ( fillfactor = 1 ) ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x = 'x' ; 
RESET maintenance_work_mem ; 
CREATE UNIQUE INDEX x ON x ( x ( x , x ) ) ; 
CREATE UNIQUE INDEX x ON x ( ( x || x ) text_ops ) ; 
CREATE UNIQUE INDEX x ON x ( x , x ) INCLUDE ( x ) ; 
CREATE UNIQUE INDEX x ON x ( ( x + 1 ) , x ) ; 
CREATE UNIQUE INDEX x ON x ( x ) WHERE x > 1 ; 
CREATE INDEX CONCURRENTLY x ON x ( x , x ) ; 
CREATE INDEX CONCURRENTLY IF NOT EXISTS x ON x ( x , x ) ; 
CREATE UNIQUE INDEX CONCURRENTLY x ON x ( x ) ; 
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS x ON x ( x ) ; 
CREATE INDEX CONCURRENTLY x ON x ( x ) WHERE x = 'x' ; 
CREATE INDEX CONCURRENTLY ON x ( ( x || x ) ) ; 
CREATE INDEX CONCURRENTLY x ON x ( x ) ; 
VACUUM FULL x ; 
DROP INDEX CONCURRENTLY concur_index5" ; 
DROP INDEX CONCURRENTLY IF EXISTS concur_index3" ; 
DROP INDEX CONCURRENTLY concur_index4" ; 
DROP INDEX CONCURRENTLY concur_index1" ; 
DROP INDEX CONCURRENTLY concur_heap_expr_idx" ; 
CREATE TABLE x ( x INT , x VARCHAR ( 1 ) , x CHAR ) ; 
CREATE UNIQUE INDEX x ON x ( x , x ) ; 
ALTER TABLE x DROP CONSTRAINT cwi_uniq_idx , ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY USING INDEX x ; 
CREATE TABLE x ( x INT ) PARTITION BY hash ( a ) ; 
CREATE INDEX ON x ( ( x >= 'x' ) ) ; 
CREATE INDEX ON x ( x ) WHERE x >= 'x' ; 
SELECT x , x INTO x FROM x ; 
INSERT INTO x ( x , x ) VALUES ( NULL , 1 ) , ( NULL , NULL ) ; 
SELECT x ( * ) FROM x WHERE x IS NULL AND x IS NULL ; 
SELECT x ( * ) FROM x WHERE x IS NOT NULL ; 
SELECT x ( * ) FROM x WHERE x IS NULL AND x IS NOT NULL ; 
SELECT x ( * ) FROM x WHERE x IS NOT NULL AND x > 1 ; 
SELECT x ( * ) FROM x WHERE x IS NULL AND x > 1 ; 
CREATE UNIQUE INDEX x ON x ( x DESC , x ) ; 
CREATE UNIQUE INDEX x ON x ( x DESC NULLS LAST , x ) ; 
CREATE UNIQUE INDEX x ON x ( x NULLS FIRST , x ) ; 
SELECT x , x FROM x ORDER BY x LIMIT 1 ; 
SELECT x , x FROM x WHERE x >= 1 ORDER BY x LIMIT 1 ; 
SELECT x , x FROM x ORDER BY x DESC LIMIT 1 ; 
SELECT x , x FROM x WHERE x >= 1 ORDER BY x DESC LIMIT 1 ; 
SELECT x , x FROM x WHERE x < 1 ORDER BY x DESC LIMIT 1 ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x = 1 AND ( x = 1 OR x = 1 OR x = 1 ) ; 
SELECT * FROM x WHERE x = 1 AND ( x = 1 OR x = 1 OR x = 1 ) ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x = 1 AND ( x = 1 OR x = 1 ) ; 
SELECT x ( * ) FROM x WHERE x = 1 AND ( x = 1 OR x = 1 ) ; 
CREATE INDEX x ON x ( x , x , x text_pattern_ops ) ; 
~~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x BETWEEN 'x' AND 'x' AND x < 1 AND x < 'x' ; 
~~SELECT x ( * ) FROM x WHERE x BETWEEN 'x' AND 'x' AND x < 1 AND x < 'x' ; 
SET enable_indexonlyscan = OFF ; 
RESET enable_indexonlyscan ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x , x ) IN ( ( 1 , 1 ) , ( NULL , NULL ) ) ; 
CREATE TEMP TABLE x ( x bool , x INT , UNIQUE ( x , x ) , x FLOAT ) ; 
EXPLAIN ( costs off ) SELECT * FROM x ORDER BY x , x LIMIT 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x ORDER BY x LIMIT 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = TRUE ORDER BY x DESC LIMIT 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE NOT x ORDER BY x LIMIT 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS TRUE ORDER BY x DESC LIMIT 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS FALSE ORDER BY x DESC LIMIT 1 ; 
\\CREATE INDEX x ON x ( x , x , x ) ; 
CREATE TABLE x ( x INT REFERENCES x ) ; 
CREATE TABLE x ( x INT , x int4range , EXCLUDE USING gist ( x WITH && ) ) ; 
REINDEX INDEX CONCURRENTLY x ; 
REINDEX TABLE CONCURRENTLY x ; 
COMMENT ON INDEX testcomment_idx1 IS 'x' ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) PARTITION BY list ( c2 ) ; 
CREATE TABLE x ( x INT , x BOOLEAN ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , FALSE ) , ( 1 , TRUE ) , ( 1 , FALSE ) ; 
ALTER TABLE x ALTER x TYPE TEXT ; 
SET search_path = 'x' ; 
CREATE TABLE x ( x SERIAL PRIMARY KEY ) ; 
INSERT INTO x SELECT x ( 1 , 1 ) ; 
CREATE TABLE x ( x SERIAL PRIMARY KEY , x TEXT NOT NULL ) ; 
INSERT INTO x SELECT x ( 1 , 1 ) , 'x' ; 
CREATE MATERIALIZED VIEW x AS SELECT x FROM x ; 
REINDEX SCHEMA schema_to_reindex ; 
CREATE TABLE x AS SELECT x , x , x , x FROM x WHERE x = ( SELECT x FROM x WHERE x = 'x' ) ; 
SELECT x . x , x . x , CASE WHEN x . x = x . x THEN 'x' ELSE 'x' END FROM x b JOIN x a ON x . x = x . x ORDER BY 1 ; 
REINDEX SCHEMA CONCURRENTLY schema_to_reindex ; 
CREATE ROLE x NOLOGIN ; 
SET SESSION ROLE regress_reindexuser ; 
GRANT USAGE ON SCHEMA pg_toast TO x ; 
REINDEX TABLE x . pg_toast_1260 ; 
REINDEX INDEX x . pg_toast_1260_index ; 
REVOKE USAGE ON SCHEMA pg_toast FROM x ; 
DROP SCHEMA schema_to_reindex CASCADE ; 
CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler ; 
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER int4in ; 
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER heap_tableam_handler ; 
CREATE INDEX x ON x USING gist2 ( x ) ; 
@@DROP ACCESS METHOD gist2 ; 
DROP ACCESS METHOD gist2 CASCADE ; 
SET default_table_access_method = 'x' ; 
CREATE ACCESS METHOD heap2 TYPE TABLE HANDLER heap_tableam_handler ; 
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER int4in ; 
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER bthandler ; 
SELECT x , x , x FROM x WHERE x = 'x' ORDER BY 1 , 1 ; 
CREATE TABLE x ( x INT ) USING heap2 ; 
CREATE TABLE x USING heap2 AS SELECT * FROM x ; 
CREATE MATERIALIZED VIEW x USING heap2 AS SELECT * FROM x ; 
CREATE TABLE x ( x TEXT , x INT ) PARTITION BY list ( a ) USING heap2 ; 
RESET default_table_access_method ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' ) USING heap ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' ) USING heap2 ; 
SET LOCAL default_table_access_method = 'x' ; 
SELECT INTO x FROM x ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' ) USING heap ; 
CREATE FOREIGN DATA WRAPPER fdw_heap2 VALIDATOR postgresql_fdw_validator ; 
CREATE SERVER fs_heap2 FOREIGN DATA WRAPPER fdw_heap2 ; 
CREATE FOREIGN TABLE x ( ) SERVER fs_heap2 ; 
""CREATE TABLE x ( ) USING i_do_not_exist_am ; 
CREATE TABLE x ( ) USING I do not exist AM" ; 
CREATE TABLE x ( ) USING btree" ; 
DROP ACCESS METHOD heap2 ; 
CREATE TEMP TABLE x ( x serial , x INT , x TEXT NOT NULL DEFAULT 'x' , x TEXT , x TEXT ) ; 
COPY x ( x , x , x , x , x ) FROM STDIN ; 
COPY x ( x , x , x , x , x , x , x ) FROM STDIN ; 
\\COPY x FROM STDIN WHERE x = 1 ; 
COPY x FROM STDIN WHERE x = x ( x . x ) ; 
COPY x FROM STDIN WHERE x IN ( SELECT 1 FROM x ) ; 
COPY x FROM STDIN WHERE x IN ( x ( 1 , 1 ) ) ; 
COPY x FROM STDIN WHERE x = x ( ) OVER ( b ) ; 
COPY x ( x , x ) TO STDOUT ; 
COPY x ( x , x ) TO STDOUT WITH NULL 'x' ; 
INSERT INTO x VALUES ( 'x' , x 'x' ) ; 
INSERT INTO x VALUES ( 'x' , NULL ) ; 
COPY x TO STDOUT WITH CSV ; 
COPY x TO STDOUT WITH CSV QUOTE 'x' DELIMITER 'x' ; 
COPY x TO STDOUT WITH CSV FORCE QUOTE * ; 
\COPY x FROM STDIN CSV ; 
INSERT INTO x VALUES ( 1 , x 'x' ) , ( NULL , NULL ) ; 
SAVEPOINT s1 ; 
COPY x FROM STDIN CSV FREEZE ; 
\\\ROLLBACK TO SAVEPOINT s1 ; 
$$$$CREATE TEMP TABLE x ( x INT NOT NULL , x TEXT NOT NULL , x TEXT , x TEXT , x TEXT ) ; 
\SELECT x , x FROM x WHERE x = 1 ; 
\$$$$ALTER TABLE x ADD CHECK ( x ( x . * ) ) ; 
\\COPY x ( x , x , x ) FROM STDIN ; 
ALTER TABLE x FORCE ROW LEVEL SECURITY ; 
GRANT SELECT ON TABLE x TO x ; 
GRANT SELECT ( x , x ) ON TABLE x TO x ; 
COPY x ( x , x , x ) TO STDOUT ; 
SET SESSION AUTHORIZATION regress_rls_copy_user ; 
SET SESSION AUTHORIZATION regress_rls_copy_user_colperms ; 
$$SELECT x . * FROM x b WHERE x . x >= 1 ; 
SELECT x . * FROM x b WHERE x . x = 1 ; 
SET enable_seqscan TO FALSE ; 
SET enable_indexscan TO TRUE ; 
SET enable_bitmapscan TO FALSE ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x LIKE x 'x' ORDER BY 1 ; 
SELECT x FROM x WHERE x LIKE x 'x' ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x ILIKE 'x' ORDER BY 1 ; 
SELECT x FROM x WHERE x ILIKE 'x' ORDER BY 1 ; 
SET enable_indexscan TO FALSE ; 
SET enable_bitmapscan TO TRUE ; 
CREATE TEMP TABLE x ( x TEXT COLLATE C" ) ; 
CREATE INDEX ON x ( x bpchar_ops ) ; 
INSERT INTO x VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x LIKE 'x' ; 
SELECT * FROM x WHERE x LIKE 'x' ; 
CREATE INDEX x ON x ( x , x ) WITH ( fillfactor = 1 ) ; 
INSERT INTO x SELECT x , x ( 'x' , 1 ) FROM x ( 1 , 1 ) g ; 
CREATE INDEX x ON x ( x ) WITH ( vacuum_cleanup_index_scale_factor = 1.000000 ) ; 
CREATE INDEX x ON x ( x ) WITH ( vacuum_cleanup_index_scale_factor = 'x' ) ; 
ALTER INDEX x SET ( vacuum_cleanup_index_scale_factor = 1.000000 ) ; 
CREATE TABLE x ( x BIGINT , x BIGINT , x BIGINT , x BIGINT ) ; 
INSERT INTO x SELECT x , 1 , 1 , 1 FROM x ( 1 , 1 ) i ; 
ALTER TABLE x ADD PRIMARY KEY ( x , x , x , x ) ; 
CREATE TABLE x ( x INT , x macaddr ) ; 
CREATE FUNCTION x ( TEXT ) RETURNS bool LANGUAGE 'x' COST 1.000000 AS 'x' ; 
CREATE TABLE x ( x INT REFERENCES x ( x ) , x TEXT , x INT ) ; 
CREATE TABLE x ( x INT REFERENCES x ( x ) , x date , x INT ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) ; 
CREATE VIEW x AS SELECT * FROM x l NATURAL JOIN x r ; 
CREATE VIEW x WITH ( security_barrier ) AS SELECT * FROM x l NATURAL JOIN x r ; 
SET SESSION AUTHORIZATION regress_alice ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x ( x ) ; 
SELECT * FROM x v WHERE x ( 'x' ) AND x ( x ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x v WHERE x ( 'x' ) AND x ( x ) ; 
SELECT * FROM x WHERE x ( x ) AND x >= 'x' AND x < 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x ( x ) AND x >= 'x' AND x < 'x' ; 
PREPARE p1 AS SELECT * FROM x WHERE x ( x ) ; 
PREPARE p2 AS SELECT * FROM x WHERE x ( x ) ; 
EXECUTE p1 ; 
EXECUTE p2 ; 
CREATE TYPE casttesttype ; 
CREATE FUNCTION x ( cstring ) RETURNS casttesttype AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( casttesttype ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE CAST ( int4 AS casttesttype ) WITH FUNCTION x ( int4 ) AS IMPLICIT ; 
SELECT 'x' AS one , x . * FROM x i WHERE x . x = x 'x' ; 
SELECT 'x' AS two , x . * FROM x i WHERE x . x < x 'x' ; 
SELECT 'x' AS three , x . * FROM x i WHERE x . x <= x 'x' ; 
SELECT 'x' AS two , x . * FROM x i WHERE x . x > x 'x' ; 
SELECT 'x' AS three , x . * FROM x i WHERE x . x >= x 'x' ; 
SELECT 'x' AS one , x . * FROM x i WHERE ( x . x % x 'x' ) = x 'x' ; 
SELECT 'x' AS three , x . * FROM x i WHERE ( x . x % x 'x' ) = x 'x' ; 
SELECT 'x' AS five , x . x , x . x * x 'x' AS x FROM x i ; 
SELECT 'x' AS five , x . x , x . x + x 'x' AS x FROM x i ; 
SELECT 'x' AS five , x . x , x . x - x 'x' AS x FROM x i ; 
SELECT 'x' AS five , x . x , x . x / x 'x' AS x FROM x i ; 
SELECT x ( 1 ) , x ( 1 ) , x ( 1 , 1 ) , x ( 1 , 1 ) ; 
SELECT x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 , 1 ) , x ( 1 , 1 ) , x ( 1 , 1 ) , x ( 1 , 1 ) ; 
CREATE TABLE x ( x int4 , x int4 NOT NULL , x TEXT DEFAULT 'x' ) ; 
INSERT INTO x ( x , x , x ) VALUES ( DEFAULT , DEFAULT , DEFAULT ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , DEFAULT ) ; 
INSERT INTO x ( x , x , x ) VALUES ( DEFAULT , 1 , DEFAULT ) ; 
INSERT INTO x VALUES ( DEFAULT , 1 , 'x' ) ; 
INSERT INTO x VALUES ( DEFAULT , 1 ) ; 
INSERT INTO x ( x , x , x ) VALUES ( DEFAULT , DEFAULT ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 1 , 1 ) ; 
INSERT INTO x ( x ) VALUES ( 1 , 1 ) ; 
INSERT INTO x ( x ) VALUES ( DEFAULT , DEFAULT ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' ) , ( 1 , 1 , DEFAULT ) , ( ( SELECT 1 ) , ( SELECT x FROM ( VALUES ( 1 ) ) AS foo ( i ) ) , 'x' ) ; 
INSERT INTO x VALUES ( 1 , 1 , x ( 'x' , 1 ) ) ; 
CREATE TYPE insert_test_type AS ( if1 INT , if2 TEXT [ ] ) ; 
CREATE TABLE x ( x INT , x INT [ ] , x insert_test_type , x insert_test_type [ ] ) ; 
INSERT INTO x ( x [ 1 ] , x [ 1 ] ) VALUES ( 1 , 1 ) , ( 1 , 1 ) ; 
INSERT INTO x ( x [ 1 ] , x [ 1 ] ) SELECT 1 , 1 ; 
INSERT INTO x ( x . if1 , x . if2 ) VALUES ( 1 , 'x' ) , ( 1 , 'x' ) ; 
INSERT INTO x ( x . if1 , x . if2 ) SELECT 1 , 'x' ; 
INSERT INTO x ( x . if2 [ 1 ] , x . if2 [ 1 ] ) VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) ; 
INSERT INTO x ( x . if2 [ 1 ] , x . if2 [ 1 ] ) SELECT 'x' , 'x' ; 
INSERT INTO x ( x [ 1 ] . if2 [ 1 ] , x [ 1 ] . if2 [ 1 ] ) VALUES ( 'x' , 'x' ) ; 
INSERT INTO x ( x [ 1 ] . if2 [ 1 ] , x [ 1 ] . if2 [ 1 ] ) VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) ; 
INSERT INTO x ( x [ 1 ] . if2 [ 1 ] , x [ 1 ] . if2 [ 1 ] ) SELECT 'x' , 'x' ; 
CREATE TABLE x ( x BIGINT , x TEXT ) ; 
DROP TYPE insert_test_type ; 
CREATE TABLE x ( x TEXT , x INT ) PARTITION BY list ( x ( x ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( NULL ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' ) PARTITION BY list ( a ) ; 
INSERT INTO x SELECT 'x' , x . x FROM x ( 1 , 1 ) s ( a ) ; 
$$CREATE TABLE x ( x INT ) PARTITION BY hash ( a part_test_int4_ops ) ; 
INSERT INTO x VALUES ( x ( 1 , 1 ) ) ; 
ALTER TABLE x ADD CONSTRAINT check_b CHECK ( x = 1 ) ; 
$$DROP TRIGGER mlparted11_trig ON mlparted11 ; 
CREATE TABLE x ( x INT , x CHAR ) PARTITION BY list ( b ) ; 
ALTER TABLE x DROP CONSTRAINT check_b ; 
CREATE TABLE x ( x INT NOT NULL , x INT NOT NULL ) ; 
CREATE TABLE x ( x TEXT , x INT NOT NULL , x INT NOT NULL ) PARTITION BY list ( c ) ; 
CREATE TABLE x ( x INT NOT NULL , x TEXT , x INT NOT NULL ) ; 
ALTER TABLE x ADD CONSTRAINT check_b CHECK ( x = 1 AND x < 1 ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 1 , 1 , 'x' ) ; 
ALTER TABLE x ADD x INT , ADD x INT ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' ) TO ( 'x' ) PARTITION BY list ( c ) ; 
CREATE TABLE x ( x INT , x INT , x TEXT , x INT ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' , 1 ) ; 
CREATE TABLE x ( x INT , x INT ) PARTITION BY list ( ( x + 1 ) ) ; 
GRANT SELECT ( x ) ON x TO x ; 
SET ROLE regress_insert_other_user ; 
REVOKE ALL ON x FROM x ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 , 1 , 1 ) TO ( 1 , 1 , 1 ) ; 
INSERT INTO x VALUES ( NULL , NULL , NULL ) ; 
CREATE TABLE x ( x INT , x TEXT ) PARTITION BY list ( a ) ; 
CREATE TABLE x ( x TEXT DEFAULT 'x' , x TEXT DEFAULT 'x' , x INT ) ; 
SET ROLE regress_coldesc_role ; 
WITH result AS ( INSERT INTO x VALUES ( 1 , 'x' ) RETURNING 1 ) INSERT INTO x ( x ) SELECT * FROM x ; 
CREATE TABLE x ( x TEXT , x TEXT , x INT ) ; 
COPY x FROM STDOUT ; 
INSERT INTO x VALUES ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) ; 
INSERT INTO x VALUES ( 1 ) RETURNING x ; 
INSERT INTO x VALUES ( 1 , 'x' ) RETURNING x ; 
CREATE TABLE x AS SELECT x ( x , x ) AS p FROM x ; 
INSERT INTO x VALUES ( NULL ) , ( NULL ) , ( NULL ) ; 
CREATE INDEX x ON x USING spgist ( x kd_point_ops ) ; 
INSERT INTO x SELECT 'x' FROM x ( 1 , 1 ) ; 
@@~~~~~~~~~@SELECT x ( * ) FROM x WHERE x ^ 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x IS NOT NULL ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x ; 
@@@@~~@@@@~~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x < 'x' ; 
~~~~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x <= 'x' ; 
~~~~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x >= 'x' ; 
~~~~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x > 'x' ; 
~~~~@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x ^ 'x' ; 
@@@@@~~@@@@~~~~~~~~~~~~~~~~~~@@CREATE TABLE x ( x INT DEFAULT 1 , x TEXT DEFAULT 'x' , x float8 DEFAULT 1.000000 ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 1.000000 ) ; 
INSERT INTO x VALUES ( 1 , NULL , 1.000000 ) ; 
SELECT 'x' AS four , * FROM x ; 
CREATE TABLE x ( x bool DEFAULT ( 1 IN ( 1 , 1 ) ) ) ; 
CREATE TABLE x ( x INT , CONSTRAINT CHECK_CON CHECK ( x > 1 ) ) ; 
SELECT 'x' AS three , * FROM x ; 
SELECT 'x' AS zero , * FROM x ; 
SELECT 'x' AS one , x ( 'x' ) ; 
SELECT 'x' AS six , * FROM x ; 
SELECT 'x' AS nine , * FROM x ; 
INSERT INTO x VALUES ( 'x' , 'x' , FALSE , 1 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , TRUE , 1 ) ; 
CREATE TABLE x ( x INT DEFAULT 1 , x INT CHECK ( x > x ) ) INHERITS ( x ) ; 
INSERT INTO x ( x , x , x , x ) VALUES ( 1 , 'x' , 1 , 1 ) ; 
CREATE TABLE x ( x INT CHECK ( x > 1 ) NO INHERIT ) ; 
CREATE TABLE x ( x INT , x INT CHECK ( x > 1 ) , CHECK ( x > 1 ) NO INHERIT ) ; 
ALTER SEQUENCE x RESTART WITH 1 ; 
CREATE TEMP TABLE x ( x INT , x TEXT , x INT ) ; 
INSERT INTO x VALUES ( NULL , 'x' , NULL ) ; 
INSERT INTO x VALUES ( 1 , 'x' , NULL ) ; 
INSERT INTO x ( x ) SELECT x FROM x ; 
INSERT INTO x SELECT * FROM x WHERE x = 'x' ; 
INSERT INTO x ( x , x ) SELECT x , 1 FROM x WHERE x = 'x' ; 
UPDATE x SET x = NULL WHERE x = 1 ; 
UPDATE x SET x = - x , x = - x ; 
UPDATE x SET x = x , x = x ; 
COPY x FROM 'x' ; 
CREATE TABLE x ( x INT , x TEXT , PRIMARY KEY ( x , x ) ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' ; 
CREATE TABLE x ( x INT , x TEXT , UNIQUE ( x , x ) ) ; 
CREATE TABLE x ( x INT UNIQUE DEFERRABLE , x TEXT ) ; 
SET CONSTRAINTS x DEFERRED ; 
ALTER TABLE x DROP CONSTRAINT unique_tbl_i_key ; 
ALTER TABLE x ADD CONSTRAINT unique_tbl_i_key UNIQUE ( x ) DEFERRABLE INITIALLY DEFERRED ; 
UPDATE x SET x = 1 WHERE x = 1 AND x = 'x' ; 
DELETE FROM x WHERE x = 1 AND x = 'x' ; 
SET CONSTRAINTS ALL IMMEDIATE ; 
SET CONSTRAINTS ALL DEFERRED ; 
SAVEPOINT f ; 
INSERT INTO x VALUES ( 'x' , 'x' ) ON CONFLICT ON CONSTRAINT circles_c1_c2_excl DO NOTHING ; 
INSERT INTO x VALUES ( 'x' , 'x' ) ON CONFLICT ON CONSTRAINT circles_c1_c2_excl DO UPDATE SET x = x . x ; 
CREATE TABLE x ( x INT , x INT , CONSTRAINT deferred_excl_con EXCLUDE ( x WITH = ) INITIALLY DEFERRED ) ; 
ALTER TABLE x DROP CONSTRAINT deferred_excl_con ; 
ALTER TABLE x ADD EXCLUDE ( x WITH = ) ; 
SET SESSION AUTHORIZATION regress_constraint_comments ; 
CREATE TABLE x ( x INT CONSTRAINT the_constraint CHECK ( x > 1 ) ) ; 
COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'x' ; 
COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'x' ; 
COMMENT ON CONSTRAINT no_constraint ON constraint_comments_tbl IS 'x' ; 
COMMENT ON CONSTRAINT no_constraint ON DOMAIN constraint_comments_dom IS 'x' ; 
COMMENT ON CONSTRAINT the_constraint ON no_comments_tbl IS 'x' ; 
COMMENT ON CONSTRAINT the_constraint ON DOMAIN no_comments_dom IS 'x' ; 
COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS NULL ; 
COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS NULL ; 
SET SESSION AUTHORIZATION regress_constraint_comments_noaccess ; 
DROP DOMAIN constraint_comments_dom ; 
CREATE TABLE x ( x oid , x INTEGER ) ; 
INSERT INTO x ( x ) SELECT x ( 1 ) ; 
$$$$UPDATE x SET x = x ( x , CAST ( x 'x' | x 'x' AS INTEGER ) ) ; 
\SELECT x ( x , 1 , 1 ) FROM x ; 
SELECT x ( x , 1 ) FROM x ; 
INSERT INTO x ( x ) SELECT x ( 'x' ) ; 
\\\COMMENT ON LARGE OBJECT 1 IS 'x' ; 
INSERT INTO x SELECT ( x % 1 ) , ( x % 1 ) , 'x' FROM x ( 1 , 1 ) r ; 
SET enable_seqscan = FALSE ; 
SET work_mem = 1 ; 
SELECT x ( * ) FROM x WHERE x = 1 AND x = 1 ; 
SELECT x ( * ) FROM x WHERE x = 1 OR x = 1 ; 
CREATE EVENT TRIGGER x ON ddl_command_start EXECUTE PROCEDURE x ( ) ; 
$$$$$$CREATE EVENT TRIGGER x ON elephant_bootstrap EXECUTE PROCEDURE x ( ) ; 
CREATE EVENT TRIGGER x ON ddl_command_end EXECUTE FUNCTION x ( ) ; 
CREATE EVENT TRIGGER x ON ddl_command_start WHEN food IN ( 'x' ) EXECUTE PROCEDURE x ( ) ; 
CREATE EVENT TRIGGER x ON ddl_command_start WHEN tag IN ( 'x' ) EXECUTE PROCEDURE x ( ) ; 
CREATE EVENT TRIGGER x ON ddl_command_start WHEN tag IN ( 'x' , 'x' ) EXECUTE PROCEDURE x ( ) ; 
CREATE EVENT TRIGGER x ON ddl_command_start WHEN tag IN ( 'x' ) AND tag IN ( 'x' ) EXECUTE PROCEDURE x ( ) ; 
COMMENT ON EVENT TRIGGER regress_event_trigger IS 'x' ; 
SET ROLE regress_evt_user ; 
ALTER EVENT TRIGGER x DISABLE ; 
ALTER EVENT TRIGGER x ENABLE ; 
ALTER EVENT TRIGGER x ENABLE REPLICA ; 
ALTER EVENT TRIGGER x ENABLE ALWAYS ; 
RESET session_replication_role ; 
$$$$$$CALL x ( ) ; 
DROP TABLE x , x , x , x , x , x ; 
DROP ROUTINE x ( ) , x ( ) ; 
GRANT ALL ON TABLE x TO x ; 
COMMENT ON TABLE event_trigger_fire1 IS 'x' ; 
REVOKE ALL ON TABLE x FROM x ; 
CREATE FOREIGN DATA WRAPPER useless ; 
CREATE SERVER useless_server FOREIGN DATA WRAPPER useless ; 
CREATE USER MAPPING FOR x SERVER useless_server ; 
ALTER EVENT TRIGGER regress_event_trigger OWNER TO x ; 
ALTER ROLE x superuser ; 
ALTER EVENT TRIGGER regress_event_trigger RENAME TO regress_event_trigger2 ; 
ALTER EVENT TRIGGER regress_event_trigger RENAME TO regress_event_trigger3 ; 
DROP EVENT TRIGGER regress_event_trigger ; 
DROP EVENT TRIGGER IF EXISTS regress_event_trigger2 ; 
DROP EVENT TRIGGER regress_event_trigger3 ; 
DROP EVENT TRIGGER regress_event_trigger_end ; 
CREATE SCHEMA x AUTHORIZATION x ; 
SET SESSION AUTHORIZATION regress_evt_user ; 
CREATE TABLE x . table_one ( x INT ) ; 
CREATE TABLE x . table two" ( x INT ) ; 
CREATE TABLE x . table_three ( x INT ) ; 
CREATE TABLE x . schema_one_table_two ( x TEXT ) ; 
CREATE TABLE x . table_two ( x INT ) ; 
CREATE TABLE x . table_three ( x INT , x TEXT ) ; 
CREATE TABLE x . schema_two_table_three ( x TEXT ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) ; 
$$CREATE EVENT TRIGGER x ON sql_drop EXECUTE PROCEDURE x ( ) ; 
$$CREATE EVENT TRIGGER x ON sql_drop WHEN TAG IN ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) EXECUTE PROCEDURE x ( ) ; 
ALTER TABLE x . table_one DROP COLUMN x ; 
DROP SCHEMA schema_one , schema_two CASCADE ; 
DROP EVENT TRIGGER regress_event_trigger_drop_objects ; 
DROP EVENT TRIGGER undroppable ; 
$$$$CREATE SCHEMA x CREATE TABLE x ( x SERIAL PRIMARY KEY , x TEXT DEFAULT 'x' ) CREATE INDEX x ON x ( x ) CREATE TABLE x ( x INTEGER CHECK ( x > 1 ) REFERENCES x DEFAULT 1 ) ; 
CREATE TABLE x . part_1_10 PARTITION OF x . parted ( x ) FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
CREATE TABLE x . part_10_15 PARTITION OF x . part_10_20 ( x ) FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
CREATE TABLE x . part_15_20 PARTITION OF x . part_10_20 ( x ) FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
ALTER TABLE x . two DROP COLUMN x ; 
ALTER TABLE x . one ALTER COLUMN x DROP DEFAULT ; 
ALTER TABLE x . one DROP CONSTRAINT one_pkey ; 
DROP INDEX x . one_idx ; 
DROP SCHEMA evttrig CASCADE ; 
DROP EVENT TRIGGER regress_event_trigger_report_dropped ; 
$$CREATE EVENT TRIGGER x ON table_rewrite EXECUTE PROCEDURE x ( ) ; 
CREATE TABLE x ( x serial PRIMARY KEY , x FLOAT , x timestamptz ) ; 
INSERT INTO x SELECT x * 1.000000 FROM x ( 1 , 1 ) AS t ( x ) ; 
ALTER TABLE x ADD COLUMN x INT DEFAULT 1 ; 
$$ALTER TABLE x ADD COLUMN x INT DEFAULT 1 , ADD COLUMN x INT DEFAULT 1 , ALTER COLUMN x TYPE NUMERIC ( 1 , 1 ) ; 
ALTER TABLE x ALTER COLUMN x TYPE NUMERIC ( 1 , 1 ) ; 
SET timezone TO 'x' ; 
ALTER TABLE x ALTER COLUMN x TYPE TIMESTAMP ; 
ALTER TABLE x ALTER COLUMN x TYPE timestamptz ; 
$$CREATE TYPE rewritetype AS ( a INT ) ; 
CREATE TABLE x OF rewritetype ; 
ALTER TYPE rewritetype ALTER ATTRIBUTE a TYPE TEXT CASCADE ; 
CREATE TABLE x ( x rewritetype ) ; 
ALTER TYPE rewritetype ALTER ATTRIBUTE a TYPE VARCHAR CASCADE ; 
DROP EVENT TRIGGER no_rewrite_allowed ; 
CREATE TABLE x ( x INTEGER , x TEXT ) ; 
$$$$$$$$$$$$CREATE EVENT TRIGGER x ON ddl_command_start WHEN TAG IN ( 'x' , 'x' , 'x' ) EXECUTE PROCEDURE x ( ) ; 
CREATE EVENT TRIGGER x ON ddl_command_end WHEN TAG IN ( 'x' , 'x' , 'x' ) EXECUTE PROCEDURE x ( ) ; 
CREATE EVENT TRIGGER x ON sql_drop WHEN TAG IN ( 'x' ) EXECUTE PROCEDURE x ( ) ; 
CREATE POLICY p1 ON x USING ( FALSE ) ; 
ALTER POLICY p1 ON x USING ( TRUE ) ; 
ALTER POLICY p1 ON x RENAME TO p2 ; 
DROP POLICY p2 ON event_trigger_test ; 
DROP EVENT TRIGGER start_rls_command ; 
DROP EVENT TRIGGER end_rls_command ; 
DROP EVENT TRIGGER sql_drop_command ; 
CREATE TABLE x ( x circle ) ; 
SELECT 'x' AS six , x ( x ) AS radius FROM x ; 
SELECT 'x' AS six , x ( x ) AS diameter FROM x ; 
SELECT 'x' AS two , x FROM x WHERE x ( x ) < 1 ; 
SELECT 'x' AS four , x FROM x WHERE x ( x ) >= 1 ; 
INSERT INTO x SELECT x , 1 * x , 1 * x , x ( x ( x , x + 1 ) , x ( 1 * x , 1 * x + 1 ) ) FROM x ( 1 , 1 ) AS x ; 
CREATE INDEX x ON x USING gist ( x ) INCLUDE ( x , x , x ) ; 
@SELECT * FROM x WHERE x < x ( x ( 1 , 1 ) , x ( 1 , 1 ) ) ; 
@EXPLAIN ( costs off ) SELECT * FROM x WHERE x < x ( x ( 1 , 1 ) , x ( 1 , 1 ) ) ; 
SET enable_bitmapscan TO DEFAULT ; 
@@CREATE INDEX CONCURRENTLY x ON x USING gist ( x ) INCLUDE ( x , x , x ) ; 
CREATE INDEX x ON x USING gist ( x ) INCLUDE ( x , x ) ; 
INSERT INTO x SELECT x , 1 * x , 1 * x , x ( x ( 1 * x , 1 * x ) , x ( 1 * x + 1 , 1 * x + 1 ) ) FROM x ( 1 , 1 ) AS x ; 
@SELECT 1 AS one ; 
SELECT x 'x' AS error ; 
INSERT INTO x ( x ) VALUES ( x 'x' ) ; 
SELECT 'x' AS t_3 , x . * FROM x ; 
SELECT 'x' AS t_3 , x . * FROM x WHERE x = x 'x' ; 
SELECT 'x' AS zero , x . * FROM x WHERE x ( x 'x' , x ) ; 
SELECT 'x' AS f_1 , x . * FROM x WHERE x = x 'x' ; 
CREATE TABLE x ( x bool ) ; 
SELECT 'x' AS f_4 , x . * FROM x ; 
SELECT 'x' AS tf_12 , x . * , x . * FROM x , x WHERE x ( x . x , x . x ) ; 
SELECT 'x' AS ff_4 , x . * , x . * FROM x , x WHERE x . x = x . x AND x . x = x 'x' ; 
SELECT 'x' AS tf_12_ff_4 , x . * , x . * FROM x , x WHERE x . x = x . x OR x . x = x 'x' ORDER BY x . x , x . x ; 
SELECT 'x' AS True" , x FROM x WHERE x IS TRUE ; 
SELECT 'x' AS Not False" , x FROM x WHERE x IS NOT FALSE ; 
SELECT 'x' AS False" , x FROM x WHERE x IS FALSE ; 
SELECT 'x' AS Not True" , x FROM x WHERE x IS NOT TRUE ; 
CREATE TABLE x ( x TEXT , x bool , x INT ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , TRUE , 1 ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , FALSE , 1 ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , NULL , 1 ) ; 
CREATE TABLE x ( x bool , x bool , x bool ) ; 
INSERT INTO x VALUES ( FALSE , TRUE , NULL ) ; 
\SELECT x AND x AND x FROM x ; 
SELECT x OR x OR x FROM x ; 
CREATE TABLE x ( x box ) ; 
SELECT 'x' AS four , x . * , x ( x . x ) AS barea FROM x b ; 
SELECT 'x' AS three , x . x FROM x b WHERE x . x && x 'x' ; 
SELECT 'x' AS two , x . * FROM x b1 WHERE x . x & < x 'x' ; 
SELECT 'x' AS two , x . * FROM x b1 WHERE x . x & > x 'x' ; 
SELECT 'x' AS four , x . x FROM x b WHERE x . x <= x 'x' ; 
SELECT 'x' AS two , x . x FROM x b WHERE x . x < x 'x' ; 
SELECT 'x' AS two , x . x FROM x b WHERE x . x = x 'x' ; 
@SELECT 'x' AS three , x . x FROM x b WHERE x . x < x 'x' ; 
@SELECT 'x' AS three , x . x FROM x b WHERE x 'x' > x . x ; 
~SELECT 'x' AS one , x . x FROM x b WHERE x 'x' = x . x ; 
@@SELECT 'x' AS four , ( x . x ) AS p FROM x b1 ; 
@~SELECT 'x' AS one , x . * , x . * FROM x b1 , x b2 WHERE x . x > x . x AND NOT x . x = x . x ; 
SELECT 'x' AS four , x ( x ) , x ( x ) FROM x ; 
CREATE TEMPORARY TABLE x ( x box ) ; 
INSERT INTO x SELECT x ( x ( x , x ) , x ( x * 1 , x * 1 ) ) FROM x ( 1 , 1 ) AS i ; 
INSERT INTO x VALUES ( NULL ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) ; 
SELECT * FROM x WHERE x & < 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x & < 'x' ; 
SELECT * FROM x WHERE x && 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x && 'x' ; 
SELECT * FROM x WHERE x & > 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x & > 'x' ; 
SELECT * FROM x WHERE x & < | 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x & < | 'x' ; 
@SELECT * FROM x WHERE x > 'x' ; 
@EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x > 'x' ; 
@SELECT * FROM x WHERE x < 'x' ; 
@EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x < 'x' ; 
~SELECT * FROM x WHERE x = 'x' ; 
~EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x = 'x' ; 
CREATE TABLE x ( x INT , x box ) ; 
INSERT INTO x SELECT ( x - 1 ) * 1 + x , x ( x ( x * 1 , x * 1 ) , x ( x * 1 + 1 , x * 1 + 1 ) ) FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ; 
INSERT INTO x SELECT x , 'x' FROM x ( 1 , 1 ) AS i ; 
SELECT x ( * ) FROM x WHERE x & < x 'x' ; 
SELECT x ( * ) FROM x WHERE x && x 'x' ; 
SELECT x ( * ) FROM x WHERE x & > x 'x' ; 
SELECT x ( * ) FROM x WHERE x & < | x 'x' ; 
@SELECT x ( * ) FROM x WHERE x > x 'x' ; 
@~SELECT x ( * ) FROM x WHERE x = x 'x' ; 
SELECT * FROM x seq FULL JOIN x idx ON x . x = x . x AND x . x = x . x AND ( x . x = x . x OR x . x IS NULL AND x . x IS NULL ) WHERE x . x IS NULL OR x . x IS NULL ; 
SET standard_conforming_strings = ON ; 
~~~~~~~~~~~SELECT SUBSTRING ( 'x' FROM 'x' ) ; 
SELECT x ( 'x' , 'x' ) IS NULL ; 
~~~~~~~~~~EXPLAIN ( costs off ) SELECT * FROM x WHERE x 'x' ; 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@CREATE TYPE xfloat4 ; 
CREATE FUNCTION x ( cstring ) RETURNS xfloat4 IMMUTABLE STRICT LANGUAGE internal AS 'x' ; 
CREATE FUNCTION x ( xfloat4 ) RETURNS cstring IMMUTABLE STRICT LANGUAGE internal AS 'x' ; 
CREATE CAST ( xfloat4 AS float4 ) WITHOUT FUNCTION ; 
CREATE CAST ( float4 AS xfloat4 ) WITHOUT FUNCTION ; 
CREATE CAST ( xfloat4 AS INTEGER ) WITHOUT FUNCTION ; 
CREATE CAST ( INTEGER AS xfloat4 ) WITHOUT FUNCTION ; 
DROP TYPE xfloat4 CASCADE ; 
$$$$$$$$\\SELECT x , x FROM x WHERE NOT x ( x ) ; 
SELECT x , * FROM x ; 
EXPLAIN ( COSTS OFF ) SELECT x , * FROM x WHERE x = 'x' ; 
SELECT x , * FROM x WHERE x = 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT x , * FROM x WHERE 'x' = x ; 
SELECT x , * FROM x WHERE 'x' = x ; 
EXPLAIN ( COSTS OFF ) SELECT x , * FROM x WHERE x = 'x' OR 'x' = x ; 
SELECT x , * FROM x WHERE x = 'x' OR 'x' = x ; 
SELECT x . x , x . * , x . x , x . * FROM x t1 JOIN x t2 ON x . x = x . x WHERE x . x = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x . x , x . * , x . x , x . * FROM x t1 LEFT JOIN x t2 ON x . x = x . x WHERE x . x = 1 ; 
SELECT x . x , x . * , x . x , x . * FROM x t1 LEFT JOIN x t2 ON x . x = x . x WHERE x . x = 1 ; 
FETCH BACKWARD 1 FROM c ; 
FETCH FIRST FROM c ; 
DECLARE c CURSOR FOR SELECT x , * FROM x ; 
EXPLAIN ( ANALYZE , COSTS OFF , SUMMARY OFF , TIMING OFF ) UPDATE x SET x = - x WHERE CURRENT OF c RETURNING * ; 
FETCH NEXT FROM c ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x t1 JOIN x t2 ON x . x = x . x ; 
SELECT x ( * ) FROM x t1 JOIN x t2 ON x . x = x . x ; 
UPDATE x SET x = x . x + 1 ; 
UPDATE x SET x = x . x - 1 ; 
UPDATE x SET x = x ( x . x ) FROM x WHERE x . x = 'x' AND x . x = x . x ; 
SELECT x FROM x WHERE x < 1 ORDER BY x ; 
COPY BINARY x TO 'x' ; 
COPY BINARY x FROM 'x' ; 
SELECT * FROM x * ; 
SELECT * FROM x * x WHERE x . x = TEXT 'x' OR x . x < 1 ; 
SELECT * FROM x * x WHERE x . x ISNULL ; 
SELECT x ( x ) FROM x * ; 
ALTER TABLE x * RENAME COLUMN x TO x ; 
SELECT * FROM x * WHERE x < 1 ; 
ALTER TABLE x * ADD COLUMN x int4 ; 
ALTER TABLE x * ADD COLUMN x TEXT ; 
SELECT * FROM x ( ROW ( 'x' , 'x' ) ) ; 
SELECT 1 ; 
SELECT ; 
SELECT * FROM x WHERE x = x . x ; 
SELECT * FROM x WHERE x . x = x ; 
SELECT DISTINCT ON ( x ) * FROM x ; 
CREATE AGGREGATE x ( sfunc = int4pl , basetype = int4 , stype = int4 , finalfunc = int2um , initcond = 'x' ) ; 
CREATE AGGREGATE x ( sfunc = int4inc , stype = int4 , initcond = 'x' ) ; 
DROP AGGREGATE x ( nonesuch ) ; 
DROP AGGREGATE x ( int4 ) ; 
DROP AGGREGATE x ( float4 ) ; 
DROP TYPE nonesuch ; 
DROP OPERATOR = ( nonesuch ) ; 
DROP OPERATOR = ( nonesuch , int4 ) ; 
DROP OPERATOR = ( int4 , nonesuch ) ; 
DROP RULE nonesuch ON noplace ; 
SELECT 1 / 1 ; 
\\CREATE TABLE x ( x TIME ( 1 ) WITH TIME ZONE ) ; 
SELECT x AS Time TZ" FROM x ; 
SELECT x AS Three" FROM x WHERE x < 'x' ; 
SELECT x AS Seven" FROM x WHERE x > 'x' ; 
SELECT x AS None" FROM x WHERE x < 'x' ; 
SELECT x AS Ten" FROM x WHERE x >= 'x' ; 
SELECT x + TIME WITH TIME ZONE 'x' AS Illegal" FROM x ; 
SELECT 1 + 1 AS one ; 
SELECT 1 - 1 AS three ; 
SELECT 1 - 1 AS four ; 
SELECT 1 ! AS twenty_four ; 
SELECT ! ! 1 AS six ; 
SELECT 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 AS ten ; 
SELECT 1 + 1 / 1 AS three ; 
SELECT ( 1 + 1 ) / 1 AS two ; 
CREATE USER x IN ROLE x ; 
GRANT ALL ON SCHEMA alt_nsp1 , alt_nsp2 TO x ; 
SET search_path = alt_nsp1 , public ; 
SET SESSION AUTHORIZATION regress_alter_generic_user1 ; 
CREATE AGGREGATE x ( sfunc1 = int4pl , basetype = int4 , stype1 = int4 , initcond = 1 ) ; 
CREATE AGGREGATE x ( sfunc1 = int4mi , basetype = int4 , stype1 = int4 , initcond = 1 ) ; 
CREATE CONVERSION alt_conv1 FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
CREATE CONVERSION alt_conv2 FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
SELECT x . x , x . x , x . x FROM x c , x n , x a WHERE x . x = x . x AND x . x = x . x AND x . x IN ( 'x' , 'x' ) ORDER BY x , x ; 
CREATE FOREIGN DATA WRAPPER alt_fdw1 ; 
CREATE FOREIGN DATA WRAPPER alt_fdw2 ; 
CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1 ; 
CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2 ; 
SELECT x FROM x WHERE x LIKE 'x' ; 
CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler ; 
CREATE LANGUAGE alt_lang2 HANDLER plpgsql_call_handler ; 
SELECT x , x . x FROM x l , x a WHERE x . x = x . x AND x . x LIKE 'x' ORDER BY x ; 
@@@@@@@@@@CREATE OPERATOR FAMILY alt_opf1 USING hash ; 
CREATE OPERATOR FAMILY alt_opf2 USING hash ; 
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO x ; 
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO x ; 
CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid ; 
CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid ; 
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO x ; 
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO x ; 
CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr ; 
CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr ; 
SET SESSION AUTHORIZATION regress_alter_generic_user2 ; 
SELECT x , x , x , x FROM x o , x m , x n , x a WHERE x . x = x . x AND x . x = x . x AND x . x = x . x AND x . x IN ( 'x' , 'x' ) AND NOT x LIKE 'x' ORDER BY x , x ; 
SELECT x , x , x , x FROM x o , x m , x n , x a WHERE x . x = x . x AND x . x = x . x AND x . x = x . x AND x . x IN ( 'x' , 'x' ) ORDER BY x , x ; 
CREATE OPERATOR FAMILY alt_opf4 USING btree ; 
DROP OPERATOR FAMILY alt_opf4 USING btree ; 
CREATE ROLE x NOSUPERUSER ; 
CREATE OPERATOR FAMILY alt_opf5 USING btree ; 
SET ROLE regress_alter_generic_user5 ; 
ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < ( int4 , int2 ) , FUNCTION 1 x ( int4 , int2 ) ; 
DROP OPERATOR FAMILY alt_opf5 USING btree ; 
REVOKE ALL ON SCHEMA alt_nsp6 FROM x ; 
CREATE OPERATOR FAMILY alt_nsp6 . alt_opf6 USING btree ; 
SET ROLE regress_alter_generic_user6 ; 
ALTER OPERATOR FAMILY alt_nsp6 . alt_opf6 USING btree ADD OPERATOR 1 < ( int4 , int2 ) ; 
CREATE OPERATOR FAMILY alt_opf7 USING btree ; 
ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < ( int4 , int2 ) ; 
ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 ( int4 , int2 , int8 ) ; 
DROP OPERATOR FAMILY alt_opf7 USING btree ; 
CREATE OPERATOR FAMILY alt_opf8 USING btree ; 
ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < ( int4 , int4 ) ; 
DROP OPERATOR FAMILY alt_opf8 USING btree ; 
CREATE OPERATOR FAMILY alt_opf9 USING gist ; 
ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < ( int4 , int4 ) FOR ORDER BY float_ops ; 
DROP OPERATOR FAMILY alt_opf9 USING gist ; 
CREATE OPERATOR FAMILY alt_opf10 USING btree ; 
ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < ( int4 , int4 ) FOR ORDER BY float_ops ; 
DROP OPERATOR FAMILY alt_opf10 USING btree ; 
CREATE OPERATOR FAMILY alt_opf11 USING gist ; 
ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < ( int4 , int4 ) FOR ORDER BY float_ops ; 
ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 ( int4 , int4 ) ; 
DROP OPERATOR FAMILY alt_opf11 USING gist ; 
CREATE OPERATOR FAMILY alt_opf12 USING btree ; 
ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 x ( int4 , int2 ) ; 
DROP OPERATOR FAMILY alt_opf12 USING btree ; 
CREATE OPERATOR FAMILY alt_opf13 USING hash ; 
ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 x ( int4 ) ; 
DROP OPERATOR FAMILY alt_opf13 USING hash ; 
CREATE OPERATOR FAMILY alt_opf14 USING btree ; 
ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 x ( int4 ) ; 
DROP OPERATOR FAMILY alt_opf14 USING btree ; 
CREATE OPERATOR FAMILY alt_opf15 USING hash ; 
ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 x ( int4 , int2 ) ; 
DROP OPERATOR FAMILY alt_opf15 USING hash ; 
CREATE OPERATOR FAMILY alt_opf16 USING gist ; 
ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 x ( int4 , int2 ) ; 
DROP OPERATOR FAMILY alt_opf16 USING gist ; 
CREATE OPERATOR FAMILY alt_opf17 USING btree ; 
CREATE OPERATOR FAMILY alt_opf18 USING btree ; 
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 ( int4 , int4 ) ; 
ALTER OPERATOR FAMILY alt_opf18 USING btree ADD OPERATOR 1 < ( int4 , int2 ) , OPERATOR 1 <= ( int4 , int2 ) , OPERATOR 1 = ( int4 , int2 ) , OPERATOR 1 >= ( int4 , int2 ) , OPERATOR 1 > ( int4 , int2 ) , FUNCTION 1 x ( int4 , int2 ) ; 
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 1 ( int4 , int4 ) ; 
DROP OPERATOR FAMILY alt_opf18 USING btree ; 
CREATE STATISTICS alt_stat1 ON x , x FROM x ; 
CREATE STATISTICS alt_stat2 ON x , x FROM x ; 
SELECT x , x , x FROM x s , x n , x a WHERE x . x = x . x AND x . x = x . x AND x . x IN ( 'x' , 'x' ) ORDER BY x , x ; 
SELECT x , x , x FROM x t , x n , x a WHERE x . x = x . x AND x . x = x . x AND x . x IN ( 'x' , 'x' ) ORDER BY x , x ; 
CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 ( lexize = dsimple_lexize ) ; 
CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 ( lexize = dsimple_lexize ) ; 
SELECT x , x FROM x t , x n WHERE x . x = x . x AND x LIKE 'x' ORDER BY x , x ; 
DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE ; 
DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE ; 
DROP LANGUAGE alt_lang2 CASCADE ; 
DROP LANGUAGE alt_lang3 CASCADE ; 
DROP SCHEMA alt_nsp1 CASCADE ; 
DROP SCHEMA alt_nsp2 CASCADE ; 
CREATE TABLE x ( x int4 , x NUMERIC ( 1 , 1 ) ) ; 
CREATE TABLE x ( x int4 , x int4 , x NUMERIC ( 1 , 1 ) ) ; 
COMMIT TRANSACTION ; 
INSERT INTO x SELECT x . x , x . x , x . x + x . x FROM x t1 , x t2 ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x = x . x AND x . x != x . x ; 
INSERT INTO x SELECT x . x , x . x , x ( x . x + x . x , 1 ) FROM x t1 , x t2 ; 
SELECT x . x , x . x , x . x , x ( x . x , 1 ) AS expected FROM x t1 , x t2 WHERE x . x = x . x AND x . x = x . x AND x . x != x ( x . x , 1 ) ; 
INSERT INTO x SELECT x . x , x . x , x . x - x . x FROM x t1 , x t2 ; 
INSERT INTO x SELECT x . x , x . x , x ( x . x - x . x , 1 ) FROM x t1 , x t2 ; 
SELECT x . x , x . x , x . x , x ( x . x , 1 ) FROM x t1 , x t2 WHERE x . x = x . x AND x . x = x . x AND x . x != x ( x . x , 1 ) ; 
INSERT INTO x SELECT x . x , x . x , x . x * x . x FROM x t1 , x t2 ; 
INSERT INTO x SELECT x . x , x . x , x ( x . x * x . x , 1 ) FROM x t1 , x t2 ; 
INSERT INTO x SELECT x . x , x . x , x . x / x . x FROM x t1 , x t2 WHERE x . x != 'x' ; 
INSERT INTO x SELECT x . x , x . x , x ( x . x / x . x , 1 ) FROM x t1 , x t2 WHERE x . x != 'x' ; 
INSERT INTO x SELECT x , 1 , x ( x ( x ) ) FROM x ; 
SELECT x . x , x . x , x . x FROM x t1 , x t2 WHERE x . x = x . x AND x . x != x . x ; 
INSERT INTO x SELECT x , 1 , x ( x ( x ) ) FROM x WHERE x != 'x' ; 
INSERT INTO x SELECT x , 1 , x ( NUMERIC 'x' , x ( x ( x ( x , 1 ) ) ) ) FROM x WHERE x != 'x' ; 
WITH t ( b , p , bc_result ) AS ( VALUES ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) , ( 1.000000 , 1 , 1.000000 ) ) SELECT x , x , x , x ^ x AS power , x ^ x - x AS diff FROM x ; 
WITH t ( b , p , bc_result ) AS ( VALUES ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) ) SELECT x , x , x , x ^ x AS power , x ^ x - x AS diff FROM x ; 
WITH t ( b , p , bc_result ) AS ( VALUES ( 1.000000 , 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 , 1.000000 ) ) SELECT x , x , x , x ^ x AS power , x ^ x - x AS diff FROM x ; 
WITH t ( x , bc_result ) AS ( VALUES ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) , ( 1.000000 , 1.000000 ) ) SELECT x , x , x ( x ) , x ( x ) - x AS diff FROM x ; 
CREATE UNIQUE INDEX x ON x USING btree ( x bpchar_ops ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x CHAR ( 1 ) , x CHAR ( 1 ) , x CHAR ( 1 ) ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x TEXT , x CHAR ( 1 ) , x CHAR ( 1 ) ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x CHAR ( 1 ) , x INTEGER , x CHAR ( 1 ) ) ; 
CREATE INDEX x ON x USING btree ( x bpchar_ops ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x TEXT , x TEXT , x CHAR ( 1 ) ) ; 
CREATE TRIGGER x AFTER UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
$$$$$CREATE TRIGGER x AFTER INSERT OR UPDATE OR DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
COMMENT ON FUNCTION x ( bpchar , INTEGER , INTEGER ) IS 'x' ; 
COMMENT ON FUNCTION x ( bpchar , INTEGER , INTEGER ) IS NULL ; 
CREATE TRIGGER x BEFORE INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( 'x' ) ; 
CREATE TRIGGER x AFTER INSERT OR UPDATE OR DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 'x' ) ; 
CREATE VIEW x AS SELECT x . x , x . x , x ( x . x ) AS backside , x ( x . x ) AS patch FROM x PF ; 
~SELECT * FROM x WHERE x 'x' ORDER BY x ; 
~~~~~INSERT INTO x VALUES ( 'x' , 'x' , 1 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 1 , 'x' ) ; 
SELECT * FROM x ( 1 ) AS ( a INT , b INT , c INT ) ; 
SELECT * FROM x ( 1 ) AS ( a INT , b NUMERIC , c TEXT ) ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$CREATE TEMP TABLE x ( x TEXT , x serial ) ; 
$$$$$$INSERT INTO x ( x ) VALUES ( x ) ; 
$$$$$$$$$$$$$$$$FETCH NEXT IN test1 ; 
FETCH ALL FROM test2 ; 
FETCH NEXT FROM test1 ; 
$$CLOSE c1 ; 
$$SELECT x ( 1 , 1 ) AS Should be false" , x ( 1 , 1 ) AS Should be true" ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$CREATE TYPE eitype AS ( i INTEGER , y INTEGER ) ; 
$$__$$DROP TYPE eitype CASCADE ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SET plpgsql . print_strict_params TO TRUE ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$#$$RESET plpgsql . print_strict_params ; 
$$#$$SET plpgsql . extra_warnings TO 'x' ; 
SET plpgsql . extra_errors TO 'x' ; 
$$$$$$$$$$$$$$$$RESET plpgsql . extra_errors ; 
RESET plpgsql . extra_warnings ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$CLOSE c ; 
$$$$$$$$$$$$$$MOVE BACKWARD 1 FROM c ; 
$$$$$$$$MOVE FORWARD ALL IN c ; 
$$$$$$$$$$$CREATE TYPE record_type AS ( x TEXT , y INT , z BOOLEAN ) ; 
$$$$$$$$SELECT x ( 1 , 'x' ) ; 
DROP FUNCTION x ( INT , TEXT ) ; 
$$$$$$$$CREATE TEMP TABLE x AS SELECT x AS i , x AS j FROM x ( 1 , 1 ) n ; 
$$UPDATE x SET x = x * 1 , x = x . x * 1 WHERE CURRENT OF c ; 
$$$$$$$$$$$$$$CREATE TABLE x ( x INT , x INT , x INT , x INT ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 1 ) , ( 1 , 1 , 1 , 1 ) ; 
$$$$CREATE TYPE compostype AS ( x INT , y VARCHAR ) ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$DROP TYPE compostype ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$__$$$$__$$$$__$$$$$$$$____$$$$$$SELECT x ( 1 , 1 , 1 , 1 , 1 ) ; 
DROP FUNCTION x ( INT [ ] ) ; 
$$$$SELECT x ( 1.000000 , 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1 , 1 ) ; 
$$$$DROP FUNCTION x ( NUMERIC [ ] ) ; 
$$$$$$$$$$$$$$$$$$$$SELECT * FROM x ( FALSE ) ; 
SELECT * FROM x ( TRUE ) ; 
DROP FUNCTION x ( bool ) ; 
$$$$$$$$$$$$$$$$$$CREATE TABLE x . stuffs ( x TEXT ) ; 
SAVEPOINT a ; 
ROLLBACK TO a ; 
DROP FUNCTION x ( p_name_table TEXT ) ; 
$$CREATE CAST ( INTEGER AS date ) WITH FUNCTION x ( INTEGER ) AS ASSIGNMENT ; 
$$$$DROP FUNCTION x ( INTEGER ) ; 
DROP FUNCTION x ( INTEGER ) CASCADE ; 
$$$$$$$$SET standard_conforming_strings = off ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SET plpgsql . variable_conflict = error ; 
$$$$$$#$$$$#$$$$$$$$$$$$COMMENT ON FUNCTION x ( ) IS 'x' ; 
$$$$$$SELECT x ( ARRAY [ 1 , 1 , 1 , 1 ] ) ; 
SELECT x ( ARRAY [ [ 1 , 1 ] , [ 1 , 1 ] ] ) ; 
$$$$$$$$$$$$SELECT x ( ARRAY [ [ [ 1 , 1 ] ] , [ [ 1 , 1 ] ] ] ) ; 
CREATE TYPE xy_tuple AS ( x INT , y INT ) ; 
$$$$$$$$$$$$DROP FUNCTION x ( anyarray ) ; 
DROP TYPE xy_tuple ; 
CREATE TEMP TABLE x ( x INT , x TEXT [ ] ) ; 
$$$$$$DROP FUNCTION x ( x1 INT , x2 INT , x3 INT ) ; 
$$$$$$SELECT x ( x ( 1 ) ) ; 
SELECT x , x FROM ( SELECT x ( 1 ) AS a OFFSET 1 ) ss , LATERAL x ( x ) i ; 
SELECT x ( x ) , x FROM x ( 1 ) a ; 
SELECT x ( x ) , x FROM ( VALUES ( x ( 1 ) ) , ( x ( 1 ) ) ) v ( a ) ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SET plpgsql . check_asserts = off ; 
$$$$RESET plpgsql . check_asserts ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$CREATE TRIGGER x AFTER INSERT ON x REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER INSERT ON x REFERENCING NEW TABLE AS newtable FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = 'x' || x || 'x' WHERE x BETWEEN 1 AND 1 ; 
$$CREATE TRIGGER x AFTER DELETE ON x REFERENCING OLD TABLE AS p FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS d NEW TABLE AS i FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$CREATE TRIGGER x AFTER INSERT ON x REFERENCING NEW TABLE AS i FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE ON x REFERENCING NEW TABLE AS i FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
INSERT INTO x ( x ) SELECT x ( 1 , 1 ) ; 
INSERT INTO x ( x , x ) SELECT x , x / 1 + 1 AS parent_no FROM x ( 1 , 1 ) level2_no ; 
$$CREATE TRIGGER x AFTER DELETE ON x REFERENCING OLD TABLE AS dx FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
DELETE FROM x WHERE x BETWEEN 1 AND 1 ; 
DROP TRIGGER transition_table_level2_bad_usage_trigger ON transition_table_level2 ; 
$$CREATE TRIGGER x AFTER TRUNCATE OR UPDATE ON x REFERENCING OLD TABLE AS d NEW TABLE AS i FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING NEW TABLE AS new_test OLD TABLE AS old_test FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$SELECT * INTO x FROM x WHERE x = x ; 
$$SELECT * FROM x ( 1 ) AS t ; 
$$$$SELECT * FROM x ( ) AS t ; 
$$$$CREATE TABLE x ( x INT , x TEXT , x jsonb ) PARTITION BY HASH ( a part_test_int4_ops , b part_test_text_ops ) ; 
SELECT x ( 1 , 1 , 1 , NULL ) ; 
CREATE TABLE x ( x INT , x INT , x jsonb ) PARTITION BY HASH ( a part_test_int4_ops , b part_test_int4_ops ) ; 
CREATE TABLE x ( x TEXT ) PARTITION BY hash ( a ) ; 
CREATE TABLE x OF person_type ; 
CREATE TABLE IF NOT EXISTS x OF person_type ; 
$$DROP TYPE person_type RESTRICT ; 
DROP TYPE person_type CASCADE ; 
GRANT SELECT ON TABLE x TO GROUP x ; 
GRANT ALL ON TABLE x TO x , x ; 
REVOKE SELECT ON x FROM GROUP x ; 
\\SET SESSION AUTHORIZATION regress_dep_user0 ; 
DROP OWNED BY x , x ; 
CREATE TABLE x ( x INT UNIQUE ) ; 
GRANT ALL ON x TO x WITH GRANT OPTION ; 
SET SESSION AUTHORIZATION regress_dep_user1 ; 
GRANT ALL ON x TO x ; 
\\ALTER DEFAULT PRIVILEGES FOR ROLE x IN SCHEMA deptest GRANT ALL ON TABLES TO x ; 
$$CREATE TYPE deptest_enum AS ENUM ( 'x' ) ; 
CREATE TYPE deptest_range AS RANGE ( SUBTYPE = int4 ) ; 
ALTER TABLE x ALTER x SET DEFAULT x ( 'x' ) ; 
ALTER SEQUENCE x OWNED BY deptest2 . f1 ; 
CREATE TYPE deptest_t AS ( a INT ) ; 
GRANT SELECT ON x TO CURRENT_USER ; 
GRANT SELECT ( x ) ON x TO CURRENT_USER ; 
GRANT SELECT ( x , x ) ON x TO CURRENT_USER ; 
CREATE TABLE x ( x TEXT ) INHERITS ( x , x , x ) ; 
SELECT x , x . * FROM x , x WHERE x . x = x . x ; 
SELECT x , x . * FROM ONLY x , x WHERE x . x = x . x ; 
UPDATE ONLY x SET x = 'x' WHERE x = 'x' ; 
UPDATE x SET x = 'x' WHERE x LIKE 'x' ; 
DELETE FROM ONLY x WHERE x = 'x' ; 
CREATE TEMP TABLE x ( x TEXT , PRIMARY KEY ( x , x ) ) INHERITS ( x ) ; 
UPDATE x SET x = x + 1 WHERE FALSE ; 
UPDATE x SET x = x + 1 WHERE FALSE RETURNING x , x ; 
UPDATE x SET x = x + 1 WHERE x IN ( SELECT x FROM x ) ; 
CREATE TABLE x ( x INT , x CHAR ) PARTITION BY list ( a ) ; 
UPDATE x SET x = 'x' FROM ( SELECT x FROM x UNION ALL SELECT x + 1 FROM x ) ss ( a ) WHERE x . x = x . x ; 
UPDATE x SET x = 'x' FROM ( SELECT 1 FROM x UNION ALL SELECT 1 FROM x ) ss ( a ) WHERE x . x = x . x ; 
EXPLAIN UPDATE x SET x = 1 WHERE FALSE ; 
CREATE TABLE x ( x INT , x CHAR , x TEXT ) PARTITION BY list ( a ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ; 
UPDATE x x SET x = 'x' FROM ( SELECT x FROM x UNION ALL SELECT x + 1 FROM x ) ss ( a ) WHERE ( x . x = x . x AND x . x = 'x' ) OR x . x = 1 ; 
ALTER TABLE x ALTER COLUMN x TYPE INTEGER USING x ( x ) ; 
CREATE TEMP TABLE x ( x INT , x BIGINT ) ; 
CREATE TEMP TABLE x ( x INT ) INHERITS ( x , x ) ; 
ALTER TABLE x ADD CONSTRAINT p1chk CHECK ( x > 1 ) NO INHERIT ; 
ALTER TABLE x ADD CONSTRAINT p2chk CHECK ( x > 1 ) ; 
SELECT x . x , x . x , x . x , x . x , x . x , x . x FROM x AS pc INNER JOIN x AS pgc ON ( x . x = x . x ) WHERE x . x = 'x' ORDER BY 1 , 1 ; 
CREATE TABLE x ( LIKE x , x INT ) INHERITS ( x ) ; 
SELECT x ( x . * ) FROM x ; 
DROP FUNCTION x ( p2 ) ; 
ALTER TABLE x ADD CONSTRAINT ac_check CHECK ( x IS NOT NULL ) ; 
SELECT x . x , x . x , x . x , x . x , x . x , x ( x . x , x . x ) AS consrc FROM x AS pc INNER JOIN x AS pgc ON ( x . x = x . x ) WHERE x . x IN ( 'x' , 'x' ) ORDER BY 1 , 1 ; 
ALTER TABLE x ADD CHECK ( x IS NOT NULL ) ; 
ALTER TABLE x DROP CONSTRAINT ac_check ; 
SELECT x . x , x . x , x . x , x . x , x . x , x ( x . x , x . x ) AS consrc FROM x AS pc INNER JOIN x AS pgc ON ( x . x = x . x ) WHERE x . x IN ( 'x' , 'x' , 'x' ) ORDER BY 1 , 1 ; 
CREATE TABLE x ( x FLOAT ) INHERITS ( x , x ) ; 
CREATE TABLE x ( x INT , x VARCHAR , x INT , UNIQUE ( x , x ) ) ; 
ALTER TABLE ONLY x DROP CONSTRAINT test_constraints_val1_val2_key ; 
CREATE TABLE x ( x circle , EXCLUDE USING gist ( x WITH && ) ) ; 
ALTER TABLE x DROP CONSTRAINT test_ex_constraints_c_excl ; 
CREATE TABLE x ( x INT REFERENCES x ( x ) ) ; 
ALTER TABLE x DROP CONSTRAINT test_foreign_constraints_id1_fkey ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT REFERENCES x ON DELETE CASCADE ) ; 
SELECT * FROM x ORDER BY 1 , 1 ; 
ALTER TABLE x ADD CONSTRAINT inh_check_constraint1 CHECK ( x > 1 ) ; 
ALTER TABLE x ADD CONSTRAINT inh_check_constraint2 CHECK ( x < 1 ) ; 
ALTER TABLE x ADD CONSTRAINT inh_check_constraint CHECK ( x > 1 ) NOT VALID ; 
ALTER TABLE x ADD CONSTRAINT inh_check_constraint CHECK ( x > 1 ) ; 
CREATE TEMP TABLE x ( x , x ) AS SELECT x , x FROM x ( 1 , 1 ) x ; 
INSERT INTO x SELECT x , x FROM x ( 1 , 1 ) x ; 
EXPLAIN ( costs off ) SELECT * FROM x JOIN ( SELECT x FROM x LIMIT 1 ) ss ON x = x ; 
SELECT * FROM x JOIN ( SELECT x FROM x LIMIT 1 ) ss ON x = x ; 
CREATE TABLE x ( x INTEGER PRIMARY KEY ) INHERITS ( x ) ; 
CREATE INDEX x ON x ( ( 1 - x ) ) ; 
SELECT * FROM x ORDER BY 1 - x ; 
SELECT x ( 1 - x ) FROM x ; 
RESET enable_parallel_append ; 
SET enable_bitmapscan = off ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM ( SELECT x AS x FROM x a UNION ALL SELECT x AS x FROM x b ) s ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x a UNION ALL SELECT x AS x , x AS y FROM x b ) s ; 
EXPLAIN ( costs off ) SELECT ARRAY ( SELECT x . x FROM ( ( SELECT x + x . x FROM x ( 1 , 1 , 1 ) d ORDER BY 1 ) UNION ALL ( SELECT x + x . x FROM x ( 1 , 1 , 1 ) d ORDER BY 1 ) ) f ( i ) ORDER BY x . x LIMIT 1 ) FROM x ( 1 , 1 ) g ( i ) ; 
SELECT ARRAY ( SELECT x . x FROM ( ( SELECT x + x . x FROM x ( 1 , 1 , 1 ) d ORDER BY 1 ) UNION ALL ( SELECT x + x . x FROM x ( 1 , 1 , 1 ) d ORDER BY 1 ) ) f ( i ) ORDER BY x . x LIMIT 1 ) FROM x ( 1 , 1 ) g ( i ) ; 
CREATE TABLE x ( CHECK ( x = 1 OR x = NULL ) ) INHERITS ( x ) ; 
CREATE TABLE x ( x VARCHAR ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( NULL , 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NOT NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IN ( 'x' , 'x' , 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 'x' OR x IN ( NULL , 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x BETWEEN 1 AND 1 AND x IN ( 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NOT NULL AND x < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x >= 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) , x ( x ) FROM x WHERE x = 'x' ; 
SELECT x ( x ) , x ( x ) FROM x WHERE x = 'x' ; 
CREATE INDEX x ON x ( x , x ( x ) , x ) ; 
EXPLAIN ( costs off ) SELECT * FROM x ORDER BY x , x ( x ) , x ; 
EXPLAIN ( costs off ) SELECT * FROM x ORDER BY x DESC , x ( x ) DESC , x DESC ; 
EXPLAIN ( costs off ) SELECT x , x ( x ) FROM x ORDER BY x , x ( x ) , x ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x < 1 ORDER BY x , x ( x ) , x ; 
EXPLAIN ( costs off ) SELECT * FROM x ORDER BY x ; 
CREATE INDEX ON x ( x , x ( x ) , x ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x < 1 ORDER BY x , x ( x ) , x LIMIT 1 ; 
SET enable_bitmapscan = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 ORDER BY x , x ( x ) , x ; 
CREATE TABLE x ( x bool ) PARTITION BY list ( b ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( TRUE ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( FALSE ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( FALSE , 1 ) TO ( FALSE , 1 ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( TRUE , 1 ) TO ( TRUE , 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = TRUE ORDER BY x , x ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = FALSE ORDER BY x , x ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = TRUE ORDER BY x ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = FALSE ORDER BY x ; 
CREATE INDEX ON x ( x , x , x ) ; 
EXPLAIN ( costs off ) SELECT * FROM x ORDER BY x , x , x ; 
EXPLAIN ( costs off ) SELECT * FROM x ORDER BY x DESC , x DESC , x DESC ; 
CREATE TABLE x ( x INT , x TEXT , x TEXT ) PARTITION BY list ( a ) ; 
CREATE TABLE x ( x TEXT , x TEXT , x INT ) PARTITION BY list ( b ) ; 
SET SESSION AUTHORIZATION regress_no_child_access ; 
~EXPLAIN ( costs off ) SELECT * FROM x p1 INNER JOIN x p2 ON x . x = x . x AND p1 . c 'x' ; 
~EXPLAIN ( costs off ) SELECT x . x , x . x FROM x p1 INNER JOIN x p2 ON x . x = x . x AND p1 . c 'x' ; 
SET standard_conforming_strings TO ON ; 
SELECT x & 'x' ; 
SET standard_conforming_strings TO off ; 
RESET standard_conforming_strings ; 
SET bytea_output TO hex ; 
SELECT CAST ( x AS TEXT ) AS text(char)" FROM x ; 
SELECT CAST ( x AS TEXT ) AS text(varchar)" FROM x ; 
SELECT CAST ( x AS CHAR ( 1 ) ) AS char(text)" FROM x ; 
SELECT CAST ( x AS CHAR ( 1 ) ) AS char(varchar)" FROM x ; 
SELECT CAST ( x AS VARCHAR ) AS varchar(text)" FROM x ; 
SELECT CAST ( x AS VARCHAR ) AS varchar(char)" FROM x ; 
SELECT TRIM ( BOTH FROM 'x' ) = 'x' AS bunch o blanks" ; 
SELECT TRIM ( LEADING FROM 'x' ) = 'x' AS bunch o blanks " ; 
SELECT TRIM ( TRAILING FROM 'x' ) = 'x' AS bunch o blanks" ; 
SELECT TRIM ( BOTH 'x' FROM 'x' ) = 'x' AS some Xs" ; 
SELECT SUBSTRING ( 'x' FROM 1 ) = 'x' AS 34567890" ; 
SELECT SUBSTRING ( 'x' FROM 1 FOR 1 ) = 'x' AS 456" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR 'x' ) AS bcd" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR 'x' ) IS NULL AS True" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR NULL ) IS NULL AS True" ; 
SELECT SUBSTRING ( NULL FROM 'x' FOR 'x' ) IS NULL AS True" ; 
SELECT SUBSTRING ( 'x' FROM NULL FOR 'x' ) IS NULL AS True" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR 'x' ) AS bcdef" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR 'x' ) AS abcdefg" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR 'x' ) AS error" ; 
SELECT SUBSTRING ( 'x' FROM 'x' FOR 'x' ) AS bcdefg" ; 
SELECT SUBSTRING ( 'x' FROM 'x' ) AS cde" ; 
SELECT 'x' SIMILAR TO 'x' ESCAPE 'x' AS error ; 
SELECT x ( 'x' , x 'x' , 'x' , 'x' ) ; 
SELECT x ( 'x' , 'x' , 'x' , 'x' ) ; 
\$$$$$$$$$$$$SELECT x ( 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' , 'x' , 'x' ) ; 
SELECT x ( 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) , 'x' , 'x' ) ; 
SELECT x ( x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) , 'x' , 'x' ) ; 
SELECT x ( x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' || x ( 1 ) || 'x' , 'x' , 'x' ) ; 
$$$$$$$$$\$$\$$\$$\SELECT x , x ( x ) FROM x ( 'x' , 'x' ) AS foo ; 
SELECT x , x ( x ) FROM x ( 'x' , 'x' , 'x' ) AS foo ; 
\SELECT POSITION ( 'x' IN 'x' ) = 'x' AS 5" ; 
SELECT OVERLAY ( 'x' PLACING 'x' FROM 1 ) AS abc45f" ; 
SELECT OVERLAY ( 'x' PLACING 'x' FROM 1 ) AS yabadaba" ; 
SELECT OVERLAY ( 'x' PLACING 'x' FROM 1 FOR 1 ) AS yabadabadoo" ; 
SELECT OVERLAY ( 'x' PLACING 'x' FROM 1 FOR 1 ) AS bubba" ; 
SELECT 'x' LIKE 'x' AS true" ; 
SELECT 'x' NOT LIKE 'x' AS false" ; 
SELECT 'x' LIKE 'x' AS false" ; 
SELECT 'x' NOT LIKE 'x' AS true" ; 
SELECT 'x' LIKE 'x' ESCAPE 'x' AS true" ; 
SELECT 'x' NOT LIKE 'x' ESCAPE 'x' AS false" ; 
SELECT 'x' LIKE 'x' ESCAPE 'x' AS false" ; 
SELECT 'x' NOT LIKE 'x' ESCAPE 'x' AS true" ; 
SELECT 'x' ILIKE 'x' AS true" ; 
SELECT 'x' NOT ILIKE 'x' AS false" ; 
SELECT 'x' LIKE 'x' AS t , 'x' LIKE 'x' AS t , 'x' LIKE 'x' AS f ; 
SELECT 'x' LIKE 'x' AS t ; 
CREATE TABLE x ( x TEXT PRIMARY KEY , x INT ) ; 
CREATE TABLE x ( x bytea PRIMARY KEY , x INT ) ; 
SELECT 'x' || 'x' AS Concat unknown types" ; 
SELECT TEXT 'x' || 'x' AS Concat text to unknown type" ; 
SELECT CHAR ( 1 ) 'x' || 'x' AS Concat char to unknown type" ; 
SELECT TEXT 'x' || CHAR ( 1 ) 'x' AS Concat text to char" ; 
SELECT TEXT 'x' || VARCHAR 'x' AS Concat text to varchar" ; 
TRUNCATE TABLE x ; 
SELECT x ( x ) = 1 AS is_empty FROM x WHERE x = 'x' ; 
ALTER TABLE x SET ( toast_tuple_target = 1 ) ; 
CREATE TABLE x ( x bytea ) ; 
INSERT INTO x VALUES ( x ( x ( 'x' , 1 ) , 'x' ) ) ; 
CREATE TABLE x ( x CHAR ( 1 ) ) ; 
SELECT x ( 'x' ) AS length_6" ; 
SELECT x ( 'x' , 'x' ) AS pos_3" ; 
SELECT x ( 'x' , 'x' ) AS pos_0" ; 
SELECT x ( 'x' , 'x' ) AS pos_1" ; 
SELECT x ( 'x' , 'x' , 1 ) AS an error" ; 
SELECT x ( 'x' , 'x' , 1 ) AS joeuser" ; 
SELECT x ( 'x' , 'x' , 1 ) AS mydatabase" ; 
SELECT x ( 'x' , 'x' , 1 ) AS empty string" ; 
SELECT x ( 1 * 1 * 1 - 1 ) AS ffffff" ; 
SELECT x ( 'x' ) = 'x' AS TRUE" ; 
SET escape_string_warning = off ; 
SHOW escape_string_warning ; 
SHOW standard_conforming_strings ; 
SET escape_string_warning = ON ; 
SELECT 'x' AS f1 , 'x' AS f2 , 'x' AS f3 , 'x' AS f4 , 'x' AS f5 , 'x' AS f6 ; 
SELECT CASE x ( ) WHEN FALSE THEN 'x' || 'x' || 'x' ELSE 'x' END ; 
SELECT 1 AS one WHERE 1 IN ( SELECT 1 ) ; 
SELECT 1 AS zero WHERE 1 NOT IN ( SELECT 1 ) ; 
SELECT 1 AS zero WHERE 1 IN ( SELECT 1 ) ; 
SELECT * FROM ( SELECT 1 AS x ) ss ; 
SELECT * FROM ( ( SELECT 1 AS x ) ) ss ; 
( SELECT 1 ) UNION SELECT 1 ; 
( ( SELECT 1 ) ) UNION SELECT 1 ; 
SELECT ( ( SELECT 1 ) UNION SELECT 1 ) ; 
SELECT ( ( ( SELECT 1 ) ) UNION SELECT 1 ) ; 
SELECT ( SELECT ARRAY [ 1 , 1 , 1 ] ) [ 1 ] ; 
SELECT ( ( SELECT ARRAY [ 1 , 1 , 1 ] ) ) [ 1 ] ; 
SELECT ( ( ( SELECT ARRAY [ 1 , 1 , 1 ] ) ) ) [ 1 ] ; 
CREATE TABLE x ( x INTEGER , x INTEGER , x FLOAT ) ; 
INSERT INTO x VALUES ( 1 , 1 , NULL ) ; 
SELECT 'x' AS eight , * FROM x ; 
SELECT 'x' AS two , x AS Constant Select" FROM x WHERE x IN ( SELECT 1 ) ; 
SELECT 'x' AS six , x AS Uncorrelated Field" FROM x WHERE x IN ( SELECT x FROM x ) ; 
SELECT 'x' AS six , x AS Uncorrelated Field" FROM x WHERE x IN ( SELECT x FROM x WHERE x IN ( SELECT x FROM x ) ) ; 
SELECT 'x' AS three , x , x FROM x WHERE ( x , x ) NOT IN ( SELECT x , CAST ( x AS int4 ) FROM x WHERE x IS NOT NULL ) ; 
SELECT 'x' AS six , x AS Correlated Field" , x AS Second Field" FROM x upper WHERE x IN ( SELECT x FROM x WHERE x = x . x ) ; 
SELECT 'x' AS six , x AS Correlated Field" , x AS Second Field" FROM x upper WHERE x IN ( SELECT x FROM x WHERE CAST ( x . x AS FLOAT ) = x ) ; 
SELECT 'x' AS six , x AS Correlated Field" , x AS Second Field" FROM x upper WHERE x IN ( SELECT x . x + x FROM x WHERE x = CAST ( x AS INTEGER ) ) ; 
SELECT 'x' AS five , x AS Correlated Field" FROM x WHERE ( x , x ) IN ( SELECT x , CAST ( x AS int4 ) FROM x WHERE x IS NOT NULL ) ; 
SELECT 'x' AS eight , x . x AS Correlated Field" , x . x AS Second Field" FROM x ss WHERE x NOT IN ( SELECT x + 1 FROM x WHERE x != x . x AND x < 1 ) ; 
SELECT x , x ( x ( * ) ) / ( SELECT x ( * ) FROM x ) FROM x GROUP BY x ORDER BY x ; 
SELECT * , x ( x ) FROM ( SELECT 'x' AS f1 FROM x ( 1 , 1 ) ) ss ORDER BY 1 ; 
SELECT 1 = ALL ( SELECT ( SELECT 1 ) ) ; 
EXPLAIN ( costs off ) SELECT * FROM x o WHERE EXISTS ( SELECT 1 FROM x i WHERE x . x = x . x LIMIT NULL ) ; 
EXPLAIN ( costs off ) SELECT * FROM x o WHERE NOT EXISTS ( SELECT 1 FROM x i WHERE x . x = x . x LIMIT 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x o WHERE EXISTS ( SELECT 1 FROM x i WHERE x . x = x . x LIMIT 1 ) ; 
SELECT x ( * ) FROM ( SELECT 1 FROM x a WHERE x IN ( SELECT x FROM x b ) ) ss ; 
SELECT x ( DISTINCT x . x ) FROM ( SELECT x FROM x a WHERE x IN ( SELECT x FROM x b ) ) ss ; 
SELECT x ( * ) FROM ( SELECT 1 FROM x a WHERE x IN ( SELECT DISTINCT x FROM x b ) ) ss ; 
SELECT x ( DISTINCT x . x ) FROM ( SELECT x FROM x a WHERE x IN ( SELECT DISTINCT x FROM x b ) ) ss ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM ( SELECT DISTINCT x , x FROM x ) AS s ) ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM ( SELECT x , x FROM x GROUP BY x , x ) AS s ) ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM ( SELECT x , x FROM x UNION SELECT x , x FROM x ) AS s ) ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM ( SELECT DISTINCT ON ( x ) x , x FROM x ) AS s ) ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM ( SELECT x FROM x GROUP BY x ) AS s ) ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM ( SELECT x FROM x UNION SELECT x FROM x ) AS s ) ; 
CREATE TABLE x ( x INTEGER , x INTEGER , x BOOLEAN ) ; 
CREATE TEMP VIEW x AS SELECT * FROM x WHERE x = 'x' ; 
SELECT x , x AS relabel FROM ( SELECT * , ( SELECT x ( x ) FROM x b WHERE x >= x . x ) AS ss1 FROM x a ) ss ; 
SELECT * FROM ( SELECT x ( x ) FROM x AS a WHERE EXISTS ( SELECT 1 FROM x AS b WHERE x . x = x . x ) ) ss ; 
SELECT * FROM ( SELECT x ( x ) FROM x AS a WHERE NOT EXISTS ( SELECT 1 FROM x AS b WHERE x . x = 1 ) ) ss ; 
INSERT INTO x VALUES ( 1 ) , ( 1.000000 ) , ( 1 ) , ( 1 ) ; 
CREATE TEMP TABLE x ( x float8 ) ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM x ) ; 
CREATE TEMP TABLE x ( x NUMERIC ( 1 , 1 ) , x VARCHAR ( 1 ) ) ; 
SELECT ( SELECT x ) FROM x ; 
SELECT ( SELECT ( SELECT x ) ) FROM x ; 
SELECT x FROM ( SELECT x ( x ) FROM x GROUP BY x ORDER BY x ) q ; 
WITH q AS ( SELECT x ( x ) FROM x GROUP BY x ORDER BY x ) SELECT x FROM x ; 
CREATE TEMP TABLE x ( x int8 , x int8 ) ; 
SELECT * FROM x WHERE ( x , x ) NOT IN ( SELECT * FROM x ) ; 
CREATE TEMP TABLE x ( x INT NOT NULL ) ; 
INSERT INTO x VALUES ( NULL ) , ( 1 ) ; 
SELECT * FROM x WHERE x NOT IN ( SELECT x FROM x ) ; 
SELECT EXISTS ( SELECT * FROM x ) ; 
SELECT x . x FROM x ( 1 , 1 ) AS s ( i ) , LATERAL ( VALUES ( ( SELECT x . x + 1 ) ) , ( x . x + 1 ) ) AS val ( x ) WHERE x . x < 1 AND ( SELECT x . x ) < 1 ; 
SELECT * FROM x WHERE ( CASE WHEN x IN ( SELECT x FROM x a ) THEN x ELSE NULL END ) IN ( SELECT x FROM x b ) ; 
SELECT * FROM x o WHERE ( x , x ) IN ( SELECT x , x ( 1 , 1 ) / 1 g FROM x i GROUP BY x ) ; 
SELECT ( SELECT x FROM ( SELECT 1 , 1 , 1 WHERE x > 1 UNION ALL SELECT 1 , 1 , 1.000000 WHERE x <= 1 ) q ) FROM x ; 
SELECT * FROM ( SELECT DISTINCT x FROM x ) ss WHERE x < 1 + x ( 'x' ) ORDER BY 1 ; 
$$$$SELECT * FROM ( SELECT 1 AS x , x ( ARRAY [ 1 , 1 , 1 , 1 , 1 , 1 ] ) AS u ) ss WHERE x ( x , 1 ) ; 
ALTER FUNCTION x ( x INT , y INT ) STABLE ; 
SELECT * FROM ( SELECT 1 AS x , x ( ARRAY [ 1 , 1 , 1 , 1 , 1 , 1 ] ) AS u ) ss WHERE x ( x , x ) ; 
DROP FUNCTION x ( x INT , y INT ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT , x INT ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) ; 
$$$$SELECT * FROM ( SELECT x , x FROM x ORDER BY x , x ) AS x LIMIT 1 ; 
MOVE FORWARD ALL IN c1 ; 
WITH RECURSIVE x ( a ) AS ( ( VALUES ( 'x' ) , ( 'x' ) ) UNION ALL ( WITH z AS NOT MATERIALIZED ( SELECT * FROM x ) SELECT x . x || x . x AS a FROM x CROSS JOIN x AS z1 WHERE x ( x . x || x . x ) < 1 ) ) SELECT * FROM x ; 
WITH RECURSIVE x ( a ) AS ( ( VALUES ( 'x' ) , ( 'x' ) ) UNION ALL ( WITH z AS NOT MATERIALIZED ( SELECT * FROM x ) SELECT x . x || x . x AS a FROM x WHERE x ( x . x || x . x ) < 1 ) ) SELECT * FROM x ; 
CREATE USER x WITH NOCREATEDB NOCREATEROLE ; 
SET SESSION AUTHORIZATION regress_conversion_user ; 
CREATE CONVERSION myconv FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
CREATE DEFAULT CONVERSION public . mydef FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
CREATE DEFAULT CONVERSION public . mydef2 FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
COMMENT ON CONVERSION myconv_bad IS 'x' ; 
COMMENT ON CONVERSION myconv IS 'x' ; 
COMMENT ON CONVERSION myconv IS NULL ; 
CREATE TABLE x ( x oid ) ; 
SELECT 'x' AS one , x . * FROM x o WHERE x . x = 1 ; 
SELECT 'x' AS three , x . * FROM x o WHERE x . x <= 'x' ; 
SELECT 'x' AS two , x . * FROM x o WHERE x . x < 'x' ; 
SELECT 'x' AS four , x . * FROM x o WHERE x . x >= 'x' ; 
SELECT 'x' AS three , x . * FROM x o WHERE x . x > 'x' ; 
CREATE UNLOGGED SEQUENCE x ; 
CREATE SEQUENCE x INCREMENT BY 1 ; 
CREATE SEQUENCE x INCREMENT BY 1 MINVALUE 1 ; 
CREATE SEQUENCE x INCREMENT BY 1 MAXVALUE 1 ; 
CREATE SEQUENCE x INCREMENT BY 1 START 1 ; 
CREATE SEQUENCE x CACHE 1 ; 
CREATE SEQUENCE x AS INTEGER ; 
CREATE SEQUENCE x AS SMALLINT ; 
CREATE SEQUENCE x AS BIGINT ; 
CREATE SEQUENCE x AS INTEGER MAXVALUE 1 ; 
CREATE SEQUENCE x AS INTEGER INCREMENT BY 1 ; 
CREATE SEQUENCE x AS INTEGER MINVALUE 1 START 1 ; 
CREATE SEQUENCE x AS SMALLINT INCREMENT 1 ; 
CREATE SEQUENCE x AS SMALLINT MINVALUE 1 ; 
CREATE SEQUENCE x AS SMALLINT MAXVALUE 1 INCREMENT 1 ; 
CREATE SEQUENCE x AS TEXT ; 
CREATE SEQUENCE x AS nosuchtype ; 
CREATE SEQUENCE x AS SMALLINT MAXVALUE 1 ; 
CREATE TABLE x ( x TEXT , x serial , x smallserial , x serial2 , x bigserial , x serial8 ) ; 
INSERT INTO x ( x , x , x , x , x , x ) VALUES ( 'x' , 1 , 1 , 1 , 1 , 1 ) , ( 'x' , 1 , 1 , 1 , 1 , 1 ) ; 
SELECT * FROM x ORDER BY x ASC ; 
CREATE SEQUENCE IF NOT EXISTS x ; 
DISCARD SEQUENCES ; 
SELECT x , x IN ( 1 , 1 ) AS log_cnt_ok , x FROM x ; 
ALTER SEQUENCE IF EXISTS x RESTART WITH 1 INCREMENT BY 1 MAXVALUE 1 MINVALUE 1 CYCLE ; 
ALTER SEQUENCE x RESTART ; 
COMMENT ON SEQUENCE asdf IS 'x' ; 
COMMENT ON SEQUENCE sequence_test2 IS 'x' ; 
COMMENT ON SEQUENCE sequence_test2 IS NULL ; 
START TRANSACTION READ ONLY ; 
SET LOCAL SESSION AUTHORIZATION regress_seq_user ; 
GRANT USAGE ON x TO x ; 
SAVEPOINT save ; 
ROLLBACK TO save ; 
ALTER SEQUENCE x START WITH 1 ; 
SELECT * INTO TABLE x FROM x WHERE x . x < 1 ; 
GRANT ALL ON SCHEMA selinto_schema TO x ; 
SET SESSION AUTHORIZATION regress_selinto_user ; 
DROP SCHEMA selinto_schema CASCADE ; 
$$$$$$$$DECLARE foo CURSOR FOR SELECT 1 INTO x ; 
COPY ( SELECT 1 INTO x UNION SELECT 1 ) TO 'x' ; 
SELECT * FROM ( SELECT 1 INTO x ) bar ; 
CREATE VIEW x AS SELECT 1 INTO x ; 
INSERT INTO x SELECT 1 INTO x ; 
CREATE TABLE x ( x pg_lsn ) ; 
SELECT 'x' > x 'x' ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT ) ; 
CREATE INDEX x ON x ( x DESC , x ASC , x NULLS FIRST , x NULLS LAST ) ; 
CREATE INDEX x ON x ( x ) INCLUDE ( x , x ) ; 
CREATE TABLE x ( x INT ) WITH ( fillfactor = 1 ) ; 
CREATE TABLE x ( x INT ) WITH ( autovacuum_analyze_scale_factor = 1.000000 ) ; 
CREATE TABLE x ( x INT ) WITH ( not_existing_option = 1 ) ; 
CREATE TABLE x ( x INT ) WITH ( not_existing_namespace . fillfactor = 1 ) ; 
CREATE TABLE x ( x INT ) WITH ( fillfactor = 1.000000 ) ; 
CREATE TABLE x ( x INT ) WITH ( fillfactor = 'x' ) ; 
CREATE TABLE x ( x INT ) WITH ( autovacuum_enabled = 1 ) ; 
CREATE TABLE x ( x INT ) WITH ( autovacuum_enabled = 1.000000 ) ; 
CREATE TABLE x ( x INT ) WITH ( autovacuum_enabled = 'x' ) ; 
CREATE TABLE x ( x INT ) WITH ( autovacuum_analyze_scale_factor = 'x' ) ; 
CREATE TABLE x ( x INT ) WITH ( fillfactor = 1 , fillfactor = 1 ) ; 
CREATE TABLE x ( x INT ) WITH ( fillfactor ) ; 
ALTER TABLE x SET ( fillfactor = 1 , autovacuum_analyze_scale_factor = 1.000000 ) ; 
ALTER TABLE x SET ( autovacuum_enabled , fillfactor = 1 ) ; 
ALTER TABLE x RESET ( fillfactor ) ; 
ALTER TABLE x RESET ( autovacuum_enabled , autovacuum_analyze_scale_factor ) ; 
ALTER TABLE x RESET ( fillfactor = 1 ) ; 
INSERT INTO x VALUES ( 1 , NULL ) , ( NULL , NULL ) ; 
SELECT x ( 'x' ) > 1 ; 
ALTER TABLE x RESET ( vacuum_truncate ) ; 
SELECT x ( 'x' ) = 1 ; 
CREATE TABLE x ( x VARCHAR ) WITH ( toast . autovacuum_vacuum_cost_delay = 1 ) ; 
ALTER TABLE x SET ( toast . autovacuum_vacuum_cost_delay = 1 ) ; 
ALTER TABLE x RESET ( toast . autovacuum_vacuum_cost_delay ) ; 
CREATE TABLE x ( x INT ) WITH ( toast . not_existing_option = 1 ) ; 
CREATE TABLE x ( x VARCHAR ) WITH ( toast . autovacuum_vacuum_cost_delay = 1 , autovacuum_vacuum_cost_delay = 1 , fillfactor = 1 ) ; 
CREATE INDEX x ON x ( x ) WITH ( fillfactor = 1 ) ; 
CREATE INDEX x ON x ( x ) WITH ( not_existing_option = 1 ) ; 
CREATE INDEX x ON x ( x ) WITH ( not_existing_ns . fillfactor = 1 ) ; 
INSERT INTO x SELECT 1 LIMIT 1 ; 
SELECT x , x , * FROM x ; 
ROLLBACK TO s1 ; 
DECLARE c CURSOR FOR SELECT x , x , * FROM x ; 
SELECT x , x , * FROM x FOR UPDATE ; 
CREATE TABLE IF NOT EXISTS x ( x INT PRIMARY KEY , x NUMERIC ) ; 
SELECT * FROM x WHERE x . x = 1 FOR UPDATE ; 
SAVEPOINT subxact ; 
ROLLBACK TO SAVEPOINT subxact ; 
SELECT * FROM x WHERE x = 1 FOR UPDATE ; 
SET enable_indexscan TO ON ; 
SET enable_indexonlyscan TO off ; 
$$$$CREATE TABLE x ( x serial ) ; 
CREATE TABLE x ( x serial , x TEXT ) ; 
UPDATE x SET x = x + 1 WHERE x IN ( 1 , 1 ) ; 
SAVEPOINT p1 ; 
RELEASE SAVEPOINT p1 ; 
ROLLBACK TO SAVEPOINT p1 ; 
SELECT x ( * ) FROM x WHERE x = 1 ; 
\SELECT x , x , x , x , x , x FROM x WHERE x LIKE 'x' ORDER BY x ; 
SELECT x . x >= x . x + 1 , x . x >= x . x + x . x , x . x >= x . x + 1 , x . x >= x . x + 1 FROM x AS st , x AS cl , x AS pr WHERE x . x = 'x' AND x . x = 'x' ; 
SELECT x . x + x . x >= x . x + x . x , x . x + x . x >= x . x + 1 FROM x AS st , x AS cl , x AS pr WHERE x . x = 'x' AND x . x = 'x' ; 
SET DATESTYLE = 'x' ; 
SET IntervalStyle TO postgres ; 
SELECT INTERVAL 'x' AS One hour" ; 
SELECT INTERVAL 'x' AS Two hours" ; 
SELECT INTERVAL 'x' AS Eight hours" ; 
SELECT INTERVAL 'x' AS 22 hours ago..." ; 
SELECT INTERVAL 'x' AS Ten days twelve hours" ; 
SELECT INTERVAL 'x' AS One month 15 days" ; 
SELECT INTERVAL 'x' AS 9 years..." ; 
CREATE TABLE x ( x INTERVAL ) ; 
SELECT 'x' AS ten , * FROM x ; 
SELECT 'x' AS three , * FROM x WHERE x . x <= INTERVAL 'x' ; 
SELECT 'x' AS three , * FROM x WHERE x . x < INTERVAL 'x' ; 
SELECT 'x' AS one , * FROM x WHERE x . x = INTERVAL 'x' ; 
SELECT 'x' AS five , * FROM x WHERE x . x >= INTERVAL 'x' ; 
SELECT 'x' AS nine , * FROM x WHERE x . x > INTERVAL 'x' ; 
SELECT 'x' AS fortyfive , x . * , x . * FROM x r1 , x r2 WHERE x . x > x . x ORDER BY x . x , x . x ; 
CREATE TEMP TABLE x ( x INTERVAL ) ; 
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) ; 
SELECT x . * , x . * FROM x r1 , x r2 WHERE x . x > x . x ORDER BY x . x , x . x ; 
CREATE INDEX ON x USING btree ( x ) ; 
EXPLAIN ( COSTS OFF ) SELECT x FROM x r1 ORDER BY x ; 
SELECT x FROM x r1 ORDER BY x ; 
SET IntervalStyle TO postgres_verbose ; 
SELECT x ( INTERVAL 'x' ) AS 6 mons 5 days 4 hours 3 mins 2 seconds" ; 
SELECT x ( INTERVAL 'x' ) AS 7 mons 6 days 5 hours 4 mins 3 seconds" ; 
SELECT x ( INTERVAL 'x' ) AS 1 month -1 hour" ; 
SELECT INTERVAL 'x' HOUR ; 
SELECT INTERVAL 'x' DAY ; 
SELECT INTERVAL 'x' MONTH ; 
SELECT INTERVAL 'x' YEAR ; 
SELECT INTERVAL 'x' MINUTE ; 
SELECT INTERVAL 'x' SECOND ; 
SELECT INTERVAL 'x' YEAR TO MONTH ; 
SELECT INTERVAL 'x' DAY TO HOUR ; 
SELECT INTERVAL 'x' DAY TO MINUTE ; 
SELECT INTERVAL 'x' DAY TO SECOND ; 
SELECT INTERVAL 'x' HOUR TO MINUTE ; 
SELECT INTERVAL 'x' HOUR TO SECOND ; 
SELECT INTERVAL 'x' MINUTE TO SECOND ; 
SELECT INTERVAL ( 1 ) 'x' ; 
SELECT INTERVAL 'x' SECOND ( 1 ) ; 
SELECT INTERVAL 'x' DAY TO SECOND ( 1 ) ; 
SELECT INTERVAL 'x' HOUR TO SECOND ( 1 ) ; 
SELECT INTERVAL 'x' MINUTE TO SECOND ( 1 ) ; 
SET IntervalStyle TO sql_standard ; 
SELECT INTERVAL 'x' AS zero" , INTERVAL 'x' YEAR TO MONTH AS year-month" , INTERVAL 'x' DAY TO SECOND AS day-time" , - INTERVAL 'x' AS negative year-month" , - INTERVAL 'x' AS negative day-time" ; 
SELECT INTERVAL 'x' , INTERVAL 'x' , INTERVAL 'x' , INTERVAL 'x' ; 
SELECT INTERVAL 'x' , INTERVAL 'x' , INTERVAL 'x' , - INTERVAL 'x' ; 
SET IntervalStyle TO iso_8601 ; 
SELECT INTERVAL 'x' AS zero" , INTERVAL 'x' AS a year 2 months" , INTERVAL 'x' AS a bit over a day" , INTERVAL 'x' AS a bit over 2 hours" , ( INTERVAL 'x' + INTERVAL 'x' ) AS all fields" , ( INTERVAL 'x' - INTERVAL 'x' ) AS mixed sign" , ( - INTERVAL 'x' + INTERVAL 'x' ) AS negative" ; 
SELECT INTERVAL 'x' AS zero" , INTERVAL 'x' AS a year 2 months" , INTERVAL 'x' AS a week" , INTERVAL 'x' AS a bit over a day" , INTERVAL 'x' AS all fields" , INTERVAL 'x' AS negative" , INTERVAL 'x' AS fractional second" ; 
SELECT INTERVAL 'x' AS ISO8601 Basic Format" , INTERVAL 'x' AS ISO8601 Extended Format" ; 
SELECT INTERVAL 'x' AS year only" , INTERVAL 'x' AS year month" , INTERVAL 'x' AS year month day" , INTERVAL 'x' AS year only plus time" , INTERVAL 'x' AS year month plus time" , INTERVAL 'x' AS year month day plus time" , INTERVAL 'x' AS hour only" , INTERVAL 'x' AS hour minute" ; 
SELECT INTERVAL 'x' ; 
SELECT INTERVAL 'x' , INTERVAL 'x' , INTERVAL 'x' ; 
SELECT x ( years := 1 ) ; 
SELECT x ( years := 1 , months := 1 ) ; 
SELECT x ( years := 1 , months := 1 , weeks := 1 , days := 1 , hours := 1 , mins := 1 ) ; 
SELECT x ( ) = x ( years := 1 , months := 1 , weeks := 1 , days := 1 , mins := 1 , secs := 1.000000 ) ; 
SELECT x ( hours := 1 , mins := 1 , secs := 1.000000 ) ; 
SELECT x ( secs := 'x' ) ; 
CREATE TABLE x ( x point ) ; 
~SELECT 'x' AS one , x . * FROM x p WHERE x . x = 'x' ; 
@SELECT 'x' AS three , x . * FROM x p WHERE x . x < x 'x' ; 
@SELECT 'x' AS three , x . * FROM x p WHERE x 'x' > x . x ; 
@SELECT 'x' AS three , x . * FROM x p WHERE NOT x . x < x 'x' ; 
@SELECT 'x' AS two , x . * FROM x p WHERE x . x < x 'x' ; 
@SELECT 'x' AS three , x . * FROM x p WHERE NOT x 'x' > x . x ; 
CREATE TEMP TABLE x ( x point ) ; 
SET enable_seqscan TO TRUE ; 
~@~~@~CREATE TABLE x ( x INT REFERENCES x MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE , x INT ) ; 
CREATE TABLE x ( x INT , x INT , x TEXT , PRIMARY KEY ( x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , x INT , CONSTRAINT constrname FOREIGN KEY ( x , x ) REFERENCES x MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL ) ; 
COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'x' ; 
COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'x' ; 
COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL ; 
INSERT INTO x VALUES ( NULL , NULL , 1 ) ; 
INSERT INTO x VALUES ( NULL , 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , NULL , 1 ) ; 
DELETE FROM x WHERE x = 1 AND x = 1 ; 
CREATE TABLE x ( x INT DEFAULT 1 , x INT DEFAULT 1 , x INT , CONSTRAINT constrname2 FOREIGN KEY ( x , x ) REFERENCES x MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT ) ; 
CREATE TABLE x ( x INT REFERENCES x MATCH FULL , x INT ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x MATCH FULL ; 
CREATE TABLE x ( x INT , x INT , x INT , x TEXT , PRIMARY KEY ( x , x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , CONSTRAINT constrname3 FOREIGN KEY ( x , x , x ) REFERENCES x ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 'x' ) ; 
INSERT INTO x VALUES ( NULL , 1 , 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , NULL , 1 , 1 ) ; 
DELETE FROM x WHERE x = 1 AND x = 1 AND x = 1 ; 
CREATE TABLE x ( x INT , x INT , x INT , x TEXT , UNIQUE ( x , x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , CONSTRAINT constrname3 FOREIGN KEY ( x , x , x ) REFERENCES x ( x , x , x ) ) ; 
INSERT INTO x VALUES ( 1 , 1 , NULL , 'x' ) ; 
INSERT INTO x VALUES ( 1 , NULL , 1 , 'x' ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , CONSTRAINT constrname3 FOREIGN KEY ( x , x , x ) REFERENCES x ON DELETE CASCADE ON UPDATE CASCADE ) ; 
CREATE TABLE x ( x INT DEFAULT 1 , x INT , x INT , x INT , CONSTRAINT constrname3 FOREIGN KEY ( x , x , x ) REFERENCES x ON DELETE SET DEFAULT ON UPDATE SET NULL ) ; 
UPDATE x SET x = 1 WHERE x = 1 AND x = 1 ; 
CREATE TABLE x ( x INT DEFAULT 1 , x INT DEFAULT 1 , x INT DEFAULT 1 , x INT , CONSTRAINT constrname3 FOREIGN KEY ( x , x , x ) REFERENCES x ON DELETE SET NULL ON UPDATE SET DEFAULT ) ; 
UPDATE x SET x = 1 , x = 1 , x = 1 WHERE x = 1 ; 
CREATE TABLE x ( x INT , CONSTRAINT fkfail1 FOREIGN KEY ( x ) REFERENCES x ) ; 
CREATE TABLE x ( x INT , CONSTRAINT fkfail1 FOREIGN KEY ( x ) REFERENCES x ( x ) ) ; 
CREATE TABLE x ( x inet REFERENCES x ) ; 
CREATE TABLE x ( x inet REFERENCES x ( x ) ) ; 
CREATE TABLE x ( x int8 REFERENCES x ) ; 
CREATE TABLE x ( x NUMERIC REFERENCES x ) ; 
CREATE TABLE x ( x NUMERIC PRIMARY KEY ) ; 
CREATE TABLE x ( x INT , x inet , PRIMARY KEY ( x , x ) ) ; 
CREATE TABLE x ( x cidr , x TIMESTAMP , FOREIGN KEY ( x , x ) REFERENCES x ) ; 
CREATE TABLE x ( x cidr , x TIMESTAMP , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) ; 
CREATE TABLE x ( x INT , x inet , FOREIGN KEY ( x , x ) REFERENCES x ) ; 
CREATE TABLE x ( x INT , x inet , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) ; 
CREATE TABLE x ( x INT , x inet , x INT , x inet , PRIMARY KEY ( x , x ) , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) ; 
CREATE TABLE x ( x INT , x inet , x INT , x inet , PRIMARY KEY ( x , x ) , FOREIGN KEY ( x , x ) REFERENCES x ) ; 
CREATE TABLE x ( x INT , PRIMARY KEY ( x ) , UNIQUE ( x , x ) ) INHERITS ( x ) ; 
UPDATE x SET x = x * 1 ; 
UPDATE x SET x = x * 1 WHERE x < 1 ; 
CREATE TABLE x ( x INT , x INT , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) ; 
CREATE TABLE x ( x INT NOT NULL , x INT ) ; 
CREATE TABLE x ( x INT , x INT , PRIMARY KEY ( x , x ) , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) INHERITS ( x ) ; 
CREATE TABLE x ( x inet , PRIMARY KEY ( x , x ) ) INHERITS ( x ) ; 
CREATE TABLE x ( x cidr , x INT [ ] , FOREIGN KEY ( x , x ) REFERENCES x ) ; 
CREATE TABLE x ( x cidr , x INT [ ] , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) ; 
CREATE TABLE x ( x inet , x inet [ ] , PRIMARY KEY ( x , x ) , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) INHERITS ( x ) ; 
CREATE TABLE x ( x inet , x inet , PRIMARY KEY ( x , x ) , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ) INHERITS ( x ) ; 
CREATE TABLE x ( x INT4 PRIMARY KEY , x INT4 ) ; 
CREATE TABLE x ( x INT4 PRIMARY KEY , x INT4 REFERENCES x DEFERRABLE ) ; 
CREATE TABLE x ( x INT4 PRIMARY KEY , x INT4 REFERENCES x DEFERRABLE INITIALLY DEFERRED ) ; 
CREATE TEMP TABLE x ( x INT4 PRIMARY KEY , x VARCHAR ( 1 ) UNIQUE , x REAL UNIQUE , UNIQUE ( x , x , x ) ) ; 
CREATE TEMP TABLE x ( x INT4 REFERENCES x ( x ) , x VARCHAR ( 1 ) REFERENCES x ( x ) , x REAL REFERENCES x ( x ) , x TEXT , x INT2 ) ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT REFERENCES x DEFERRABLE INITIALLY DEFERRED ) ; 
SAVEPOINT savept1 ; 
RELEASE SAVEPOINT savept1 ; 
ROLLBACK TO savept1 ; 
ALTER TABLE x ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE ; 
ALTER TABLE x ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE ; 
ALTER TABLE x ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED ; 
INSERT INTO x VALUES ( 1 , 1 , NULL , NULL ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , NULL ) ; 
UPDATE x SET x = x WHERE x = 1 ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , FOREIGN KEY ( x ) REFERENCES x ( x ) ON UPDATE CASCADE ON DELETE CASCADE ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 1 ) , ( 1 , 1 ) ; 
CREATE TEMP TABLE x ( x INT DEFAULT 1 REFERENCES x ON DELETE SET DEFAULT ) ; 
CREATE TEMP TABLE x ( x INT REFERENCES x ON UPDATE NO ACTION ON DELETE NO ACTION ) ; 
CREATE TEMP TABLE x ( x INT REFERENCES x ON UPDATE RESTRICT ON DELETE RESTRICT ) ; 
CREATE TEMP TABLE x ( x INTEGER PRIMARY KEY , x TEXT ) ; 
CREATE TEMP TABLE x ( x INTEGER PRIMARY KEY , x INTEGER REFERENCES x ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , FOREIGN KEY ( x , x ) REFERENCES x ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 1 , 1 ) ; 
CREATE TABLE x ( x INT , x INT , x INT , FOREIGN KEY ( x ) REFERENCES x , FOREIGN KEY ( x , x ) REFERENCES x , FOREIGN KEY ( x , x ) REFERENCES x ) ; 
CREATE TABLE x ( x INT REFERENCES x DEFERRABLE INITIALLY DEFERRED ) ; 
SAVEPOINT x ; 
ROLLBACK TO x ; 
ALTER TABLE x DROP CONSTRAINT fktable2_f1_fkey ; 
CREATE TABLE x ( x float8 , x float8 , PRIMARY KEY ( x , x ) ) ; 
CREATE TABLE x ( x float8 , x float8 , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ON UPDATE CASCADE ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , x INT ) ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , x INT , x INT ) PARTITION BY HASH ( a ) ; 
ALTER TABLE x DROP COLUMN x , DROP COLUMN x , DROP COLUMN x , DROP COLUMN x ; 
ALTER TABLE ONLY x ADD FOREIGN KEY ( x , x ) REFERENCES x ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x NOT VALID ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
ALTER TABLE x DROP CONSTRAINT fk_partitioned_fk_a_b_fkey ; 
CREATE TABLE x ( x INT , PRIMARY KEY ( x ) , CHECK ( x > 1 ) ) ; 
CREATE TABLE x ( x INT DEFAULT 1 , x INT DEFAULT 1 ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( NULL , 1 , 1 , 1 ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x MATCH SIMPLE ON DELETE SET NULL ON UPDATE SET NULL ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 , 1 , 1 , 1 ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ON DELETE SET DEFAULT ON UPDATE SET DEFAULT ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ON DELETE CASCADE ON UPDATE CASCADE ; 
CREATE TABLE x ( x INT , x TEXT , x INT , FOREIGN KEY ( x , x ) REFERENCES x ON UPDATE CASCADE ON DELETE CASCADE ) ; 
CREATE TABLE x ( x INT , x INT , FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ON UPDATE SET NULL ) ; 
GRANT REFERENCES ON x TO x ; 
SET ROLE regress_other_partitioned_fk_owner ; 
INSERT INTO x SELECT 1 , x FROM x ( 1 , 1 ) x ; 
INSERT INTO x ( x , x ) SELECT 1 , x FROM x ( 1 , 1 ) x ; 
CREATE SCHEMA x CREATE TABLE x ( x INT PRIMARY KEY ) CREATE TABLE x ( x INT ) PARTITION BY list ( a ) CREATE TABLE x PARTITION OF x ( FOREIGN KEY ( x ) REFERENCES x . pkey ) FOR VALUES IN ( 1 ) CREATE TABLE x PARTITION OF x ( FOREIGN KEY ( x ) REFERENCES x . pkey ) FOR VALUES IN ( 1 , 1 ) PARTITION BY list ( a ) CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
ALTER TABLE x . fk_part ADD FOREIGN KEY ( x ) REFERENCES x . pkey ; 
ALTER TABLE x . fk_part_1 DROP CONSTRAINT fk_part_1_a_fkey ; 
ALTER TABLE x . fk_part_23 DROP CONSTRAINT fk_part_23_a_fkey ; 
ALTER TABLE x . fk_part_23_2 DROP CONSTRAINT fk_part_23_a_fkey ; 
CREATE TABLE x . fk_part_4 PARTITION OF x . fk_part FOR VALUES IN ( 1 ) ; 
ALTER TABLE x . fk_part_4 DROP CONSTRAINT fk_part_a_fkey ; 
CREATE TABLE x . fk_part_56 PARTITION OF x . fk_part FOR VALUES IN ( 1 , 1 ) PARTITION BY list ( a ) ; 
CREATE TABLE x . fk_part_56_5 PARTITION OF x . fk_part_56 FOR VALUES IN ( 1 ) ; 
ALTER TABLE x . fk_part_56 DROP CONSTRAINT fk_part_a_fkey ; 
ALTER TABLE x . fk_part_56_5 DROP CONSTRAINT fk_part_a_fkey ; 
CREATE SCHEMA x CREATE TABLE x ( x INT PRIMARY KEY ) CREATE TABLE x ( x INT ) PARTITION BY list ( a ) CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( a ) CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
INSERT INTO x . fk_part VALUES ( 1 ) ; 
CREATE TABLE x . fk_part_1_2 PARTITION OF x . fk_part_1 FOR VALUES IN ( 1 ) ; 
CREATE SCHEMA x CREATE TABLE x ( x INT PRIMARY KEY ) CREATE TABLE x ( x INT , CONSTRAINT fkey FOREIGN KEY ( x ) REFERENCES x . pkey ) PARTITION BY list ( a ) CREATE TABLE x PARTITION OF x . fk_part FOR VALUES IN ( 1 ) PARTITION BY list ( a ) CREATE TABLE x ( x INT , CONSTRAINT my_fkey FOREIGN KEY ( x ) REFERENCES x . pkey ) ; 
ALTER TABLE x . fk_part_1 ATTACH PARTITION x . fk_part_1_1 FOR VALUES IN ( 1 ) ; 
SET CONSTRAINTS x . fkey DEFERRED ; 
INSERT INTO x . pkey VALUES ( 1 ) ; 
DELETE FROM x . pkey ; 
DELETE FROM x . fk_part ; 
DROP SCHEMA fkpart0 , fkpart1 , fkpart2 , fkpart3 CASCADE ; 
SET search_path TO fkpart3 ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ; 
SET search_path TO fkpart4 ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ; 
SET search_path TO fkpart5 ; 
CREATE TABLE x ( x INT PRIMARY KEY ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x INT NOT NULL ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x INT , x INT NOT NULL ) ; 
SET search_path TO fkpart9 ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 , 1 ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x INT REFERENCES x DEFERRABLE INITIALLY IMMEDIATE ) ; 
SET search_path TO fkpart6 ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ON UPDATE CASCADE ON DELETE CASCADE ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ON UPDATE SET NULL ON DELETE SET NULL ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ON UPDATE SET DEFAULT ON DELETE SET DEFAULT ; 
UPDATE x SET x = 1 WHERE x = 1 RETURNING * ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ON UPDATE RESTRICT ON DELETE RESTRICT ; 
CREATE SCHEMA x CREATE TABLE x ( x INT ) PARTITION BY LIST ( a ) CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
ALTER TABLE x . pkpart1 ADD PRIMARY KEY ( x ) ; 
ALTER TABLE x . pkpart ADD PRIMARY KEY ( x ) ; 
CREATE TABLE x . fk ( x INT REFERENCES x . pkpart ) ; 
DROP SCHEMA fkpart7 CASCADE ; 
INSERT INTO x . tbl1 VALUES ( 1 ) ; 
INSERT INTO x . tbl2 VALUES ( 1 ) ; 
ALTER TABLE x . tbl2 DROP CONSTRAINT tbl2_f1_fkey ; 
DROP SCHEMA fkpart8 CASCADE ; 
CREATE TABLE x ( x float8 ) INHERITS ( x ) ; 
CREATE TABLE x ( x int4 ) INHERITS ( x , x ) ; 
CREATE TABLE x ( x int4 , x TEXT , x path ) ; 
CREATE TABLE x ( x float8 ) INHERITS ( x , x ) ; 
CREATE TABLE x ( x int2 ) INHERITS ( x ) ; 
CREATE TABLE x ( x polygon ) INHERITS ( x ) ; 
CREATE TABLE x ( x int2 , x float4 ) ; 
CREATE TABLE x ( x int4 , x int4 ) ; 
CREATE TABLE x ( x int4 , x float8 ) ; 
CREATE TABLE x ( x TEXT , x int4 ) ; 
CREATE TABLE x ( x float8 , x int4 ) ; 
CREATE TABLE x ( x int4 , x int4 [ ] , x TEXT [ ] ) ; 
CREATE TABLE x ( x jsonb ) ; 
CREATE TABLE IF NOT EXISTS x ( x TEXT , x tsvector ) ; 
CREATE TABLE IF NOT EXISTS x ( x TEXT ) ; 
CREATE TABLE x WITH ( Fillfactor" = 1 ) AS SELECT 1 a ; 
CREATE TABLE x AS SELECT * FROM x WHERE x = 'x' ; 
CREATE TABLE IF NOT EXISTS x AS SELECT * FROM x WHERE x = 'x' ; 
PREPARE select1 AS SELECT 1 AS a ; 
CREATE TABLE x AS EXECUTE select1 ; 
CREATE TABLE IF NOT EXISTS x AS EXECUTE select1 ; 
DEALLOCATE select1 ; 
\CREATE TEMP TABLE x ( ) WITHOUT OIDS ; DROP TABLE x ; 
CREATE TABLE x ( x INT DEFAULT ( x ) ) ; 
CREATE TABLE x ( x INT DEFAULT ( x . x ) ) ; 
CREATE TABLE x ( x INT DEFAULT ( x ( x ) ) ) ; 
CREATE TABLE x ( x INT DEFAULT ( x ( 1 ) ) ) ; 
CREATE TABLE x ( x INT DEFAULT ( SELECT 1 ) ) ; 
CREATE TABLE x ( x INT DEFAULT ( x ( 1 , 1 ) ) ) ; 
CREATE TABLE x ( x INT ) INHERITS ( x ) PARTITION BY LIST ( a ) ; 
$$CREATE TABLE x ( x INT ) PARTITION BY LIST ( ( x LIKE ( SELECT 1 ) ) ) ; 
$$CREATE TABLE x ( x INT ) PARTITION BY MAGIC ( a ) ; 
$$CREATE TABLE x ( x point ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x point ) PARTITION BY LIST ( a point_ops ) ; 
$$CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 , 'x' ) TO ( 1 , 'x' ) ; 
CREATE DOMAIN intdom1 AS INT ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( ( 1 + 1 ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( x ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( x . x ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( x ( x ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( x ( 1 ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( ( SELECT 1 ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( x ( 1 , 1 ) ) ; 
CREATE TABLE x ( x bool ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x money ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x BIGINT ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( x ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( x . x ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( x ( x ) ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( ( SELECT 1 ) ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( x ( 1 , 1 ) ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' ) TO ( 'x' , 1 ) ; 
CREATE TABLE x ( x INT ) PARTITION BY HASH ( a ) ; 
CREATE TABLE x ( x VARCHAR ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x VARCHAR ) PARTITION BY HASH ( a ) ; 
CREATE TABLE x ( x TEXT , x INT NOT NULL DEFAULT 1 , CONSTRAINT check_a CHECK ( x ( x ) > 1 ) ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x ( x NOT NULL , x DEFAULT 1 , x CHECK ( x >= 1 ) , CONSTRAINT check_a CHECK ( x ( x ) > 1 ) ) FOR VALUES IN ( 'x' ) ; 
CREATE TABLE x PARTITION OF x ( x NOT NULL DEFAULT 1 , CONSTRAINT check_a CHECK ( x ( x ) > 1 ) , CONSTRAINT check_b CHECK ( x >= 1 ) ) FOR VALUES IN ( 'x' ) ; 
ALTER TABLE x ADD CONSTRAINT check_b CHECK ( x >= 1 ) ; 
ALTER TABLE x DROP CONSTRAINT check_a , DROP CONSTRAINT check_b ; 
CREATE TABLE x ( x INT DEFAULT 1 , x INT NOT NULL DEFAULT 1 ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x ( x NOT NULL , x DEFAULT 1 ) FOR VALUES IN ( 1 ) ; 
CREATE TABLE x PARTITION OF x ( x COLLATE POSIX" ) FOR VALUES FROM ( 'x' ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' COLLATE C" ) TO ( 'x' ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' COLLATE POSIX" ) TO ( 'x' ) ; 
CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS OPERATOR 1 < ( int4 , int4 ) , OPERATOR 1 <= ( int4 , int4 ) , OPERATOR 1 = ( int4 , int4 ) , OPERATOR 1 >= ( int4 , int4 ) , OPERATOR 1 > ( int4 , int4 ) , FUNCTION 1 x ( int4 , int4 ) ; 
DROP OPERATOR CLASS test_int4_ops USING btree ; 
DROP FUNCTION x ( int4 , int4 ) ; 
COMMENT ON TABLE parted_col_comment IS 'x' ; 
COMMENT ON COLUMN parted_col_comment . a IS 'x' ; 
CREATE TABLE x ( x INT [ ] ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x bool ) PARTITION BY list ( a ) ; 
CREATE TEMPORARY TABLE x ( x INT ) PARTITION BY list ( a ) ; 
$$INSERT INTO x VALUES ( CURRENT_TIMESTAMP ) ; 
CREATE TABLE x ( x INT , x INT ) PARTITION BY list ( b ) ; 
ALTER TABLE x ADD CHECK ( x <= 1 AND x IS NOT NULL ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 , NULL ) ; 
CREATE INDEX x ON x ( x ) WHERE x = 1 ; 
CREATE INDEX x ON x ( ( x = 1 ) ) ; 
COPY ( SELECT x FROM x WHERE x = 1 ) TO STDOUT ; 
COPY ( SELECT x FROM x WHERE x = 1 FOR UPDATE ) TO STDOUT ; 
COPY ( SELECT x INTO TEMP x FROM x WHERE x = 1 ) TO STDOUT ; 
COPY ( SELECT * FROM x JOIN x USING ( id ) ) TO STDOUT ; 
COPY ( SELECT x FROM x WHERE x = 1 UNION SELECT * FROM x ORDER BY 1 ) TO STDOUT ; 
COPY ( SELECT * FROM ( SELECT x FROM x WHERE x = 1 UNION SELECT * FROM x ORDER BY 1 ) t1 ) TO STDOUT ; 
COPY ( SELECT x FROM x WHERE x = 1 ) TO STDOUT CSV HEADER FORCE QUOTE x ; 
\\\\\\CREATE TABLE x ( x TIME ( 1 ) ) ; 
SELECT x AS Time" FROM x ; 
SELECT x AS Five" FROM x WHERE x > 'x' ; 
SELECT x AS Eight" FROM x WHERE x >= 'x' ; 
SELECT x + TIME 'x' AS Illegal" FROM x ; 
CREATE TEMP TABLE x AS SELECT * FROM x ; 
PREPARE prepstmt AS SELECT * FROM x ; 
EXECUTE prepstmt ; 
$PREPARE prepstmt2 ( BIGINT ) AS SELECT * FROM x WHERE x = 1 ; 
EXECUTE prepstmt2 ( 1 ) ; 
CREATE TEMP TABLE x AS SELECT * FROM x ORDER BY 1 ; 
PREPARE vprep AS SELECT * FROM x ; 
EXECUTE vprep ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT x , x / 1 AS q2 FROM x ; 
$$$SELECT x ( x ) INTO x FROM x ; 
$$CREATE TEMP VIEW x AS SELECT 1 + 1 AS f1 ; 
$$$$CREATE OR REPLACE TEMP VIEW x AS SELECT 1 + 1 + 1 AS f1 ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT 1 + 1 + 1 + ( SELECT x ( x ) FROM x ) AS f1 ; 
CREATE SCHEMA x CREATE TABLE x ( x INT ) ; 
INSERT INTO x . abc VALUES ( 1 ) ; 
SET search_path = s1 ; 
PREPARE p1 AS SELECT x FROM x ; 
SET search_path = s2 ; 
DROP SCHEMA s1 CASCADE ; 
DROP SCHEMA s2 CASCADE ; 
PREPARE p2 AS SELECT x ( 'x' ) ; 
$$CREATE TEMP TABLE x AS SELECT * FROM x ( 1 , 1 ) AS f1 ; 
$$$PREPARE pstmt_def_insert ( INT ) AS INSERT INTO x VALUES ( 1 ) ; 
EXECUTE pstmt_def_insert ( NULL ) ; 
EXECUTE pstmt_def_insert ( 1 ) ; 
DEALLOCATE pstmt_def_insert ; 
INSERT INTO x SELECT 1 FROM x ( 1 , 1 ) UNION ALL SELECT 1 ; 
$PREPARE test_mode_pp ( INT ) AS SELECT x ( * ) FROM x WHERE x = 1 ; 
EXPLAIN ( costs off ) EXECUTE test_mode_pp ( 1 ) ; 
SET plan_cache_mode TO force_generic_plan ; 
SET plan_cache_mode TO auto ; 
SET plan_cache_mode TO force_custom_plan ; 
SELECT x , x , x FROM x WHERE x NOT IN ( 'x' , 'x' ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( 1 ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
SELECT x , x , x FROM x . column_column_usage ORDER BY 1 , 1 , 1 ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x * 1 ) STORED GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x * 1 ) STORED , x INT GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x DOUBLE PRECISION GENERATED ALWAYS AS ( x ( ) ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT DEFAULT 1 GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS IDENTITY GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x ( x ) ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x ( ) OVER ( ORDER BY x ) ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( ( SELECT x ) ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x ( 1 , x ) ) STORED ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED BY DEFAULT AS ( x * 1 ) STORED ) ; 
INSERT INTO x VALUES ( 1 , DEFAULT ) ; 
UPDATE x SET x = DEFAULT WHERE x = 1 ; 
SELECT x , x , x * 1 AS b2 FROM x ORDER BY x ; 
SELECT x , x FROM x WHERE x = 1 ORDER BY x ; 
SELECT * FROM x , x WHERE x . x = x . x ; 
WITH foo AS ( SELECT * FROM x ) SELECT * FROM x ; 
INSERT INTO x ( x ) VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) ; 
CREATE TABLE x ( x TEXT , x TEXT GENERATED ALWAYS AS ( x || 'x' || x ) STORED ) ; 
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) , ( NULL ) ; 
INSERT INTO x ( x ) VALUES ( 1 ) , ( 1 ) ; 
\\CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( NULL ) STORED ) ; 
CREATE TYPE double_int AS ( a INT , b INT ) ; 
CREATE TABLE x ( x INT , x double_int GENERATED ALWAYS AS ( ( x * 1 , x * 1 ) ) STORED ) ; 
DROP TYPE double_int ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT , x INT GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
$$REVOKE ALL ON FUNCTION x ( INT ) FROM x ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT , x INT GENERATED ALWAYS AS ( x ( x ) ) STORED ) ; 
SET ROLE regress_user11 ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT GENERATED ALWAYS AS ( x * 1 ) STORED CHECK ( x < 1 ) ) ; 
ALTER TABLE x ADD CONSTRAINT chk CHECK ( x < 1 ) NOT VALID ; 
CREATE TABLE x ( x INT , x INT GENERATED ALWAYS AS ( x / 1 ) STORED , PRIMARY KEY ( x , x ) ) ; 
CREATE INDEX x ON x ( ( x * 1 ) ) ; 
CREATE INDEX x ON x ( x ) WHERE x > 1 ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x * 1 = 1 ; 
SELECT * FROM x WHERE x * 1 = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x = 1 AND x > 1 ; 
SELECT * FROM x WHERE x = 1 AND x > 1 ; 
CREATE TABLE x ( x INT , x INT GENERATED ALWAYS AS ( x * 1 ) STORED , PRIMARY KEY ( x ) ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT REFERENCES x ( x ) ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x gtestdomain1 GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
CREATE TABLE x OF gtest_type ( x WITH OPTIONS GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
DROP TYPE gtest_type CASCADE ; 
ALTER TABLE x ADD COLUMN x INT GENERATED ALWAYS AS ( x * 1 ) STORED ; 
$$INSERT INTO x ( x ) VALUES ( 1 ) , ( 1 ) , ( 1 ) ; 
DROP TRIGGER gtest1 ON gtest26 ; 
DROP TRIGGER gtest2 ON gtest26 ; 
DROP TRIGGER gtest3 ON gtest26 ; 
$$CREATE TRIGGER x BEFORE UPDATE OF x ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER gtest11 ON gtest26 ; 
$$CREATE TABLE x ( x INT , x INT , x INT , x INT GENERATED ALWAYS AS ( x * 1 ) STORED ) ; 
SET search_path = lock_schema1 ; 
CREATE TABLE x ( x BIGINT ) ; 
CREATE VIEW x ( x , x ) AS SELECT * FROM x , x ; 
CREATE VIEW x AS SELECT ( SELECT x FROM x LIMIT 1 ) FROM x ; 
CREATE VIEW x AS SELECT * FROM x WHERE x IN ( SELECT * FROM x ) ; 
CREATE VIEW x AS SELECT * FROM ( SELECT * FROM x ) sub ; 
ALTER ROLE x SET search_path = lock_schema1 ; 
GRANT USAGE ON SCHEMA lock_schema1 TO x ; 
LOCK TABLE x IN ACCESS SHARE MODE ; 
LOCK TABLE x IN ROW EXCLUSIVE MODE ; 
LOCK TABLE x IN SHARE UPDATE EXCLUSIVE MODE ; 
LOCK TABLE x IN SHARE MODE ; 
LOCK TABLE x IN EXCLUSIVE MODE ; 
LOCK TABLE x IN ACCESS EXCLUSIVE MODE ; 
LOCK TABLE x IN ACCESS SHARE MODE NOWAIT ; 
LOCK TABLE x IN ROW SHARE MODE NOWAIT ; 
LOCK TABLE x IN ROW EXCLUSIVE MODE NOWAIT ; 
LOCK TABLE x IN SHARE UPDATE EXCLUSIVE MODE NOWAIT ; 
LOCK TABLE x IN SHARE MODE NOWAIT ; 
LOCK TABLE x IN SHARE ROW EXCLUSIVE MODE NOWAIT ; 
LOCK TABLE x IN EXCLUSIVE MODE NOWAIT ; 
LOCK TABLE x IN ACCESS EXCLUSIVE MODE NOWAIT ; 
CREATE OR REPLACE VIEW x AS SELECT * FROM x ; 
CREATE TABLE x ( x BIGINT ) INHERITS ( x ) ; 
LOCK TABLE x * IN ACCESS EXCLUSIVE MODE ; 
SET ROLE regress_rol_lock1 ; 
LOCK TABLE ONLY x ; 
DROP SCHEMA lock_schema1 CASCADE ; 
SELECT CURRENT_TIMESTAMP = x ( ) ; 
SELECT CURRENT_CATALOG = x ( ) ; 
SELECT CURRENT_SCHEMA ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT x ( * ) FROM x WHERE x BETWEEN 'x' AND 'x' ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x NOT BETWEEN 'x' AND 'x' ; 
SELECT x ( * ) FROM x WHERE x NOT BETWEEN 'x' AND 'x' ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x BETWEEN SYMMETRIC 'x' AND 'x' ; 
SELECT x ( * ) FROM x WHERE x BETWEEN SYMMETRIC 'x' AND 'x' ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x NOT BETWEEN SYMMETRIC 'x' AND 'x' ; 
SELECT x ( * ) FROM x WHERE x NOT BETWEEN SYMMETRIC 'x' AND 'x' ; 
$$\$$SELECT 'x' ; 
$$$$SELECT x ( 'x' , 'x' , 1 ) ; 
@@SELECT x ( 'x' , 'x' ) 'x' AS true" ; 
@@SELECT x ( 'x' , 'x' ) 'x' AS false" ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SELECT x ( x ( 'x' , 'x' ) , 'x' ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' ] ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , NULL ] ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' ] ) ; 
EXPLAIN ( costs off ) CREATE TABLE x AS SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
CREATE TABLE x AS SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
EXPLAIN ( costs off ) SELECT x ( x ) INTO x FROM x GROUP BY x ( x ) ; 
SELECT x ( x ) INTO x FROM x GROUP BY x ( x ) ; 
EXPLAIN ( costs off ) CREATE MATERIALIZED VIEW x AS SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
CREATE MATERIALIZED VIEW x AS SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
PREPARE prep_stmt AS SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
EXPLAIN ( costs off ) CREATE TABLE x AS EXECUTE prep_stmt ; 
CREATE TABLE x AS EXECUTE prep_stmt ; 
CREATE TEMPORARY TABLE x ( x VARCHAR , x BIGINT , x INT , x date ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) , ( 'x' , 1 , 1 , 'x' ) ; 
SELECT x , x , x , x ( x ) OVER ( PARTITION BY x ) FROM x ORDER BY x , x ; 
SELECT x , x , x , x ( ) OVER ( PARTITION BY x ORDER BY x ) FROM x ; 
SELECT x , x , x , x ( x ) OVER w FROM x WINDOW w AS ( PARTITION BY x ) ; 
SELECT x , x , x , x ( ) OVER w FROM x WINDOW w AS ( PARTITION BY x ORDER BY x ) ORDER BY x ( ) OVER w ; 
SELECT x ( * ) OVER ( ) FROM x WHERE x < 1 ; 
SELECT x ( * ) OVER w FROM x WHERE x < 1 WINDOW w AS ( ) ; 
SELECT x FROM x WHERE FALSE WINDOW w AS ( PARTITION BY x ) ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x ) AS sum_1 , x , x FROM x WHERE x < 1 ; 
SELECT x ( ) OVER ( ORDER BY x ) FROM x WHERE x < 1 ; 
SELECT x ( ) OVER ( PARTITION BY x ORDER BY x ) AS rank_1 , x , x FROM x WHERE x < 1 ; 
SELECT x ( ) OVER ( PARTITION BY x ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( 1 ) OVER ( ORDER BY x , x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( NULL ) OVER ( ORDER BY x , x ) , x , x FROM x LIMIT 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( x , x ) OVER ( PARTITION BY x ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( x , x , 1 ) OVER ( PARTITION BY x ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( x * 1 , 1 ) OVER ( PARTITION BY x ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( x * 1 , 1 , 1 ) OVER ( PARTITION BY x ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x ) , x , x FROM x WHERE x < 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ) , x , x FROM ( SELECT * FROM x WHERE x < 1 ORDER BY x , x ) s ORDER BY x , x ; 
SELECT x ( x , x + 1 ) OVER ( PARTITION BY x ) , x , x FROM ( SELECT * FROM x WHERE x < 1 ORDER BY x , x ) s ; 
SELECT x ( * ) OVER ( PARTITION BY x ) , x FROM ( SELECT * FROM x WHERE x = 1 ) s WHERE x < 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x / 1 ) FROM x WHERE x < 1 ; 
SELECT x ( x ) , x ( ) OVER ( ORDER BY x ) , x ( x ( x ) ) OVER ( ORDER BY x DESC ) FROM x GROUP BY x ; 
SELECT x ( x ) OVER w1 , x ( * ) OVER w2FROM empsalary WINDOW w1 AS ( ORDER BY x ) , w2 AS ( ORDER BY x ) ; 
SELECT x ( x , ( SELECT x FROM x WHERE x . x = x ) ) OVER ( PARTITION BY x ORDER BY x ) FROM x s WHERE x < 1 ; 
SELECT x ( * ) OVER ( PARTITION BY x ) FROM ( SELECT * FROM x WHERE FALSE ) s ; 
SELECT x ( x ) OVER w , x ( ) OVER w FROM x WINDOW w AS ( PARTITION BY x ORDER BY x DESC ) ; 
SELECT x , x , x , x , x , x ( x ) OVER ( ORDER BY x ) , x ( x ) OVER ( ) FROM ( SELECT * , CASE WHEN x < 'x' THEN 1 - EXTRACT ( YEAR FROM x ) END * 1 AS bonus , CASE WHEN x ( x ) OVER ( PARTITION BY x ) < x THEN 1 END AS depadj FROM x ) s ; 
SELECT x ( x ( x ) ) OVER ( ) FROM x WHERE x = 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ( x ) ) OVER ( ) , x FROM ( SELECT x AS x , x + x AS y FROM x ) ss GROUP BY x ; 
SELECT x , x , x ( x ) OVER ( PARTITION BY x ORDER BY x ) , x ( x ) OVER ( PARTITION BY x ORDER BY x ) FROM ( SELECT DISTINCT x , x FROM x ) ss ; 
SELECT x , x , x ( x ) OVER ( PARTITION BY x ORDER BY x RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) , x ( x ) OVER ( PARTITION BY x ORDER BY x RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) FROM ( SELECT DISTINCT x , x FROM x ) ss ; 
SELECT x , x , x ( x ) OVER ( PARTITION BY x ORDER BY x RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) , x ( x ) OVER ( PARTITION BY x ORDER BY x RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) FROM ( SELECT DISTINCT x , x FROM x ) ss ; 
SELECT x , x / 1 AS two , x ( x / 1 ) OVER ( PARTITION BY x ORDER BY x / 1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) , x ( x / 1 ) OVER ( PARTITION BY x ORDER BY x / 1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) FROM ( SELECT DISTINCT x , x FROM x ) ss ; 
SELECT x , x / 1 AS two , x ( x / 1 ) OVER ( PARTITION BY x ORDER BY x / 1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) , x ( x / 1 ) OVER ( PARTITION BY x ORDER BY x / 1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) FROM ( SELECT DISTINCT x , x FROM x ) ss ; 
SELECT x ( x ) OVER ( ORDER BY x RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE NO OTHERS ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE CURRENT ROW ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE GROUP ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE TIES ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING EXCLUDE CURRENT ROW ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING EXCLUDE GROUP ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING EXCLUDE TIES ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( w RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 WINDOW w AS ( ORDER BY x ) ; 
SELECT x ( x ) OVER ( w RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE CURRENT ROW ) , x , x tenk1 WHERE x < 1 WINDOW w AS ( ORDER BY x ) ; 
SELECT x ( x ) OVER ( w RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE GROUP ) , x , x tenk1 WHERE x < 1 WINDOW w AS ( ORDER BY x ) ; 
SELECT x ( x ) OVER ( w RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES ) , x , x tenk1 WHERE x < 1 WINDOW w AS ( ORDER BY x ) ; 
SELECT x ( x ) OVER w , x ( x , 1 ) OVER w AS nth_2 , x ( x ) OVER w , x , x tenk1 WHERE x < 1 WINDOW w AS ( ORDER BY x RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) ; 
SELECT x ( x ) OVER ( ORDER BY x ROWS ( SELECT x FROM x ORDER BY x LIMIT 1 ) + 1 PRECEDING ) , x tenk1 WHERE x < 1 ; 
CREATE TEMP VIEW x AS SELECT x , x ( x ) OVER ( ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) AS sum_rows FROM x ( 1 , 1 ) i ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT x , x ( x ) OVER ( ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE CURRENT ROW ) AS sum_rows FROM x ( 1 , 1 ) i ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT x , x ( x ) OVER ( ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE GROUP ) AS sum_rows FROM x ( 1 , 1 ) i ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT x , x ( x ) OVER ( ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE TIES ) AS sum_rows FROM x ( 1 , 1 ) i ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT x , x ( x ) OVER ( ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE NO OTHERS ) AS sum_rows FROM x ( 1 , 1 ) i ; 
CREATE OR REPLACE TEMP VIEW x AS SELECT x , x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) AS sum_rows FROM x ( 1 , 1 ) i ; 
SELECT x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x ( x , 1 ) OVER ( ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE CURRENT ROW ) , x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE TIES ) , x ( x , 1 ) OVER ( ORDER BY x RANGE BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE TIES ) , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE GROUP ) , x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE GROUP ) , x FROM x ; 
SELECT x , x ( x ) OVER ( ORDER BY x RANGE BETWEEN CURRENT ROW AND 1 FOLLOWING ) FROM x ( 1 , 1 ) x ; 
SELECT x , x ( x ) OVER ( ORDER BY x DESC RANGE BETWEEN CURRENT ROW AND 1 FOLLOWING ) FROM x ( 1 , 1 ) x ; 
CREATE TEMP TABLE x ( x INT , x float4 , x float8 , x NUMERIC ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
SELECT x ( x ) OVER ( ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE TIES ) , x , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 PRECEDING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE CURRENT ROW ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE GROUP ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE TIES ) , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE CURRENT ROW ) , x , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE GROUP ) , x , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( PARTITION BY x ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE TIES ) , x , x , x tenk1 WHERE x < 1 ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x ( x , 1 ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) , x , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE CURRENT ROW ) , x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE TIES ) , x ( x , 1 ) OVER ( ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE TIES ) , x , x FROM x ; 
SELECT x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE GROUP ) , x ( x ) OVER ( ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND 1 FOLLOWING EXCLUDE GROUP ) , x , x FROM x ; 
SELECT x ( * ) OVER ( PARTITION BY x ) FROM ( SELECT * FROM x UNION ALL SELECT * FROM x ) s LIMIT 1 ; 
CREATE TEMP TABLE x ( x INT , x int8 ) ; 
SELECT x , x ( x ) OVER ( PARTITION BY x ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING ) FROM x WHERE x = x ; 
SELECT x , x ( x ) OVER ( PARTITION BY x , x ORDER BY x RANGE BETWEEN 1 PRECEDING AND 1 PRECEDING ) FROM x WHERE x = x ; 
SELECT x , x ( x ) OVER ( PARTITION BY x , x ORDER BY x RANGE BETWEEN 1 FOLLOWING AND 1 FOLLOWING ) FROM x WHERE x = x ; 
SELECT x , x ( x ) OVER ( PARTITION BY x ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) FROM x WHERE x = x ; 
SELECT x , x ( x ) OVER ( PARTITION BY x , x ORDER BY x GROUPS BETWEEN 1 PRECEDING AND 1 PRECEDING ) FROM x WHERE x = x ; 
SELECT x , x ( x ) OVER ( PARTITION BY x , x ORDER BY x GROUPS BETWEEN 1 FOLLOWING AND 1 FOLLOWING ) FROM x WHERE x = x ; 
SELECT x ( ) OVER ( ORDER BY x ( 'x' ) ) ; 
SELECT x ( ) OVER ( ORDER BY x ( ) OVER ( ORDER BY x ( ) ) ) ; 
SELECT * FROM x WHERE x ( ) OVER ( ORDER BY x ) < 1 ; 
SELECT * FROM x INNER JOIN x ON x ( ) OVER ( ORDER BY x ) < 1 ; 
SELECT x ( ) OVER ( ORDER BY 1 ) , x ( * ) FROM x GROUP BY 1 ; 
DELETE FROM x WHERE ( x ( ) OVER ( ORDER BY x ( ) ) ) > 1 ; 
DELETE FROM x RETURNING x ( ) OVER ( ORDER BY x ( ) ) ; 
SELECT x ( * ) OVER w FROM x WINDOW w AS ( ORDER BY x ) , w AS ( ORDER BY x ) ; 
SELECT x ( ) OVER ( ) FROM x ; 
SELECT x ( 1 , 1 ) OVER ( ) FROM x ; 
SELECT x ( 1 ) OVER ( ORDER BY x ) , x , x FROM x ; 
SELECT x ( x , 1 ) OVER ( ORDER BY x ) , x , x FROM x ; 
EXPLAIN ( COSTS OFF ) SELECT x ( 1 ) OVER ( PARTITION BY x ORDER BY x , x ) , x ( 1 ) OVER ( PARTITION BY x ORDER BY x , x , x ) FROM x ; 
CREATE FUNCTION x ( val anyelement , n INTEGER = 1 ) RETURNS anyelement LANGUAGE internal WINDOW IMMUTABLE STRICT AS 'x' ; 
SELECT x ( n := 1 , val := x ) OVER ( PARTITION BY x ) , x , x FROM ( SELECT * FROM x WHERE x < 1 ORDER BY x , x ) s ; 
SELECT x ( x ) OVER ( PARTITION BY x ) , x , x FROM ( SELECT * FROM x WHERE x < 1 ORDER BY x , x ) s ; 
$$$$$$$$$$$$$$SELECT x , x ( x ) OVER ( ORDER BY x ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , NULL ) , ( 1 , NULL ) ) t ( i , v ) ; 
SELECT x , x ( * ) OVER ( ORDER BY x ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , NULL ) , ( 1 , NULL ) ) t ( i , v ) ; 
SELECT x , x , x ( x ) OVER w , x ( x ) OVER w FROM ( VALUES ( 1 , TRUE ) , ( 1 , TRUE ) , ( 1 , FALSE ) , ( 1 , FALSE ) , ( 1 , TRUE ) ) v ( i , b ) WINDOW w AS ( ORDER BY x ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING ) ; 
$$EXPLAIN ( costs off ) SELECT * FROM pg_temp . f ( 1 ) ; 
SELECT * FROM pg_temp . f ( 1 ) ; 
SELECT 1 AS two UNION SELECT 1 ORDER BY 1 ; 
SELECT 1 AS one UNION SELECT 1 ORDER BY 1 ; 
SELECT 1 AS two UNION ALL SELECT 1 ; 
SELECT 1 AS three UNION SELECT 1 UNION SELECT 1 ORDER BY 1 ; 
SELECT 1 AS two UNION SELECT 1 UNION SELECT 1 ORDER BY 1 ; 
SELECT 1 AS three UNION SELECT 1 UNION ALL SELECT 1 ORDER BY 1 ; 
SELECT 1.000000 AS two UNION SELECT 1.000000 ORDER BY 1 ; 
SELECT 1.000000 AS two UNION SELECT 1 ORDER BY 1 ; 
SELECT 1 AS two UNION SELECT 1.000000 ORDER BY 1 ; 
SELECT 1.000000 AS two UNION ALL SELECT 1 ORDER BY 1 ; 
SELECT 1.000000 AS three UNION SELECT 1 UNION SELECT 1 ORDER BY 1 ; 
SELECT 1.000000 AS three UNION SELECT 1 UNION ALL SELECT 1 ORDER BY 1 ; 
SELECT 1.000000 AS two UNION ( SELECT 1 UNION ALL SELECT 1 ) ORDER BY 1 ; 
SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x INTERSECT ALL SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x EXCEPT ALL SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x EXCEPT ALL SELECT DISTINCT x FROM x ORDER BY 1 ; 
SELECT x FROM x EXCEPT ALL SELECT x FROM x FOR NO KEY UPDATE ; 
( SELECT 1 , 1 , 1 UNION SELECT 1 , 1 , 1 ) INTERSECT SELECT 1 , 1 , 1 ; 
( SELECT 1 , 1 , 1 UNION SELECT 1 , 1 , 1 ORDER BY 1 , 1 ) INTERSECT SELECT 1 , 1 , 1 ; 
( SELECT 1 , 1 , 1 UNION SELECT 1 , 1 , 1 ) EXCEPT SELECT 1 , 1 , 1 ; 
( SELECT 1 , 1 , 1 UNION SELECT 1 , 1 , 1 ORDER BY 1 , 1 ) EXCEPT SELECT 1 , 1 , 1 ; 
SET enable_hashagg TO ON ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM ( SELECT x FROM x INTERSECT SELECT x FROM x ) ss ; 
SELECT x ( * ) FROM ( SELECT x FROM x INTERSECT SELECT x FROM x ) ss ; 
EXPLAIN ( costs off ) SELECT x FROM x EXCEPT SELECT x FROM x WHERE x != 1 ; 
SELECT x FROM x EXCEPT SELECT x FROM x WHERE x != 1 ; 
SET enable_hashagg TO off ; 
SELECT x FROM x INTERSECT SELECT x FROM x UNION ALL SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x INTERSECT ( ( ( SELECT x FROM x UNION ALL SELECT x FROM x ) ) ) ORDER BY 1 ; 
( ( ( SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY 1 ) ) ) UNION ALL SELECT x FROM x ; 
SELECT x FROM x UNION ALL SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x UNION ALL ( ( ( SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 ) ) ) ; 
( ( ( SELECT x FROM x UNION ALL SELECT x FROM x ) ) ) EXCEPT SELECT x FROM x ORDER BY 1 ; 
SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY x LIMIT 1 ; 
SELECT x FROM x EXCEPT ( ( ( SELECT x FROM x ORDER BY x LIMIT 1 ) ) ) ORDER BY 1 ; 
( ( ( ( ( SELECT * FROM x ) ) ) ) ) ; 
SELECT UNION SELECT ; 
SELECT INTERSECT SELECT ; 
SELECT EXCEPT SELECT ; 
EXPLAIN ( costs off ) SELECT FROM x ( 1 , 1 ) UNION SELECT FROM x ( 1 , 1 ) ; 
EXPLAIN ( costs off ) SELECT FROM x ( 1 , 1 ) INTERSECT SELECT FROM x ( 1 , 1 ) ; 
SELECT FROM x ( 1 , 1 ) UNION SELECT FROM x ( 1 , 1 ) ; 
SELECT FROM x ( 1 , 1 ) UNION ALL SELECT FROM x ( 1 , 1 ) ; 
SELECT FROM x ( 1 , 1 ) INTERSECT SELECT FROM x ( 1 , 1 ) ; 
SELECT FROM x ( 1 , 1 ) INTERSECT ALL SELECT FROM x ( 1 , 1 ) ; 
SELECT FROM x ( 1 , 1 ) EXCEPT SELECT FROM x ( 1 , 1 ) ; 
SELECT FROM x ( 1 , 1 ) EXCEPT ALL SELECT FROM x ( 1 , 1 ) ; 
SET enable_hashagg = FALSE ; 
SET enable_sort = TRUE ; 
CREATE TEMP TABLE x ( x TEXT PRIMARY KEY ) ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT x || x AS ab FROM x UNION ALL SELECT * FROM x ) t WHERE x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT x || x AS ab FROM x UNION SELECT * FROM x ) t WHERE x = 'x' ; 
CREATE TEMP TABLE x ( PRIMARY KEY ( x ) ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) , ( 'x' , 'x' ) , ( 'x' , 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT x || x AS ab FROM x UNION ALL SELECT x FROM x ) t ORDER BY 1 LIMIT 1 ; 
SELECT * FROM ( SELECT x || x AS ab FROM x UNION ALL SELECT x FROM x ) t ORDER BY 1 LIMIT 1 ; 
EXPLAIN ( costs off ) SELECT x FROM ( SELECT x FROM x UNION ALL SELECT x FROM x ) ss ORDER BY x ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT 1 AS t , * FROM x a UNION ALL SELECT 1 AS t , * FROM x b ) c WHERE x = 1 ; 
CREATE TEMP TABLE x AS SELECT x ( 1 , 1 ) AS x ; 
CREATE INDEX x ON x ( x ( x ) ) ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT * FROM x a UNION ALL SELECT * FROM x b ) ss JOIN x ON x = x ( x ) ; 
SELECT * FROM ( SELECT * FROM x a UNION ALL SELECT * FROM x b ) ss JOIN x ON x = x ( x ) ; 
CREATE TABLE x ( x path ) ; 
SELECT 'x' AS count , x AS open_path FROM x WHERE x ( x ) ; 
SELECT 'x' AS count , x AS closed_path FROM x WHERE x ( x ) ; 
SELECT 'x' AS count , x ( x ) AS closed_path FROM x ; 
SELECT 'x' AS count , x ( x ) AS open_path FROM x ; 
$$ALTER FUNCTION x ( INT , INT ) SUPPORT test_support_func ; 
$$EXPLAIN ( COSTS OFF ) SELECT * FROM x a JOIN x ( 1 , 1 ) g ON x . x = x ; 
CREATE TABLE x ( x TEXT , x INT DEFAULT 1 , x TEXT , x TEXT ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , x ( 'x' , 1 ) , x ( 'x' , 1 ) ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , NULL , x ( 'x' , 1 ) ) ; 
VACUUM FREEZE x ; 
$$INSERT INTO x ( x , x , x ) VALUES ( 'x' , x ( 'x' , 1 ) , NULL ) ; 
CREATE TYPE rainbow AS ENUM ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
CREATE TYPE planets AS ENUM ( 'x' , 'x' , 'x' ) ; 
ALTER TYPE planets ADD VALUE 'x' ; 
ALTER TYPE planets ADD VALUE 'x' BEFORE 'x' ; 
ALTER TYPE planets ADD VALUE 'x' AFTER 'x' ; 
ALTER TYPE planets ADD VALUE IF NOT EXISTS 'x' ; 
CREATE TYPE insenum AS ENUM ( 'x' , 'x' ) ; 
ALTER TYPE insenum ADD VALUE 'x' BEFORE 'x' ; 
CREATE TABLE x ( x rainbow ) ; 
SELECT * FROM x WHERE x >= 'x' ORDER BY x ; 
SELECT * FROM x WHERE x <= 'x' ORDER BY x ; 
SELECT x ( x ) FROM x WHERE x < 'x' ; 
CREATE UNIQUE INDEX x ON x USING btree ( x ) ; 
DROP DOMAIN rgb ; 
$$$$$$$$DROP FUNCTION x ( anyenum ) ; 
DROP FUNCTION x ( rainbow ) ; 
CREATE TABLE x ( x rainbow PRIMARY KEY ) ; 
CREATE TABLE x ( x rainbow REFERENCES x ) ; 
CREATE TABLE x ( x bogus REFERENCES x ) ; 
DROP TYPE bogus ; 
ALTER TYPE rainbow RENAME VALUE 'x' TO 'x' ; 
CREATE TYPE bogus AS ENUM ( 'x' ) ; 
ALTER TYPE bogus ADD VALUE 'x' ; 
ALTER TYPE bogus RENAME TO bogon ; 
ALTER TYPE bogon ADD VALUE 'x' ; 
ALTER TYPE bogus RENAME VALUE 'x' TO 'x' ; 
CREATE TYPE bogus AS ENUM ( 'x' , 'x' , 'x' ) ; 
DROP TYPE rainbow ; 
SELECT * FROM x WHERE NOT EXISTS ( SELECT 1 FROM x WHERE x . x = x ) ; 
SELECT x ( x ) FROM x WHERE x >= 1 AND x < 1 ORDER BY x ; 
CREATE GROUP x WITH USER x , x ; 
ALTER GROUP x ADD USER x ; 
GRANT regress_priv_group2 TO x WITH ADMIN OPTION ; 
SET SESSION AUTHORIZATION regress_priv_user1 ; 
SELECT SESSION_USER , CURRENT_USER ; 
UPDATE x SET x = 1 WHERE x = 'x' ; 
GRANT SELECT ON x TO x , x ; 
CREATE TABLE x ( x VARCHAR ( 1 ) , x BOOLEAN ) ; 
SET SESSION AUTHORIZATION regress_priv_user2 ; 
SELECT * FROM x WHERE ( x IN ( SELECT x FROM x ) ) ; 
SET SESSION AUTHORIZATION regress_priv_user3 ; 
SET SESSION AUTHORIZATION regress_priv_user4 ; 
CREATE TABLE x AS SELECT x AS a , 1 - x AS b FROM x ( 1 , 1 ) x ; 
CREATE INDEX ON x ( x ( x ) ) ; 
$$EXPLAIN ( COSTS OFF ) SELECT * FROM x x , x y WHERE x . x = x . x ; 
$$DROP FUNCTION x ( INTEGER , INTEGER ) CASCADE ; 
SET constraint_exclusion = ON ; 
RESET constraint_exclusion ; 
CREATE TABLE x ( x INT , x INT UNIQUE , x INT , x INT UNIQUE ) ; 
GRANT ALL ( x ) ON x TO x ; 
INSERT INTO x ( x ) VALUES ( 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 1 RETURNING x . x ; 
INSERT INTO x ( x ) VALUES ( 1 ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
REVOKE ALL ( x ) ON x FROM x ; 
GRANT SELECT ( x , x , x ) ON x TO x ; 
CREATE TABLE x ( x INT , x INT , x INT CHECK ( x < 1 ) , PRIMARY KEY ( x , x ) ) ; 
REVOKE SELECT ( x , x ) ON x FROM x ; 
CREATE AGGREGATE x ( INT ) ( sfunc = int4pl , stype = int4 ) ; 
REVOKE ALL ON FUNCTION x ( INT ) , x ( INT ) , x ( INT ) FROM x ; 
GRANT ALL PRIVILEGES ON FUNCTION x ( INT ) TO x ; 
GRANT ALL PRIVILEGES ON PROCEDURE x ( INT ) TO x ; 
REVOKE ALL ON FUNCTION x ( INTEGER ) FROM x ; 
\REVOKE USAGE ON TYPE priv_testtype1 FROM x ; 
GRANT USAGE ON TYPE priv_testtype1 TO x ; 
_REVOKE USAGE ON DOMAIN priv_testdomain1 FROM x ; 
GRANT USAGE ON DOMAIN priv_testdomain1 TO x ; 
CREATE AGGREGATE x ( priv_testdomain1 ) ( sfunc = int4_sum , stype = BIGINT ) ; 
CREATE DOMAIN priv_testdomain2a AS priv_testdomain1 ; 
CREATE DOMAIN priv_testdomain3a AS INT ; 
$$CREATE CAST ( priv_testdomain1 AS priv_testdomain3a ) WITH FUNCTION x ( INT ) ; 
DROP FUNCTION x ( INT ) CASCADE ; 
DROP DOMAIN priv_testdomain3a ; 
CREATE TABLE x ( x INT , x priv_testdomain1 ) ; 
CREATE TABLE x OF priv_testtype1 ; 
CREATE TABLE x ( x INT [ ] , x priv_testtype1 [ ] ) ; 
ALTER TABLE x ADD COLUMN x priv_testdomain1 ; 
ALTER TABLE x ALTER COLUMN x TYPE priv_testdomain1 ; 
CREATE TYPE test7a AS ( a INT , b priv_testdomain1 ) ; 
CREATE TYPE test8a AS ( a INT , b INT ) ; 
ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1 ; 
ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1 ; 
REVOKE ALL ON TYPE priv_testtype1 FROM x ; 
CREATE DOMAIN priv_testdomain2b AS priv_testdomain1 ; 
CREATE DOMAIN priv_testdomain3b AS INT ; 
$$CREATE CAST ( priv_testdomain1 AS priv_testdomain3b ) WITH FUNCTION x ( INT ) ; 
CREATE TYPE test7b AS ( a INT , b priv_testdomain1 ) ; 
CREATE TYPE test8b AS ( a INT , b INT ) ; 
ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1 ; 
ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1 ; 
\DROP DOMAIN priv_testdomain2b ; 
DROP FUNCTION x ( a priv_testdomain1 ) ; 
DROP FUNCTION x ( b INT ) ; 
DROP TYPE test7b ; 
DROP TYPE test8b ; 
DROP CAST ( priv_testdomain1 AS priv_testdomain3b ) ; 
DROP DOMAIN priv_testdomain3b ; 
SELECT x ( 1 , 'x' , 'x' ) ; 
\SELECT x ( CURRENT_USER , 'x' , 'x' ) ; 
SELECT x ( x . x , 'x' , 'x' ) FROM ( SELECT x FROM x WHERE x = CURRENT_USER ) AS t2 ; 
SELECT x ( CURRENT_USER , x . x , 'x' ) FROM ( SELECT x FROM x WHERE x = 'x' ) AS t1 ; 
SELECT x ( x . x , x . x , 'x' ) FROM ( SELECT x FROM x WHERE x = 'x' ) AS t1 , ( SELECT x FROM x WHERE x = CURRENT_USER ) AS t2 ; 
SELECT x ( x . x , 'x' ) FROM ( SELECT x FROM x WHERE x = 'x' ) AS t1 ; 
REVOKE SELECT ON TABLE x FROM x ; 
GRANT SELECT ON x TO x WITH GRANT OPTION ; 
GRANT SELECT ON x TO GROUP x WITH GRANT OPTION ; 
REVOKE regress_priv_group2 FROM x ; 
\\GRANT ALL ON LARGE OBJECT 1 TO x ; 
GRANT SELECT ON LARGE OBJECT 1 TO x ; 
GRANT SELECT ON LARGE OBJECT 1 TO x WITH GRANT OPTION ; 
\\GRANT ALL ON SCHEMA testns TO x ; 
CREATE TABLE x . acltest1 ( x INT ) ; 
DROP TABLE x . acltest1 ; 
ALTER DEFAULT PRIVILEGES GRANT USAGE ON SCHEMAS TO x ; 
CREATE AGGREGATE testns . agg1 ( INT ) ( sfunc = int4pl , stype = int4 ) ; 
DROP FUNCTION testns . foo ( ) ; 
DROP AGGREGATE testns . agg1 ( INT ) ; 
DROP PROCEDURE testns . bar ( ) ; 
ALTER DEFAULT PRIVILEGES FOR ROLE x REVOKE USAGE ON TYPES FROM x ; 
CREATE DOMAIN testns . priv_testdomain1 AS INT ; 
DROP DOMAIN testns . priv_testdomain1 ; 
SELECT x ( * ) FROM x d LEFT JOIN x n ON x = x . x WHERE x = 'x' ; 
DROP SCHEMA testns CASCADE ; 
DROP SCHEMA testns2 CASCADE ; 
DROP SCHEMA testns3 CASCADE ; 
DROP SCHEMA testns4 CASCADE ; 
DROP SCHEMA testns5 CASCADE ; 
\CREATE TABLE x . t1 ( x INT ) ; 
CREATE TABLE x . t2 ( x INT ) ; 
CREATE AGGREGATE testns . priv_testagg ( INT ) ( sfunc = int4pl , stype = int4 ) ; 
\CREATE ROLE x superuser login ; 
SET SESSION ROLE regress_schemauser1 ; 
SELECT x , x FROM x , x WHERE x . x = 'x' AND x . x = x . x ; 
ALTER SCHEMA testns OWNER TO x ; 
ALTER ROLE x RENAME TO x ; 
SET SESSION ROLE regress_schemauser_renamed ; 
\\SET SESSION ROLE regress_priv_user2 ; 
SET SESSION ROLE regress_priv_user3 ; 
SET SESSION ROLE regress_priv_user4 ; 
REVOKE SELECT ON x FROM x CASCADE ; 
SET SESSION ROLE regress_priv_user1 ; 
\DROP FUNCTION x ( BOOLEAN ) ; 
SET SESSION AUTHORIZATION regress_locktable_user ; 
\\\\\DROP USER IF EXISTS x ; 
DROP SCHEMA IF EXISTS regress_rls_schema CASCADE ; 
CREATE USER x NOLOGIN ; 
CREATE USER x BYPASSRLS NOLOGIN ; 
GRANT regress_rls_group1 TO x ; 
GRANT regress_rls_group2 TO x ; 
GRANT ALL ON SCHEMA regress_rls_schema TO x ; 
SET search_path = regress_rls_schema ; 
CREATE OR REPLACE FUNCTION x ( TEXT ) RETURNS bool COST 1.000000 LANGUAGE plpgsql AS 'x' ; 
SET SESSION AUTHORIZATION regress_rls_alice ; 
INSERT INTO x VALUES ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) ; 
SELECT * FROM x WHERE x = 'x' AND x = 'x' ORDER BY x ; 
SET SESSION AUTHORIZATION regress_rls_bob ; 
SET row_security TO ON ; 
SET SESSION AUTHORIZATION regress_rls_carol ; 
SET SESSION AUTHORIZATION regress_rls_dave ; 
CREATE POLICY p2 ON x USING ( CASE WHEN CURRENT_USER = 'x' THEN x IN ( 1 , 1 ) WHEN CURRENT_USER = 'x' THEN x IN ( 1 , 1 ) ELSE FALSE END ) ; 
SET row_security TO OFF ; 
SET SESSION AUTHORIZATION regress_rls_exempt_user ; 
CREATE TABLE x ( x INT NOT NULL PRIMARY KEY , x INT , x TEXT , x TEXT ) ; 
COPY x FROM STDIN WITH ; 
COPY x ( x , x , x , x ) FROM STDIN ; 
EXPLAIN ( COSTS OFF ) SELECT * , x FROM x ; 
SELECT * , x FROM x ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x FOR SHARE ; 
SELECT * FROM x WHERE x ( x ) FOR SHARE ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x ( x ) FOR SHARE ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) , ( 1 , 1 , 1 , 'x' , 'x' ) ; 
CREATE POLICY pp1 ON x AS PERMISSIVE USING ( x <= ( SELECT x FROM x WHERE x = CURRENT_USER ) ) ; 
CREATE POLICY pp1r ON x AS RESTRICTIVE TO x USING ( x < 1 ) ; 
SELECT * FROM x WHERE x = 'x' AND x LIKE 'x' ORDER BY x ; 
SELECT * FROM x WHERE x ( x ) ORDER BY x ; 
CREATE POLICY pp3 ON x AS RESTRICTIVE USING ( x < 1 ) ; 
ALTER POLICY pp1 ON x USING ( x = CURRENT_USER ) ; 
CREATE POLICY pp3 ON x AS RESTRICTIVE USING ( ( SELECT x <= x FROM x WHERE x = CURRENT_USER ) ) ; 
CREATE POLICY d1 ON x FOR ALL TO x USING ( x = ( SELECT x . x FROM x d WHERE x . x = x ) ) ; 
CREATE POLICY r1 ON x USING ( x = ( SELECT x . x FROM x r WHERE x = x . x ) ) ; 
ALTER POLICY r1 ON x USING ( x = ( SELECT x FROM x WHERE x = x ) ) ; 
CREATE POLICY r2 ON x USING ( x = ( SELECT x FROM x WHERE x = x ) ) ; 
ALTER POLICY r2 ON x USING ( x = ( SELECT x FROM x WHERE x = x ) ) ; 
DROP VIEW x , x CASCADE ; 
CREATE VIEW x WITH ( security_barrier ) AS SELECT * FROM x ; 
CREATE POLICY r1 ON x USING ( x = ( SELECT x FROM x WHERE x = x ) ) ; 
GRANT SELECT ON x , x TO x ; 
CREATE POLICY p1 ON x USING ( x IN ( SELECT x FROM x WHERE x LIKE 'x' ) ) ; 
CREATE POLICY p2 ON x USING ( x IN ( SELECT x FROM x WHERE x LIKE 'x' ) ) ; 
CREATE POLICY p3 ON x FOR INSERT WITH CHECK ( x = ( SELECT x FROM x ) ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE x LIKE 'x' ; 
DROP POLICY p3 ON s1 ; 
ALTER POLICY p2 ON x USING ( x % 1 = 1 ) ; 
SELECT ( SELECT x FROM x LIMIT 1 ) xx , * FROM x WHERE x LIKE 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT ( SELECT x FROM x LIMIT 1 ) xx , * FROM x WHERE x LIKE 'x' ; 
ALTER POLICY p2 ON x USING ( x IN ( SELECT x FROM x WHERE x LIKE 'x' ) ) ; 
EXECUTE p1 ( 1 ) ; 
EXPLAIN ( COSTS OFF ) EXECUTE p1 ( 1 ) ; 
$PREPARE p2 ( INT ) AS SELECT * FROM x WHERE x = 1 ; 
EXECUTE p2 ( 1 ) ; 
EXPLAIN ( COSTS OFF ) EXECUTE p2 ( 1 ) ; 
EXPLAIN ( COSTS OFF ) UPDATE x SET x = x || x WHERE x ( x ) ; 
UPDATE x SET x = x || x WHERE x ( x ) ; 
EXPLAIN ( COSTS OFF ) UPDATE ONLY x SET x = x || 'x' WHERE x ( x ) ; 
UPDATE ONLY x SET x = x || 'x' WHERE x ( x ) ; 
UPDATE x SET x = x WHERE x ( x ) RETURNING * ; 
SELECT * FROM x ORDER BY x , x ; 
EXPLAIN ( COSTS OFF ) DELETE FROM ONLY x WHERE x ( x ) ; 
EXPLAIN ( COSTS OFF ) DELETE FROM x WHERE x ( x ) ; 
CREATE POLICY p1 ON x USING ( x % 1 = 1 ) ; 
CREATE VIEW x WITH ( security_barrier ) AS SELECT * FROM x WHERE x > 1 WITH CHECK OPTION ; 
UPDATE x SET x = 'x' WHERE x = 1 AND x ( x ) ; 
EXPLAIN ( COSTS OFF ) DELETE FROM x WHERE x = 1 AND x ( x ) ; 
DELETE FROM x WHERE x = 1 AND x ( x ) ; 
GRANT SELECT ON x , x TO x , x , x , x ; 
CREATE POLICY p1 ON x TO x USING ( x % 1 = 1 ) ; 
CREATE POLICY p2 ON x TO x USING ( x % 1 = 1 ) ; 
PREPARE plancache_test AS SELECT * FROM x WHERE x ( x ) ; 
EXPLAIN ( COSTS OFF ) EXECUTE plancache_test ; 
PREPARE plancache_test2 AS WITH q AS MATERIALIZED ( SELECT * FROM x WHERE x ( x ) ) SELECT * FROM x , x ; 
EXPLAIN ( COSTS OFF ) EXECUTE plancache_test2 ; 
PREPARE plancache_test3 AS WITH q AS MATERIALIZED ( SELECT * FROM x ) SELECT * FROM x , x WHERE x ( x . x ) ; 
EXPLAIN ( COSTS OFF ) EXECUTE plancache_test3 ; 
SET ROLE regress_rls_group1 ; 
SET ROLE regress_rls_group2 ; 
CREATE VIEW x AS SELECT * FROM x WHERE x ( x ) ; 
CREATE TABLE x ( x INT , x TEXT , x TEXT ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) ; 
CREATE POLICY p0 ON x FOR ALL USING ( x = CURRENT_USER ) ; 
CREATE POLICY p1 ON x FOR SELECT USING ( x % 1 = 1 ) ; 
CREATE POLICY p2 ON x FOR INSERT WITH CHECK ( x % 1 = 1 ) ; 
CREATE POLICY p3 ON x FOR UPDATE USING ( x % 1 = 1 ) ; 
CREATE POLICY p4 ON x FOR DELETE USING ( x < 1 ) ; 
SELECT * FROM x WHERE x ( x ) ORDER BY x ASC ; 
UPDATE x SET x = x || 'x' WHERE x ( x ) RETURNING * ; 
DELETE FROM x WHERE x ( x ) RETURNING * ; 
CREATE POLICY p1 ON x FOR ALL USING ( x % 1 = 1 ) ; 
CREATE POLICY p2 ON x FOR SELECT USING ( x > 1 ) ; 
CREATE VIEW x WITH ( security_barrier ) AS SELECT * FROM x WHERE x ( x ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE ( x = 1 ) ; 
CREATE POLICY p2 ON x USING ( x % 1 = 1 ) ; 
CREATE POLICY p3 ON x USING ( x % 1 = 1 ) ; 
SELECT * FROM x WHERE x ( 'x' ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x ( 'x' ) ; 
SELECT * FROM x JOIN x ON ( x = x ) WHERE x ( x ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x JOIN x ON ( x = x ) WHERE x ( x ) ; 
CREATE POLICY p1 ON x TO x USING ( ( x % 1 ) = 1 ) ; 
CREATE POLICY p2 ON x TO x USING ( ( x % 1 ) = 1 ) ; 
SET ROLE regress_rls_bob ; 
PREPARE role_inval AS SELECT * FROM x ; 
EXPLAIN ( COSTS OFF ) EXECUTE role_inval ; 
SET ROLE regress_rls_carol ; 
WITH cte1 AS MATERIALIZED ( SELECT * FROM x WHERE x ( x ) ) SELECT * FROM x ; 
EXPLAIN ( COSTS OFF ) WITH cte1 AS MATERIALIZED ( SELECT * FROM x WHERE x ( x ) ) SELECT * FROM x ; 
INSERT INTO x ( SELECT * FROM x ) ; 
EXPLAIN ( COSTS OFF ) INSERT INTO x ( SELECT * FROM x ) ; 
CREATE TABLE x ( x INTEGER , x TEXT , x TEXT ) ; 
CREATE POLICY blog_1 ON x USING ( x % 1 = 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) ; 
DROP POLICY p2 ON t1 ; 
GRANT ALL ON x TO x , x ; 
COPY ( SELECT * FROM x ORDER BY x ASC ) TO STDOUT WITH DELIMITER 'x' ; 
INSERT INTO x VALUES ( 1 , x ( 'x' ) ) ; 
COPY x TO STDOUT WITH DELIMITER 'x' ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) ; 
CREATE POLICY p2 ON x FOR DELETE USING ( x = 1 AND x = CURRENT_USER ) ; 
CREATE POLICY p3 ON x FOR UPDATE USING ( x = 1 ) WITH CHECK ( x = CURRENT_USER ) ; 
UPDATE x SET x = x || 'x' WHERE x = 1 RETURNING * ; 
DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM x ; 
FETCH ABSOLUTE 1 FROM current_check_cursor ; 
UPDATE x SET x = x || 'x' WHERE CURRENT OF current_check_cursor RETURNING * ; 
FETCH RELATIVE 1 FROM current_check_cursor ; 
EXPLAIN ( COSTS OFF ) UPDATE x SET x = x WHERE CURRENT OF current_check_cursor ; 
DELETE FROM x WHERE CURRENT OF current_check_cursor RETURNING * ; 
SELECT x , x FROM x WHERE x = 'x' ORDER BY 1 ; 
CREATE POLICY P ON x TO x , x USING ( TRUE ) ; 
SAVEPOINT q ; 
ALTER POLICY p ON x TO x USING ( TRUE ) ; 
DROP POLICY p ON tbl1 ; 
CREATE POLICY p ON x USING ( x % 1 = 1 ) ; 
ALTER TABLE x DISABLE ROW LEVEL SECURITY ; 
DROP POLICY p ON t ; 
CREATE POLICY p1 ON x USING ( TRUE ) ; 
CREATE POLICY p1 ON x FOR SELECT USING ( TRUE ) ; 
CREATE POLICY p2 ON x FOR INSERT WITH CHECK ( FALSE ) ; 
CREATE POLICY p3 ON x FOR UPDATE USING ( FALSE ) ; 
CREATE POLICY p4 ON x FOR DELETE USING ( FALSE ) ; 
SET row_security = ON ; 
SET row_security = off ; 
DROP POLICY p1 ON r2 ; 
ALTER TABLE x NO FORCE ROW LEVEL SECURITY ; 
CREATE TABLE x ( x INT REFERENCES x ON DELETE CASCADE ) ; 
CREATE TABLE x ( x INT REFERENCES x ON UPDATE CASCADE ) ; 
CREATE POLICY p1 ON x FOR SELECT USING ( FALSE ) ; 
CREATE POLICY p2 ON x FOR INSERT WITH CHECK ( TRUE ) ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) RETURNING * ; 
CREATE POLICY p1 ON x FOR SELECT USING ( x < 1 ) ; 
CREATE POLICY p2 ON x FOR UPDATE USING ( x < 1 ) WITH CHECK ( TRUE ) ; 
CREATE POLICY p3 ON x FOR INSERT WITH CHECK ( TRUE ) ; 
UPDATE x SET x = 1 RETURNING * ; 
INSERT INTO x VALUES ( 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 1 RETURNING * ; 
INSERT INTO x VALUES ( 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 1 ; 
INSERT INTO x VALUES ( 1 ) ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET x = 1 ; 
CREATE POLICY dep_p1 ON x TO x USING ( x > ( SELECT x ( x . x ) FROM x ) ) ; 
ALTER POLICY dep_p1 ON x TO x , x ; 
SELECT x ( * ) = 1 FROM x WHERE x = ( SELECT x FROM x WHERE x = 'x' ) AND x = ( SELECT x FROM x WHERE x = 'x' ) ; 
ALTER POLICY dep_p1 ON x USING ( TRUE ) ; 
CREATE POLICY p1 ON x TO x USING ( TRUE ) ; 
CREATE POLICY p1 ON x USING ( EXISTS ( SELECT 1 FROM x ) ) ; 
ALTER VIEW x OWNER TO x ; 
INSERT INTO x SELECT x / 1 FROM x ( 1 , 1 ) x ; 
CREATE FUNCTION x ( INT , INT ) RETURNS bool AS 'x' LANGUAGE plpgsql ; 
DROP FUNCTION x ( INT , INT ) ; 
CREATE POLICY p1 ON x USING ( x >= ROW ( 1 , 1 , 1 ) ) ; 
INSERT INTO x SELECT 1 , 1 , 1 ; 
INSERT INTO x SELECT * FROM ( SELECT x , x FROM x ORDER BY x ) ss ; 
DROP SCHEMA regress_rls_schema CASCADE ; 
CREATE POLICY p1 ON x USING ( x > 1 ) ; 
CREATE POLICY p2 ON x FOR SELECT USING ( x <= 1 ) ; 
CREATE POLICY p3 ON x FOR UPDATE USING ( x <= 1 ) WITH CHECK ( x > 1 ) ; 
CREATE POLICY p4 ON x FOR DELETE USING ( x <= 1 ) ; 
CREATE POLICY p1 ON x USING ( x = 1 ) WITH CHECK ( x < 1 ) ; 
CREATE POLICY p2 ON x FOR SELECT USING ( x = 1 ) ; 
CREATE POLICY p3 ON x FOR UPDATE USING ( x = 1 ) WITH CHECK ( x >= 1 ) ; 
CREATE POLICY p4 ON x FOR DELETE USING ( x = 1 ) ; 
$$CREATE FUNCTION x ( internal , oid , internal , INTEGER ) RETURNS float8 AS 'x' LANGUAGE internal STABLE STRICT ; 
__ALTER OPERATOR & ( BIT , BIT ) SET ( Restrict" = int_contsel , Join" = int_contjoinsel ) ; 
SET SESSION AUTHORIZATION regress_alter_op_user ; 
DROP FUNCTION x ( internal , oid , internal , INTEGER ) ; 
DROP FUNCTION x ( BOOLEAN , BOOLEAN ) ; 
SET plan_cache_mode = force_generic_plan ; 
CREATE TABLE x ( x CHAR ) PARTITION BY list ( a ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x > 'x' AND x < 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x > 'x' AND x <= 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 'x' OR x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NOT NULL AND ( x = 'x' OR x = 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x NOT IN ( 'x' , 'x' ) ; 
CREATE TABLE x ( x TEXT COLLATE C" ) PARTITION BY list ( a ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x COLLATE C" = 'x' COLLATE C" ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x COLLATE POSIX" = 'x' COLLATE POSIX" ; 
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY list ( a ) ; 
CREATE TABLE x ( x VARCHAR , x INT ) PARTITION BY list ( b varchar_ops ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x > 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x <= 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x > 1 AND x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x IN ( 'x' , 'x' , 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x <= 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x IS NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x IS NOT NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 OR x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 OR x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x > 1 AND x < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x < 1 OR ( x > 1 AND x < 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x ( x ) < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x ( x ) = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x ( x ) = 1 AND x < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x ( x ) BETWEEN 1 AND 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x <= 1 AND x ( x ) < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x ( x ) = 1 AND x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x = 1 AND x ( x ) = 1 AND x = 1 ) OR ( x = 1 AND x ( x ) = 1 AND x = 1 ) OR ( x > 1 AND x < 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x = 1 AND x ( x ) = 1 AND x = 1 ) OR ( x = 1 AND x ( x ) = 1 AND x = 1 ) OR ( x > 1 AND x < 1 ) OR x < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x = 1 AND x ( x ) = 1 AND x = 1 ) OR ( x = 1 AND x ( x ) = 1 AND x = 1 ) OR ( x > 1 AND x < 1 ) OR x < 1 OR x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 OR x ( x ) = 1 OR x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x = 1 AND x ( x ) = 1 ) OR ( x = 1 AND x ( x ) = 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x < 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = 1 AND x > 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NULL AND x IS NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NULL AND x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IN ( TRUE , FALSE ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = FALSE ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE NOT x = FALSE ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS TRUE OR x IS NOT TRUE ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NOT TRUE ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NOT TRUE AND x IS NOT FALSE ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS UNKNOWN ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NOT UNKNOWN ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' , 'x' , 1 ) TO ( 'x' , 'x' , 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE NOT x AND NOT x AND x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IN ( 'x' , x ( 1 , 'x' ) ) ; 
~~EXPLAIN ( costs off ) SELECT * FROM x WHERE x ! ALL ( 'x' ) ; 
~~EXPLAIN ( costs off ) SELECT * FROM x WHERE x = ANY ( 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = ALL ( 'x' ) ; 
CREATE TABLE x ( x INT , x INT ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 , 1 , 1 , 1 , 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x t1 , LATERAL ( SELECT x ( * ) FROM x t2 WHERE x . x = x . x AND x ( x . x ) = 1 AND x . x = 1 ) s WHERE x . x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x t1 , LATERAL ( SELECT x ( * ) FROM x t2 WHERE x . x = 1 AND x ( x . x ) = 1 AND x . x = 1 ) s WHERE x . x = 1 ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' , 'x' ) TO ( 'x' , 'x' ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x ( x , 1 ) = 'x' COLLATE C" ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x ( x , 1 ) = 'x' COLLATE POSIX" ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x ( x , 1 ) = 'x' COLLATE C" AND x ( x , 1 ) = 'x' COLLATE POSIX" ; 
CREATE TABLE x ( x TEXT ) PARTITION BY list ( a ) ; 
CREATE TABLE x ( x SMALLINT ) PARTITION BY list ( a ) ; 
DROP TABLE x , x , x , x , x , x , x , x , x , x , x , x ; 
CREATE TABLE x ( x INT , x TEXT ) PARTITION BY hash ( a part_test_int4_ops , b part_test_text_ops ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x < 1 AND x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IS NULL AND x = 'x' ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE ( x = 1 AND x = 'x' ) OR ( x = 1 AND x = 'x' ) OR ( x IS NULL AND x IS NULL ) ; 
CREATE TABLE x ( x INT NOT NULL , x INT NOT NULL ) PARTITION BY list ( a ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ab_q1 ( 1 , 1 , 1 ) ; 
DEALLOCATE ab_q1 ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ab_q1 ( 1 , 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ab_q2 ( 1 , 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ab_q3 ( 1 , 1 ) ; 
DECLARE cur SCROLL CURSOR FOR SELECT 1 FROM x WHERE x > ( SELECT 1 ) AND x < ( SELECT 1 ) ; 
MOVE 1 FROM cur ; 
FETCH BACKWARD ALL FROM cur ; 
$$EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x WHERE x = x ( 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x WHERE x = x ( x ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x WHERE x = x ( 1 ) + x ; 
$$INSERT INTO x SELECT 1 FROM x ( 1 , 1 ) ; 
RESET parallel_tuple_cost ; 
RESET max_parallel_workers_per_gather ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM ( SELECT * FROM x WHERE x = 1 UNION ALL SELECT * FROM x ) ab WHERE x = ( SELECT 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM ( SELECT * FROM x WHERE x = 1 UNION ALL ( VALUES ( 1 , 1 ) ) UNION ALL SELECT * FROM x ) ab WHERE x = ( SELECT 1 ) ; 
SET enable_indexscan = 1 ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ab_q6 ( 1 ) ; 
EXECUTE ab_q6 ( 1 ) ; 
DEALLOCATE ab_q2 ; 
DEALLOCATE ab_q3 ; 
DEALLOCATE ab_q4 ; 
DEALLOCATE ab_q5 ; 
DEALLOCATE ab_q6 ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) UPDATE x SET x = 1 FROM x WHERE x . x = 1 AND x . x = x . x ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) UPDATE x SET x = 1 FROM x WHERE x . x = ( SELECT 1 ) ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ; 
SET enable_hashjoin = off ; 
SET enable_mergejoin = off ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x JOIN x ON x . x > x . x ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x JOIN x ON x . x = x . x ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x INNER JOIN x ON x . x > x . x ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x INNER JOIN x ON x . x = x . x ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x JOIN x ON x . x < x . x ; 
CREATE TABLE x ( x INT NOT NULL , x INT NOT NULL , x INT NOT NULL ) PARTITION BY list ( a ) ; 
CREATE TABLE x ( x INT NOT NULL , x INT NOT NULL , x INT NOT NULL ) PARTITION BY list ( b ) ; 
CREATE TABLE x ( x INT NOT NULL , x INT NOT NULL , x INT NOT NULL ) PARTITION BY list ( c ) ; 
CREATE TABLE x ( x INT NOT NULL , x INT NOT NULL , x INT NOT NULL ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE part_abc_q1 ( 1 , 1 , 1 ) ; 
DEALLOCATE part_abc_q1 ; 
$$PREPARE q1 ( INT , INT ) AS SELECT * FROM x WHERE x IN ( 1 , 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE q1 ( 1 , 1 ) ; 
DEALLOCATE q1 ; 
$$$EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE q1 ( 1 , 1 , 1 , 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x WHERE x < LOCALTIMESTAMP ; 
INSERT INTO x VALUES ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) , ( 1 , 1 , 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x WHERE x < 1 AND x ( x ) = 1 ; 
$PREPARE ps1 AS SELECT * FROM x WHERE x = 1 AND x ( x ) < ( SELECT 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ps1 ( 1 ) ; 
DEALLOCATE ps1 ; 
$PREPARE ps2 AS SELECT * FROM x WHERE x <= 1 AND x ( x ) < ( SELECT 1 ) ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE ps2 ( 1 ) ; 
DEALLOCATE ps2 ; 
INSERT INTO x SELECT x , x FROM x ( 1 , 1 ) t ( x ) ; 
$PREPARE mt_q1 ( INT ) AS SELECT x FROM x WHERE x >= 1 AND x % 1 = 1 ORDER BY x ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) EXECUTE mt_q1 ( 1 ) ; 
EXECUTE mt_q1 ( 1 ) ; 
DEALLOCATE mt_q1 ; 
EXPLAIN ( ANALYZE , costs off , summary off , timing off ) SELECT * FROM x WHERE x >= ( SELECT x ( x ) FROM x ) ORDER BY x ; 
CREATE TABLE x ( x INT [ ] ) PARTITION BY list ( a ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x IN ( 'x' , 'x' ) ; 
EXPLAIN ( costs off ) UPDATE x SET x = x WHERE x = 'x' ; 
EXPLAIN ( costs off ) DELETE FROM x WHERE x = 'x' ; 
CREATE TABLE x ( x INT [ ] ) PARTITION BY hash ( a ) ; 
INSERT INTO x VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ; 
CREATE TYPE pp_colors AS ENUM ( 'x' , 'x' , 'x' ) ; 
CREATE TABLE x ( x pp_colors ) PARTITION BY list ( a ) ; 
DROP TYPE pp_colors ; 
CREATE TYPE pp_rectype AS ( a INT , b INT ) ; 
CREATE TABLE x ( x pp_rectype ) PARTITION BY list ( a ) ; 
DROP TYPE pp_rectype ; 
CREATE TABLE x ( x int4range ) PARTITION BY list ( a ) ; 
SET enable_partition_pruning = off ; 
SET constraint_exclusion = 'x' ; 
RESET enable_partition_pruning ; 
CREATE TEMP TABLE x PARTITION OF x DEFAULT ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE TRUE ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT ) PARTITION BY list ( a ) ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( b ) ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( c ) ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT 1 , 1 , 1 ) s ( a , b , c ) WHERE x . x = 1 AND x . x = 1 AND x . x = ( SELECT 1 ) ; 
SELECT * FROM ( SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT 1 , 1 , 1 ) s ( a , b , c ) WHERE x . x = 1 AND x . x = 1 AND x . x = ( SELECT 1 ) ; 
EXPLAIN ( costs off ) EXECUTE q ( 1 , 1 ) ; 
EXECUTE q ( 1 , 1 ) ; 
SET enable_partition_pruning TO off ; 
COPY ( INSERT INTO x ( x ) VALUES ( 'x' ) RETURNING x ) TO STDOUT ; 
COPY ( UPDATE x SET x = 'x' WHERE x = 'x' RETURNING x ) TO STDOUT ; 
COPY ( DELETE FROM x WHERE x = 'x' RETURNING x ) TO STDOUT ; 
\\\COPY ( INSERT INTO x DEFAULT VALUES ) TO STDOUT ; 
COPY ( UPDATE x SET x = 'x' ) TO STDOUT ; 
COPY ( DELETE FROM x ) TO STDOUT ; 
CREATE RULE qqq AS ON INSERT TO x DO INSTEAD NOTHING ; 
DROP RULE qqq ON copydml_test ; 
CREATE RULE qqq AS ON INSERT TO x DO ALSO DELETE FROM x ; 
CREATE RULE qqq AS ON INSERT TO x DO INSTEAD ( DELETE FROM x ; DELETE FROM x ) ; 
CREATE RULE qqq AS ON UPDATE TO x DO INSTEAD NOTHING ; 
CREATE RULE qqq AS ON UPDATE TO x DO ALSO DELETE FROM x ; 
CREATE RULE qqq AS ON UPDATE TO x DO INSTEAD ( DELETE FROM x ; DELETE FROM x ) ; 
CREATE RULE qqq AS ON DELETE TO x DO INSTEAD NOTHING ; 
CREATE RULE qqq AS ON DELETE TO x DO ALSO INSERT INTO x DEFAULT VALUES ; 
CREATE RULE qqq AS ON DELETE TO x DO INSTEAD ( INSERT INTO x DEFAULT VALUES ; INSERT INTO x DEFAULT VALUES ) ; 
$$CREATE TRIGGER x BEFORE INSERT OR UPDATE OR DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
VACUUM ; 
\\CREATE TEMP TABLE x ( x INTEGER , x txid_snapshot ) ; 
SELECT x ( x ) , x ( x ) , x ( x ) FROM x ORDER BY x ; 
SELECT x ( ) >= x ( x ( ) ) ; 
SELECT x ( x ( ) , x ( ) ) ; 
SELECT x ( ) IS NULL ; 
\\\$$CREATE TABLE x ( x BIT ( 1 ) ) ; 
INSERT INTO x VALUES ( x 'x' ) ; 
CREATE TABLE x ( x BIT VARYING ( 1 ) ) ; 
SELECT x , x , ( x || x ) AS concat FROM x , x ORDER BY 1 ; 
SELECT x , x ( x ) AS lb FROM x ; 
SELECT x , x ( x ) AS lv FROM x ; 
SELECT x , SUBSTRING ( x FROM 1 FOR 1 ) AS sub_2_4 , SUBSTRING ( x FROM 1 FOR 1 ) AS sub_7_13 , SUBSTRING ( x FROM 1 ) AS sub_6 FROM x ; 
CREATE TABLE x ( x BIT VARYING ( 1 ) , x BIT VARYING ( 1 ) ) ; 
CREATE TABLE x ( x BIT ( 1 ) , x BIT ( 1 ) ) ; 
SELECT x 'x' & x 'x' ; 
SELECT x 'x' | x 'x' ; 
#SELECT POSITION ( x 'x' IN x ) , POSITION ( x 'x' IN x ) , x FROM x ; 
SELECT x ( x 'x' , 1 , 1 ) ; 
SELECT OVERLAY ( x 'x' PLACING 'x' FROM 1 ) ; 
CREATE TABLE x ( x BIT ( 1 ) DEFAULT 'x' , x BIT ( 1 ) DEFAULT x 'x' , x BIT VARYING ( 1 ) DEFAULT 'x' , x BIT VARYING ( 1 ) DEFAULT x 'x' ) ; 
SELECT x , x ( x ) FROM ( VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) ) x ( size ) ; 
SELECT x , x ( x ) FROM ( VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) ) x ( size ) ; 
CREATE TABLE x ( x int4 [ ] ) WITH ( autovacuum_enabled = off ) ; 
INSERT INTO x SELECT ARRAY [ 1 , 1 , x ] FROM x ( 1 , 1 ) g ; 
ALTER INDEX x SET ( fastupdate = off ) ; 
@DELETE FROM x WHERE x > ARRAY [ 1 ] ; 
DROP TABLESPACE x ; 
CREATE TABLESPACE x LOCATION 'x' ; 
ALTER TABLESPACE regress_tblspace SET ( random_page_cost = 1.000000 , seq_page_cost = 1.000000 ) ; 
CREATE TABLE x . foo ( x INT ) TABLESPACE x ; 
SELECT x , x FROM x . pg_tablespace t , x . pg_class c WHERE x . x = x . x AND x . x = 'x' ; 
INSERT INTO x . foo VALUES ( 1 ) ; 
CREATE TABLE x . asselect TABLESPACE x AS SELECT 1 ; 
$PREPARE selectsource ( INT ) AS SELECT 1 ; 
CREATE TABLE x . asexecute TABLESPACE x AS EXECUTE selectsource ( 1 ) ; 
CREATE INDEX x ON x . foo ( x ) TABLESPACE x ; 
CREATE TABLE x . part ( x INT ) PARTITION BY LIST ( a ) ; 
SET default_tablespace TO pg_global ; 
CREATE TABLE x . part_1 PARTITION OF x . part FOR VALUES IN ( 1 ) ; 
RESET default_tablespace ; 
SET default_tablespace TO regress_tblspace ; 
CREATE TABLE x . part_2 PARTITION OF x . part FOR VALUES IN ( 1 ) ; 
CREATE TABLE x . part_3 PARTITION OF x . part FOR VALUES IN ( 1 ) ; 
ALTER TABLE x . part SET TABLESPACE regress_tblspace ; 
CREATE TABLE x . part_4 PARTITION OF x . part FOR VALUES IN ( 1 ) TABLESPACE x ; 
CREATE TABLE x . part_56 PARTITION OF x . part FOR VALUES IN ( 1 , 1 ) PARTITION BY LIST ( a ) ; 
ALTER TABLE x . part SET TABLESPACE pg_default ; 
CREATE TABLE x . part_78 PARTITION OF x . part FOR VALUES IN ( 1 , 1 ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x . part_910 PARTITION OF x . part FOR VALUES IN ( 1 , 1 ) PARTITION BY LIST ( a ) TABLESPACE x ; 
SELECT x , x FROM x . pg_class c JOIN x . pg_namespace n ON ( x . x = x . x ) LEFT JOIN x . pg_tablespace t ON x . x = x . x WHERE x . x LIKE 'x' AND x . x = 'x' ORDER BY x ; 
DROP TABLE x . part ; 
CREATE TABLE x . part1 PARTITION OF x . part FOR VALUES IN ( 1 ) ; 
CREATE INDEX x ON x . part ( x ) TABLESPACE x ; 
CREATE TABLE x . part2 PARTITION OF x . part FOR VALUES IN ( 1 ) ; 
SELECT x , x FROM x . pg_tablespace t , x . pg_class c WHERE x . x = x . x AND x . x LIKE 'x' ; 
CREATE TABLE x . dflt ( x INT PRIMARY KEY ) PARTITION BY LIST ( a ) TABLESPACE x ; 
CREATE TABLE x . dflt ( x INT PRIMARY KEY USING INDEX TABLESPACE pg_default ) PARTITION BY LIST ( a ) ; 
SET default_tablespace TO 'x' ; 
CREATE TABLE x . dflt ( x INT PRIMARY KEY USING INDEX TABLESPACE regress_tblspace ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x . dflt ( x INT PRIMARY KEY USING INDEX TABLESPACE regress_tblspace ) PARTITION BY LIST ( a ) TABLESPACE x ; 
CREATE TABLE x . dflt2 ( x INT PRIMARY KEY ) PARTITION BY LIST ( a ) ; 
DROP TABLE x . dflt , x . dflt2 ; 
CREATE TABLE x . test_default_tab ( x BIGINT ) TABLESPACE x ; 
INSERT INTO x . test_default_tab VALUES ( 1 ) ; 
CREATE INDEX x ON x . test_default_tab ( x ) ; 
CREATE INDEX x ON x . test_default_tab ( x ) TABLESPACE x ; 
ALTER TABLE x . test_default_tab ADD CONSTRAINT test_index3 PRIMARY KEY ( x ) ; 
ALTER TABLE x . test_default_tab ADD CONSTRAINT test_index4 UNIQUE ( x ) USING INDEX TABLESPACE regress_tblspace ; 
ALTER TABLE x . test_default_tab ALTER x TYPE BIGINT ; 
SELECT * FROM x . test_default_tab ; 
ALTER TABLE x . test_default_tab ALTER x TYPE INT ; 
DROP TABLE x . test_default_tab ; 
CREATE TABLE x . test_default_tab_p ( x BIGINT , x BIGINT ) PARTITION BY LIST ( id ) TABLESPACE x ; 
CREATE TABLE x . test_default_tab_p1 PARTITION OF x . test_default_tab_p FOR VALUES IN ( 1 ) ; 
INSERT INTO x . test_default_tab_p VALUES ( 1 ) ; 
CREATE INDEX x ON x . test_default_tab_p ( x ) ; 
CREATE INDEX x ON x . test_default_tab_p ( x ) TABLESPACE x ; 
ALTER TABLE x . test_default_tab_p ADD CONSTRAINT test_index3 PRIMARY KEY ( x ) ; 
ALTER TABLE x . test_default_tab_p ADD CONSTRAINT test_index4 UNIQUE ( x ) USING INDEX TABLESPACE regress_tblspace ; 
ALTER TABLE x . test_default_tab_p ALTER x TYPE BIGINT ; 
SELECT * FROM x . test_default_tab_p ; 
ALTER TABLE x . test_default_tab_p ALTER x TYPE INT ; 
DROP TABLE x . test_default_tab_p ; 
CREATE TABLE x . test_tab ( x INT ) TABLESPACE x ; 
INSERT INTO x . test_tab VALUES ( 1 ) ; 
ALTER TABLE x . test_tab ADD CONSTRAINT test_tab_unique UNIQUE ( x ) ; 
ALTER TABLE x . test_tab ADD CONSTRAINT test_tab_pkey PRIMARY KEY ( x ) ; 
SELECT * FROM x . test_tab ; 
DROP TABLE x . test_tab ; 
CREATE TABLE x . test_tab ( x INT , x INT , x INT ) ; 
CREATE INDEX x ON x . test_tab ( x ) ; 
ALTER TABLE x . test_tab ALTER x TYPE BIGINT , ADD UNIQUE ( x ) ; 
CREATE TABLE x . atable AS VALUES ( 1 ) , ( 1 ) ; 
CREATE UNIQUE INDEX x ON x . atable ( x ) ; 
ALTER TABLE x . atable SET TABLESPACE regress_tblspace ; 
CREATE TABLE x ( x INT ) TABLESPACE x ; 
CREATE ROLE x login ; 
GRANT USAGE ON SCHEMA testschema TO x ; 
ALTER TABLESPACE regress_tblspace OWNER TO x ; 
CREATE TABLE x . tablespace_acl ( x INT ) ; 
CREATE INDEX x ON x . tablespace_acl ( x ) TABLESPACE x ; 
ALTER TABLE x . tablespace_acl OWNER TO x ; 
SET SESSION ROLE regress_tablespace_user2 ; 
ALTER TABLESPACE x RENAME TO x ; 
ALTER TABLE ALL IN TABLESPACE x SET TABLESPACE x ; 
ALTER INDEX ALL IN TABLESPACE x SET TABLESPACE x ; 
DROP SCHEMA testschema CASCADE ; 
SET search_path = collate_tests ; 
CREATE TABLE x ( x INT , x TEXT COLLATE C" NOT NULL ) ; 
CREATE TABLE x ( x INT COLLATE C" , x TEXT ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE POSIX" ) ; 
SELECT * FROM x WHERE x COLLATE C" >= 'x' ; 
SELECT * FROM x WHERE x >= 'x' COLLATE C" ; 
SELECT * FROM x WHERE x COLLATE C" >= 'x' COLLATE C" ; 
CREATE TABLE x ( x INT , x testdomain_p COLLATE C" ) ; 
SELECT x , x FROM x ORDER BY x COLLATE C" ; 
SELECT 'x' COLLATE C" > 'x' COLLATE C" AS true" ; 
SELECT 'x' COLLATE POSIX" < 'x' COLLATE POSIX" AS false" ; 
CREATE TABLE x ( x INT , x TEXT COLLATE C" , x TEXT COLLATE POSIX" ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) ; 
SELECT x , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) FROM x ; 
SELECT x , x ( x COLLATE C" ) , x ( x COLLATE C" ) FROM x ; 
SELECT x , x , x FROM x ORDER BY x ( x ) , x ; 
CREATE VIEW x AS SELECT * FROM x WHERE x COLLATE C" >= 'x' ; 
CREATE VIEW x AS SELECT x , x FROM x ORDER BY x COLLATE C" ; 
CREATE VIEW x AS SELECT x , x ( ( x || x ) COLLATE POSIX" ) FROM x ; 
SELECT x , COALESCE ( x , 'x' ) FROM x ORDER BY 1 ; 
SELECT x , x ( COALESCE ( x , 'x' ) ) , x ( COALESCE ( x , 'x' ) ) FROM x ; 
SELECT x , x , GREATEST ( x , 'x' ) FROM x ORDER BY 1 ; 
SELECT x , x , x , x ( GREATEST ( x , 'x' ) ) , x ( GREATEST ( x , 'x' ) ) FROM x ; 
SELECT x , NULLIF ( x , 'x' ) FROM x ORDER BY 1 ; 
SELECT x , x ( NULLIF ( x , 'x' ) ) , x ( NULLIF ( x , 'x' ) ) FROM x ; 
SELECT x , CASE x WHEN 'x' THEN 'x' ELSE x END FROM x ORDER BY 1 ; 
CREATE DOMAIN testdomain AS TEXT ; 
SELECT x ( x ORDER BY x ) FROM x ; 
SELECT x ( x ORDER BY x COLLATE C" , x COLLATE POSIX" ) FROM x ; 
SELECT x , x FROM x UNION SELECT x , x FROM x ORDER BY 1 ; 
SELECT x , x FROM x WHERE x < 1 INTERSECT SELECT x , x FROM x WHERE x > 1 ORDER BY 1 ; 
SELECT x , x FROM x EXCEPT SELECT x , x FROM x WHERE x < 1 ORDER BY 1 ; 
SELECT x , x , x < x AS lt FROM ( VALUES ( 'x' , 'x' ) , ( 'x' , 'x' COLLATE C" ) ) v ( a , b ) ; 
SELECT * FROM x WHERE ( x , x ) NOT IN ( SELECT x , x FROM x ) ; 
SELECT * FROM x WHERE ( x COLLATE POSIX" , x COLLATE C" ) NOT IN ( SELECT x , x FROM x ) ; 
SELECT * FROM x WHERE ( x , x ) NOT IN ( SELECT x COLLATE C" , x COLLATE POSIX" FROM x ) ; 
SELECT x , CAST ( x AS VARCHAR ) FROM x ORDER BY 1 ; 
SELECT * FROM x ( ( SELECT x ( x ORDER BY x ) FROM x ) ) ORDER BY 1 ; 
SELECT x , x ( x ) FROM x ORDER BY 1 ; 
CREATE INDEX x ON x ( x COLLATE POSIX" ) ; 
SET enable_seqscan TO 1 ; 
CREATE TABLE x ( x TEXT COLLATE C" PRIMARY KEY ) ; 
CREATE TABLE x ( x TEXT COLLATE POSIX" REFERENCES x ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x ORDER BY x , x ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x ORDER BY x DESC , x COLLATE C" ASC NULLS FIRST ; 
CREATE COLLATION mycoll1 FROM C" ; 
CREATE COLLATION mycoll2 ( LC_COLLATE = POSIX" , LC_CTYPE = POSIX" ) ; 
CREATE TABLE x ( x TEXT COLLATE mycoll2 ) ; 
CREATE TEMP TABLE x ( x VARCHAR ( 1 ) ) ; 
INSERT INTO x VALUES ( 'x' COLLATE C" ) ; 
DROP SCHEMA collate_tests CASCADE ; 
INSERT INTO x VALUES ( 1 , 1.000000 ) ; 
SELECT 'x' AS One" , CASE WHEN 1 < 1 THEN 1 END AS Simple WHEN" ; 
SELECT 'x' AS One" , CASE WHEN 1 > 1 THEN 1 END AS Simple default" ; 
SELECT 'x' AS One" , CASE WHEN 1 < 1 THEN 1 ELSE 1 END AS Simple ELSE" ; 
SELECT 'x' AS One" , CASE WHEN 1 > 1 THEN 1 ELSE 1 END AS ELSE default" ; 
SELECT 'x' AS One" , CASE WHEN 1 > 1 THEN 1 WHEN 1 < 1 THEN 1 ELSE 1 END AS Two WHEN with default" ; 
SELECT 'x' AS None" , CASE WHEN x ( ) < 1 THEN 1 END AS NULL on no matches" ; 
SELECT CASE WHEN 1 = 1 THEN 1 / 1 WHEN 1 = 1 THEN 1 ELSE 1 / 1 END ; 
SELECT CASE 1 WHEN 1 THEN 1 / 1 WHEN 1 THEN 1 ELSE 1 / 1 END ; 
SELECT CASE WHEN x > 1 THEN 1 / 1 ELSE 1 END FROM x ; 
SELECT CASE 'x' WHEN 'x' THEN 1 ELSE 1 END ; 
SELECT 'x' AS Five" , CASE WHEN x >= 1 THEN x END AS >= 3 or Null" FROM x ; 
SELECT 'x' AS Five" , CASE WHEN x >= 1 THEN ( x + x ) ELSE x END AS Simplest Math" FROM x ; 
SELECT 'x' AS Five" , x AS Value" , CASE WHEN ( x < 1 ) THEN 'x' WHEN ( x = 1 ) THEN 'x' WHEN ( x = 1 ) THEN 'x' WHEN ( x = 1 ) THEN 'x' ELSE 'x' END AS Category" FROM x ; 
SELECT 'x' AS Five" , CASE WHEN ( ( x < 1 ) OR ( x < 1 ) ) THEN 'x' WHEN ( ( x = 1 ) OR ( x = 1 ) ) THEN 'x' WHEN ( ( x = 1 ) OR ( x = 1 ) ) THEN 'x' WHEN ( ( x = 1 ) OR ( x = 1 ) ) THEN 'x' ELSE 'x' END AS Category" FROM x ; 
SELECT * FROM x WHERE COALESCE ( x , x ) = 1 ; 
SELECT * FROM x WHERE NULLIF ( x , x ) = 1 ; 
SELECT COALESCE ( x . x , x . x , x . x ) FROM x a , x b ; 
SELECT * FROM x a , x b WHERE COALESCE ( x . x , x . x , x . x ) = 1 ; 
SELECT 'x' AS Five , NULLIF ( x . x , x . x ) AS NULLIF(a.i,b.i)" , NULLIF ( x . x , 1 ) AS NULLIF(b.i,4)" FROM x a , x b ; 
SELECT 'x' AS Two" , * FROM x a , x b WHERE COALESCE ( x , x . x ) = 1 ; 
UPDATE x SET x = CASE WHEN x >= 1 THEN ( - x ) ELSE ( 1 * x ) END ; 
UPDATE x SET x = CASE WHEN x >= 1 THEN ( 1 * x ) ELSE ( 1 * x ) END ; 
UPDATE x SET x = CASE WHEN x . x >= 1 THEN ( 1 * x ) ELSE ( 1 * x ) END FROM x b WHERE x = - x . x ; 
CREATE FUNCTION x ( TEXT ) RETURNS TEXT AS 'x' LANGUAGE plpgsql VOLATILE ; 
SELECT CASE ( CASE x ( 'x' ) WHEN 'x' THEN 'x' WHEN x ( NULL ) THEN 'x' WHEN 'x' THEN 'x' END ) WHEN 'x' THEN 'x' WHEN 'x' THEN 'x' ELSE 'x' END ; 
CREATE DOMAIN foodomain AS TEXT ; 
CREATE FUNCTION x ( TEXT ) RETURNS foodomain AS 'x' LANGUAGE plpgsql VOLATILE ; 
CREATE DOMAIN arrdomain AS INT [ ] ; 
CREATE FUNCTION x ( arrdomain , arrdomain ) RETURNS BOOLEAN AS 'x' LANGUAGE plpgsql ; 
CREATE TYPE casetestenum AS ENUM ( 'x' , 'x' , 'x' ) ; 
CREATE ROLE x PASSWORD 'x' ; 
SET password_encryption = 'x' ; 
CREATE ROLE x PASSWORD NULL ; 
SELECT x , x FROM x WHERE x LIKE 'x' ORDER BY x , x ; 
ALTER ROLE x PASSWORD 'x' ; 
SELECT x , x NOT LIKE 'x' AS is_rolpassword_rehashed FROM x WHERE x LIKE 'x' ORDER BY x ; 
CREATE SUBSCRIPTION regress_testsub CONNECTION 'x' PUBLICATION testpub WITH ( create_slot ) ; 
CREATE SUBSCRIPTION regress_testsub CONNECTION 'x' PUBLICATION testpub ; 
COMMENT ON SUBSCRIPTION regress_testsub IS 'x' ; 
SELECT x ( x . x , 'x' ) FROM x s ; 
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'x' PUBLICATION testpub WITH ( slot_name = NONE ) ; 
ALTER SUBSCRIPTION regress_testsub3 ENABLE ; 
ALTER SUBSCRIPTION regress_testsub3 REFRESH PUBLICATION ; 
DROP SUBSCRIPTION regress_testsub3 ; 
ALTER SUBSCRIPTION regress_testsub CONNECTION 'x' ; 
ALTER SUBSCRIPTION regress_testsub SET ( slot_name = 'x' ) ; 
ALTER SUBSCRIPTION regress_doesnotexist CONNECTION 'x' ; 
ALTER SUBSCRIPTION regress_testsub ENABLE ; 
ALTER SUBSCRIPTION regress_testsub DISABLE ; 
SET ROLE regress_subscription_user_dummy ; 
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_dummy ; 
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_foo ; 
ALTER SUBSCRIPTION regress_testsub_foo SET ( synchronous_commit = foobar ) ; 
ALTER SUBSCRIPTION regress_testsub_foo RENAME TO regress_testsub ; 
ALTER SUBSCRIPTION regress_testsub OWNER TO x ; 
ALTER ROLE x SUPERUSER ; 
DROP SUBSCRIPTION regress_testsub ; 
ALTER SUBSCRIPTION regress_testsub SET ( slot_name = NONE ) ; 
DROP SUBSCRIPTION IF EXISTS regress_testsub ; 
DELETE FROM x WHERE x != 1 ; 
ALTER TABLE x CLUSTER ON vaccluster_pkey ; 
CLUSTER x ; 
VACUUM ( DISABLE_PAGE_SKIPPING ) x ; 
INSERT INTO x ( x , x ) VALUES ( x ( 1 , 1 ) , x ( 'x' , 1 ) ) ; 
VACUUM ( INDEX_CLEANUP FALSE ) x ; 
VACUUM ( ANALYZE ) x ; 
VACUUM ANALYZE x ( a , b , a ) ; 
ANALYZE x ( a , b , b ) ; 
VACUUM x , x ; 
VACUUM ANALYZE x , x ( a ) ; 
VACUUM ANALYZE x ( does_not_exist ) , x ( b ) ; 
VACUUM FULL x , x ; 
VACUUM FULL x , x ( a , b ) , x ( i ) ; 
ANALYZE x , x ; 
ANALYZE x ( b ) , x ; 
ANALYZE x , x , x ; 
ANALYZE x ( i ) , x ( does_not_exist ) ; 
ANALYZE ( nonexistentarg ) x ; 
VACUUM ( SKIP_LOCKED ) x ; 
ANALYZE ( SKIP_LOCKED ) x ; 
RESET default_transaction_isolation ; 
SET ROLE regress_vacuum ; 
VACUUM x . pg_class ; 
ANALYZE x . pg_class ; 
VACUUM ( ANALYZE ) x . pg_class ; 
VACUUM x . pg_authid ; 
ANALYZE x . pg_authid ; 
VACUUM ( ANALYZE ) x . pg_authid ; 
ALTER TABLE x OWNER TO CURRENT_USER ; 
CREATE TABLE x ( x TIMESTAMP ( 1 ) WITHOUT TIME ZONE ) ; 
SELECT x ( * ) AS One FROM x WHERE x = TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT x ( * ) AS Three FROM x WHERE x = TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT x ( * ) AS One FROM x WHERE x = TIMESTAMP ( 1 ) WITHOUT TIME ZONE 'x' ; 
SELECT x ( * ) AS two FROM x WHERE x = TIMESTAMP ( 1 ) WITHOUT TIME ZONE 'x' ; 
SET datestyle TO ymd ; 
SELECT 'x' AS 64" , x FROM x ; 
SELECT 'x' AS 15" , x FROM x WHERE x < TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT 'x' AS one , x FROM x WHERE x = TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT 'x' AS 63" , x FROM x WHERE x != TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT 'x' AS 16" , x FROM x WHERE x <= TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT 'x' AS 49" , x FROM x WHERE x >= TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT 'x' AS 54" , x - TIMESTAMP WITHOUT TIME ZONE 'x' AS diff FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS date_trunc_week , x ( 'x' , TIMESTAMP 'x' ) AS week_trunc ; 
SELECT 'x' AS 54" , x - TIMESTAMP WITHOUT TIME ZONE 'x' AS diff FROM x WHERE x BETWEEN TIMESTAMP WITHOUT TIME ZONE 'x' AND TIMESTAMP WITHOUT TIME ZONE 'x' ; 
SELECT 'x' AS 54" , x AS timestamp" , x ( 'x' , x ) AS quarter , x ( 'x' , x ) AS msec , x ( 'x' , x ) AS usec FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS 54" , x AS timestamp" , x ( 'x' , x ) AS isoyear , x ( 'x' , x ) AS week , x ( 'x' , x ) AS dow FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS to_char_1 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_2 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_3 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_4 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_6 , x ( x , x 'x' ) FROM x ; 
SELECT x ( 1 , 1 , 1 , 1 , 1 , 1.000000 ) ; 
CREATE TABLE x ( x SERIAL PRIMARY KEY , x INT ) ; 
CREATE TABLE x ( x SERIAL PRIMARY KEY , x INT , x TEXT , x TEXT , CONSTRAINT clstr_tst_con FOREIGN KEY ( x ) REFERENCES x ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 1 , 'x' , x ( 'x' , 1 ) ) ; 
CLUSTER x ON x ; 
SELECT x , x , x , SUBSTRING ( x FOR 1 ) , x ( x ) FROM x ; 
SELECT x , x , x , SUBSTRING ( x FOR 1 ) , x ( x ) FROM x ORDER BY x ; 
ALTER TABLE x CLUSTER ON clstr_tst_b_c ; 
ALTER TABLE x SET WITHOUT CLUSTER ; 
SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x ; 
SET SESSION AUTHORIZATION regress_clstr_user ; 
CLUSTER ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x TEXT ) ; 
ALTER TABLE x CLUSTER ON clstrpart_idx ; 
SET enable_indexscan = off ; 
CREATE TABLE x ( x serial PRIMARY KEY , x INT , x TEXT COLLATE C" ) ; 
INSERT INTO x ( x , x ) SELECT x . x % 1 , 'x' || x . x FROM x ( 1 , 1 ) g ( i ) ; 
CREATE INDEX x ON x ( ( - x ) , x ) ; 
CREATE INDEX x ON x ( ( x ( x ) ) ) ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE x ( x ) = 'x' ; 
SELECT * FROM x WHERE x ( x ) = 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x WHERE - x = 1 ORDER BY - x , x ; 
SELECT * FROM x WHERE - x = 1 ORDER BY - x , x ; 
CREATE TABLE x ( x lseg ) ; 
INSERT INTO x VALUES ( x ( x ( 1 , 1 ) , x ( 1 , 1 ) ) ) ; 
SELECT x ( NULL , 'x' ) ; 
NOTIFY notify_async2 ; 
LISTEN notify_async2 ; 
UNLISTEN notify_async2 ; 
CREATE TABLE x ( x polygon ) ; 
CREATE TABLE x ( x INT , x polygon ) ; 
INSERT INTO x SELECT ( x - 1 ) * 1 + x , x ( x ( x ( x * 1 , x * 1 ) , 1 + ( x + x ) % 1 ) ) FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ; 
INSERT INTO x SELECT x , x 'x' FROM x ( 1 , 1 ) AS i ; 
INSERT INTO x VALUES ( 1 , NULL ) , ( 1 , NULL ) , ( 1 , NULL ) ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x & < x 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x && x 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x & > x 'x' ; 
EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x & < | x 'x' ; 
@@@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x > x 'x' ; 
@~EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x = x 'x' ; 
~CREATE INDEX x ON x USING gist ( x ) WITH ( buffering = off ) ; 
CREATE INDEX x ON x USING gist ( x ) WITH ( buffering = auto ) ; 
DROP INDEX x , x , x ; 
CREATE INDEX x ON x USING gist ( x ) WITH ( buffering = invalid_value ) ; 
CREATE INDEX x ON x USING gist ( x ) WITH ( fillfactor = 1 ) ; 
CREATE TABLE x ( x box , x point , x circle ) ; 
SET enable_indexonlyscan = ON ; 
@EXPLAIN ( costs off ) SELECT x FROM x WHERE x < x ( x ( 1 , 1 ) , x ( 1.000000 , 1.000000 ) ) ; 
@SELECT x FROM x WHERE x < x ( x ( 1 , 1 ) , x ( 1.000000 , 1.000000 ) ) ; 
@@@@@@@EXPLAIN ( costs off ) SELECT x FROM x WHERE x < x ( x ( 1 , 1 ) , x ( 1 , 1 ) ) ; 
@SELECT x FROM x WHERE x < x ( x ( 1 , 1 ) , x ( 1 , 1 ) ) ; 
@@@@CREATE INDEX x ON x USING gist ( x , x ) ; 
$$$$$$$$$$$CALL x ( 1 ) ; 
$$CALL x ( 'x' ) ; 
$$$$CALL x ( NULL , NULL ) ; 
$$DROP PROCEDURE ptest4a ; 
$$INSERT INTO x VALUES ( x , x ) ; 
$$CALL x ( 1 , 'x' , 1 ) ; 
CALL x ( 1 , 'x' ) ; 
CALL x ( 1 , b => 'x' ) ; 
CALL x ( b => 'x' , a => 1 ) ; 
$$$$CALL x ( 1 , 1 ) ; 
$$$$CALL x ( LEAST ( 'x' , 'x' ) , 'x' ) ; 
ALTER PROCEDURE x ( TEXT ) STRICT ; 
SET ROLE regress_cp_user1 ; 
ALTER ROUTINE x ( INT ) RENAME TO cp_testfunc1a ; 
ALTER ROUTINE cp_testfunc1a RENAME TO cp_testfunc1 ; 
ALTER ROUTINE x ( TEXT ) RENAME TO ptest1a ; 
ALTER ROUTINE ptest1a RENAME TO ptest1 ; 
DROP ROUTINE x ( INT ) ; 
DROP PROCEDURE ptest1 ; 
DROP PROCEDURE ptest2 ; 
CREATE TEMP TABLE x ( x TEXT , x TEXT , x INT ) ; 
INSERT INTO x VALUES ( 'x' , x 'x' , 1 ) ; 
INSERT INTO x VALUES ( x 'x' , x 'x' , 1 ) ; 
COPY x TO 'x' CSV ; 
CREATE TEMP TABLE x ( LIKE x ) ; 
COPY x FROM 'x' CSV ; 
SELECT * FROM x EXCEPT SELECT * FROM x ; 
COPY x FROM STDIN CSV HEADER ; 
CREATE TABLE x ( x INT , x INT , x TEXT ) PARTITION BY list ( b ) ; 
INSERT INTO x SELECT x , 1 , 'x' FROM x ( 1 , 1 ) x ; 
COPY ( SELECT * FROM x ORDER BY x ) TO 'x' ; 
$$DROP TRIGGER part_ins_trig ON parted_copytest_a2 ; 
SELECT x FROM x WHERE x > 1 ; 
CREATE TEMPORARY TABLE x ( x INT ) ; 
SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY ; 
SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE ; 
SAVEPOINT one ; 
ROLLBACK TO SAVEPOINT one ; 
RELEASE SAVEPOINT one ; 
SAVEPOINT two ; 
RELEASE SAVEPOINT two ; 
ROLLBACK TO one ; 
RELEASE two ; 
SAVEPOINT three ; 
SAVEPOINT four ; 
RELEASE SAVEPOINT four ; 
ROLLBACK TO SAVEPOINT three ; 
RELEASE SAVEPOINT three ; 
SELECT x ; 
SAVEPOINT five ; 
ROLLBACK TO SAVEPOINT five ; 
SELECT x . x = x . x FROM x a , x b WHERE x . x = 1 AND x . x = 1 ; 
SELECT x FROM x WHERE x IN ( 1 , 1 , 1 ) ; 
SELECT x FROM x WHERE x BETWEEN 1 AND 1 ; 
DECLARE c CURSOR FOR SELECT x FROM x ORDER BY x ; 
FETCH 1 FROM c ; 
DECLARE c CURSOR FOR SELECT x / 1 FROM x ORDER BY x ; 
ROLLBACK TO SAVEPOINT two ; 
UPDATE x SET x = x ( ) + 1 WHERE x > 1 ; 
CREATE OR REPLACE FUNCTION x ( ) RETURNS SMALLINT LANGUAGE plpgsql AS 'x' STABLE ; 
CREATE OR REPLACE FUNCTION x ( ) RETURNS SMALLINT LANGUAGE plpgsql AS 'x' VOLATILE ; 
$$$$CREATE TABLE x ( x float8 UNIQUE ) ; 
INSERT INTO x VALUES ( x ( 1 ) ) ; 
DECLARE foo CURSOR FOR SELECT * FROM x ; 
FETCH FROM foo ; 
$$$$DECLARE ok CURSOR FOR SELECT * FROM x ; 
DECLARE ctt CURSOR FOR SELECT x ( ) ; 
FETCH ok ; 
DROP FUNCTION x ( x float8 ) ; 
SET default_transaction_read_only = ON ; 
START TRANSACTION ISOLATION LEVEL REPEATABLE READ , READ WRITE , DEFERRABLE ; 
SHOW transaction_isolation ; 
SHOW transaction_read_only ; 
SHOW transaction_deferrable ; 
START TRANSACTION ISOLATION LEVEL SERIALIZABLE , READ WRITE , NOT DEFERRABLE ; 
RESET default_transaction_read_only ; 
\\SELECT 1 ; SELECT 1 ; SELECT 1 ; 
\INSERT INTO x VALUES ( 1 ) ; SELECT * FROM x ; 
\\INSERT INTO x VALUES ( 1 ) ; SELECT * FROM x ; SELECT 1 / 1 ; 
\\SELECT 1 ; BEGIN ; INSERT INTO x VALUES ( 1 ) ; 
\\\INSERT INTO x VALUES ( 1 ) ; COMMIT ; INSERT INTO x VALUES ( 1 ) ; SELECT 1 / 1 ; 
\\INSERT INTO x VALUES ( 1 ) ; ROLLBACK ; SELECT 1 ; 
\\SELECT 1 ; COMMIT ; VACUUM ; 
\SELECT 1 ; SAVEPOINT sp ; 
\\SELECT 1 ; COMMIT ; SAVEPOINT sp ; 
\ROLLBACK TO SAVEPOINT sp ; SELECT 1 ; 
\\SELECT 1 ; RELEASE SAVEPOINT sp ; SELECT 1 ; 
\\\\SELECT 1 ; BEGIN ; SAVEPOINT sp ; ROLLBACK TO SAVEPOINT sp ; COMMIT ; 
\\\\\\\\\\\ROLLBACK TO X ; 
CREATE TABLE x . test1 ( x INT , x TEXT ) ; 
INSERT INTO x . test1 VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , NULL ) ; 
CREATE DOMAIN testxmldomain AS VARCHAR ; 
ALTER TABLE x . test2 DROP COLUMN x ; 
INSERT INTO x . test2 VALUES ( 1 , 'x' , 'x' , 1.000000 , 1 , 1 , 1 , 'x' , 'x' , 'x' , NULL , 'x' , TRUE , 'x' ) ; 
SELECT x ( 'x' , FALSE , FALSE , 'x' ) ; 
SELECT x ( 'x' , TRUE , FALSE , 'x' ) ; 
SELECT x ( 'x' , FALSE , TRUE , 'x' ) ; 
SELECT x ( 'x' , TRUE , TRUE , 'x' ) ; 
DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM x . test1 ORDER BY 1 , 1 ; 
MOVE BACKWARD ALL IN xc ; 
CREATE DOMAIN testboolxmldomain AS bool ; 
CREATE DOMAIN testdatexmldomain AS date ; 
SELECT XMLFOREST ( x , x , x , x ) FROM x . test3 ; 
CREATE FUNCTION x ( cstring ) RETURNS widget AS 'x' LANGUAGE C STRICT IMMUTABLE ; 
CREATE FUNCTION x ( widget ) RETURNS cstring AS 'x' LANGUAGE C STRICT IMMUTABLE ; 
CREATE FUNCTION x ( cstring ) RETURNS city_budget AS 'x' LANGUAGE C STRICT IMMUTABLE ; 
CREATE FUNCTION x ( city_budget ) RETURNS cstring AS 'x' LANGUAGE C STRICT IMMUTABLE ; 
CREATE FUNCTION x ( int4 ) RETURNS int4 AS 'x' LANGUAGE C STRICT ; 
CREATE FUNCTION x ( record ) RETURNS record AS 'x' LANGUAGE C STRICT ; 
CREATE FUNCTION x ( ) RETURNS bool AS 'x' LANGUAGE C ; 
CREATE FUNCTION x ( ) RETURNS fdw_handler AS 'x' , 'x' LANGUAGE C ; 
CREATE FUNCTION x ( internal ) RETURNS internal AS 'x' , 'x' LANGUAGE C STRICT ; 
CREATE FUNCTION x ( INT ) RETURNS INT LANGUAGE C AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS INT LANGUAGE C AS 'x' , 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS INT LANGUAGE internal AS 'x' ; 
SELECT x ( 1 , 1 ) , x ( 1 , 1 ) ; 
SELECT x ( 1 , x ( 1 , 1 ) ) ; 
SELECT * FROM x ( 1 , x ( 1 , 1 ) ) ; 
SELECT x ( x ( 1 , 1 ) , x ( 1 , 1 ) ) ; 
SELECT x ( 1 , x ( 1 , 1 ) ) , x ( 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) , ( 1 , 'x' , 'x' ) ; 
SELECT x ( ARRAY [ 1 , 1 ] ) FROM x WHERE FALSE ; 
SELECT * FROM x f1 , ( SELECT x ( ARRAY [ 1 , 1 ] ) FROM x f2 WHERE FALSE OFFSET 1 ) ss ; 
SELECT x . x , x ( 1 , 1 ) g FROM x ORDER BY x DESC ; 
SELECT x . x , x ( 1 , 1 ) g FROM x ORDER BY x , x DESC ; 
SELECT x . x , x ( 1 , 1 ) g FROM x ORDER BY x , x ( 1 , 1 ) DESC ; 
SELECT x . x FROM x ORDER BY x , x ( 1 , 1 ) DESC ; 
SELECT x , x ( 1 , 1 ) , x ( * ) FROM x GROUP BY 1 HAVING x ( * ) > 1 ; 
SELECT x , x ( 1 , 1 ) , x ( * ) FROM x GROUP BY 1 , 1 HAVING x ( * ) > 1 ; 
SELECT x . x , x ( * ) FROM x WHERE x = 'x' GROUP BY x . x ORDER BY 1 ; 
SELECT x , CASE WHEN x > 1 THEN x ( 1 , 1 ) ELSE 1 END FROM x ; 
SELECT x , COALESCE ( x ( 1 , 1 ) , 1 ) FROM x ; 
SELECT x ( x ( 1 , 1 ) ) FROM x ; 
SELECT x ( x ( 1 , 1 ) ) OVER ( ) FROM x ; 
SELECT x , x ( x ) OVER ( ) , x ( * ) OVER ( ) , x ( 1 , 1 ) FROM x ; 
SELECT x ( x ( * ) ) OVER ( PARTITION BY x ( 1 , 1 ) ORDER BY x ( 1 , 1 ) ) , x ( 1 , 1 ) g FROM x GROUP BY x ; 
SELECT x . x , x ( * ) , x ( x ) , x ( x ) , x ( 1 , 1 ) FROM x GROUP BY x . x ORDER BY 1 , 1 ; 
SELECT x , x b , x ( 1 , 1 ) g , x ( * ) FROM x GROUP BY CUBE ( x , x ) ; 
SELECT x , x b , x ( 1 , 1 ) g , x ( * ) FROM x GROUP BY CUBE ( x , x ) ORDER BY x ; 
SELECT x , x b , x ( 1 , 1 ) g , x ( * ) FROM x GROUP BY CUBE ( x , x , x ) ; 
SELECT x , x b , x ( 1 , 1 ) g , x ( * ) FROM x GROUP BY CUBE ( x , x , x ) ORDER BY x ; 
SELECT 'x' AS f , x ( 1 , 1 ) AS g FROM x ORDER BY 1 ; 
INSERT INTO x VALUES ( 1 ) RETURNING x ( 1 , 1 ) ; 
VALUES ( 1 , x ( 1 , 1 ) ) ; 
SELECT x ( x ( 1 , 1 ) , 1 ) ; 
SELECT x ( 1 , 1 ) IS DISTINCT FROM 1 ; 
SELECT * FROM x ( x ( 1 , 1 ) , 1 ) ; 
SELECT x , x ( 1 , 1 ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) r ( a ) LIMIT 1 OFFSET 1 ; 
SELECT 1 LIMIT x ( 1 , 1 ) ; 
SELECT ( SELECT x ( 1 , 1 ) LIMIT 1 OFFSET x . x ) FROM x ; 
SELECT ( SELECT x ( 1 , 1 ) LIMIT 1 OFFSET x . x ) FROM x ( 1 , 1 ) g ( i ) ; 
@@SELECT | | ARRAY [ 1 , 1 , 1 ] ; 
SELECT x ( 1 , 1 ) AS x , x ( 1 , 1 ) + 1 AS xp1 ; 
SELECT x ( 1 , 1 ) + 1 ORDER BY x ( 1 , 1 ) ; 
SELECT x ( 1 , 1 ) AS x , x ( 1 , 1 ) + 1 AS y ; 
CREATE TABLE x ( x serial PRIMARY KEY ) ; 
CREATE TABLE x ( x INT REFERENCES x , x INT REFERENCES x ) ; 
TRUNCATE TABLE x , x ; 
TRUNCATE TABLE x , x , x ; 
TRUNCATE TABLE x , x , x , x ; 
TRUNCATE TABLE x , x , x , x , x ; 
SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x ; 
DROP TABLE x , x , x , x , x CASCADE ; 
TRUNCATE ONLY x ; 
TRUNCATE ONLY x , ONLY x ; 
TRUNCATE ONLY x , x ; 
INSERT INTO x VALUES ( x , x , x , x [ 1 ] , x , x ) ; 
$$SELECT x ( * ) AS Row count in test table" FROM x ; 
DROP TRIGGER t ON trunc_trigger_test ; 
CREATE SEQUENCE x START WITH 1 ; 
CREATE TABLE x ( x serial , x INTEGER DEFAULT x ( 'x' ) ) ; 
ALTER SEQUENCE x OWNED BY truncate_a . id1 ; 
TRUNCATE x RESTART IDENTITY ; 
CREATE TABLE x ( x INT GENERATED ALWAYS AS IDENTITY ( START WITH 1 ) ) ; 
$$$$$$$$TRUNCATE TABLE x CASCADE ; 
DROP FUNCTION x ( ) , x ( ) ; 
SHOW datestyle ; 
SET vacuum_cost_delay TO 1 ; 
SET datestyle = 'x' ; 
SHOW vacuum_cost_delay ; 
SET LOCAL vacuum_cost_delay TO 1 ; 
SET LOCAL datestyle = 'x' ; 
SAVEPOINT first_sp ; 
SET vacuum_cost_delay TO 1.000000 ; 
ROLLBACK TO first_sp ; 
SAVEPOINT second_sp ; 
SET vacuum_cost_delay TO 'x' ; 
SAVEPOINT third_sp ; 
ROLLBACK TO third_sp ; 
ROLLBACK TO second_sp ; 
SAVEPOINT sp ; 
ROLLBACK TO sp ; 
RELEASE SAVEPOINT sp ; 
SET datestyle = iso , ymd ; 
SET seq_page_cost TO 'x' ; 
DECLARE foo CURSOR WITH HOLD FOR SELECT 1 ; 
PREPARE foo AS SELECT 1 ; 
LISTEN foo_event ; 
SET vacuum_cost_delay = 1 ; 
SET SESSION AUTHORIZATION regress_guc_user ; 
SELECT CURRENT_USER = 'x' ; 
SET search_path = foo , public , not_there_initially ; 
SELECT x ( FALSE ) ; 
DROP SCHEMA not_there_initially ; 
$$SELECT x ( 'x' ) , x ( 'x' ) ; 
ALTER FUNCTION x ( TEXT ) SET work_mem = 'x' ; 
ALTER FUNCTION x ( TEXT ) RESET ALL ; 
$$$$SELECT x ( 1 ) , x ( 'x' ) ; 
ALTER FUNCTION x ( INT ) RESET ALL ; 
$$$$$$$$SET nosuch . setting = 'x' ; 
SELECT x ( 'x' , FALSE ) ; 
$$SET check_function_bodies = off ; 
$$RESET check_function_bodies ; 
SET default_with_oids TO f ; 
SET default_with_oids TO t ; 
SELECT DISTINCT x FROM x ORDER BY 1 ; 
SELECT DISTINCT x , x , x FROM x ORDER BY x USING < , x USING < , x USING < ; 
SELECT DISTINCT x . x FROM x * p ORDER BY x USING > ; 
SELECT x ( * ) FROM ( SELECT DISTINCT x , x , x FROM x ) ss ; 
SELECT x , x IS DISTINCT FROM 1 AS not 2" FROM x ; 
SELECT x , x IS DISTINCT FROM NULL AS not null" FROM x ; 
SELECT x , x IS DISTINCT FROM x AS false" FROM x ; 
SELECT x , x IS DISTINCT FROM x + 1 AS not null" FROM x ; 
SELECT 1 IS DISTINCT FROM 1 AS yes" ; 
SELECT 1 IS DISTINCT FROM 1 AS no" ; 
SELECT 1 IS DISTINCT FROM NULL AS yes" ; 
SELECT NULL IS DISTINCT FROM NULL AS no" ; 
SELECT 1 IS NOT DISTINCT FROM 1 AS no" ; 
SELECT 1 IS NOT DISTINCT FROM 1 AS yes" ; 
SELECT 1 IS NOT DISTINCT FROM NULL AS no" ; 
SELECT NULL IS NOT DISTINCT FROM NULL AS yes" ; 
INSERT INTO x ( x [ 1 : 1 ] , x [ 1 : 1 ] [ 1 : 1 ] [ 1 : 1 ] , x , x , x , x ) VALUES ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
UPDATE x SET x [ 1 ] = 'x' ; 
INSERT INTO x ( x , x [ 1 : 1 ] [ 1 : 1 ] , x , x , x , x , x ) VALUES ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
INSERT INTO x ( x , x [ 1 : 1 ] , x , x [ 1 : 1 ] ) VALUES ( 'x' , 'x' , 'x' , 'x' ) ; 
SELECT x . x [ 1 ] , x . x [ 1 ] [ 1 ] [ 1 ] , x . x [ 1 ] , x . x [ 1 ] [ 1 ] , x . x [ 1 ] FROM x ; 
SELECT x [ 1 ] , x [ 1 ] [ 1 ] [ 1 ] , x [ 1 ] , x [ 1 ] [ 1 ] , x [ 1 ] FROM x ; 
SELECT x [ 1 : 1 ] , x [ 1 : 1 ] [ 1 : 1 ] [ 1 : 1 ] , x [ 1 : 1 ] , x [ 1 : 1 ] [ 1 : 1 ] FROM x ; 
SELECT x ( x ) AS a , x ( x ) AS b , x ( x ) AS c FROM x ; 
UPDATE x SET x [ 1 : 1 ] [ 1 : 1 ] [ 1 : 1 ] = 'x' , x [ 1 : 1 ] [ 1 : 1 ] [ 1 : 1 ] = 'x' WHERE x ( x ) = 'x' ; 
UPDATE x SET x [ 1 : 1 ] = 'x' WHERE x ( x ) IS NOT NULL ; 
SELECT x [ 1 : 1 ] [ 1 ] [ 1 ] , x [ 1 : 1 ] [ 1 ] FROM x ; 
UPDATE x SET x [ 1 ] = NULL WHERE x [ 1 ] IS NULL ; 
SELECT x FROM x WHERE x [ 1 ] IS NULL ; 
DELETE FROM x WHERE x [ 1 ] IS NULL AND x IS NULL ; 
UPDATE x SET x [ NULL ] = 'x' WHERE x ( x ) IS NOT NULL ; 
UPDATE x SET x [ NULL : 1 ] = 'x' WHERE x ( x ) IS NOT NULL ; 
UPDATE x SET x [ 1 : NULL ] = 'x' WHERE x ( x ) IS NOT NULL ; 
CREATE TEMP TABLE x ( x int2 [ ] , x int2 [ ] [ ] ) ; 
SELECT x [ : 1 ] , x [ : 1 ] [ : 1 ] FROM x ; 
SELECT x [ 1 : ] , x [ 1 : ] [ 1 : ] FROM x ; 
SELECT x [ : ] , x [ : ] FROM x ; 
UPDATE x SET x [ : 1 ] = 'x' , x [ : 1 ] [ : 1 ] = 'x' WHERE x ( x , 1 ) = 1 ; 
UPDATE x SET x [ 1 : ] = 'x' , x [ 1 : ] [ 1 : ] = 'x' ; 
UPDATE x SET x [ : ] = 'x' ; 
SELECT x [ 1 : ] FROM x ; 
SELECT x [ : 1 ] FROM x ; 
SELECT x [ : ] FROM x ; 
UPDATE x SET x [ 1 ] = 1 WHERE x IS NULL RETURNING * ; 
INSERT INTO x ( x [ 1 ] ) VALUES ( 1 ) RETURNING * ; 
CREATE TEMP TABLE x ( x INT [ ] , x TEXT [ ] ) ; 
INSERT INTO x VALUES ( ARRAY [ 1 , 1 , NULL , 1 ] , ARRAY [ 'x' , 'x' , NULL , 'x' ] ) ; 
UPDATE x SET x [ 1 ] = 1 , x [ 1 ] = 'x' ; 
UPDATE x SET x [ 1 : 1 ] = ARRAY [ 1 , 1 , 1 ] , x [ 1 : 1 ] = ARRAY [ 'x' , 'x' , 'x' ] ; 
UPDATE x SET x [ 1 : 1 ] = ARRAY [ 1 , NULL , 1 ] , x [ 1 : 1 ] = ARRAY [ 'x' , NULL , 'x' ] ; 
UPDATE x SET x [ 1 : 1 ] = ARRAY [ NULL , 1 ] , x [ 1 : 1 ] = ARRAY [ NULL , 'x' ] ; 
UPDATE x SET x [ 1 : 1 ] = ARRAY [ 1 , NULL ] , x [ 1 : 1 ] = ARRAY [ 'x' , NULL ] ; 
UPDATE x SET x [ 1 : 1 ] = ARRAY [ 1 , 1 , 1 , NULL , 1 , 1 ] , x [ 1 : 1 ] = ARRAY [ 'x' , 'x' , 'x' , NULL , 'x' , 'x' ] ; 
CREATE TEMP TABLE x ( x INTEGER ARRAY [ 1 ] , x float8 [ ] , x NUMERIC [ ] , x TEXT [ ] , x TIMESTAMP [ ] ) ; 
CREATE TEMP TABLE x ( x INT , x TEXT , x float8 ) ; 
SELECT x . x [ 1 ] [ 1 ] [ 1 ] AS 131" , x . x [ 1 ] [ 1 ] [ 1 ] AS 221" FROM ( SELECT ARRAY [ [ [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] ] , [ [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] ] ] AS f ) AS t ; 
SELECT ARRAY [ [ [ [ [ [ 'x' ] , [ 'x' ] ] ] ] ] ] ; 
SELECT ARRAY [ ARRAY [ 'x' ] , ARRAY [ 'x' ] ] ; 
SELECT ARRAY ( SELECT x FROM x ORDER BY x ) AS ARRAY" ; 
SELECT ARRAY [ 1 , NULL , 1 ] ; 
SELECT x ( ARRAY [ 1 ] , 1 ) AS {42,6}" ; 
SELECT x ( 1 , ARRAY [ 1 ] ) AS {6,42}" ; 
SELECT x ( ARRAY [ 1 , 1 ] , ARRAY [ 1 , 1 ] ) AS {1,2,3,4}" ; 
SELECT x ( ARRAY [ 1 , 1 ] , ARRAY [ [ 1 , 1 ] , [ 1 , 1 ] ] ) AS {{1,2},{3,4},{5,6}}" ; 
SELECT x ( ARRAY [ [ 1 , 1 ] , [ 1 , 1 ] ] , ARRAY [ 1 , 1 ] ) AS {{3,4},{5,6},{1,2}}" ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , 1 ] , 1 ) ; 
SELECT x ( ARRAY [ [ 1 , 1 ] , [ 1 , 1 ] ] , 1 ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ] , 'x' ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ] , NULL ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' , NULL , 'x' , 'x' ] , NULL ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' , NULL , 'x' , 'x' ] , 'x' ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] , 1 ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] , NULL ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , NULL , 1 , 1 , 1 , 1 , 1 , NULL , 1 , 1 ] , NULL ) ; 
$$$$SELECT x ( x , ( 1 , 1 ) ) , x ( x , ( 1 , 1 ) ) FROM ( VALUES ( ARRAY [ ( 1 , 1 ) , ( 1 , 1 ) ] ) , ( ARRAY [ ( 1 , 1 ) ] ) ) AS f ( ids ) ; 
SELECT x FROM x WHERE x = ARRAY [ [ [ 1 , 1 ] , [ 1 , 1 ] ] ] ; 
SELECT NOT ARRAY [ 1.000000 , 1.000000 , 1.000000 ] = ARRAY [ 1.000000 , 1.000000 , 1.000000 ] AS FALSE" ; 
SELECT ARRAY [ 1 , 1 ] || 1 AS {1,2,3}" ; 
SELECT 1 || ARRAY [ 1 , 1 ] AS {0,1,2}" ; 
SELECT ARRAY [ 1 , 1 ] || ARRAY [ 1 , 1 ] AS {1,2,3,4}" ; 
SELECT ARRAY [ [ [ 'x' , 'x' ] ] ] || ARRAY [ [ [ 'x' , 'x' ] ] ] AS ARRAY" ; 
SELECT ARRAY [ [ 1 , 1 ] , [ 1 , 1 ] ] || ARRAY [ 1 , 1 ] AS {{1,2},{3,4},{5,6}}" ; 
SELECT ARRAY [ 1 , 1 ] || ARRAY [ 1 , 1 ] || ARRAY [ 1 , 1 ] AS {0,0,1,1,2,2}" ; 
SELECT 1 || ARRAY [ 1 , 1 ] || 1 AS {0,1,2,3}" ; 
@@@@@@@@@@@@@@SELECT CAST ( ARRAY [ [ [ [ [ [ 'x' , 'x' , 'x' ] ] ] ] ] ] AS TEXT [ ] ) AS {{{{{{a,bb,ccc}}}}}}" ; 
SELECT 1 = ANY ( 'x' ) ; 
SELECT 1 = ALL ( 'x' ) ; 
SELECT 1 >= ALL ( 'x' ) ; 
SELECT 1.000000 = ANY ( ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT 1.000000 > ALL ( ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT 1 * ANY ( 'x' ) ; 
SELECT 1 * ANY ( 1 ) ; 
SELECT 1 != ALL ( ARRAY ( SELECT NULLIF ( x . x , 1 ) FROM x ( 1 , 1 ) g ( i ) ) ) ; 
CREATE TEMP TABLE x ( x INT [ ] UNIQUE ) ; 
SELECT * FROM x WHERE x > 'x' AND x <= 'x' ; 
SELECT * FROM x WHERE x >= 'x' AND x < 'x' ; 
CREATE TEMP TABLE x ( x int4 PRIMARY KEY , x INT [ ] ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x [ 1 ] = x . x [ 1 ] , x [ 1 ] = x . x [ 1 ] RETURNING x , x ; 
INSERT INTO x ( x , x [ 1 : 1 ] ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x [ 1 ] = x . x [ 1 ] , x [ 1 ] = x . x [ 1 ] , x [ 1 ] = x . x [ 1 ] RETURNING x , x ; 
SELECT ARRAY [ ] ; 
CREATE TEMP TABLE x ( x INT [ ] , x TEXT [ ] [ ] , x FLOAT [ ] ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , 'x' , 'x' ) ; 
SELECT x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) , x ( x ) FROM x ; 
INSERT INTO x ( x , x , x ) VALUES ( 'x' , 'x' , NULL ) ; 
CREATE TYPE comptype AS ( f1 INT , f2 TEXT ) ; 
CREATE TABLE x ( x comptype , x comptype [ ] ) ; 
_CREATE TYPE comptype AS ENUM ( 'x' ) ; 
SELECT x [ 1 ] . x FROM x ; 
_DROP TYPE comptype ; 
$$$$$$$$SELECT * FROM x ( ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT * FROM x ( ARRAY [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ) ; 
SELECT x ( 1 , ARRAY [ 1 , 1 ] , ARRAY [ 1 , 1 ] ) ; 
SELECT x ( 1 , ARRAY [ 1 , 1 ] ) ; 
SELECT x , x = 'x' AS is_eq , x ( x ) FROM ( SELECT x ( 1 , ARRAY [ 1 ] ) AS a ) ss ; 
SELECT x , x = 'x' AS is_eq , x ( x ) FROM ( SELECT x ( 1 , 'x' ) AS a ) ss ; 
SELECT x , x = 'x' AS is_eq , x ( x ) FROM ( SELECT x ( 1 , 'x' , 'x' ) AS a ) ss ; 
SELECT x ( 1 , NULL , ARRAY [ 1 , 1 ] ) ; 
SELECT x ( 1 , ARRAY [ 1 , 1 ] , NULL ) ; 
SELECT x ( 1 , ARRAY [ 1 , 1 ] , 'x' ) ; 
SELECT x ( 1 , ARRAY [ 1 , 1 ] , ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT x ( 1 , ARRAY [ 1 , 1 , NULL ] ) ; 
SELECT x ( 1 , ARRAY [ [ 1 , 1 ] , [ 1 , 1 ] ] ) ; 
SELECT x ( NULL , 'x' ) IS NULL ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , NULL , 1 ] , 'x' ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , NULL , 1 ] , 'x' , 'x' ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , NULL , 1 ] , NULL ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 , NULL , 1 ] , 'x' , NULL ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 ] , 1 ) ; 
SELECT x ( ARRAY [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] , 1 ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT x ( x ) FROM ( SELECT x FROM x WHERE x < 1 ORDER BY x ) ss ; 
SELECT x ( NULLIF ( x , 1 ) ) FROM ( SELECT x FROM x WHERE x < 1 ORDER BY x ) ss ; 
SELECT x ( DISTINCT x ORDER BY x DESC ) FROM ( SELECT ARRAY [ x / 1 ] FROM x ( 1 , 1 ) a ( i ) ) b ( ar ) ; 
SELECT x ( ARRAY [ x + 1.000000 , x + 1.000000 , x + 1.000000 ] ) FROM x ( 1 , 1 ) g ( i ) ; 
SELECT x ( ARRAY [ x , NULLIF ( x , 1 ) , x + 1 ] ) FROM x ( 1 , 1 ) g ( i ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , NULL , 1 , NULL , NULL , 1 , 1 ] ) ; 
SELECT x ( x ( ARRAY [ 1 , 1 , NULL , 1 ] ) ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 ] , 1 ) ; 
SELECT x ( ARRAY [ 1 , NULL , NULL , 1 ] , NULL ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' ] , 'x' ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 ] , 1 , 1 ) ; 
SELECT x ( ARRAY [ 1 , 1 , 1 , 1 ] , 1 , NULL ) ; 
SELECT x ( ARRAY [ 1 , 1 , NULL , 1 , NULL ] , NULL , 1 ) ; 
SELECT x ( ARRAY [ 'x' , 'x' , 'x' , 'x' ] , 'x' , 'x' ) ; 
SELECT x ( ARRAY [ 1 , NULL , 1 ] , NULL , NULL ) ; 
SELECT x ( ARRAY [ 'x' , NULL , 'x' ] , NULL , 'x' ) ; 
SELECT ARRAY ( SELECT ARRAY [ x , x / 1 ] FROM x ( 1 , 1 ) i ) ; 
CREATE TEMP TABLE x ( x int8_tbl [ ] ) ; 
INSERT INTO x ( x [ 1 ] . q1 ) VALUES ( 1 ) ; 
UPDATE x SET x [ 1 ] . q2 = 1 ; 
CREATE TYPE textandtext AS ( c1 TEXT , c2 TEXT ) ; 
CREATE TEMP TABLE x ( x textandtext [ ] ) ; 
SELECT x ( x ( ( x [ 1 ] ) . c2 ) ) FROM x ; 
DROP TYPE textandtext ; 
SELECT x ( 1 , ARRAY [ 1 ] ) ; 
SELECT x ( 1 , ARRAY [ ARRAY [ 1 , 1 ] , ARRAY [ 1 , 1 ] ] ) ; 
CREATE TABLE x ( x VARCHAR ( 1 ) ) ; 
SAVEPOINT b ; 
FETCH 1 FROM foo ; 
\SELECT x , x , x , x , x , x , x , x , x , x , x FROM x WHERE x = 'x' ; 
CREATE ROLE x WITH SUPERUSER ; 
ALTER ROLE x WITH NOSUPERUSER ; 
ALTER ROLE x WITH SUPERUSER ; 
CREATE ROLE x WITH NOINHERIT ; 
ALTER ROLE x WITH INHERIT ; 
ALTER ROLE x WITH NOINHERIT ; 
CREATE ROLE x WITH CREATEROLE ; 
ALTER ROLE x WITH NOCREATEROLE ; 
ALTER ROLE x WITH CREATEROLE ; 
CREATE ROLE x WITH CREATEDB ; 
ALTER ROLE x WITH NOCREATEDB ; 
ALTER ROLE x WITH CREATEDB ; 
CREATE ROLE x WITH LOGIN ; 
ALTER ROLE x WITH NOLOGIN ; 
ALTER ROLE x WITH LOGIN ; 
CREATE USER x WITH NOLOGIN ; 
ALTER USER x WITH LOGIN ; 
ALTER USER x WITH NOLOGIN ; 
CREATE ROLE x WITH REPLICATION ; 
ALTER ROLE x WITH NOREPLICATION ; 
ALTER ROLE x WITH REPLICATION ; 
CREATE ROLE x WITH BYPASSRLS ; 
ALTER ROLE x WITH NOBYPASSRLS ; 
ALTER ROLE x WITH BYPASSRLS ; 
SELECT x , x , x FROM x WHERE x NOT IN ( 'x' , 'x' , 'x' ) ; 
CREATE TABLE x ( x INT GENERATED BY DEFAULT AS IDENTITY , x TEXT ) ; 
CREATE TABLE x ( x SMALLINT GENERATED BY DEFAULT AS IDENTITY ( START WITH 1 INCREMENT BY 1 ) , x TEXT ) ; 
CREATE TABLE x ( x TEXT GENERATED BY DEFAULT AS IDENTITY ) ; 
CREATE TABLE x ( x INT GENERATED ALWAYS AS IDENTITY GENERATED BY DEFAULT AS IDENTITY ) ; 
CREATE TABLE x ( x INT DEFAULT 1 GENERATED BY DEFAULT AS IDENTITY ) ; 
CREATE TABLE x ( x serial GENERATED BY DEFAULT AS IDENTITY ) ; 
INSERT INTO x VALUES ( DEFAULT , 'x' ) ; 
INSERT INTO x VALUES ( DEFAULT , 'x' ) , ( DEFAULT , 'x' ) ; 
INSERT INTO x OVERRIDING USER VALUE VALUES ( 1 , 'x' ) ; 
INSERT INTO x OVERRIDING SYSTEM VALUE VALUES ( 1 , 'x' ) ; 
CREATE TABLE x ( x INT GENERATED ALWAYS AS IDENTITY , x TEXT , x BIGINT ) ; 
ALTER TABLE x ALTER COLUMN x DROP IDENTITY ; 
CREATE TABLE x ( x INT GENERATED ALWAYS AS IDENTITY , x TEXT ) ; 
ALTER TABLE x ADD COLUMN x INT GENERATED BY DEFAULT AS IDENTITY ; 
ALTER TABLE x ALTER COLUMN x ADD GENERATED ALWAYS AS IDENTITY ; 
ALTER TABLE x ALTER COLUMN x TYPE INT ; 
ALTER TABLE x ALTER COLUMN x SET GENERATED BY DEFAULT SET INCREMENT BY 1 SET START WITH 1 RESTART ; 
CREATE TABLE x ( x INT GENERATED ALWAYS AS IDENTITY ) ; 
CREATE TABLE x ( x INT GENERATED ALWAYS AS IDENTITY ) INHERITS ( x ) ; 
ALTER TABLE x ALTER COLUMN x SET GENERATED BY DEFAULT ; 
ALTER TABLE x ALTER COLUMN x RESTART ; 
SET ROLE regress_identity_user1 ; 
CREATE TYPE itest_type AS ( f1 INTEGER , f2 TEXT , f3 BIGINT ) ; 
ALTER TABLE x ALTER x ADD GENERATED BY DEFAULT AS IDENTITY ; 
$$EXPLAIN ( costs off ) SELECT x ( x ( x ) ) , x ( x ) FROM x ; 
SELECT x ( x ( x ) ) , x ( x ) FROM x a1 ; 
SELECT x ( x ( x ) ) , x ( x ) FROM x a2 ; 
SELECT x ( x ( x ) ) , x ( x ) FROM x a3 ; 
ALTER TABLE x RESET ( parallel_workers ) ; 
SET enable_parallel_append TO off ; 
SELECT x ( x ( x ) ) , x ( x ) FROM x a4 ; 
$$SELECT x ( ) ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT ( SELECT x ( ( SELECT x . x FROM x pa1 WHERE x . x = x . x ) ) ) FROM x pa2 ; 
SET parallel_leader_participation = off ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x = 'x' ; 
SET max_parallel_workers = 1 ; 
RESET max_parallel_workers ; 
RESET parallel_leader_participation ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
SELECT x ( x ) FROM x GROUP BY x ( x ) ; 
EXPLAIN ( costs off ) SELECT x , x ( * ) FROM x GROUP BY x ORDER BY x ; 
EXPLAIN ( costs off ) SELECT x ( x ( x ) ) FROM x GROUP BY ( x ( x ) ) ; 
$PREPARE tenk1_count ( INTEGER ) AS SELECT x ( ( x ) ) FROM x WHERE x > 1 ; 
EXPLAIN ( costs off ) EXECUTE tenk1_count ( 1 ) ; 
EXECUTE tenk1_count ( 1 ) ; 
DEALLOCATE tenk1_count ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE ( x , x ) NOT IN ( SELECT x , x FROM x WHERE x > 1 ) ; 
SELECT x ( * ) FROM x WHERE ( x , x ) NOT IN ( SELECT x , x FROM x WHERE x > 1 ) ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x . x = ( SELECT x ( x . x ) FROM x ) ; 
SELECT x ( * ) FROM x WHERE x . x = ( SELECT x ( x . x ) FROM x ) ; 
EXPLAIN ( costs off ) SELECT x ( ( x ) ) FROM x WHERE x > 1 ; 
SELECT x ( ( x ) ) FROM x WHERE x > 1 ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x > 1 ; 
SELECT x ( * ) FROM x WHERE x > 1 ; 
SET enable_material = FALSE ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT x ( x ) FROM x WHERE x > 1 ) ss RIGHT JOIN ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ON TRUE ; 
SELECT * FROM ( SELECT x ( x ) FROM x WHERE x > 1 ) ss RIGHT JOIN ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ON TRUE ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT x ( * ) FROM x WHERE x > 1 ) ss RIGHT JOIN ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ON TRUE ; 
SELECT * FROM ( SELECT x ( * ) FROM x WHERE x > 1 ) ss RIGHT JOIN ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ON TRUE ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x LEFT JOIN ( SELECT x . x FROM x ORDER BY 1 LIMIT 1 ) ss ON x . x < x . x + 1 WHERE x . x < 1 ; 
SELECT x ( * ) FROM x LEFT JOIN ( SELECT x . x FROM x ORDER BY 1 LIMIT 1 ) ss ON x . x < x . x + 1 WHERE x . x < 1 ; 
RESET enable_material ; 
SET enable_material TO off ; 
$$SELECT x ( * ) FROM x , x WHERE x . x > 1 AND x . x = 1 ; 
INSERT INTO x SELECT x , 'x' FROM x ( 1 , 1 ) r ; 
EXPLAIN ( ANALYZE , timing off , summary off , costs off ) SELECT x ( * ) FROM x , x WHERE x . x > 1 AND x . x = 1 ; 
$$RESET effective_io_concurrency ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x , x WHERE x . x = x . x ; 
SELECT x ( * ) FROM x , x WHERE x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x GROUP BY x ; 
SELECT x ( * ) FROM x GROUP BY x ; 
$$$$EXPLAIN ( costs off ) SELECT x ( * ) , x ( 1 , 1 ) FROM x GROUP BY x ; 
SELECT x ( * ) , x ( 1 , 1 ) FROM x GROUP BY x ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT x , x ( x ) FROM x GROUP BY x ORDER BY x ) ss RIGHT JOIN ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ON TRUE ; 
SELECT * FROM ( SELECT x , x ( x ) FROM x GROUP BY x ORDER BY x ) ss RIGHT JOIN ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ON TRUE ; 
EXPLAIN ( costs off ) SELECT x FROM x ORDER BY x LIMIT 1 ; 
SELECT x FROM x ORDER BY x LIMIT 1 ; 
SAVEPOINT settings ; 
SET LOCAL force_parallel_mode = 1 ; 
ROLLBACK TO SAVEPOINT settings ; 
$$$$SELECT x ( x ) FROM ( SELECT x ( 1 , 1 ) x ) ss ORDER BY x ; 
DROP FUNCTION x ( n INT ) ; 
SET ROLE regress_parallel_worker ; 
SET force_parallel_mode = 1 ; 
RESET force_parallel_mode ; 
EXPLAIN ( costs off ) SELECT * FROM x a WHERE x IN ( SELECT x FROM x b WHERE x LIKE 'x' LIMIT 1 ) ; 
EXPLAIN ( ANALYZE , timing off , summary off , costs off ) SELECT * FROM x ; 
$$$$CREATE TABLE x ( x TEXT , x INT [ ] , x TEXT ) ; 
INSERT INTO x VALUES ( 'x' , ARRAY [ 1 , 1 ] , 'x' ) ; 
$$PREPARE pstmt ( TEXT , INT [ ] ) AS SELECT * FROM x WHERE x = 1 AND x = 1 ; 
EXPLAIN ( COSTS OFF ) EXECUTE pstmt ( 'x' , x ( 1 , 1 ) ) ; 
EXECUTE pstmt ( 'x' , x ( 1 , 1 ) ) ; 
DEALLOCATE pstmt ; 
EXPLAIN ( COSTS OFF ) SELECT 1 FROM x WHERE ( SELECT x ( x ) FROM x WHERE x < x ) < 1 ; 
SET max_parallel_maintenance_workers = 1 ; 
CREATE TABLE x ( x serial NOT NULL , x uuid , x uuid , x uuid , x uuid ) ; 
INSERT INTO x ( x , x , x , x ) SELECT x , x , x , x FROM x WHERE ( x < 1 OR x > 1 ) AND x % 1 = 1 AND x IS NOT NULL ; 
SELECT x , x FROM x ORDER BY x OFFSET 1 - 1 ; 
SELECT x , x FROM x ORDER BY x NULLS FIRST OFFSET 1 - 1 ; 
SELECT x , x FROM x ORDER BY x NULLS FIRST LIMIT 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x , x , x FROM x ORDER BY x LIMIT 1 ; 
SELECT x , x , x FROM x ORDER BY x LIMIT 1 ; 
SET LOCAL enable_indexscan = FALSE ; 
EXPLAIN ( COSTS OFF ) DECLARE c SCROLL CURSOR FOR SELECT x FROM x ORDER BY x ; 
DECLARE c SCROLL CURSOR FOR SELECT x FROM x ORDER BY x ; 
FETCH BACKWARD FROM c ; 
FETCH LAST FROM c ; 
SET LOCAL work_mem = 'x' ; 
INSERT INTO x ( x , x , x ) SELECT x . x , x . x , x . x * x . x FROM x ( 1 , 1 ) a ( i ) , x ( 1 , 1 ) b ( i ) ; 
SET LOCAL enable_nestloop = off ; 
SET LOCAL enable_hashjoin = off ; 
SET LOCAL enable_material = off ; 
$$CREATE TABLE x ( x NUMRANGE ) ; 
INSERT INTO x VALUES ( x ( 1.000000 , 1.000000 ) ) ; 
INSERT INTO x VALUES ( x ( 1.000000 , 1.000000 , 'x' ) ) ; 
SELECT x , x ( x ) , x ( x ) , x ( x ) FROM x ; 
SELECT x , x ( x ) , x ( x ) , x ( x ) , x ( x ) FROM x ; 
SELECT * FROM x WHERE x ( x , x ( 1.000000 , 1.000000 ) ) ; 
@SELECT * FROM x WHERE x > x ( 1.000000 , 1.000000 ) ; 
@SELECT * FROM x WHERE 1.000000 < x ; 
SELECT * FROM x WHERE x < x ( 1.000000 , 1.000000 , 'x' ) ; 
SELECT * FROM x WHERE x <= 'x' ; 
SELECT * FROM x WHERE x >= 'x' ; 
SELECT * FROM x WHERE x > x ( 1.000000 , 1.000000 , 'x' ) ; 
SELECT x ( 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1.000000 ) - | - x ( 1.000000 , 1.000000 ) ; 
SELECT x ( x ( 1.000000 , 1.000000 ) , x ( 1.000000 , 1.000000 ) ) ; 
SELECT x ( x ( 1.000000 , 1.000000 ) , x ( 1.000000 , NULL ) ) ; 
SELECT x ( 1.000000 , 1.000000 , 'x' ) - | - x ( 1.000000 , 1.000000 , 'x' ) ; 
SELECT x ( 1.000000 , 1.000000 ) - | - x ( 1.000000 , 1.000000 , 'x' ) ; 
SELECT x ( x ( 1.000000 , 1.000000 , 'x' ) , x ( 1.000000 , 1.000000 , 'x' ) ) ; 
@SELECT x ( 1.000000 , 1.000000 ) < x ( 1.000000 , 1.000000 ) ; 
@SELECT x ( 1.000000 , 1.000000 ) - x ( 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1.000000 , 'x' ) - x ( 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1.000000 , 'x' ) && x ( 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1.000000 ) & < x ( 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1.000000 ) + x ( 1.000000 , 1.000000 ) ; 
SELECT x ( 1.000000 , 1.000000 ) * x ( 1.000000 , 1.000000 ) ; 
CREATE TABLE x ( x numrange ) ; 
SELECT * FROM x WHERE x = x ( 1.000000 , 1.000000 ) ; 
SET enable_nestloop = t ; 
SET enable_hashjoin = f ; 
SET enable_mergejoin = f ; 
SELECT * FROM x NATURAL JOIN x ORDER BY x ; 
SET enable_nestloop = f ; 
SET enable_hashjoin = t ; 
SET enable_mergejoin = t ; 
SET enable_nestloop TO DEFAULT ; 
SET enable_hashjoin TO DEFAULT ; 
SET enable_mergejoin TO DEFAULT ; 
SELECT x ( 1 , 1 , 'x' ) ; 
CREATE TABLE x ( x int4range ) ; 
INSERT INTO x SELECT x ( x , x + 1 ) FROM x ( 1 , 1 ) g ; 
INSERT INTO x SELECT x ( NULL , x * 1 , 'x' ) FROM x ( 1 , 1 ) g ; 
INSERT INTO x SELECT x ( x * 1 , NULL , 'x' ) FROM x ( 1 , 1 ) g ; 
SET enable_seqscan = t ; 
SET enable_indexscan = f ; 
SET enable_bitmapscan = f ; 
@SELECT x ( * ) FROM x WHERE x = x ( 1 , 1 ) ; 
@@SELECT x ( * ) FROM x WHERE x > x ( 1 , 1 ) ; 
SELECT x ( * ) FROM x WHERE x && x ( 1 , 1 ) ; 
@SELECT x ( * ) FROM x WHERE x < x ( 1 , 1 ) ; 
SELECT x ( * ) FROM x WHERE x & < x ( 1 , 1 ) ; 
SELECT x ( * ) FROM x WHERE x & > x ( 1 , 1 ) ; 
SELECT x ( * ) FROM x WHERE x - | - x ( 1 , 1 ) ; 
SET enable_seqscan = f ; 
SET enable_indexscan = t ; 
@@@@@@@@@@@@@@@@@@@@EXPLAIN ( costs off ) SELECT x FROM x WHERE x - | - x ( 1 , 1 ) ORDER BY x ; 
SELECT x FROM x WHERE x - | - x ( 1 , 1 ) ORDER BY x ; 
INSERT INTO x SELECT x FROM x ( 1 , 1 ) i ; 
@CREATE TABLE x ( x int4range , x int4range , x tsrange , EXCLUDE USING gist ( x WITH = , x WITH && ) , EXCLUDE USING gist ( x WITH = , x WITH && ) ) ; 
INSERT INTO x VALUES ( x ( 1 , 1 , 'x' ) , x ( 1 , 1 , 'x' ) , 'x' ) ; 
SET timezone TO DEFAULT ; 
CREATE TYPE float8range AS RANGE ( subtype = float8 , subtype_diff = float4mi ) ; 
CREATE TYPE float8range AS RANGE ( subtype = float8 , subtype_diff = float8mi ) ; 
CREATE TABLE x ( x float8range , x INT ) ; 
INSERT INTO x VALUES ( x ( 1.000000 , 'x' ) , 1 ) ; 
CREATE DOMAIN mydomain AS int4 ; 
CREATE TYPE mydomainrange AS RANGE ( subtype = mydomain ) ; 
@@DROP TYPE textrange1 ; 
DROP TYPE textrange2 ; 
SELECT x ( ARRAY [ 1 , 1 ] , x ( 1 , 1 ) ) ; 
DROP FUNCTION x ( anyarray , anyrange ) ; 
SELECT x ( x ( 1 , 1 ) ) ; 
SELECT x ( x ( 1.000000 , 1.000000 ) ) ; 
$$SELECT x ( x ( 1 , 1 ) , ARRAY [ 1 , 1 ] ) ; 
CREATE TABLE x ( x INT , x int8range [ ] ) ; 
INSERT INTO x VALUES ( 1 , ARRAY [ x ( 1 , 1 ) , x ( 1 , 1 ) ] ) ; 
CREATE TYPE arrayrange AS RANGE ( subtype = int4 [ ] ) ; 
SELECT x ( ARRAY [ 1 , 1 ] , ARRAY [ 1 , 1 ] ) ; 
@SELECT ARRAY [ 1 , 1 ] < x ( ARRAY [ 1 , 1 ] , ARRAY [ 1 , 1 ] ) ; 
CREATE TYPE two_ints AS ( a INT , b INT ) ; 
CREATE TYPE two_ints_range AS RANGE ( subtype = two_ints ) ; 
SELECT * , x ( x ( x ) ) AS u FROM ( VALUES ( x ( ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ) ) , ( x ( ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ) ) ) v ( t ) ; 
DROP TYPE two_ints CASCADE ; 
CREATE TYPE cashrange AS RANGE ( subtype = money ) ; 
$$SELECT * FROM x ( x ( 1 , 1 ) ) ; 
$$$$$$$$$$CREATE INDEX CONCURRENTLY ON x ( x ) ; 
SELECT x FROM x fk LEFT OUTER JOIN x pk ON ( x = x ) ; 
INSERT INTO x ( x , x , x ) SELECT x , x , x FROM x ( 1 , 1 ) i ; 
CREATE INDEX x ON ONLY x ( x , x ) ; 
CREATE INDEX x ON x ( x , x ) WHERE x > 1 ; 
CREATE INDEX ON x USING hash ( x ) ; 
CREATE INDEX ON x ( x ) WHERE x > 1 ; 
CREATE INDEX ON x ( ( x + 1 ) ) ; 
CREATE INDEX ON ONLY x ( x ) ; 
CREATE TABLE x ( LIKE x INCLUDING INDEXES ) ; 
SELECT x , x FROM x JOIN x ON x = x WHERE x LIKE 'x' ORDER BY x ; 
SELECT x , x FROM x WHERE x LIKE 'x' ORDER BY x ; 
DROP TABLE x , x , x , x ; 
CREATE INDEX ON x ( ( x + x ) ) ; 
CREATE INDEX ON x ( x COLLATE POSIX" ) ; 
CREATE INDEX ON x ( x COLLATE C" ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 'x' ) TO ( 'x' ) ; 
CREATE INDEX ON x ( x text_pattern_ops ) ; 
CREATE INDEX ON ONLY x ( x text_pattern_ops ) ; 
CREATE INDEX x ON ONLY x ( ( x + x ) ) WHERE x > 1 ; 
CREATE INDEX x ON x ( ( x + x ) ) WHERE x > 1 ; 
CREATE TABLE x ( x INT , x INT , x INT , x INT , x INT , x INT ) ; 
CREATE TABLE x PARTITION OF x ( x PRIMARY KEY ) FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
CREATE TABLE x ( x INT ) PARTITION BY hash ( i ) ; 
CREATE TABLE x PARTITION OF x ( x ) FOR VALUES WITH ( modulus 1 , remainder 1 ) ; 
ALTER TABLE x ADD PRIMARY KEY ( x , x ) ; 
CREATE TABLE x ( x INT NOT NULL , x INT PRIMARY KEY ) ; 
ALTER TABLE ONLY x ADD PRIMARY KEY ( x ) ; 
CREATE TABLE x ( x INT , LIKE x ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 ^ 1 , 'x' ) ; 
INSERT INTO x SELECT 1 ^ x , x ( 'x' , x ) FROM x ( 1 , 1 ) g ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) , ( 'x' , 1 ) ; 
INSERT INTO x SELECT x * 1 , x || x FROM x WHERE x BETWEEN 1 ^ 1 AND 1 ^ 1 ; 
SET search_path TO regress_indexing ; 
CREATE UNIQUE INDEX ON x ( x ) INCLUDE ( x ) ; 
ALTER TABLE x DROP CONSTRAINT parted_pk_detach_test1_pkey ; 
CREATE TABLE x ( x INT UNIQUE ) PARTITION BY list ( a ) ; 
ALTER TABLE x DROP CONSTRAINT parted_uniq_detach_test1_a_key ; 
CREATE TABLE x ( x INT , x INT , x INT ) PARTITION BY list ( a ) ; 
SELECT x , x FROM x GROUP BY x , x HAVING x ( * ) = 1 ORDER BY x , x ; 
SELECT x , x FROM x GROUP BY x , x HAVING x = 1 ORDER BY x , x ; 
SELECT x ( x ) , x ( x ) FROM x GROUP BY x ( x ) HAVING x ( * ) > 1 OR x ( x ) = x ( x ) ORDER BY x ( x ) ; 
SELECT x , x ( x ) FROM x GROUP BY x HAVING x ( * ) > 1 OR x ( x ) = x ( x ) ORDER BY x ; 
SELECT x ( x ) , x ( x ) FROM x HAVING x ( x ) = x ( x ) ; 
SELECT x ( x ) , x ( x ) FROM x HAVING x ( x ) < x ( x ) ; 
SELECT x FROM x HAVING x ( x ) < x ( x ) ; 
SELECT 1 AS one FROM x HAVING x > 1 ; 
SELECT 1 AS one FROM x HAVING 1 > 1 ; 
SELECT 1 AS one FROM x HAVING 1 < 1 ; 
SELECT 1 AS one FROM x WHERE 1 / x = 1 HAVING 1 < 1 ; 
CREATE TABLE x ( x CHAR ) ; 
SELECT 'x' AS seven , * FROM x ; 
SELECT 'x' AS one , x . * FROM x c WHERE x . x = 'x' ; 
SELECT 'x' AS five , x . * FROM x c WHERE x . x < 'x' ; 
SELECT 'x' AS six , x . * FROM x c WHERE x . x <= 'x' ; 
SELECT 'x' AS one , x . * FROM x c WHERE x . x > 'x' ; 
SELECT 'x' AS two , x . * FROM x c WHERE x . x >= 'x' ; 
( SELECT x AS random FROM x ORDER BY x ( ) LIMIT 1 ) INTERSECT ( SELECT x AS random FROM x ORDER BY x ( ) LIMIT 1 ) INTERSECT ( SELECT x AS random FROM x ORDER BY x ( ) LIMIT 1 ) ; 
SELECT x ( * ) AS random INTO x FROM x WHERE x ( ) < 1.000000 / 1 ; 
INSERT INTO x ( x ) SELECT x ( * ) FROM x WHERE x ( ) < 1.000000 / 1 ; 
SELECT x , x ( x ) FROM x GROUP BY x HAVING x ( x ) > 1 ; 
SELECT x ( x ) FROM x HAVING x ( x ) NOT BETWEEN 1 AND 1 ; 
INSERT INTO x SELECT x , 1 , x ( NUMERIC 'x' , x ( x ) ) FROM x WHERE x != 'x' ; 
CREATE TABLE x ( x INT , x NUMERIC ( 1 , 1 ) ) ; 
CREATE TABLE x ( x NUMERIC ) ; 
SELECT x ( 1.000000 , 1.000000 , 1.000000 , 1 ) ; 
SELECT x ( 'x' , 1.000000 , 1.000000 , 1 ) ; 
CREATE TABLE x ( x NUMERIC , x float8 ) ; 
SELECT x , x ( x , 1 , 1 , 1 ) AS wb_1 , x ( x , 1 , 1 , 1 ) AS wb_1f , x ( x , 1 , 1 , 1 ) AS wb_2 , x ( x , 1 , 1 , 1 ) AS wb_2f , x ( x , 1 , 1 , 1 ) AS wb_3 , x ( x , 1 , 1 , 1 ) AS wb_3f , x ( x , 1.000000 , 1.000000 , 1 ) AS wb_4 , x ( x , 1.000000 , 1.000000 , 1 ) AS wb_4f , x ( x , 1 , 1 , 1 ) AS wb_5 , x ( x , 1 , 1 , 1 ) AS wb_5f FROM x ; 
SELECT 'x' AS to_char_16 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_18 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_19 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_20 , x ( x , x 'x' ) FROM x ; 
SELECT 'x' AS to_char_21 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_22 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_23 , x ( x , 'x' ) FROM x ; 
SET lc_numeric = 'x' ; 
SELECT 'x' AS to_number_1 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_2 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_3 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_4 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_5 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_7 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_8 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_9 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_10 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_11 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_12 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_13 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_14 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_15 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_16 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_17 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_18 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_19 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_20 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_21 , x ( 'x' , 'x' ) ; 
SELECT 'x' AS to_number_22 , x ( 'x' , 'x' ) ; 
RESET lc_numeric ; 
SELECT 1 * 1 ; 
SELECT x ( 1.000000 , 1 ) ; 
SELECT 1.000000 / 1 ; 
SELECT 1 % 1 ; 
SELECT x ( 1 , 1 ) * 1 + 1 % 1 ; 
SELECT 1.000000 ^ 1 AS rounds_to_zero ; 
SELECT 1.000000 ^ 1 AS overflows ; 
SELECT 1.000000 ^ 1 ; 
SELECT 1.000000 ^ ( 1 ) ; 
SELECT 1.000000 ^ 1.000000 ; 
SELECT ( 1.000000 ) ^ 1.000000 ; 
SELECT 1.000000 ^ ( 1.000000 ) ; 
SELECT x ( NUMERIC 'x' ) ; 
PREPARE q1 AS SELECT 1 AS a ; 
EXECUTE q1 ; 
PREPARE q1 AS SELECT 1 ; 
PREPARE q2 AS SELECT 1 AS b ; 
DEALLOCATE PREPARE q1 ; 
DEALLOCATE PREPARE q2 ; 
$PREPARE q2 ( TEXT ) AS SELECT x , x , x FROM x WHERE x = 1 ; 
EXECUTE q2 ( 'x' ) ; 
$$$EXECUTE q3 ( 'x' ) ; 
$PREPARE q4 ( nonexistenttype ) AS SELECT 1 ; 
$$PREPARE q5 ( INT , TEXT ) AS SELECT * FROM x WHERE x = 1 OR x = 1 ORDER BY x ; 
CREATE TEMPORARY TABLE x AS EXECUTE q5 ( 1 , 'x' ) ; 
CREATE TEMPORARY TABLE x AS EXECUTE q5 ( 1 , 'x' ) WITH NO DATA ; 
$$PREPARE q6 AS SELECT * FROM x WHERE x = 1 AND x = 1 ; 
DEALLOCATE ALL ; 
$$$$CREATE STATISTICS tst ON x , x FROM x ; 
CREATE STATISTICS tst ON x , x , x FROM x ; 
CREATE STATISTICS tst ON x + x FROM x ; 
CREATE STATISTICS tst ON ( x , x ) FROM x ; 
CREATE STATISTICS tst ( unrecognized ) ON x , x FROM x ; 
CREATE TABLE x ( x INTEGER , x INTEGER , x INTEGER ) ; 
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON x , x FROM x ; 
DROP STATISTICS x ; 
CREATE STATISTICS regress_schema_2 . ab1_a_b_stats ON x , x FROM x ; 
SELECT x ( x ) FROM x WHERE x = 'x' ; 
DROP STATISTICS x . ab1_a_b_stats ; 
CREATE STATISTICS ab1_b_c_stats ON x , x FROM x ; 
CREATE STATISTICS ab1_a_b_c_stats ON x , x , x FROM x ; 
CREATE STATISTICS ab1_b_a_stats ON x , x FROM x ; 
INSERT INTO x SELECT x , x % 1 FROM x ( 1 , 1 ) a ; 
CREATE STATISTICS ab1_a_b_stats ON x , x FROM x ; 
ALTER STATISTICS ab1_a_b_stats SET STATISTICS 1 ; 
SELECT x , x , x , x FROM x s , x d WHERE x . x = 'x' AND x . x = x . x ; 
ALTER STATISTICS IF EXISTS ab1_a_b_stats SET STATISTICS 1 ; 
CREATE TABLE x . t ( x INT , x INT , x TEXT ) ; 
CREATE INDEX x ON x . t ( x , x ) ; 
CREATE SEQUENCE x . s ; 
CREATE VIEW x . v AS SELECT * FROM x . t ; 
CREATE MATERIALIZED VIEW x . mv AS SELECT * FROM x . t ; 
CREATE TYPE tststats . ty AS ( a INT , b INT , c TEXT ) ; 
CREATE FOREIGN DATA WRAPPER extstats_dummy_fdw ; 
CREATE SERVER extstats_dummy_srv FOREIGN DATA WRAPPER extstats_dummy_fdw ; 
CREATE FOREIGN TABLE x . f ( x INT , x INT , x TEXT ) SERVER extstats_dummy_srv ; 
CREATE TABLE x . pt1 PARTITION OF x . pt FOR VALUES FROM ( 1 , 1 ) TO ( 1 , 1 ) ; 
CREATE STATISTICS tststats . s1 ON x , x FROM x . t ; 
CREATE STATISTICS tststats . s2 ON x , x FROM x . ti ; 
CREATE STATISTICS tststats . s3 ON x , x FROM x . s ; 
CREATE STATISTICS tststats . s4 ON x , x FROM x . v ; 
CREATE STATISTICS tststats . s5 ON x , x FROM x . mv ; 
CREATE STATISTICS tststats . s6 ON x , x FROM x . ty ; 
CREATE STATISTICS tststats . s7 ON x , x FROM x . f ; 
CREATE STATISTICS tststats . s8 ON x , x FROM x . pt ; 
CREATE STATISTICS tststats . s9 ON x , x FROM x . pt1 ; 
$$$$DROP SCHEMA tststats CASCADE ; 
DROP FOREIGN DATA WRAPPER extstats_dummy_fdw CASCADE ; 
CREATE TABLE x ( x TEXT , x NUMERIC , x INT , x INT , x DATE , x INT , x INT ) ; 
CREATE STATISTICS s10 ON x , x , x FROM x ; 
CREATE TABLE x ( x TEXT , x NUMERIC , x INT , x TEXT , x DATE , x INT , x TEXT ) ; 
INSERT INTO x ( x , x , x , x ) SELECT x ( x , 1 ) , x ( x , 1 ) , x ( x , 1 ) , x FROM x ( 1 , 1 ) s ( i ) ; 
CREATE STATISTICS func_deps_stat ( dependencies ) ON x , x , x FROM x ; 
CREATE TABLE x ( x TEXT , x NUMERIC , x INT , x VARCHAR , x DATE , x INT , x TEXT ) ; 
INSERT INTO x ( x , x , x , x ) SELECT x ( x , 1 ) , x ( x , 1 ) , x ( x , 1 ) , x ( x , 1 ) FROM x ( 1 , 1 ) s ( i ) ; 
CREATE STATISTICS mcv_lists_stats ( mcv ) ON x , x , x FROM x ; 
ALTER TABLE x ALTER COLUMN x TYPE VARCHAR ( 1 ) ; 
SELECT x . x IS NOT NULL FROM x s , x d WHERE x . x = 'x' AND x . x = x . x ; 
INSERT INTO x ( x , x , x , x ) SELECT ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE x ( x , 1 ) END ) , ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE x ( x , 1 ) END ) , ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE x ( x , 1 ) END ) , x FROM x ( 1 , 1 ) s ( i ) ; 
INSERT INTO x ( x , x , x ) SELECT 1 , 1 , 1 FROM x ( 1 , 1 ) s ( i ) ; 
SELECT x . * FROM x s , x d , x ( x . x ) m WHERE x . x = 'x' AND x . x = x . x ; 
INSERT INTO x ( x , x , x , x ) SELECT ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE 1 END ) , ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE 'x' END ) , ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE 1 END ) , ( CASE WHEN x ( x , 1 ) = 1 THEN NULL ELSE 'x' END ) FROM x ( 1 , 1 ) s ( i ) ; 
CREATE STATISTICS mcv_lists_stats ( mcv ) ON x , x FROM x ; 
CREATE TABLE x ( x TEXT [ ] , x NUMERIC [ ] , x INT [ ] ) ; 
CREATE STATISTICS mcv_lists_arrays_stats ( mcv ) ON x , x , x FROM x ; 
CREATE TABLE x ( x BOOL , x BOOL , x BOOL ) ; 
INSERT INTO x ( x , x , x ) SELECT ( x ( x , 1 ) = 1 ) , ( x ( x , 1 ) = 1 ) , ( x ( x , 1 ) = 1 ) FROM x ( 1 , 1 ) s ( i ) ; 
CREATE STATISTICS mcv_lists_bool_stats ( mcv ) ON x , x , x FROM x ; 
CREATE TABLE x . priv_test_tbl ( x INT , x INT ) ; 
INSERT INTO x . priv_test_tbl SELECT x ( x , 1 ) , x ( x , 1 ) FROM x ( 1 , 1 ) s ( i ) ; 
CREATE STATISTICS tststats . priv_test_stats ( mcv ) ON x , x FROM x . priv_test_tbl ; 
ANALYZE x . priv_test_tbl ; 
GRANT USAGE ON SCHEMA tststats TO x ; 
SET SESSION AUTHORIZATION regress_stats_user1 ; 
ALTER TABLE x . priv_test_tbl ENABLE ROW LEVEL SECURITY ; 
SELECT 'x' AS one , x . x FROM x c WHERE x . x = 'x' ; 
SELECT 'x' AS three , x . x FROM x c WHERE x . x < 'x' ; 
SELECT 'x' AS four , x . x FROM x c WHERE x . x <= 'x' ; 
SELECT 'x' AS three , x . x FROM x c WHERE x . x > 'x' ; 
SELECT 'x' AS four , x . x FROM x c WHERE x . x >= 'x' ; 
~SELECT 'x' AS seven , x . x FROM x c WHERE c . f1 'x' ; 
~SELECT 'x' AS zero , x . x FROM x c WHERE x . x ! 'x' ; 
~SELECT 'x' AS three , x . x FROM x c WHERE c . f1 'x' ; 
~SELECT 'x' AS two , x . x FROM x c WHERE c . f1 'x' ; 
$$$$SELECT x ( x [ 1 ] ) , x ( x [ 1 ] ) FROM x ( 'x' ) AS a ; 
SELECT x ( 'x' || x ( 'x' , 1 ) || 'x' ) ; 
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'x' ; 
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'x' ; 
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL ; 
CREATE TABLE x ( x CHAR ( 1 ) , x money ) ; 
CREATE TABLE x ( x int4 , x int4 , x TEXT ) ; 
CREATE RULE rtest_nothn_r4 AS ON INSERT TO x DO INSTEAD NOTHING ; 
INSERT INTO x ( x , x ) SELECT x , x FROM x ; 
SELECT * FROM x WHERE x ISNULL ; 
UPDATE x SET x = x + 1 WHERE x ISNULL ; 
DELETE FROM x WHERE x ISNULL ; 
UPDATE x SET x = 1 WHERE x < 1 ; 
INSERT INTO x SELECT x . x , x . x FROM x , x WHERE x . x = x . x ; 
UPDATE x SET x = x . x FROM x WHERE x . x = x . x ; 
UPDATE x SET x = x + 1 WHERE x > 1 ; 
UPDATE x SET x = x . x + 1 FROM x WHERE x . x = x . x ; 
UPDATE x SET x = 'x' , x = 'x' WHERE x = 'x' ; 
UPDATE x SET x = x + 'x' ; 
DELETE FROM x USING x WHERE x . x = x . x ; 
INSERT INTO x SELECT * FROM x WHERE x < 1 ; 
~INSERT INTO x SELECT * FROM x WHERE x 'x' ; 
INSERT INTO x SELECT x + 1 , x FROM x WHERE x IN ( 1 , 1 , 1 ) ; 
CREATE TABLE x ( x int4 , x TEXT , x bool ) ; 
CREATE TABLE x ( x int4 , x TEXT , x int4 ) ; 
CREATE VIEW x AS SELECT x , x FROM x X WHERE 1 < ( SELECT x ( * ) FROM x Y WHERE x . x = x . x ) ; 
CREATE VIEW x AS SELECT x , x FROM x WHERE x ; 
CREATE VIEW x AS SELECT x . x , x . x , x ( x . x ) AS refcount FROM x X , x Y WHERE x . x = x . x GROUP BY x . x , x . x ; 
CREATE VIEW x AS SELECT x , x , x ( x ) AS refcount FROM x ; 
~INSERT INTO x SELECT * FROM x WHERE x != 1 AND x ! 'x' ; 
INSERT INTO x SELECT * FROM x WHERE 1 > x ; 
INSERT INTO x SELECT * FROM x WHERE x > 1 AND x = 1 ; 
CREATE TABLE x ( x TEXT , x CHAR ( 1 ) , x FLOAT ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x FLOAT ) ; 
CREATE VIEW x AS SELECT x . x , ( x . x * x . x ) AS size_in_cm FROM x X , x Y WHERE x . x = x . x ; 
INSERT INTO x VALUES ( 'x' , 1.000000 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 1.000000 ) ; 
SELECT * FROM x WHERE x > 1.000000 ORDER BY x USING > ; 
CREATE VIEW x AS SELECT x . x , x . x , x . x , x . x , x . x * x . x AS slminlen_cm , x . x , x . x * x . x AS slmaxlen_cm , x . x FROM x sh , x un WHERE x . x = x . x ; 
CREATE VIEW x AS SELECT x . x , x . x , x . x , x . x , x . x , x . x * x . x AS sl_len_cm FROM x s , x u WHERE x . x = x . x ; 
CREATE VIEW x AS SELECT x . x , x . x , x . x , x . x , x ( x . x , x . x ) AS total_avail FROM x rsh , x rsl WHERE x . x = x . x AND x . x >= x . x AND x . x <= x . x ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , 1.000000 , 1.000000 , 'x' ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , 1.000000 , 'x' ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , 1 , 'x' ) ; 
SELECT * FROM x WHERE x >= 1 ORDER BY 1 ; 
CREATE TABLE x ( x CHAR ( 1 ) , x INTEGER ) ; 
CREATE VIEW x AS SELECT * FROM x WHERE NOT EXISTS ( SELECT x FROM x WHERE x = x ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , 1.000000 , 'x' , 1.000000 ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , 1.000000 , 'x' , 1.000000 ) ON CONFLICT DO NOTHING ; 
DELETE FROM x WHERE EXISTS ( SELECT * FROM x WHERE x = x . x ) ; 
CREATE RULE rules_foorule AS ON INSERT TO x WHERE x < 1 DO INSTEAD NOTHING ; 
DROP RULE rules_foorule ON rules_foo ; 
CREATE RULE rules_foorule AS ON INSERT TO x WHERE x < 1 DO INSTEAD INSERT INTO x VALUES ( x ) ; 
CREATE VIEW x AS SELECT x . x , x , x FROM x LEFT JOIN x USING ( pid ) ; 
DROP RULE rrule ON vview ; 
\\CREATE OR REPLACE RULE myrule AS ON INSERT TO x DO INSTEAD INSERT INTO x VALUES ( 1 , 1 ) ; 
CREATE TABLE x ( x INTEGER , x INTEGER , PRIMARY KEY ( x , x ) ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 'x' ) ON CONFLICT DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 'x' ) ON CONFLICT ( x , x , x ) DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , 1.000000 , 'x' , 1.000000 ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
DROP RULE _RETURN" ON rules_fooview ; 
CREATE TABLE x ( x INT , x TEXT ) PARTITION BY list ( x ) ; 
CREATE VIEW x AS SELECT * FROM x ORDER BY x ; 
CREATE TEMP TABLE x ( x INTEGER PRIMARY KEY ) ; 
CREATE TEMP TABLE x ( CHECK ( x >= 1 AND x < 1 ) ) INHERITS ( x ) ; 
INSERT INTO x SELECT * FROM x ( 1 , 1 , 1 ) g ; 
SELECT * FROM ONLY x ; 
UPDATE x SET x = x / 1 ; 
CREATE RULE r3 AS ON DELETE TO x DO NOTIFY rules_src_deletion ; 
CREATE TABLE x ( x INT , x INT [ ] , x TEXT ) ; 
ALTER RULE InsertRule ON x RENAME TO NewInsertRule ; 
CREATE VIEW x AS VALUES ( 1 , 1 ) ; 
CREATE VIEW x ( x ) AS VALUES ( 1 , 1 ) ; 
CREATE VIEW x ( x ) AS SELECT * FROM ( VALUES ( 1 , 1 ) ) v ; 
CREATE VIEW x ( x ) AS SELECT * FROM ( VALUES ( 1 , 1 ) ) v ( q , w ) ; 
CREATE UNIQUE INDEX x ON x ( x COLLATE C" bpchar_pattern_ops ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) RETURNING * ; 
SELECT x , x , x FROM x WHERE x = 'x' ; 
DROP RULE hat_nosert ON hats ; 
DROP RULE hat_nosert_all ON hats ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 'x' , 'x' ) RETURNING * ; 
SELECT * FROM x WHERE x IN ( 'x' , 'x' , 'x' ) ORDER BY x ; 
DROP RULE hat_upsert ON hats ; 
ALTER RULE rules_parted_table_insert ON x RENAME TO rules_parted_table_insert_redirect ; 
ALTER TABLE x DISABLE RULE rule1 ; 
ALTER TABLE x ENABLE RULE rule1 ; 
ALTER TABLE x ENABLE REPLICA RULE rule1 ; 
CREATE TYPE int8alias1 ; 
CREATE FUNCTION x ( cstring ) RETURNS int8alias1 STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
CREATE FUNCTION x ( int8alias1 ) RETURNS cstring STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
CREATE TYPE int8alias2 ; 
CREATE FUNCTION x ( cstring ) RETURNS int8alias2 STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
CREATE FUNCTION x ( int8alias2 ) RETURNS cstring STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
CREATE CAST ( int8 AS int8alias1 ) WITHOUT FUNCTION ; 
CREATE CAST ( int8 AS int8alias2 ) WITHOUT FUNCTION ; 
CREATE CAST ( int8alias1 AS int8 ) WITHOUT FUNCTION ; 
CREATE CAST ( int8alias2 AS int8 ) WITHOUT FUNCTION ; 
CREATE FUNCTION x ( int8alias1 , int8alias1 ) RETURNS bool STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
ALTER OPERATOR FAMILY integer_ops USING btree ADD OPERATOR 1 = ( int8alias1 , int8alias1 ) ; 
CREATE FUNCTION x ( int8alias2 , int8alias2 ) RETURNS bool STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
ALTER OPERATOR FAMILY integer_ops USING btree ADD OPERATOR 1 = ( int8alias2 , int8alias2 ) ; 
CREATE FUNCTION x ( int8 , int8alias1 ) RETURNS bool STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
ALTER OPERATOR FAMILY integer_ops USING btree ADD OPERATOR 1 = ( int8 , int8alias1 ) ; 
CREATE FUNCTION x ( int8alias1 , int8alias2 ) RETURNS bool STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
ALTER OPERATOR FAMILY integer_ops USING btree ADD OPERATOR 1 = ( int8alias1 , int8alias2 ) ; 
ALTER OPERATOR FAMILY integer_ops USING btree ADD OPERATOR 1 < ( int8alias1 , int8alias1 ) ; 
CREATE FUNCTION x ( int8 , int8alias1 ) RETURNS INT STRICT IMMUTABLE LANGUAGE internal AS 'x' ; 
ALTER OPERATOR FAMILY integer_ops USING btree ADD FUNCTION 1 x ( int8 , int8alias1 ) ; 
CREATE TABLE x ( x int8 PRIMARY KEY , x int8 , x int8 ) ; 
CREATE TABLE x ( x int8 PRIMARY KEY , x int8alias1 , x int8alias2 ) ; 
CREATE UNIQUE INDEX x ON x ( ( x + 1 ) ) ; 
CREATE UNIQUE INDEX x ON x ( ( x + 1 + 1 ) ) ; 
SET enable_mergejoin = ON ; 
SET enable_nestloop = off ; 
SET enable_nestloop = ON ; 
SET SESSION AUTHORIZATION regress_user_ectest ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = x AND x = x ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x = x OR x = x ; 
CREATE FUNCTION x ( point , widget ) RETURNS bool AS 'x' LANGUAGE C STRICT ; 
CREATE FUNCTION x ( emp ) RETURNS bool AS 'x' LANGUAGE C STRICT ; 
CREATE FUNCTION x ( path , path ) RETURNS point AS 'x' LANGUAGE C STRICT ; 
LOAD 'x' ; 
CREATE TABLE x ( x TIMESTAMP ( 1 ) WITH TIME ZONE ) ; 
SELECT x ( * ) AS One FROM x WHERE x = TIMESTAMP WITH TIME ZONE 'x' ; 
SELECT x ( * ) AS One FROM x WHERE x = TIMESTAMP ( 1 ) WITH TIME ZONE 'x' ; 
SELECT x ( * ) AS two FROM x WHERE x = TIMESTAMP ( 1 ) WITH TIME ZONE 'x' ; 
SELECT 'x' AT TIME ZONE 'x' ; 
SELECT 'x' AS 15" , x FROM x WHERE x < TIMESTAMP WITH TIME ZONE 'x' ; 
SELECT 'x' AS one , x FROM x WHERE x = TIMESTAMP WITH TIME ZONE 'x' ; 
SELECT 'x' AS 63" , x FROM x WHERE x != TIMESTAMP WITH TIME ZONE 'x' ; 
SELECT 'x' AS 16" , x FROM x WHERE x <= TIMESTAMP WITH TIME ZONE 'x' ; 
SELECT 'x' AS 49" , x FROM x WHERE x >= TIMESTAMP WITH TIME ZONE 'x' ; 
SELECT 'x' AS 54" , x - TIMESTAMP WITH TIME ZONE 'x' AS diff FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS date_trunc_week , x ( 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS week_trunc ; 
SELECT 'x' AS 54" , x AS timestamptz , x ( 'x' , x ) AS quarter , x ( 'x' , x ) AS msec , x ( 'x' , x ) AS usec FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS 54" , x AS timestamptz , x ( 'x' , x ) AS isoyear , x ( 'x' , x ) AS week , x ( 'x' , x ) AS dow FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SET timezone = 'x' ; 
SELECT x ( x ( ) , 'x' ) AS OF" , x ( x ( ) , 'x' ) AS TZH:TZM" ; 
RESET timezone ; 
CREATE TABLE x ( x INT , x timestamptz ) ; 
SET TimeZone TO 'x' ; 
SELECT x ( 1 , 1 , 1 , 1 , 1 , 1.000000 , 'x' ) ; 
WITH tzs ( tz ) AS ( VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) , ( 'x' ) ) SELECT x ( 1 , 1 , 1 , 1 , 1 , 1 , x ) , x FROM x ; 
SELECT x ( 1 , 1 , 1 , 1 , 1 , 1 , 'x' ) ; 
SELECT x ( 1 , 1 , 1 , 1 , 1 , 1 , 'x' ) = x 'x' ; 
SELECT x ( 1 , 1 , 1 , 1 , 1 , 1 , 'x' ) AT TIME ZONE 'x' ; 
RESET TimeZone ; 
CREATE TEMP TABLE x ( x timestamptz PRIMARY KEY ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x AT TIME ZONE 'x' = 'x' ; 
SELECT * FROM x WHERE x AT TIME ZONE 'x' = 'x' ; 
SET search_path = fast_default ; 
CREATE TABLE x ( x OID ) ; 
$$$$$$$ALTER TABLE x ADD x INT DEFAULT 1 ; 
ALTER TABLE x ADD x timestamptz DEFAULT CURRENT_TIMESTAMP ; 
CREATE TABLE x ( x INT NOT NULL PRIMARY KEY , x INT DEFAULT 1 ) ; 
ALTER TABLE x ADD COLUMN x BPCHAR ( 1 ) DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x DATE DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x TIMESTAMP DEFAULT 'x' , ADD COLUMN x TIMESTAMP , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x TEXT [ ] DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x SMALLINT DEFAULT 1 , ADD COLUMN x SMALLINT , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x BIGINT DEFAULT 1 , ALTER COLUMN x SET DEFAULT 1 , ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE x ADD COLUMN x NUMERIC DEFAULT 1.000000 , ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE x ADD COLUMN x TIME DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 1.000000 ; 
ALTER TABLE x ADD COLUMN x INTERVAL DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT x ( 'x' , 1 ) , ALTER COLUMN x SET DEFAULT 'x' ; 
ALTER TABLE x ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x SET DEFAULT x ( 'x' , 1 ) ; 
ALTER TABLE x ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT ; 
$$$$CREATE TABLE x ( x INT NOT NULL PRIMARY KEY , x INT DEFAULT x ( x ( 1 ) ) ) ; 
ALTER TABLE x ADD COLUMN x BPCHAR ( 1 ) DEFAULT x ( 1 ) , ALTER COLUMN x SET DEFAULT x ( x ( 1 ) ) ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT x ( 1 ) , ALTER COLUMN x SET DEFAULT x ( 1 ) ; 
ALTER TABLE x ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT , ALTER COLUMN x DROP DEFAULT ; 
CREATE TABLE x ( x INT NOT NULL PRIMARY KEY ) ; 
ALTER TABLE x ADD COLUMN x TIMESTAMP DEFAULT x ( ) ; 
INSERT INTO x SELECT * FROM x ( 1 , 1 ) a ; 
ALTER TABLE x ADD COLUMN x BIGINT NOT NULL DEFAULT 1 ; 
INSERT INTO x SELECT x , x - 1 FROM x ( 1 , 1 ) a ( b ) ; 
SELECT x , x FROM x WHERE x = 1 LIMIT 1 ; 
SELECT x , x FROM x WHERE x = 'x' LIMIT 1 ; 
SELECT x ( x ) , x ( x COLLATE C" ) , x ( x COLLATE C" ) FROM x ; 
SELECT * FROM x ORDER BY x , x , x LIMIT 1 ; 
SELECT * FROM x WHERE x > 1 ORDER BY x , x , x LIMIT 1 ; 
DELETE FROM x WHERE x BETWEEN 1 AND 1 RETURNING * ; 
UPDATE x SET x = 'x' || x || 'x' WHERE x < 1 ; 
SELECT * FROM x WHERE x LIKE 'x' ORDER BY x ; 
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 1 ; 
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' , ALTER COLUMN x SET DEFAULT 1 ; 
SELECT x FROM x WHERE x = 1 ; 
$$CREATE TABLE x ( x serial PRIMARY KEY , x INT , x INT , x INT ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 1 , 1 , NULL ) ; 
CREATE TABLE x ( x INT REFERENCES x ON DELETE CASCADE , x INT ) ; 
ALTER TABLE x ADD COLUMN x DOUBLE PRECISION DEFAULT 1.000000 ; 
ALTER TABLE x ADD COLUMN x BOOLEAN DEFAULT TRUE ; 
ALTER TABLE x ADD COLUMN x VARCHAR ( 1 ) DEFAULT 'x' ; 
SET LOCAL enable_seqscan = TRUE ; 
DROP EVENT TRIGGER has_volatile_rewrite ; 
DROP FUNCTION log_rewrite ; 
DROP SCHEMA fast_default ; 
SET search_path = public ; 
CREATE TABLE x ( x INT , x TEXT COLLATE en-x-icu" NOT NULL ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE ja_JP.eucjp-x-icu" ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE foo-x-icu" ) ; 
CREATE TABLE x ( x INT COLLATE en-x-icu" , x TEXT ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE sv-x-icu" ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE C" ) ; 
SELECT * FROM x WHERE x COLLATE C" >= 'x' COLLATE en-x-icu" ; 
CREATE DOMAIN testdomain_sv AS TEXT COLLATE sv-x-icu" ; 
CREATE TABLE x ( x INT , x testdomain_sv COLLATE en-x-icu" ) ; 
SELECT 'x' COLLATE en-x-icu" > 'x' COLLATE en-x-icu" AS true" ; 
SELECT 'x' COLLATE sv-x-icu" > 'x' COLLATE sv-x-icu" AS false" ; 
CREATE TABLE x ( x INT , x TEXT COLLATE en-x-icu" , x TEXT COLLATE tr-x-icu" ) ; 
SELECT * FROM x WHERE x ILIKE 'x' ; 
SELECT 'x' COLLATE en-x-icu" ILIKE 'x' AS true" ; 
SELECT 'x' COLLATE tr-x-icu" ILIKE 'x' AS false" ; 
SELECT 'x' ILIKE 'x' COLLATE en-x-icu" AS false" ; 
SELECT 'x' ILIKE 'x' COLLATE tr-x-icu" AS true" ; 
SELECT x FROM x WHERE x ILIKE 'x' ; 
~SELECT * FROM x WHERE x 'x' ; 
~~~SELECT * FROM x WHERE x * 'x' ; 
~~CREATE TABLE x ( x INT , x TEXT COLLATE en-x-icu" ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ; 
~~~~~~~~~~SELECT 'x' COLLATE en-x-icu" * 'x' AS true" ; 
~~SELECT x ( x 'x' , 'x' ) ; 
SELECT x ( x 'x' , 'x' COLLATE tr-x-icu" ) ; 
CREATE VIEW x AS SELECT x , x ( ( x || x ) COLLATE C" ) FROM x ; 
SELECT x , x FROM x UNION ALL SELECT x , x FROM x ORDER BY 1 ; 
$$$$$$SELECT x ( 'x' , 'x' COLLATE en-x-icu" ) AS t , x ( 'x' , 'x' COLLATE C" ) AS f ; 
$$$$SELECT x ( 'x' , 'x' ) AS f ; 
CREATE INDEX x ON x ( x COLLATE C" ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x ILIKE 'x' ; 
$$$$$$CREATE COLLATION test4 FROM nonsense ; 
CREATE COLLATION test5 FROM test0 ; 
SELECT x FROM x WHERE x LIKE 'x' ORDER BY 1 ; 
ALTER COLLATION test1 RENAME TO test11 ; 
ALTER COLLATION test11 OWNER TO x ; 
ALTER COLLATION test11 SET SCHEMA test_schema ; 
COMMENT ON COLLATION test0 IS 'x' ; 
SELECT x , x , x ( x . x , 'x' ) FROM x JOIN x ON ( x = x . x ) WHERE x LIKE 'x' ORDER BY 1 ; 
DROP COLLATION x , x . test11 , x ; 
DROP SCHEMA test_schema ; 
ALTER COLLATION en-x-icu" REFRESH VERSION ; 
CREATE COLLATION test0 FROM C" ; 
CREATE TABLE x ( x INT , x TEXT COLLATE test0 ) ; 
CREATE DOMAIN collate_dep_dom1 AS TEXT COLLATE test0 ; 
CREATE TYPE collate_dep_test2 AS ( x INT , y TEXT COLLATE test0 ) ; 
CREATE VIEW x AS SELECT TEXT 'x' COLLATE test0 AS foo ; 
CREATE INDEX x ON x ( x COLLATE test0 ) ; 
DROP TYPE collate_dep_test2 ; 
@@DROP TYPE textrange_c ; 
DROP TYPE textrange_en_us ; 
CREATE COLLATION testcoll_ignore_accents ( provider = icu , locale = 'x' ) ; 
SELECT 'x' > 'x' COLLATE und-x-icu" , 'x' < 'x' COLLATE testcoll_ignore_accents ; 
CREATE COLLATION testcoll_backwards ( provider = icu , locale = 'x' ) ; 
SELECT 'x' < 'x' COLLATE und-x-icu" , 'x' > 'x' COLLATE testcoll_backwards ; 
CREATE COLLATION testcoll_lower_first ( provider = icu , locale = 'x' ) ; 
CREATE COLLATION testcoll_upper_first ( provider = icu , locale = 'x' ) ; 
SELECT 'x' < 'x' COLLATE testcoll_lower_first , 'x' > 'x' COLLATE testcoll_upper_first ; 
CREATE COLLATION testcoll_shifted ( provider = icu , locale = 'x' ) ; 
SELECT 'x' < 'x' COLLATE und-x-icu" , 'x' > 'x' COLLATE testcoll_shifted ; 
CREATE COLLATION testcoll_numeric ( provider = icu , locale = 'x' ) ; 
SELECT 'x' > 'x' COLLATE und-x-icu" , 'x' < 'x' COLLATE testcoll_numeric ; 
CREATE COLLATION testcoll_error1 ( provider = icu , locale = 'x' ) ; 
CREATE COLLATION testcoll_de_phonebook ( provider = icu , locale = 'x' ) ; 
SELECT 'x' < 'x' COLLATE de-x-icu" , 'x' > 'x' COLLATE testcoll_de_phonebook ; 
INSERT INTO x VALUES ( 1 , x & 'x' ) ; 
SELECT * FROM x WHERE x = 'x' COLLATE ctest_det ; 
SELECT * FROM x WHERE x = 'x' COLLATE ctest_nondet ; 
CREATE COLLATION case_sensitive ( provider = icu , locale = 'x' ) ; 
SELECT 'x' <= 'x' COLLATE case_sensitive , 'x' >= 'x' COLLATE case_sensitive ; 
SELECT 'x' <= 'x' COLLATE case_insensitive , 'x' >= 'x' COLLATE case_insensitive ; 
CREATE TABLE x ( x TEXT COLLATE case_sensitive ) ; 
SELECT x FROM x WHERE x SIMILAR TO 'x' ; 
~SELECT x FROM x UNION SELECT x FROM x ORDER BY x ; 
SELECT x FROM x INTERSECT SELECT x FROM x ; 
SELECT x FROM x EXCEPT SELECT x FROM x ; 
SELECT DISTINCT x FROM x ORDER BY x ; 
SELECT x , x ( * ) FROM x GROUP BY x ORDER BY x ; 
SELECT x , x ( ) OVER ( ORDER BY x ) , x ( ) OVER ( ORDER BY x ) FROM x ORDER BY x ; 
SELECT x ( 'x' COLLATE case_sensitive , NULL , 'x' ) ; 
CREATE TABLE x ( x TEXT COLLATE case_insensitive ) ; 
~SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY x ; 
SELECT x ( 'x' COLLATE case_insensitive , NULL , 'x' ) ; 
CREATE TABLE x ( x CHAR ( 1 ) COLLATE case_insensitive ) ; 
~CREATE TABLE x ( x TEXT COLLATE C" ) ; 
SELECT 'x' = 'x' COLLATE case_sensitive ; 
SELECT 'x' = 'x' COLLATE case_insensitive ; 
CREATE TEMP TABLE x ( x TEXT COLLATE case_insensitive , x TEXT ) ; 
SELECT * FROM x WHERE x = 'x' COLLATE ignore_accents ; 
CREATE TABLE x ( x TEXT COLLATE case_sensitive PRIMARY KEY ) ; 
CREATE TABLE x ( x TEXT COLLATE case_insensitive REFERENCES x ( x ) ON UPDATE CASCADE ON DELETE CASCADE ) ; 
CREATE TABLE x ( x TEXT COLLATE case_insensitive PRIMARY KEY ) ; 
CREATE TABLE x ( x TEXT COLLATE case_sensitive REFERENCES x ( x ) ON UPDATE CASCADE ON DELETE CASCADE ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE case_insensitive ) PARTITION BY LIST ( b ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE case_sensitive ) PARTITION BY HASH ( b ) ; 
SELECT ( SELECT x ( * ) FROM x ) = ( SELECT x ( * ) FROM x ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE case_insensitive ) PARTITION BY HASH ( b ) ; 
CREATE TABLE x ( x INT , x CHAR ( 1 ) COLLATE case_insensitive ) PARTITION BY LIST ( b ) ; 
CREATE TABLE x ( x INT , x CHAR ( 1 ) COLLATE case_sensitive ) PARTITION BY HASH ( b ) ; 
CREATE TABLE x ( x INT , x CHAR ( 1 ) COLLATE case_insensitive ) PARTITION BY HASH ( b ) ; 
SET client_min_messages TO warning ; 
CREATE COLLATION coll_icu_upgrade FROM und-x-icu" ; 
CREATE TABLE x ( x INT , x TEXT COLLATE en_US" NOT NULL ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE ja_JP.eucjp" ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE foo" ) ; 
CREATE TABLE x ( x INT COLLATE en_US" , x TEXT ) ; 
CREATE TABLE x ( x INT , x TEXT COLLATE sv_SE" ) ; 
SELECT * FROM x WHERE x COLLATE C" >= 'x' COLLATE en_US" ; 
CREATE DOMAIN testdomain_sv AS TEXT COLLATE sv_SE" ; 
CREATE TABLE x ( x INT , x testdomain_sv COLLATE en_US" ) ; 
SELECT 'x' COLLATE en_US" > 'x' COLLATE en_US" AS true" ; 
SELECT 'x' COLLATE sv_SE" > 'x' COLLATE sv_SE" AS false" ; 
CREATE TABLE x ( x INT , x TEXT COLLATE en_US" , x TEXT COLLATE tr_TR" ) ; 
SELECT 'x' COLLATE en_US" ILIKE 'x' AS true" ; 
SELECT 'x' COLLATE tr_TR" ILIKE 'x' AS false" ; 
SELECT 'x' ILIKE 'x' COLLATE en_US" AS false" ; 
SELECT 'x' ILIKE 'x' COLLATE tr_TR" AS true" ; 
~~~~~~CREATE TABLE x ( x INT , x TEXT COLLATE en_US" ) ; 
~~~~~~~~~~SELECT 'x' COLLATE en_US" * 'x' AS true" ; 
~SELECT 'x' COLLATE tr_TR" * 'x' AS false" ; 
~SELECT 'x' * 'x' COLLATE en_US" AS false" ; 
~SELECT 'x' * 'x' COLLATE tr_TR" AS true" ; 
~SELECT x FROM x WHERE x * 'x' ; 
SET lc_time TO 'x' ; 
SELECT x ( x 'x' , 'x' COLLATE tr_TR" ) ; 
$$$$$$SELECT x ( 'x' , 'x' COLLATE en_US" ) AS t , x ( 'x' , 'x' COLLATE C" ) AS f ; 
$$$$$$$$$$ALTER COLLATION en_US" REFRESH VERSION ; 
@@CREATE TABLE x ( x serial PRIMARY KEY , x TEXT NOT NULL , x TEXT NOT NULL , x TEXT , CONSTRAINT test_replica_identity_unique_defer UNIQUE ( x , x ) DEFERRABLE , CONSTRAINT test_replica_identity_unique_nondefer UNIQUE ( x , x ) ) ; 
CREATE UNIQUE INDEX x ON x ( x , x , ( 1 ) ) ; 
CREATE UNIQUE INDEX x ON x ( x , x ) WHERE x != 'x' ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_keyab ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_nonkey ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_hash ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_expr ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_partial ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_othertable_pkey ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_unique_defer ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_pkey ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_unique_nondefer ; 
ALTER TABLE x REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key ; 
ALTER TABLE x REPLICA IDENTITY DEFAULT ; 
ALTER TABLE x REPLICA IDENTITY FULL ; 
ALTER TABLE x REPLICA IDENTITY NOTHING ; 
ALTER TEXT SEARCH CONFIGURATION ispell_tst ALTER MAPPING FOR word , numword , asciiword , hword , numhword , asciihword , hword_part , hword_numpart , hword_asciipart WITH ispell , english_stem ; 
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING REPLACE ispell WITH hunspell ; 
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING REPLACE hunspell WITH hunspell_long ; 
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING REPLACE hunspell_long WITH hunspell_num ; 
ALTER TEXT SEARCH CONFIGURATION synonym_tst ALTER MAPPING FOR asciiword , hword_asciipart , asciihword WITH synonym , english_stem ; 
ALTER TEXT SEARCH CONFIGURATION thesaurus_tst ALTER MAPPING FOR asciiword , hword_asciipart , asciihword WITH synonym , thesaurus , english_stem ; 
SELECT * FROM ( SELECT x AS cfgid , ( x ( x ) ) . tokid AS tokid FROM x ) AS ttRIGHT JOIN x AS m ON ( x . x = x . x AND x . x = x . x ) WHERE x . x IS NULL OR x . x IS NULL ; 
@@SELECT x ( * ) FROM x WHERE x 'x' ; 
@@@@@@@@@@@@@@@@@@@@EXPLAIN ( costs off ) SELECT x ( * ) FROM x WHERE x 'x' ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SELECT * FROM x ( 'x' ) ORDER BY x DESC , x DESC , x LIMIT 1 ; 
SELECT * FROM x ( 'x' , 'x' ) ORDER BY x DESC , x DESC , x ; 
SELECT x ( x ( 'x' , 'x' ) ) ; 
SELECT x ( 'x' , 'x' ) && x ( 'x' , 'x' ) ; 
SELECT x ( 'x' , 'x' ) || x ( 'x' , 'x' ) ; 
SELECT x ( 'x' , 'x' ) || ! ! x ( 'x' , 'x' ) ; 
SELECT x ( 'x' , 'x' ) && 'x' ; 
\UPDATE x SET x = x ( 'x' , x ) ; 
ALTER TABLE x ADD COLUMN x tsquery ; 
SELECT x ( x ( 'x' , 'x' , 'x' ) , 'x' , 'x' ) ; 
SELECT x ( x ( 'x' ) , x ( 'x' ) , x ( 'x' ) ) ; 
@SELECT x FROM x WHERE x > 'x' ; 
@@SELECT x FROM x WHERE x < 'x' ; 
@SELECT x ( x , 'x' ) FROM x ( 'x' , 'x' ) AS query ; 
CREATE INDEX x ON x USING gist ( x tsquery_ops ) ; 
@@@@SELECT x ( x ( 'x' , 'x' ) , 'x' , 'x' ) ; 
@@@@SET default_text_search_config = english ; 
@@@@UPDATE x SET x = NULL WHERE x = 'x' ; 
@@@@@@@@CREATE TEMP TABLE x ( x tsvector ) ; 
INSERT INTO x VALUES ( x ( 'x' ) ) ; 
@@@@@@CREATE TABLE x ( x line ) ; 
INSERT INTO x VALUES ( x ( x 'x' , x 'x' ) ) ; 
SELECT * FROM x WHERE x . x = 1 ; 
UPDATE x SET x = 1 WHERE x . x = 1 ; 
SELECT x . x AS i1492 , x . x AS i1 FROM x h WHERE x . x = 1 ; 
SELECT x . x AS i20000 FROM x h WHERE x . x = 1 ; 
INSERT INTO x SELECT 1 FROM x ( 1 , 1 ) a ; 
DECLARE c CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
MOVE FORWARD ALL FROM c ; 
MOVE BACKWARD ALL FROM c ; 
INSERT INTO x SELECT x / 1 FROM x ( 1 , 1 ) a ; 
CREATE TABLE x ( x float4 , x INT ) ; 
INSERT INTO x VALUES ( 1.000000 , 1 ) ; 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\DEALLOCATE q ; 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\CREATE TABLE x ( x INT , x CHAR ( 1 ) ) USING heap_psql ; 
CREATE TABLE x ( x INT , x CHAR ( 1 ) ) USING heap ; 
\DROP ACCESS METHOD heap_psql ; 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\$$\$$\$$\\\\\\\\\ALTER SCHEMA testpart OWNER TO x ; 
SET search_path TO testpart ; 
DROP SCHEMA testpart ; 
SET search_path TO DEFAULT ; 
CREATE INDEX x ON x USING brin ( x , x , x , x , x , x , x , x , x , x , x , x , x inet_inclusion_ops , x inet_minmax_ops , x inet_inclusion_ops , x inet_minmax_ops , x , x , x , x , x , x , x , x , x , x , x , x , x , x ) WITH ( pages_per_range = 1 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
$$$$$SET enable_seqscan = 1 ; 
$UPDATE x SET x = 'x' WHERE x IS NOT NULL ; 
$$$$INSERT INTO x SELECT x / 1 , x % 1 FROM x ( 1 , 1 ) x ( x ) ; 
CREATE INDEX x ON x USING brin ( x ) WITH ( pages_per_range = 1 ) ; 
SET LOCAL min_parallel_table_scan_size = 1 ; 
SET LOCAL enable_hashjoin = ON ; 
$$$$$$$$CREATE TABLE x AS SELECT x ( 1 , 1 ) AS id , 'x' ; 
ALTER TABLE x SET ( autovacuum_enabled = 'x' ) ; 
INSERT INTO x SELECT 1 AS id , 'x' FROM x ( 1 , 1 ) ; 
UPDATE x SET x = 1 , x = x ( 'x' ) / 1 WHERE x = 'x' ; 
CREATE TABLE x AS SELECT x ( 1 , 1 ) AS id , x ( 'x' , 1 , 'x' ) AS t ; 
$$$$ROLLBACK TO settings ; 
SET LOCAL enable_parallel_hash = off ; 
$$$$SET LOCAL enable_parallel_hash = ON ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SET LOCAL parallel_leader_participation = off ; 
$$$$SET enable_parallel_hash = off ; 
SET enable_material = off ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x LEFT JOIN ( SELECT x . x , x . x FROM x b1 JOIN x b2 USING ( id ) ) ss ON x . x < x . x + 1 AND x . x > x . x - 1 ; 
SELECT x ( * ) FROM x LEFT JOIN ( SELECT x . x , x . x FROM x b1 JOIN x b2 USING ( id ) ) ss ON x . x < x . x + 1 AND x . x > x . x - 1 ; 
$$$$$$$$SET enable_parallel_hash = ON ; 
$$$$$$$$EXPLAIN ( costs off ) SELECT x ( x ( x . x ) ) FROM x LEFT JOIN ( SELECT x , COALESCE ( x , 'x' ) || 'x' AS t FROM x ) s USING ( id ) ; 
SELECT x ( x ( x . x ) ) FROM x LEFT JOIN ( SELECT x , COALESCE ( x , 'x' ) || 'x' AS t FROM x ) s USING ( id ) ; 
$$$$CREATE TABLE x ( x bool , x INT , x TEXT , x INT ) ; 
CREATE TABLE x ( x money ) ; 
SELECT x + 'x' FROM x ; 
SELECT x - 'x' FROM x ; 
SELECT x * 1 FROM x ; 
SELECT 1 * x FROM x ; 
SELECT x / 1 FROM x ; 
SELECT x = 'x' FROM x ; 
SELECT x != 'x' FROM x ; 
SELECT x <= 'x' FROM x ; 
SELECT x >= 'x' FROM x ; 
SELECT x < 'x' FROM x ; 
SELECT x > 'x' FROM x ; 
SELECT x ( x + 'x' ) FROM x ; 
WITH q1 ( x , y ) AS ( SELECT 1 , 1 ) SELECT * FROM x , x AS q2 ; 
SELECT x ( * ) FROM ( WITH q1 ( x ) AS ( SELECT x ( ) FROM x ( 1 , 1 ) ) SELECT * FROM x UNION SELECT * FROM x ) ss ; 
CREATE RECURSIVE VIEW x ( x ) AS VALUES ( 1 ) UNION ALL SELECT x + 1 FROM x WHERE x < 1 ; 
CREATE OR REPLACE RECURSIVE VIEW x ( x ) AS VALUES ( 1 ) UNION ALL SELECT x + 1 FROM x WHERE x < 1 ; 
WITH RECURSIVE t ( n ) AS ( SELECT 1 UNION SELECT 1 - x FROM x ) SELECT * FROM x ; 
WITH RECURSIVE t ( n ) AS ( VALUES ( 1 ) UNION ALL SELECT x + 1 FROM x ) SELECT * FROM x LIMIT 1 ; 
WITH RECURSIVE t ( n ) AS ( SELECT 1 UNION SELECT x + 1 FROM x ) SELECT * FROM x LIMIT 1 ; 
WITH q AS ( SELECT 'x' AS x ) SELECT x , x IS OF ( TEXT ) AS is_text FROM x ; 
SELECT x ( * ) FROM ( WITH RECURSIVE t ( n ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) SELECT * FROM x ) AS t WHERE x < ( SELECT x ( * ) FROM ( WITH RECURSIVE t ( n ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) SELECT * FROM x WHERE x < 1 ) AS t WHERE x < 1 ) ; 
WITH q1 ( x , y ) AS ( SELECT x , x ( x ) FROM x GROUP BY x ) SELECT x ( * ) FROM x WHERE x > ( SELECT x ( x ) / 1 FROM x qsub ) ; 
WITH RECURSIVE q AS ( SELECT * FROM x UNION ALL ( WITH x AS ( SELECT * FROM x ) SELECT * FROM x ) ) SELECT * FROM x LIMIT 1 ; 
WITH RECURSIVE q AS ( SELECT * FROM x UNION ALL ( WITH RECURSIVE x AS ( SELECT * FROM x UNION ALL ( SELECT * FROM x UNION ALL SELECT * FROM x ) ) SELECT * FROM x ) ) SELECT * FROM x LIMIT 1 ; 
WITH RECURSIVE t ( i , j ) AS ( VALUES ( 1 , 1 ) UNION ALL SELECT x . x , x . x + 1 FROM ( SELECT 1 AS i UNION ALL SELECT 1 AS i ) AS t2 JOIN x ON ( x . x = x . x + 1 ) ) SELECT * FROM x ; 
CREATE TEMPORARY TABLE x ( x INTEGER PRIMARY KEY , x INTEGER REFERENCES x ( x ) ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ; 
WITH RECURSIVE y ( id ) AS ( VALUES ( 1 ) ) , x ( id ) AS ( SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( id ) AS ( SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) , y ( id ) AS ( VALUES ( 1 ) ) SELECT * FROM x ; 
WITH RECURSIVE x ( id ) AS ( VALUES ( 1 ) UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) , y ( id ) AS ( VALUES ( 1 ) UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) SELECT x . * , x . * FROM x LEFT JOIN x USING ( id ) ; 
WITH RECURSIVE x ( id ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) , y ( id ) AS ( SELECT * FROM x UNION ALL SELECT * FROM x ) , z ( id ) AS ( SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 INTERSECT SELECT x + 1 FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 INTERSECT ALL SELECT x + 1 FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 EXCEPT SELECT x + 1 FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 EXCEPT ALL SELECT x + 1 FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT x FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT x FROM x UNION ALL SELECT 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT x FROM x WHERE x = 1 UNION ALL SELECT x . x + 1 FROM x LEFT JOIN x ON x . x = x . x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT x FROM x WHERE x = 1 UNION ALL SELECT x . x + 1 FROM x RIGHT JOIN x ON x . x = x . x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT x FROM x WHERE x = 1 UNION ALL SELECT x . x + 1 FROM x FULL JOIN x ON x . x = x . x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x IN ( SELECT * FROM x ) ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 UNION ALL SELECT x ( * ) FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 UNION ALL SELECT x ( x ) FROM x ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x ORDER BY 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x LIMIT 1 OFFSET 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( n ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x FOR UPDATE ) SELECT * FROM x ; 
WITH RECURSIVE x ( id ) AS ( VALUES ( 1 ) UNION ALL SELECT ( SELECT * FROM x ) FROM x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE x ( id ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) , y ( id ) AS ( SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) SELECT * FROM x ; 
WITH RECURSIVE foo ( i ) AS ( VALUES ( 1 ) UNION ALL ( SELECT x + 1 FROM x WHERE x < 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) ) SELECT * FROM x ; 
WITH RECURSIVE foo ( i ) AS ( VALUES ( 1 ) UNION ALL SELECT * FROM ( SELECT x + 1 FROM x WHERE x < 1 UNION ALL SELECT x + 1 FROM x WHERE x < 1 ) AS t ) SELECT * FROM x ; 
WITH RECURSIVE foo ( i ) AS ( VALUES ( 1 ) UNION ALL ( SELECT x + 1 FROM x WHERE x < 1 EXCEPT SELECT x + 1 FROM x WHERE x < 1 ) ) SELECT * FROM x ; 
WITH RECURSIVE foo ( i ) AS ( VALUES ( 1 ) UNION ALL ( SELECT x + 1 FROM x WHERE x < 1 INTERSECT SELECT x + 1 FROM x WHERE x < 1 ) ) SELECT * FROM x ; 
WITH cte ( foo ) AS ( VALUES ( 1 ) ) VALUES ( ( SELECT x FROM x ) ) ; 
WITH cte ( foo ) AS ( SELECT 1 ) SELECT * FROM ( ( SELECT x FROM x ) ) q ; 
SELECT ( WITH cte ( foo ) AS ( VALUES ( x ) ) SELECT ( SELECT x FROM x ) ) FROM x ; 
SELECT ( WITH cte ( foo ) AS ( VALUES ( x ) ) VALUES ( ( SELECT x FROM x ) ) ) FROM x ; 
CREATE RULE y_rule AS ON DELETE TO x DO INSTEAD INSERT INTO x VALUES ( 1 ) RETURNING * ; 
DROP RULE y_rule ON y ; 
CREATE TEMP TABLE x AS SELECT x FROM x ( 1 , 1 ) AS t ( i ) ; 
WITH t1 AS ( DELETE FROM x RETURNING * ) INSERT INTO x SELECT * FROM x ; 
WITH aa AS ( SELECT 1 a , 1 b ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = ( SELECT x || 'x' FROM x WHERE x = 1 LIMIT 1 ) ; 
WITH aa AS ( SELECT 1 a , 1 b ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = 'x' WHERE x . x = ( SELECT x FROM x ) ; 
WITH aa AS ( SELECT 'x' a , 'x' b UNION ALL SELECT 'x' a , 'x' b ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = ( SELECT x || 'x' FROM x WHERE x = 'x' LIMIT 1 ) ; 
WITH aa AS ( SELECT 1 a , 1 b ) INSERT INTO x VALUES ( 1 , ( SELECT x || 'x' FROM x WHERE x = 1 ) ) ON CONFLICT ( x ) DO UPDATE SET x = ( SELECT x || 'x' FROM x WHERE x = 1 LIMIT 1 ) ; 
$$DROP TRIGGER y_trig ON y ; 
$$WITH rcte AS ( SELECT x ( x ) AS totalid FROM x ) UPDATE x SET x = x + x FROM x ; 
WITH wcte AS ( INSERT INTO x VALUES ( 1 , 'x' ) RETURNING x AS newid ) UPDATE x SET x = x + x FROM x ; 
WITH rcte AS ( SELECT x ( x ) AS maxid FROM x ) DELETE FROM x USING x WHERE x = x ; 
WITH wcte AS ( INSERT INTO x VALUES ( 1 , 'x' ) RETURNING x AS newid ) DELETE FROM x USING x WHERE x = x ; 
SELECT * FROM ( WITH t AS ( UPDATE x SET x = x + 1 RETURNING * ) SELECT * FROM x ) ss ; 
CREATE RULE y_rule AS ON INSERT TO x WHERE x = 1 DO INSTEAD DELETE FROM x ; 
WITH test AS ( SELECT 1 ) INSERT INTO x VALUES ( 1 ) ; 
WITH test AS ( SELECT 1 ) INSERT INTO x SELECT * FROM x ; 
CREATE USER x WITH CREATEROLE ; 
$$CREATE DOMAIN seclabel_domain AS TEXT ; 
DROP DOMAIN seclabel_domain ; 
SELECT * FROM x ( 1 ) WITH ORDINALITY AS z ( a , b , ord ) ; 
SELECT x , x FROM x ( ARRAY [ 'x' , 'x' ] ) WITH ORDINALITY AS z ( a , ord ) ; 
SELECT * FROM x ( ARRAY [ 'x' , 'x' ] ) WITH ORDINALITY AS z ( a , ord ) ; 
SELECT x ( x . * ) FROM x ( 1 , 1 ) WITH ORDINALITY s ; 
CREATE TEMPORARY VIEW x AS SELECT * FROM ( VALUES ( 1 ) ) v ( n ) JOIN x ( 1 ) WITH ORDINALITY AS z ( a , b , ord ) ON ( x = x ) ; 
SELECT * FROM ROWS FROM ( x ( 1 ) , x ( 1 ) ) WITH ORDINALITY AS z ( a , b , c , d , ord ) ; 
CREATE TEMPORARY VIEW x AS SELECT * FROM ( VALUES ( 1 ) ) v ( n ) JOIN ROWS FROM ( x ( 1 ) , x ( 1 ) ) WITH ORDINALITY AS z ( a , b , c , d , ord ) ON ( x = x ) ; 
SELECT * FROM x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] , ARRAY [ 1.000000 ] ) ; 
SELECT * FROM x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] , ARRAY [ 1.000000 ] ) WITH ORDINALITY AS z ( a , b , c , ord ) ; 
SELECT * FROM ROWS FROM ( x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] , ARRAY [ 1.000000 ] ) ) WITH ORDINALITY AS z ( a , b , c , ord ) ; 
SELECT * FROM ROWS FROM ( x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] ) , x ( 1 , 1 ) ) WITH ORDINALITY AS z ( a , b , c , ord ) ; 
CREATE TEMPORARY VIEW x AS SELECT * FROM x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] , ARRAY [ 1.000000 ] ) AS z ( a , b , c ) ; 
CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM ( x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] , ARRAY [ 1.000000 ] ) ) AS z ( a , b , c ) ; 
CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM ( x ( ARRAY [ 1 , 1 ] , ARRAY [ 'x' , 'x' ] ) , x ( 1 , 1 ) ) AS z ( a , b , c ) ; 
DECLARE rf_cur SCROLL CURSOR FOR SELECT * FROM ROWS FROM ( x ( 1 , 1 ) , x ( 1 , 1 ) ) WITH ORDINALITY AS g ( i , j , o ) ; 
FETCH ALL FROM rf_cur ; 
FETCH BACKWARD ALL FROM rf_cur ; 
FETCH NEXT FROM rf_cur ; 
FETCH PRIOR FROM rf_cur ; 
FETCH ABSOLUTE 1 FROM rf_cur ; 
SELECT * FROM x , x ( x . x ) z WHERE x . x = x . x ; 
SELECT * FROM x , x ( x . x ) WITH ORDINALITY AS z ( rngfuncid , f2 , ord ) WHERE x . x = x . x ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM x ( x . x ) z WHERE x . x = x . x ) ORDER BY 1 , 1 ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM x ( 1 ) z WHERE x . x = x . x ) ORDER BY 1 , 1 ; 
SELECT * FROM x WHERE x IN ( SELECT x FROM x ( x . x ) z WHERE x . x = 1 ) ORDER BY 1 , 1 ; 
SELECT * FROM x ( 1 ) AS t1 ; 
SELECT * FROM x ( 1 ) WITH ORDINALITY AS t1 ( v , o ) ; 
CREATE VIEW x AS SELECT * FROM x ( 1 ) ; 
CREATE VIEW x AS SELECT * FROM x ( 1 ) WITH ORDINALITY AS t1 ( v , o ) ; 
SELECT * FROM x ( 1 ) WITH ORDINALITY AS t1 ( a , b , c , o ) ; 
CREATE VIEW x AS SELECT * FROM x ( 1 ) WITH ORDINALITY AS t1 ( a , b , c , o ) ; 
SELECT * FROM x ( 1 ) AS t1 ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) ; 
SELECT * FROM ROWS FROM ( x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) ) WITH ORDINALITY ; 
CREATE VIEW x AS SELECT * FROM x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) ; 
CREATE VIEW x AS SELECT * FROM ROWS FROM ( x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) ) WITH ORDINALITY ; 
CREATE FUNCTION x ( INT ) RETURNS INT AS 'x' LANGUAGE plpgsql ; 
CREATE FUNCTION x ( INT ) RETURNS rngfunc AS 'x' LANGUAGE plpgsql ; 
SELECT * FROM ROWS FROM ( x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) , x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) , x ( 1 ) , x ( 1 ) ) WITH ORDINALITY AS t1 ( a , b , c , d , e , f , g , h , i , j , k , l , m , o , p , q , r , s , t , u ) ; 
SELECT * FROM ROWS FROM ( x ( 1 ) , x ( 1 ) , x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) , x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) , x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 ) , x ( 1 ) ) WITH ORDINALITY AS t1 ( a , b , c , d , e , f , g , h , i , j , k , l , m , o , p , q , r , s , t , u ) ; 
CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM ( x ( 1 ) , x ( 1 ) AS ( rngfuncid INT , rngfuncsubid INT , rngfuncname TEXT ) , x ( 1 ) ) WITH ORDINALITY AS t1 ( a , b , c , d , e , f , g , n ) ; 
CREATE TYPE rngfunc_rescan_t AS ( i INTEGER , s BIGINT ) ; 
CREATE FUNCTION x ( INT , INT ) RETURNS SETOF rngfunc_rescan_t AS 'x' LANGUAGE plpgsql ; 
SELECT x ( 'x' , 1 , FALSE ) , x ( 'x' , 1 , FALSE ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN x ( 1 , 1 ) ON ( x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN x ( 1 , 1 ) WITH ORDINALITY AS f ( i , s , o ) ON ( x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN ROWS FROM ( x ( 1 , 1 ) , x ( 1 , 1 ) ) WITH ORDINALITY AS f ( i1 , s1 , i2 , s2 , o ) ON ( x + x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN x ( 1 , 1 ) f ( i ) ON ( x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN x ( 1 , 1 ) WITH ORDINALITY AS f ( i , o ) ON ( x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN x ( ARRAY [ 1 , 1 , 1 ] ) f ( i ) ON ( x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) LEFT JOIN x ( ARRAY [ 1 , 1 , 1 ] ) WITH ORDINALITY AS f ( i , o ) ON ( x + x ) < 1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( 1 + x , 1 ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( 1 + x , 1 ) WITH ORDINALITY AS f ( i , s , o ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( 1 , 1 + x ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( 1 , 1 + x ) WITH ORDINALITY AS f ( i , s , o ) ; 
SELECT * FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( r1 , r2 ) , x ( x , x ) ; 
SELECT * FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( r1 , r2 ) , x ( x , x ) WITH ORDINALITY AS f ( i , s , o ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , ROWS FROM ( x ( 1 , 1 ) , x ( 1 + x , 1 ) ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , ROWS FROM ( x ( 1 + x , 1 ) , x ( 1 , 1 ) ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , ROWS FROM ( x ( 1 + x , 1 ) , x ( 1 + x , 1 ) ) ; 
SELECT * FROM x ( 1 , 1 ) r1 , x ( x , 1 ) r2 , ROWS FROM ( x ( 1 + x , 1 ) , x ( 1 + x , 1 ) ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( 1 + x , 1 - x ) f ( i ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( 1 + x , 1 - x ) WITH ORDINALITY AS f ( i , o ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( ARRAY [ x * 1 , x * 1 , x * 1 ] ) f ( i ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v ( r ) , x ( ARRAY [ x * 1 , x * 1 , x * 1 ] ) WITH ORDINALITY AS f ( i , o ) ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v1 ( r1 ) , LATERAL ( SELECT x , * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v2 ( r2 ) LEFT JOIN x ( 1 , 1 ) f ( i ) ON ( ( x + x ) < 1 ) OFFSET 1 ) s1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v1 ( r1 ) , LATERAL ( SELECT x , * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v2 ( r2 ) LEFT JOIN x ( 1 + x , 1 ) f ( i ) ON ( ( x + x ) < 1 ) OFFSET 1 ) s1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v1 ( r1 ) , LATERAL ( SELECT x , * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v2 ( r2 ) LEFT JOIN x ( x , x + 1 ) f ( i ) ON ( ( x + x ) < 1 ) OFFSET 1 ) s1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v1 ( r1 ) , LATERAL ( SELECT x , * FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) v2 ( r2 ) LEFT JOIN x ( x , 1 + x / 1 ) f ( i ) ON ( ( x + x ) < 1 ) OFFSET 1 ) s1 ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v1 ( r1 ) LEFT JOIN LATERAL ( SELECT * FROM x ( 1 , x . x ) AS gs1 LEFT JOIN LATERAL ( SELECT * FROM x ( 1 , x ) AS gs2 LEFT JOIN x ( 1 , x ) AS gs3 ON TRUE ) AS ss1 ON TRUE FULL JOIN x ( 1 , x . x ) AS gs4 ON FALSE ) AS ss0 ON TRUE ; 
SELECT * FROM x ( 1 ) AS p ( x ) ; 
$$SELECT * FROM x ( 1 ) AS p ( a , b ) ; 
$$SELECT x , x ( x , x / 1 ) FROM x ; 
SELECT * FROM x ( 1 , 1 ) AS p ( a , b ) ; 
DROP FUNCTION x ( IN f2 INT , OUT f1 INT , OUT TEXT ) ; 
DROP FUNCTION x ( IN f1 INT , INOUT f2 INT ) ; 
$$$$$$SELECT * FROM x ( ) GROUP BY 1 ; 
$$$$$$SELECT x ( 'x' , 'x' ) LIMIT 1 ; 
$$SELECT x . x , x , x . x FROM x ( 1 ) t LIMIT 1 ; 
DROP FUNCTION x ( n INTEGER ) ; 
$$SELECT x ( ARRAY [ 'x' , 'x' ] ) ; 
SELECT * FROM x ( ARRAY [ 'x' , 'x' ] ) AS t ( f1 INT , f2 TEXT ) ; 
$$$$SELECT * FROM x ( ) AS t ( f1 int8 , f2 int8 ) ; 
$$$$CREATE TEMP TABLE x ( x TEXT , x INT , x TEXT , x bool , x INT , x bool ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' , TRUE , 1 , TRUE ) ; 
$$$$SELECT * FROM ROWS FROM ( x ( ) , x ( 1 , 1 ) ) WITH ORDINALITY ; 
$$$$$$$$SELECT x FROM x , x ( x ) f ( x ) ; 
$$$$CREATE TYPE rngfunc2 AS ( a INTEGER , b TEXT ) ; 
DROP TYPE rngfunc2 ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfnp , STYPE = int4 [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfnp , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfp , STYPE = int4 [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfp , STYPE = int4 [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfp , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfp , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfnp , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf2p , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfnp , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf2p , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf1p , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf1p , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfp , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfp , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf1p , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf1p , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfp , STYPE = INT [ ] , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfp , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfnp , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf2p , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfnp , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf2p , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf1p , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf1p , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfp , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfp , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf1p , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf1p , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfp , STYPE = anyarray , FINALFUNC = ffp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfp , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfnp , STYPE = int4 [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfnp , STYPE = int4 [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfnp , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfnp , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfp , STYPE = int4 [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( * ) ( SFUNC = stfp , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfnp , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfnp , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf2p , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf2p , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfnp , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfnp , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf2p , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf2p , STYPE = INT [ ] , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf1p , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfp , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf1p , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfp , STYPE = INT [ ] , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfnp , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfnp , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf2p , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf2p , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfnp , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfnp , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf2p , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf2p , STYPE = anyarray , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tf1p , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = INT , SFUNC = tfp , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tf1p , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( BASETYPE = anyelement , SFUNC = tfp , STYPE = anyarray , FINALFUNC = ffnp , INITCOND = 'x' ) ; 
CREATE AGGREGATE x ( anyelement , anyelement ) ( SFUNC = sum3 , STYPE = anyelement , INITCOND = 'x' ) ; 
CREATE TEMP TABLE x ( x INT , x INT [ ] , x TEXT ) ; 
INSERT INTO x VALUES ( 1 , ARRAY [ 1 ] , 'x' ) ; 
SELECT x , x ( x ) FROM x GROUP BY x ORDER BY x ; 
SELECT x ( x , x + 1 ) FROM x ; 
$$$$$$SELECT x , x ( x > 1 , x ( x ) , x ( x + 1 ) ) FROM x ; 
SELECT x , x ( x > 1 , x , x + 1 ) FROM x ; 
SELECT x ( x ) FROM ( VALUES ( ARRAY [ 1 , 1 ] ) , ( ARRAY [ 1 , 1 ] ) ) AS t ( i ) ; 
SELECT x ( x ) FROM ( VALUES ( ARRAY [ ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ] ) , ( ARRAY [ ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ] ) ) AS t ( i ) ; 
$$$$CREATE AGGREGATE x ( anyelement , INTEGER ) ( SFUNC = add_group , STYPE = anyarray ) ; 
CREATE AGGREGATE x ( int8 , INTEGER ) ( SFUNC = add_group , STYPE = int2 [ ] ) ; 
CREATE AGGREGATE x ( int8 , INTEGER ) ( SFUNC = add_group , STYPE = int8 [ ] ) ; 
CREATE AGGREGATE x ( float8 ) ( SFUNC = array_append , STYPE = float8 [ ] , FINALFUNC = first_el ) ; 
CREATE AGGREGATE x ( anyelement ) ( SFUNC = array_append , STYPE = anyarray , FINALFUNC = first_el ) ; 
SELECT x ( x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( x ) OVER ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
$$SELECT x ( 1 , 1 , 1 , 1 ) ; 
SELECT x ( VARIADIC ARRAY [ 1.000000 , 1.000000 ] ) ; 
$$$$SELECT x ( 'x' , 1 , 1 , 1 , 1 , 1 ) ; 
DROP FUNCTION x ( TEXT , anyarray ) ; 
$$$$SELECT x ( 1.000000 , VARIADIC ARRAY [ 1.000000 , 1.000000 ] ) ; 
$$$$$$$$$$$$$$$$DROP FUNCTION x ( TEXT , TEXT ) ; 
$$$$$$$$DROP FUNCTION x ( INT , INT , INT , INT ) ; 
$$$$$$$$$$DROP FUNCTION x ( a VARIADIC INT [ ] ) ; 
$$$$$$$$$$$$DROP FUNCTION x ( INT , INT , INT ) ; 
$$$$SELECT ( x ( 1 , 1 , 1 ) ) . * ; 
SELECT ( x ( a := 1 , b := 1 , c := 1 ) ) . * ; 
SELECT * FROM x ( a := 1 , b := 1 ) ; 
SELECT * FROM x ( b := 1 , a := 1 ) ; 
SELECT * FROM x ( 1 , 1 , c := 1 ) ; 
SELECT * FROM x ( 1 , 1 , d := 1 ) ; 
$$$$__$$$$SELECT ( x ( ) ) . * ; 
SELECT * FROM x ( 'x' , 1 ) ; 
SELECT * FROM x ( a := 'x' , c := 1 ) ; 
SELECT * FROM x ( c := 1 , a := 'x' ) ; 
SELECT * FROM x ( 'x' , c := 1 ) ; 
SELECT * FROM x ( c := 1 ) ; 
__$$$$__$$$$DROP FUNCTION x ( VARCHAR , NUMERIC ) ; 
$$$$$$$$$$$$$$$$SELECT x ( a => + 1 ) ; 
$$$$CREATE VIEW x AS SELECT x , x , x ( x , x , flag := x > x ) AS c3 , x ( x , flag := x < x , b := x ) AS c4 FROM x ; 
DROP FUNCTION x ( anyelement , anyelement , bool ) ; 
$$$$CREATE TEMP TABLE x ( x TEXT , x jsonb ) ; 
SELECT x ( 'x' , ARRAY [ 'x' , 'x' ] ) ; 
SELECT x 'x' ? | ARRAY [ 'x' , 'x' ] ; 
SELECT x 'x' ? & ARRAY [ 'x' , 'x' ] ; 
SELECT x 'x' ? & ARRAY [ 'x' , 'x' , 'x' , 'x' , 'x' ] ; 
SELECT x ( 'x' ) AS null" ; 
SELECT x ( 'x' ) AS number ; 
SELECT x ( 'x' ) AS string ; 
CREATE TYPE jbpop AS ( a TEXT , b INT , c TIMESTAMP ) ; 
CREATE DOMAIN jsb_int_not_null AS INT NOT NULL ; 
CREATE TYPE jb_unordered_pair AS ( x INT , y INT ) ; 
_CREATE TYPE jsbrec AS ( i INT , ia int4 , ia1 INT [ ] , ia2 INT [ ] [ ] , ia3 INT [ ] [ ] [ ] , ia1d jsb_int_array_1d , ia2d jsb_int_array_2d , t TEXT , ta TEXT [ ] , c CHAR ( 1 ) , ca CHAR ( 1 ) [ ] , ts TIMESTAMP , js json , jsb jsonb , jsa json [ ] , rec jbpop , reca jbpop [ ] ) ; 
CREATE TYPE jsbrec_i_not_null AS ( i jsb_int_not_null ) ; 
______CREATE TEMP TABLE x ( x jsonb ) ; 
DROP TYPE jsbrec ; 
DROP TYPE jsbrec_i_not_null ; 
DROP DOMAIN jsb_int_not_null ; 
DROP DOMAIN jsb_int_array_1d ; 
DROP DOMAIN jsb_int_array_2d ; 
DROP DOMAIN jb_ordered_pair ; 
DROP TYPE jb_unordered_pair ; 
@@@@@SELECT x ( * ) FROM x WHERE x ? 'x' ; 
SELECT x ( * ) FROM x WHERE x ? | ARRAY [ 'x' , 'x' ] ; 
SELECT x ( * ) FROM x WHERE x ? & ARRAY [ 'x' , 'x' ] ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x 'x' ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EXPLAIN ( COSTS OFF ) SELECT x ( * ) FROM x WHERE x ? 'x' ; 
@@@@@@@@@@@SET enable_hashagg = off ; 
SELECT x ( * ) FROM ( SELECT x FROM ( SELECT * FROM x UNION ALL SELECT * FROM x ) js GROUP BY x ) js2 ; 
SET enable_hashagg = ON ; 
SET enable_sort = ON ; 
CREATE INDEX x ON x USING gin ( x jsonb_path_ops ) ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CREATE INDEX ON x USING gin ( x jsonb_path_ops ) ; 
@@@@@@SELECT x ( 'x' , 'x' , 'x' , FALSE ) ; 
SELECT x ( 'x' , 'x' , 'x' , TRUE ) ; 
CREATE TABLE x ( x int4 NOT NULL , x TEXT NOT NULL ) ; 
CREATE TABLE x ( x int4 , x TEXT , x INT ) ; 
CREATE TABLE x ( x int4 , x TEXT , x INT NOT NULL ) ; 
CREATE TRIGGER x BEFORE INSERT OR UPDATE ON x FOR EACH ROW EXECUTE FUNCTION x ( 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
CREATE TRIGGER x BEFORE INSERT OR UPDATE ON x FOR EACH ROW EXECUTE FUNCTION x ( 'x' , 'x' , 'x' ) ; 
CREATE TRIGGER x BEFORE INSERT OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'x' ; 
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'x' ; 
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL ; 
CREATE TRIGGER x BEFORE DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 1 , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
CREATE TRIGGER x BEFORE DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 1 , 'x' , 'x' , 'x' , 'x' ) ; 
UPDATE x SET x = 1 , x = 'x' WHERE x = 1 AND x = 'x' ; 
SELECT x , x , x , x , x , x , x , x , x , x FROM x . triggers WHERE x IN ( 'x' , 'x' , 'x' ) ORDER BY x COLLATE C" , 1 ; 
CREATE TRIGGER x BEFORE INSERT OR DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = x || 'x' ; 
DROP TRIGGER trigger_alpha ON trigtest ; 
CREATE SEQUENCE x INCREMENT 1 START 1 MINVALUE 1 ; 
CREATE TABLE x ( x int4 , x int4 , x int4 , x int4 DEFAULT 1 ) ; 
CREATE TRIGGER x BEFORE DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( price_on , price_off ) ; 
CREATE TRIGGER x BEFORE INSERT OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( price_on , ttdummy_seq ) ; 
SELECT * FROM x WHERE x <= 1 AND x > 1 AND x = 1 ; 
CREATE TABLE x ( x INT UNIQUE , x INT ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
UPDATE x SET x = x + 1 WHERE x < 1 ; 
ALTER TABLE x DROP CONSTRAINT main_table_a_key ; 
SELECT x , x , x , x , x , x , x , x , x , x FROM x . triggers WHERE x IN ( 'x' ) ORDER BY x COLLATE C" , 1 ; 
UPDATE x SET x = 1 , x = 1 ; 
ALTER TRIGGER modified_a ON x RENAME TO modified_modified_a ; 
DROP TRIGGER modified_modified_a ON main_table ; 
DROP TRIGGER modified_any ON main_table ; 
DROP TRIGGER insert_a ON main_table ; 
DROP TRIGGER delete_a ON main_table ; 
DROP TRIGGER insert_when ON main_table ; 
DROP TRIGGER delete_when ON main_table ; 
DROP TRIGGER after_upd_row_trig ON main_table ; 
CREATE TABLE x ( x BOOLEAN NOT NULL ) ; 
$$CREATE TRIGGER x BEFORE UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 'x' ) ; 
INSERT INTO x VALUES ( TRUE ) ; 
UPDATE x SET x = TRUE ; 
UPDATE x SET x = FALSE ; 
DROP TRIGGER after_upd_a_b_row_trig ON main_table ; 
DROP TRIGGER after_upd_b_row_trig ON main_table ; 
DROP TRIGGER after_upd_b_stmt_trig ON main_table ; 
CREATE TABLE x ( x INT REFERENCES x ( x ) ON DELETE CASCADE ) ; 
$$ALTER TABLE x DISABLE TRIGGER trigtest_b_row_tg ; 
ALTER TABLE x DISABLE TRIGGER USER ; 
ALTER TABLE x ENABLE TRIGGER trigtest_a_stmt_tg ; 
ALTER TABLE x DISABLE TRIGGER ALL ; 
CREATE TABLE x ( x INT , x VARCHAR ) ; 
$$DROP TRIGGER show_trigger_data_trig ON trigger_test ; 
$$$$$$INSERT INTO x SELECT x , x ( 'x' , 1 ) , 'x' FROM x ( 1 , 1 ) a ; 
INSERT INTO x VALUES ( 'x' , 1 , 1 ) , ( 'x' , 'x' , NULL ) ; 
\\CREATE VIEW x AS SELECT x , x FROM x ; 
$$\INSERT INTO x VALUES ( 1 , 1 ) RETURNING x , x ; 
UPDATE x SET x = 1 WHERE x = 1 AND x = 1 RETURNING x , x ; 
DROP TRIGGER before_upd_a_row_trig ON main_table ; 
UPDATE x SET x = 1 WHERE FALSE ; 
DELETE FROM x WHERE x IN ( 1 , 1 ) ; 
DELETE FROM x WHERE x = 1 RETURNING x , x ; 
\DROP TRIGGER instead_of_delete_trig ON main_view ; 
CREATE TABLE x ( x serial PRIMARY KEY , x TEXT UNIQUE NOT NULL , x TEXT NOT NULL ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) , ( 'x' , 'x' ) RETURNING * ; 
CREATE TABLE x ( x serial PRIMARY KEY , x TEXT NOT NULL , x BIGINT , x INT REFERENCES x ) ; 
CREATE VIEW x AS SELECT x , x , x , x , x FROM x ci LEFT JOIN x co ON x . x = x . x ; 
$$$$$$\INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) RETURNING * ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 'x' ) RETURNING * ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) RETURNING * ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 , 'x' , 'x' ) RETURNING * ; 
UPDATE x SET x = 'x' WHERE x = 'x' RETURNING * ; 
UPDATE x SET x = 'x' , x = 1 WHERE x = 'x' RETURNING * ; 
UPDATE x x SET x = x . x FROM x v2 WHERE x . x = 'x' AND x . x = 'x' RETURNING * ; 
\\\\UPDATE x SET x = 1 WHERE x = 'x' RETURNING * ; 
UPDATE x x SET x = 1 FROM x ci , x co WHERE x . x = 'x' AND x . x = 'x' AND x . x = x . x AND x . x = x . x RETURNING x . x , x . x , x . x , x . x , x . x ; 
\$$$$$$CREATE TEMP TABLE x ( x INT NOT NULL PRIMARY KEY , x TEXT , x TEXT , x TEXT , x TEXT , x INT NOT NULL DEFAULT 1 ) ; 
CREATE TEMP TABLE x ( x INT NOT NULL PRIMARY KEY , x INT NOT NULL , x TEXT ) ; 
$$$$$$$$INSERT INTO x VALUES ( 1 , 'x' , 'x' , 'x' , 'x' , 1 ) ; 
SELECT * FROM x ; SELECT * FROM x ; 
$$$$$$$$CREATE TRIGGER x BEFORE UPDATE ON x EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = x WHERE FALSE RETURNING x + 1 AS aa ; 
$$$$$$$$CREATE TRIGGER x AFTER INSERT OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS old_table FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
$$CREATE TRIGGER x BEFORE UPDATE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x BEFORE DELETE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
WITH upd AS ( UPDATE x SET x = x ) UPDATE x SET x = x ; 
\\ALTER TABLE x ENABLE TRIGGER trig_ins_after_parent ; 
$$CREATE TRIGGER x AFTER INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( 'x' , 1 ) ; 
$$$$CREATE CONSTRAINT TRIGGER x AFTER INSERT ON x DEFERRABLE FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ; 
CREATE CONSTRAINT TRIGGER x AFTER UPDATE ON x FROM x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE OF x ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
ALTER TABLE x ADD CONSTRAINT uniq UNIQUE ( x ) DEFERRABLE ; 
$$$$$$SELECT x , x , x , x , x , x , x , x , x , x FROM x . triggers WHERE x IN ( 'x' , 'x' , 'x' , 'x' ) ORDER BY x COLLATE C" , 1 ; 
DROP TRIGGER child1_update_trig ON child1 ; 
DROP TRIGGER child1_delete_trig ON child1 ; 
DROP TRIGGER child2_insert_trig ON child2 ; 
DROP TRIGGER child2_update_trig ON child2 ; 
DROP TRIGGER child2_delete_trig ON child2 ; 
DROP TRIGGER child3_insert_trig ON child3 ; 
DROP TRIGGER child3_update_trig ON child3 ; 
DROP TRIGGER child3_delete_trig ON child3 ; 
$$INSERT INTO x VALUES ( 'x' , 1 ) , ( 'x' , 1 ) , ( 'x' , 1 ) ; 
CREATE TRIGGER x AFTER INSERT ON x REFERENCING NEW TABLE AS new_table FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER child_row_trig ON child ; 
INSERT INTO x VALUES ( 'x' , 1 , 'x' ) ; 
WITH wcte AS ( INSERT INTO x VALUES ( 1 ) ) INSERT INTO x VALUES ( 'x' ) ; 
WITH wcte AS ( INSERT INTO x VALUES ( 1 ) ) INSERT INTO x VALUES ( 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x || 'x' || x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x || 'x' || x . x ; 
CREATE TABLE x ( x INT PRIMARY KEY , x TEXT ) PARTITION BY list ( a ) ; 
CREATE TRIGGER x AFTER INSERT OR UPDATE ON x REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE OF x ON x REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TABLE x ( x INT , x TEXT , FOREIGN KEY ( x ) REFERENCES x ON UPDATE CASCADE ON DELETE CASCADE ) ; 
CREATE TRIGGER x BEFORE INSERT OR UPDATE OR DELETE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( 'x' ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ; 
DELETE FROM x WHERE x ( x ) = 1 ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT REFERENCES x ( x ) ON DELETE CASCADE ) ; 
CREATE TRIGGER x BEFORE DELETE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( 'x' ) ; 
CREATE TRIGGER x AFTER DELETE ON x REFERENCING OLD TABLE AS old_table FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
INSERT INTO x VALUES ( 1 , NULL ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
DROP TRIGGER self_ref_r_trig ON self_ref ; 
INSERT INTO x VALUES ( 1 , NULL ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
SELECT x 'x' AS correct_everywhere ; 
SELECT x 'x' AS not_an_escape ; 
SELECT x 'x' AS not_unescaped ; 
SELECT x 'x' AS fails ; 
CREATE TABLE x ( x FLOAT8 ) ; 
INSERT INTO x ( x ) SELECT x ( x ) FROM x ; 
SELECT 'x' AS ten , x FROM x ORDER BY x ; 
CREATE TABLE x ( x INT4 ) ; 
INSERT INTO x ( x ) SELECT x ( x ) FROM x WHERE ( x > 1 ) AND ( x < 1 ) ; 
SELECT 'x' AS nine , x FROM x ORDER BY x ; 
CREATE TABLE x ( x INT2 ) ; 
INSERT INTO x ( x ) SELECT x ( x ) FROM x WHERE ( x >= 1 ) AND ( x <= 1 ) ; 
SELECT 'x' AS five , x FROM x ORDER BY x ; 
CREATE TABLE x ( x INT4 , x INT4 , x FLOAT8 ) ; 
INSERT INTO x SELECT 1 , ( - x . x ) , ( - x . x ) FROM x i , x f ; 
INSERT INTO x SELECT 1 , x . x , x . x FROM x i , x f ; 
SELECT DISTINCT x AS two FROM x ORDER BY 1 ; 
SELECT x AS two , x ( x ) AS max_float , x ( x ) AS min_float FROM x GROUP BY x ORDER BY x , x , x ; 
SELECT x AS two , ( x ( x ) + 1 ) AS max_plus_1 , ( x ( x ) - 1 ) AS min_minus_1 FROM x GROUP BY x ORDER BY x , x ; 
SELECT x AS two , x ( x ) + x ( x ) AS max_plus_min , x ( x ) - 1 AS min_minus_1 FROM x GROUP BY x ORDER BY x , x ; 
